Summary,Issue key,Issue id,Issue Type,Status,Project key,Project name,Project type,Project lead,Project description,Project url,Priority,Resolution,Assignee,Reporter,Creator,Created,Updated,Last Viewed,Resolved,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Fix Version/s,Component/s,Component/s,Due Date,Votes,Labels,Labels,Labels,Description,Environment,Watchers,Watchers,Watchers,Watchers,Watchers,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Original Estimate,Remaining Estimate,Time Spent,Work Ratio,Σ Original Estimate,Σ Remaining Estimate,Σ Time Spent,Security Level,Inward issue link (Blocked),Outward issue link (Blocked),Inward issue link (Blocker),Inward issue link (Blocker),Inward issue link (Blocker),Outward issue link (Blocker),Inward issue link (Child-Issue),Outward issue link (Child-Issue),Outward issue link (Child-Issue),Inward issue link (Cloners),Outward issue link (Cloners),Inward issue link (Completes),Outward issue link (Completes),Outward issue link (Container),Inward issue link (Dependency),Inward issue link (Duplicate),Outward issue link (Duplicate),Inward issue link (Incorporates),Outward issue link (Incorporates),Inward issue link (Problem/Incident),Outward issue link (Problem/Incident),Outward issue link (Problem/Incident),Inward issue link (Reference),Inward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Inward issue link (Regression),Outward issue link (Regression),Outward issue link (Regression),Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Custom field (Affects version (Component)),Custom field (Attachment count),Custom field (Blog - New Blog Administrators),Custom field (Blog - New Blog PMC),Custom field (Blog - Write access),Custom field (Blog Administrator?),Custom field (Blogs - Admin for blog),Custom field (Blogs - Email Address),Custom field (Blogs - Existing Blog Access Level),Custom field (Blogs - Existing Blog Name),Custom field (Blogs - New Blog Write Access),Custom field (Blogs - Username),Custom field (Bug Category),Custom field (Bugzilla - Email Notification Address),Custom field (Bugzilla - List of usernames),Custom field (Bugzilla - PMC Name),Custom field (Bugzilla - Project Name),Custom field (Bugzilla Id),Custom field (Bugzilla Id),Custom field (Change Category),Custom field (Complexity),Custom field (Discovered By),Custom field (Docs Text),Custom field (Enable Automatic Patch Review),Custom field (Epic Link),Custom field (Estimated Complexity),Custom field (Evidence Of Open Source Adoption),Custom field (Evidence Of Registration),Custom field (Evidence Of Use On World Wide Web),Custom field (Existing GitBox Approval),Custom field (External issue ID),Custom field (External issue URL),Custom field (Fix version (Component)),Custom field (Flags),Custom field (Git Notification Mailing List),Custom field (Git Repository Import Path),Custom field (Git Repository Name),Custom field (Git Repository Type),Custom field (GitHub Options),Custom field (Github Integration),Custom field (Github Integrations - Other),Custom field (Global Rank),Custom field (INFRA - Subversion Repository Path),Custom field (Ignite Flags),Custom field (Ignite Flags),Custom field (Initial Confluence Contributors),Custom field (Language),Custom field (Last public comment date),Custom field (Level of effort),Custom field (Machine Readable Info),Custom field (Mentor),Custom field (New-TLP-TLPName),Custom field (Original story points),Custom field (Parent Link),Custom field (Priority),Custom field (Project),Custom field (Protected Branch),Custom field (Rank),Custom field (Rank (Obsolete)),Custom field (Release Note),Custom field (Review Date),Custom field (Reviewer),Custom field (Reviewer),Custom field (Severity),Custom field (Severity),Custom field (Skill Level),Custom field (Source Control Link),Custom field (Space Description),Custom field (Space Key),Custom field (Space Name),Custom field (Start Date),Custom field (Tags),Custom field (Target end),Custom field (Target start),Custom field (Team),Custom field (Test and Documentation Plan),Custom field (Testcase included),Custom field (Tester),Custom field (Workaround),Comment,Comment,Comment,Comment,Comment,Comment
Restrict possibility to create two caches with the same schema and index name,IGNITE-19878,13541896,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,zstan,zstan,zstan,29/Jun/23 07:01,05/Jul/23 10:23,13/Jul/23 09:11,04/Jul/23 10:20,2.15,,,,,,,,sql,,,0,,,,"It’s possible to create two different caches with the same schema and index name inside it from a client and after that get a failing of the server node during start-up with the error ""Duplicate index name... "" during start caches.

scenario:

start at least two server nodes

start client node which creates two different caches during start-up (via setting cache configs to config of client node) with the same schema name and index name, it leads to crushing the cluster

then try to start the cluster and get the error ""Duplicate index name...""",,ignitetcbot,zstan,,,,"zstan opened a new pull request, #10817:
URL: https://github.com/apache/ignite/pull/10817

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;29/Jun/23 09:35;githubbot;600","sonarcloud[bot] commented on PR #10817:
URL: https://github.com/apache/ignite/pull/10817#issuecomment-1612741955

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10817)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL) [5 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_duplicated_lines_density&view=list)
   
   
   
   ![idea](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/light_bulb-16px.png 'idea') Catch issues before they fail your Quality Gate with our IDE extension ![sonarlint](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/sonarlint-16px.png 'sonarlint') [SonarLint](https://www.sonarsource.com/products/sonarlint/features/connected-mode/?referrer=sonarcloud-welcome)


;29/Jun/23 09:53;githubbot;600","sonarcloud[bot] commented on PR #10817:
URL: https://github.com/apache/ignite/pull/10817#issuecomment-1612787732

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10817)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL) [5 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_duplicated_lines_density&view=list)
   
   
   
   ![idea](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/light_bulb-16px.png 'idea') Catch issues before they fail your Quality Gate with our IDE extension ![sonarlint](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/sonarlint-16px.png 'sonarlint') [SonarLint](https://www.sonarsource.com/products/sonarlint/features/connected-mode/?referrer=sonarcloud-welcome)


;29/Jun/23 10:16;githubbot;600","sonarcloud[bot] commented on PR #10817:
URL: https://github.com/apache/ignite/pull/10817#issuecomment-1612805662

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10817)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL) [5 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_duplicated_lines_density&view=list)
   
   
   
   ![idea](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/light_bulb-16px.png 'idea') Catch issues before they fail your Quality Gate with our IDE extension ![sonarlint](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/sonarlint-16px.png 'sonarlint') [SonarLint](https://www.sonarsource.com/products/sonarlint/features/connected-mode/?referrer=sonarcloud-welcome)


;29/Jun/23 10:25;githubbot;600","sonarcloud[bot] commented on PR #10817:
URL: https://github.com/apache/ignite/pull/10817#issuecomment-1613420993

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10817)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL) [6 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_duplicated_lines_density&view=list)
   
   
   
   ![idea](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/light_bulb-16px.png 'idea') Catch issues before they fail your Quality Gate with our IDE extension ![sonarlint](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/sonarlint-16px.png 'sonarlint') [SonarLint](https://www.sonarsource.com/products/sonarlint/features/connected-mode/?referrer=sonarcloud-welcome)


;29/Jun/23 15:34;githubbot;600","sonarcloud[bot] commented on PR #10817:
URL: https://github.com/apache/ignite/pull/10817#issuecomment-1614535495

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10817)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG) [![C](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/C-16px.png 'C')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG) [1 Bug](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL) [6 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_duplicated_lines_density&view=list)
   
   
   
   ![idea](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/light_bulb-16px.png 'idea') Catch issues before they fail your Quality Gate with our IDE extension ![sonarlint](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/sonarlint-16px.png 'sonarlint') [SonarLint](https://www.sonarsource.com/products/sonarlint/features/connected-mode/?referrer=sonarcloud-welcome)


;30/Jun/23 11:43;githubbot;600","xtern commented on code in PR #10817:
URL: https://github.com/apache/ignite/pull/10817#discussion_r1247775581


##########
modules/core/src/main/java/org/apache/ignite/internal/processors/cache/ClusterCachesInfo.java:
##########
@@ -1086,33 +1088,42 @@ private boolean processStartNewCacheRequest(
             );
         }
 
-        if (err == null) {
-            String conflictErr = checkCacheConflict(req.startCacheConfiguration());
+        if (!validateStartNewCache(err, persistedCfgs, res, req))
+            return false;
 
-            if (conflictErr != null) {
-                U.warn(log, ""Ignore cache start request. "" + conflictErr);
+        err = QueryUtils.checkQueryEntityConflicts(req.startCacheConfiguration(), registeredCaches.values());
 
-                err = new IgniteCheckedException(""Failed to start cache. "" + conflictErr);
-            }
+        if (!validateStartNewCache(err, persistedCfgs, res, req))
+            return false;
+
+        String conflictErr = checkCacheConflict(req.startCacheConfiguration(), false);
+
+        if (conflictErr != null) {
+            U.warn(log, ""Ignore cache start request. "" + conflictErr);
+
+            err = new IgniteCheckedException(""Failed to start cache. "" + conflictErr);
         }
 
-        if (err == null)
-            err = QueryUtils.checkQueryEntityConflicts(req.startCacheConfiguration(), registeredCaches.values());
+        if (!validateStartNewCache(err, persistedCfgs, res, req))
+            return false;
 
-        if (err == null) {
-            GridEncryptionManager encMgr = ctx.encryption();
+        GridEncryptionManager encMgr = ctx.encryption();
 
-            if (ccfg.isEncryptionEnabled()) {
-                if (encMgr.isMasterKeyChangeInProgress())
-                    err = new IgniteCheckedException(""Cache start failed. Master key change is in progress."");
-                else if (encMgr.masterKeyDigest() != null &&
-                    !Arrays.equals(encMgr.masterKeyDigest(), req.masterKeyDigest())) {
-                    err = new IgniteCheckedException(""Cache start failed. The request was initiated before "" +
-                        ""the master key change and can't be processed."");
-                }
+        if (ccfg.isEncryptionEnabled()) {
+            IgniteCheckedException error = null;
 
-                if (err != null)
-                    U.warn(log, ""Ignore cache start request during the master key change process."", err);
+            if (encMgr.isMasterKeyChangeInProgress())
+                error = new IgniteCheckedException(""Cache start failed. Master key change is in progress."");
+            else if (encMgr.masterKeyDigest() != null &&
+                !Arrays.equals(encMgr.masterKeyDigest(), req.masterKeyDigest())) {
+                error = new IgniteCheckedException(""Cache start failed. The request was initiated before "" +
+                    ""the master key change and can't be processed."");
+            }
+
+            if (error != null) {
+                U.warn(log, ""Ignore cache start request during the master key change process."", error);
+                if (!validateStartNewCache(err, persistedCfgs, res, req))

Review Comment:
   ```suggestion
                   if (!validateStartNewCache(error, persistedCfgs, res, req))
   ```



##########
modules/core/src/main/java/org/apache/ignite/internal/processors/cache/ClusterCachesInfo.java:
##########
@@ -1086,33 +1088,42 @@ private boolean processStartNewCacheRequest(
             );
         }
 
-        if (err == null) {
-            String conflictErr = checkCacheConflict(req.startCacheConfiguration());
+        if (!validateStartNewCache(err, persistedCfgs, res, req))
+            return false;
 
-            if (conflictErr != null) {
-                U.warn(log, ""Ignore cache start request. "" + conflictErr);
+        err = QueryUtils.checkQueryEntityConflicts(req.startCacheConfiguration(), registeredCaches.values());
 
-                err = new IgniteCheckedException(""Failed to start cache. "" + conflictErr);
-            }
+        if (!validateStartNewCache(err, persistedCfgs, res, req))
+            return false;
+
+        String conflictErr = checkCacheConflict(req.startCacheConfiguration(), false);
+
+        if (conflictErr != null) {
+            U.warn(log, ""Ignore cache start request. "" + conflictErr);
+
+            err = new IgniteCheckedException(""Failed to start cache. "" + conflictErr);
         }
 
-        if (err == null)
-            err = QueryUtils.checkQueryEntityConflicts(req.startCacheConfiguration(), registeredCaches.values());
+        if (!validateStartNewCache(err, persistedCfgs, res, req))
+            return false;
 
-        if (err == null) {
-            GridEncryptionManager encMgr = ctx.encryption();
+        GridEncryptionManager encMgr = ctx.encryption();
 
-            if (ccfg.isEncryptionEnabled()) {
-                if (encMgr.isMasterKeyChangeInProgress())
-                    err = new IgniteCheckedException(""Cache start failed. Master key change is in progress."");
-                else if (encMgr.masterKeyDigest() != null &&
-                    !Arrays.equals(encMgr.masterKeyDigest(), req.masterKeyDigest())) {
-                    err = new IgniteCheckedException(""Cache start failed. The request was initiated before "" +
-                        ""the master key change and can't be processed."");
-                }
+        if (ccfg.isEncryptionEnabled()) {
+            IgniteCheckedException error = null;

Review Comment:
   Why we need this variable?



;30/Jun/23 11:55;githubbot;600","sonarcloud[bot] commented on PR #10817:
URL: https://github.com/apache/ignite/pull/10817#issuecomment-1614585344

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10817)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL) [6 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_duplicated_lines_density&view=list)
   
   
   
   ![idea](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/light_bulb-16px.png 'idea') Catch issues before they fail your Quality Gate with our IDE extension ![sonarlint](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/sonarlint-16px.png 'sonarlint') [SonarLint](https://www.sonarsource.com/products/sonarlint/features/connected-mode/?referrer=sonarcloud-welcome)


;30/Jun/23 12:30;githubbot;600","zstan commented on PR #10817:
URL: https://github.com/apache/ignite/pull/10817#issuecomment-1614624001

   @xtern thanks a lot !


;30/Jun/23 13:04;githubbot;600","sonarcloud[bot] commented on PR #10817:
URL: https://github.com/apache/ignite/pull/10817#issuecomment-1618282213

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10817)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10817&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL) [5 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10817&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10817&metric=new_duplicated_lines_density&view=list)
   
   
   
   ![idea](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/light_bulb-16px.png 'idea') Catch issues before they fail your Quality Gate with our IDE extension ![sonarlint](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/sonarlint-16px.png 'sonarlint') [SonarLint](https://www.sonarsource.com/products/sonarlint/features/connected-mode/?referrer=sonarcloud-welcome)


;03/Jul/23 13:38;githubbot;600","zstan closed pull request #10817: IGNITE-19878 Restrict possibility to create two caches with the same schemas and index names
URL: https://github.com/apache/ignite/pull/10817


;04/Jul/23 10:00;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,6600,,,0,6600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jul 05 10:23:22 UTC 2023,,,,,,,,,,"0|z1iv74:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"30/Jun/23 10:40;ignitetcbot;{panel:title=Branch: [pull/10817/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10817/head] Base: [master] : New Tests (12)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Queries 1{color} [[tests 6|https://ci2.ignite.apache.org/viewLog.html?buildId=7237759]]
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.testErroneousCacheConfigFromClientNode[persistent = false] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.teststartErroneousCacheConfigThroughDynamicCaches[persistent = false] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.testEqualIndexAreConfiguredOnServerAndJoinedNode[persistent = false] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.testErroneousCacheConfigFromClientNode[persistent = true] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.teststartErroneousCacheConfigThroughDynamicCaches[persistent = true] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.testEqualIndexAreConfiguredOnServerAndJoinedNode[persistent = true] - PASSED{color}

{color:#00008b}Queries 1 (lazy=true){color} [[tests 6|https://ci2.ignite.apache.org/viewLog.html?buildId=7237760]]
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.teststartErroneousCacheConfigThroughDynamicCaches[persistent = true] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.testEqualIndexAreConfiguredOnServerAndJoinedNode[persistent = true] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.testErroneousCacheConfigFromClientNode[persistent = false] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.teststartErroneousCacheConfigThroughDynamicCaches[persistent = false] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.testErroneousCacheConfigFromClientNode[persistent = true] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.testEqualIndexAreConfiguredOnServerAndJoinedNode[persistent = false] - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7237791&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","30/Jun/23 11:39;zstan;[~xtern] plz can u make a review ?;;;","03/Jul/23 08:42;ignitetcbot;{panel:title=Branch: [pull/10817/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10817/head] Base: [master] : New Tests (12)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Queries 1{color} [[tests 6|https://ci2.ignite.apache.org/viewLog.html?buildId=7239045]]
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.testErroneousCacheConfigFromClientNode[persistent = false] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.teststartErroneousCacheConfigThroughDynamicCaches[persistent = false] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.testEqualIndexAreConfiguredOnServerAndJoinedNode[persistent = false] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.testErroneousCacheConfigFromClientNode[persistent = true] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.teststartErroneousCacheConfigThroughDynamicCaches[persistent = true] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.testEqualIndexAreConfiguredOnServerAndJoinedNode[persistent = true] - PASSED{color}

{color:#00008b}Queries 1 (lazy=true){color} [[tests 6|https://ci2.ignite.apache.org/viewLog.html?buildId=7239046]]
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.teststartErroneousCacheConfigThroughDynamicCaches[persistent = true] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.testEqualIndexAreConfiguredOnServerAndJoinedNode[persistent = true] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.testErroneousCacheConfigFromClientNode[persistent = false] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.teststartErroneousCacheConfigThroughDynamicCaches[persistent = false] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.testErroneousCacheConfigFromClientNode[persistent = true] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.testEqualIndexAreConfiguredOnServerAndJoinedNode[persistent = false] - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7239077&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","04/Jul/23 05:18;ignitetcbot;{panel:title=Branch: [pull/10817/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10817/head] Base: [master] : New Tests (12)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Queries 1{color} [[tests 6|https://ci2.ignite.apache.org/viewLog.html?buildId=7243335]]
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.testErroneousCacheConfigFromClientNode[persistent = false] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.teststartErroneousCacheConfigThroughDynamicCaches[persistent = false] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.testEqualIndexAreConfiguredOnServerAndJoinedNode[persistent = false] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.testErroneousCacheConfigFromClientNode[persistent = true] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.teststartErroneousCacheConfigThroughDynamicCaches[persistent = true] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryTestSuite: ErroneousQueryEntityConfigurationTest.testEqualIndexAreConfiguredOnServerAndJoinedNode[persistent = true] - PASSED{color}

{color:#00008b}Queries 1 (lazy=true){color} [[tests 6|https://ci2.ignite.apache.org/viewLog.html?buildId=7243336]]
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.teststartErroneousCacheConfigThroughDynamicCaches[persistent = true] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.testEqualIndexAreConfiguredOnServerAndJoinedNode[persistent = true] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.testErroneousCacheConfigFromClientNode[persistent = false] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.teststartErroneousCacheConfigThroughDynamicCaches[persistent = false] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.testErroneousCacheConfigFromClientNode[persistent = true] - PASSED{color}
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite: ErroneousQueryEntityConfigurationTest.testEqualIndexAreConfiguredOnServerAndJoinedNode[persistent = false] - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7243367&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","05/Jul/23 10:23;ignitetcbot;{panel:title=Branch: [pull/10817/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10817/head] Base: [master] : No new tests found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7243367&amp;buildTypeId=IgniteTests24Java8_RunAll];;;",
Java thin 3.0: testAutoFlushByTimer is flaky,IGNITE-19859,13541588,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,27/Jun/23 14:45,13/Jul/23 08:08,13/Jul/23 09:11,13/Jul/23 08:08,3.0.0-beta1,,,,,,,3.0.0-beta2,thin client,,,0,ignite-3,,,"https://ci.ignite.apache.org/test/-2896687331391880214?currentProjectId=ApacheIgnite3xGradle_Test_IntegrationTests&expandTestHistoryChartSection=true&branch=

{code}
org.opentest4j.AssertionFailedError: expected: <true> but was: <false>
  at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151)
  at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132)
  at app//org.junit.jupiter.api.AssertTrue.failNotTrue(AssertTrue.java:63)
  at app//org.junit.jupiter.api.AssertTrue.assertTrue(AssertTrue.java:36)
  at app//org.junit.jupiter.api.AssertTrue.assertTrue(AssertTrue.java:31)
  at app//org.junit.jupiter.api.Assertions.assertTrue(Assertions.java:180)
  at app//org.apache.ignite.internal.streamer.ItAbstractDataStreamerTest.testAutoFlushByTimer(ItAbstractDataStreamerTest.java:144)
{code}",,isapego,ptupitsyn,,,,"ptupitsyn opened a new pull request, #2313:
URL: https://github.com/apache/ignite-3/pull/2313

   (no comment)


;13/Jul/23 07:07;githubbot;600","ptupitsyn merged PR #2313:
URL: https://github.com/apache/ignite-3/pull/2313


;13/Jul/23 08:08;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,java,Thu Jul 13 08:08:54 UTC 2023,,,,,,,,,,"0|z1itao:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"13/Jul/23 07:56;ptupitsyn;[~isapego] please review.;;;","13/Jul/23 07:57;isapego;Looks good to me.;;;","13/Jul/23 08:08;ptupitsyn;Merged to main: 415b262b752de54633fcd03b8b9a4565a97a96fa;;;",,,
Default zone replica count is not listened by rebalance trigger,IGNITE-19857,13541585,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,rpuch,rpuch,rpuch,27/Jun/23 14:38,30/Jun/23 06:51,13/Jul/23 09:11,30/Jun/23 06:51,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"As a result, when 'replicas' is changed on a default zone, rebalance is not triggered",,alapin,rpuch,,,,"rpuch opened a new pull request, #2264:
URL: https://github.com/apache/ignite-3/pull/2264

   https://issues.apache.org/jira/browse/IGNITE-19857


;27/Jun/23 15:26;githubbot;600","sanpwc commented on code in PR #2264:
URL: https://github.com/apache/ignite-3/pull/2264#discussion_r1246240312


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/rebalance/DistributionZoneRebalanceEngine.java:
##########
@@ -85,6 +86,8 @@ public class DistributionZoneRebalanceEngine {
     /** Meta storage listener for data nodes changes. */
     private final WatchListener dataNodesListener;
 
+    private final ConfigurationListener<Integer> onUpdateReplicas = this::onUpdateReplicas;

Review Comment:
   Just curious, why we need this? In order not to write this::onUpdateReplicas?



##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/rebalance/DistributionZoneRebalanceEngineTest.java:
##########
@@ -393,6 +368,72 @@ void staleDataNodesEvent(
         verify(keyValueStorage, timeout(1000).times(2)).invoke(any(), any());
     }
 
+    @Test
+    void replicasTriggersAssignmentsChangingOnNonDefaultZones(
+            @InjectConfiguration
+                    (""mock.tables {""
+                            + ""table0 = { zoneId = 1 },""
+                            + ""table1 = { zoneId = 1 },""
+                            + ""table2 = { zoneId = 2 }}"")
+            TablesConfiguration tablesConfiguration
+    ) {
+        assignTableIds(tablesConfiguration);
+
+        when(distributionZoneManager.dataNodes(anyInt())).thenReturn(Set.of(""node0""));
+
+        createRebalanceEngine(tablesConfiguration);
+
+        rebalanceEngine.start();

Review Comment:
   Should we also stop it?



##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/rebalance/DistributionZoneRebalanceEngineTest.java:
##########
@@ -393,6 +368,72 @@ void staleDataNodesEvent(
         verify(keyValueStorage, timeout(1000).times(2)).invoke(any(), any());
     }
 
+    @Test
+    void replicasTriggersAssignmentsChangingOnNonDefaultZones(
+            @InjectConfiguration
+                    (""mock.tables {""
+                            + ""table0 = { zoneId = 1 },""
+                            + ""table1 = { zoneId = 1 },""
+                            + ""table2 = { zoneId = 2 }}"")
+            TablesConfiguration tablesConfiguration
+    ) {
+        assignTableIds(tablesConfiguration);
+
+        when(distributionZoneManager.dataNodes(anyInt())).thenReturn(Set.of(""node0""));
+
+        createRebalanceEngine(tablesConfiguration);
+
+        rebalanceEngine.start();
+
+        CompletableFuture<Void> changeFuture = distributionZonesConfiguration.change(zonesChange -> zonesChange.changeDistributionZones(
+                zoneListChange -> zoneListChange.update(""zone0"", zoneChange -> zoneChange.changeReplicas(2))
+        ));
+        assertThat(changeFuture, willCompleteSuccessfully());
+
+        verify(keyValueStorage, timeout(1000).times(2)).invoke(any(), any());

Review Comment:
   So, we are checking that invoke is called on keyValueStorage assuming that within given test context it might be called only within rebalance assignments test, right? Looks unreliable to me.



##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/rebalance/DistributionZoneRebalanceEngine.java:
##########
@@ -311,7 +318,7 @@ private CompletableFuture<?> onUpdateReplicas(ConfigurationNotificationEvent<Int
                                         replicasCtx.storageRevision(),
                                         metaStorageManager,
                                         partId,
-                                        tableAssignments.get(partId)
+                                        tableAssignments.isEmpty() ? emptySet() : tableAssignments.get(partId)

Review Comment:
   I don't think that we support empty assignments processing. That should be addressed at least in https://issues.apache.org/jira/browse/IGNITE-19466 and https://issues.apache.org/jira/browse/IGNITE-19763, so for now it's better to get NPE here, because otherwise we may miss it.



##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/rebalance/DistributionZoneRebalanceEngineTest.java:
##########
@@ -393,6 +368,72 @@ void staleDataNodesEvent(
         verify(keyValueStorage, timeout(1000).times(2)).invoke(any(), any());
     }
 
+    @Test
+    void replicasTriggersAssignmentsChangingOnNonDefaultZones(
+            @InjectConfiguration
+                    (""mock.tables {""
+                            + ""table0 = { zoneId = 1 },""
+                            + ""table1 = { zoneId = 1 },""
+                            + ""table2 = { zoneId = 2 }}"")
+            TablesConfiguration tablesConfiguration
+    ) {
+        assignTableIds(tablesConfiguration);
+
+        when(distributionZoneManager.dataNodes(anyInt())).thenReturn(Set.of(""node0""));
+
+        createRebalanceEngine(tablesConfiguration);
+
+        rebalanceEngine.start();
+
+        CompletableFuture<Void> changeFuture = distributionZonesConfiguration.change(zonesChange -> zonesChange.changeDistributionZones(
+                zoneListChange -> zoneListChange.update(""zone0"", zoneChange -> zoneChange.changeReplicas(2))
+        ));
+        assertThat(changeFuture, willCompleteSuccessfully());
+
+        verify(keyValueStorage, timeout(1000).times(2)).invoke(any(), any());
+    }
+
+    @Test
+    void replicasTriggersAssignmentsChangingOnDefaultZone(

Review Comment:
   Did you consider test parametrization for replicasTriggersAssignmentsChangingOnNonDefaultZones  and replicasTriggersAssignmentsChangingOnDefaultZone?



##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/rebalance/DistributionZoneRebalanceEngineTest.java:
##########
@@ -393,6 +368,72 @@ void staleDataNodesEvent(
         verify(keyValueStorage, timeout(1000).times(2)).invoke(any(), any());
     }
 
+    @Test
+    void replicasTriggersAssignmentsChangingOnNonDefaultZones(
+            @InjectConfiguration
+                    (""mock.tables {""
+                            + ""table0 = { zoneId = 1 },""
+                            + ""table1 = { zoneId = 1 },""
+                            + ""table2 = { zoneId = 2 }}"")
+            TablesConfiguration tablesConfiguration
+    ) {
+        assignTableIds(tablesConfiguration);
+
+        when(distributionZoneManager.dataNodes(anyInt())).thenReturn(Set.of(""node0""));
+
+        createRebalanceEngine(tablesConfiguration);
+
+        rebalanceEngine.start();
+
+        CompletableFuture<Void> changeFuture = distributionZonesConfiguration.change(zonesChange -> zonesChange.changeDistributionZones(
+                zoneListChange -> zoneListChange.update(""zone0"", zoneChange -> zoneChange.changeReplicas(2))
+        ));
+        assertThat(changeFuture, willCompleteSuccessfully());
+
+        verify(keyValueStorage, timeout(1000).times(2)).invoke(any(), any());
+    }
+
+    @Test
+    void replicasTriggersAssignmentsChangingOnDefaultZone(
+            @InjectConfiguration
+                    (""mock.tables {""
+                            + ""table0 = { zoneId = 0 },""
+                            + ""table1 = { zoneId = 0 },""
+                            + ""table2 = { zoneId = 2 }}"")
+            TablesConfiguration tablesConfiguration
+    ) {
+        assignTableIds(tablesConfiguration);
+
+        when(distributionZoneManager.dataNodes(anyInt())).thenReturn(Set.of(""node0""));
+
+        createRebalanceEngine(tablesConfiguration);
+
+        rebalanceEngine.start();
+
+        CompletableFuture<Void> changeFuture = distributionZonesConfiguration.change(zonesChange ->
+                zonesChange.changeDefaultDistributionZone(zoneChange -> {
+                    zoneChange.changeReplicas(2);
+
+                    // Also change partitions to be independent from the defaults.
+                    zoneChange.changePartitions(1);

Review Comment:
   Not sure that I get if. Is initial zone creation? Because partitions count is immutable.



;29/Jun/23 08:12;githubbot;600","rpuch commented on code in PR #2264:
URL: https://github.com/apache/ignite-3/pull/2264#discussion_r1246390588


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/rebalance/DistributionZoneRebalanceEngine.java:
##########
@@ -85,6 +86,8 @@ public class DistributionZoneRebalanceEngine {
     /** Meta storage listener for data nodes changes. */
     private final WatchListener dataNodesListener;
 
+    private final ConfigurationListener<Integer> onUpdateReplicas = this::onUpdateReplicas;

Review Comment:
   To make it possible to do `stop listening` on stop



;29/Jun/23 09:40;githubbot;600","rpuch commented on code in PR #2264:
URL: https://github.com/apache/ignite-3/pull/2264#discussion_r1246392370


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/rebalance/DistributionZoneRebalanceEngineTest.java:
##########
@@ -393,6 +368,72 @@ void staleDataNodesEvent(
         verify(keyValueStorage, timeout(1000).times(2)).invoke(any(), any());
     }
 
+    @Test
+    void replicasTriggersAssignmentsChangingOnNonDefaultZones(
+            @InjectConfiguration
+                    (""mock.tables {""
+                            + ""table0 = { zoneId = 1 },""
+                            + ""table1 = { zoneId = 1 },""
+                            + ""table2 = { zoneId = 2 }}"")
+            TablesConfiguration tablesConfiguration
+    ) {
+        assignTableIds(tablesConfiguration);
+
+        when(distributionZoneManager.dataNodes(anyInt())).thenReturn(Set.of(""node0""));
+
+        createRebalanceEngine(tablesConfiguration);
+
+        rebalanceEngine.start();

Review Comment:
   It's stopped in `tearDown()`



;29/Jun/23 09:41;githubbot;600","rpuch commented on code in PR #2264:
URL: https://github.com/apache/ignite-3/pull/2264#discussion_r1246409461


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/rebalance/DistributionZoneRebalanceEngineTest.java:
##########
@@ -393,6 +368,72 @@ void staleDataNodesEvent(
         verify(keyValueStorage, timeout(1000).times(2)).invoke(any(), any());
     }
 
+    @Test
+    void replicasTriggersAssignmentsChangingOnNonDefaultZones(
+            @InjectConfiguration
+                    (""mock.tables {""
+                            + ""table0 = { zoneId = 1 },""
+                            + ""table1 = { zoneId = 1 },""
+                            + ""table2 = { zoneId = 2 }}"")
+            TablesConfiguration tablesConfiguration
+    ) {
+        assignTableIds(tablesConfiguration);
+
+        when(distributionZoneManager.dataNodes(anyInt())).thenReturn(Set.of(""node0""));
+
+        createRebalanceEngine(tablesConfiguration);
+
+        rebalanceEngine.start();
+
+        CompletableFuture<Void> changeFuture = distributionZonesConfiguration.change(zonesChange -> zonesChange.changeDistributionZones(
+                zoneListChange -> zoneListChange.update(""zone0"", zoneChange -> zoneChange.changeReplicas(2))
+        ));
+        assertThat(changeFuture, willCompleteSuccessfully());
+
+        verify(keyValueStorage, timeout(1000).times(2)).invoke(any(), any());
+    }
+
+    @Test
+    void replicasTriggersAssignmentsChangingOnDefaultZone(

Review Comment:
   I did, but the config is injected via a parameter, which clashes with how `@ParameterizedTest` deals with method parameters



;29/Jun/23 09:56;githubbot;600","rpuch commented on code in PR #2264:
URL: https://github.com/apache/ignite-3/pull/2264#discussion_r1246665166


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/rebalance/DistributionZoneRebalanceEngineTest.java:
##########
@@ -393,6 +368,72 @@ void staleDataNodesEvent(
         verify(keyValueStorage, timeout(1000).times(2)).invoke(any(), any());
     }
 
+    @Test
+    void replicasTriggersAssignmentsChangingOnNonDefaultZones(
+            @InjectConfiguration
+                    (""mock.tables {""
+                            + ""table0 = { zoneId = 1 },""
+                            + ""table1 = { zoneId = 1 },""
+                            + ""table2 = { zoneId = 2 }}"")
+            TablesConfiguration tablesConfiguration
+    ) {
+        assignTableIds(tablesConfiguration);
+
+        when(distributionZoneManager.dataNodes(anyInt())).thenReturn(Set.of(""node0""));
+
+        createRebalanceEngine(tablesConfiguration);
+
+        rebalanceEngine.start();
+
+        CompletableFuture<Void> changeFuture = distributionZonesConfiguration.change(zonesChange -> zonesChange.changeDistributionZones(
+                zoneListChange -> zoneListChange.update(""zone0"", zoneChange -> zoneChange.changeReplicas(2))
+        ));
+        assertThat(changeFuture, willCompleteSuccessfully());
+
+        verify(keyValueStorage, timeout(1000).times(2)).invoke(any(), any());
+    }
+
+    @Test
+    void replicasTriggersAssignmentsChangingOnDefaultZone(
+            @InjectConfiguration
+                    (""mock.tables {""
+                            + ""table0 = { zoneId = 0 },""
+                            + ""table1 = { zoneId = 0 },""
+                            + ""table2 = { zoneId = 2 }}"")
+            TablesConfiguration tablesConfiguration
+    ) {
+        assignTableIds(tablesConfiguration);
+
+        when(distributionZoneManager.dataNodes(anyInt())).thenReturn(Set.of(""node0""));
+
+        createRebalanceEngine(tablesConfiguration);
+
+        rebalanceEngine.start();
+
+        CompletableFuture<Void> changeFuture = distributionZonesConfiguration.change(zonesChange ->
+                zonesChange.changeDefaultDistributionZone(zoneChange -> {
+                    zoneChange.changeReplicas(2);
+
+                    // Also change partitions to be independent from the defaults.
+                    zoneChange.changePartitions(1);

Review Comment:
   I removed this to avoid confusion



;29/Jun/23 14:00;githubbot;600","rpuch commented on code in PR #2264:
URL: https://github.com/apache/ignite-3/pull/2264#discussion_r1246713441


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/rebalance/DistributionZoneRebalanceEngineTest.java:
##########
@@ -393,6 +368,72 @@ void staleDataNodesEvent(
         verify(keyValueStorage, timeout(1000).times(2)).invoke(any(), any());
     }
 
+    @Test
+    void replicasTriggersAssignmentsChangingOnNonDefaultZones(
+            @InjectConfiguration
+                    (""mock.tables {""
+                            + ""table0 = { zoneId = 1 },""
+                            + ""table1 = { zoneId = 1 },""
+                            + ""table2 = { zoneId = 2 }}"")
+            TablesConfiguration tablesConfiguration
+    ) {
+        assignTableIds(tablesConfiguration);
+
+        when(distributionZoneManager.dataNodes(anyInt())).thenReturn(Set.of(""node0""));
+
+        createRebalanceEngine(tablesConfiguration);
+
+        rebalanceEngine.start();
+
+        CompletableFuture<Void> changeFuture = distributionZonesConfiguration.change(zonesChange -> zonesChange.changeDistributionZones(
+                zoneListChange -> zoneListChange.update(""zone0"", zoneChange -> zoneChange.changeReplicas(2))
+        ));
+        assertThat(changeFuture, willCompleteSuccessfully());
+
+        verify(keyValueStorage, timeout(1000).times(2)).invoke(any(), any());

Review Comment:
   Now I check the contents of the KV store instead of looking at `invoke()` invocations



;29/Jun/23 14:36;githubbot;600","sanpwc merged PR #2264:
URL: https://github.com/apache/ignite-3/pull/2264


;30/Jun/23 06:50;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,4800,,,0,4800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Jun 30 06:51:25 UTC 2023,,,,,,,,,,"0|z1ita0:",9223372036854775807,,,alapin,,,,,,,,,,,,,,,,,,"27/Jun/23 15:40;rpuch;[~sanpwc] could you please take a look at the attached PR?;;;","30/Jun/23 06:51;alapin;LGTM, merged.;;;",,,,
Add MetaStorage update update listeners and use instead of configuration revision update listeners,IGNITE-19851,13541518,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ibessonov,ktkalenko@gridgain.com,ktkalenko@gridgain.com,27/Jun/23 07:58,28/Jun/23 11:27,13/Jul/23 09:11,28/Jun/23 11:27,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"The main problem is described in IGNITE-19801, but due to the fact that we now have code closely related to updating the configuration revision, it is difficult to do everything at once in IGNITE-19801, so it will be divided into parts.

In this task, I will add listeners for updating the revision of the *MetaStorage* and replace it with its use in the production code.",,ktkalenko@gridgain.com,rpuch,,,,"tkalkirill opened a new pull request, #2261:
URL: https://github.com/apache/ignite-3/pull/2261

   https://issues.apache.org/jira/browse/IGNITE-19851


;27/Jun/23 08:35;githubbot;600","ibessonov commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1243365841


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -216,4 +216,10 @@ public interface MetaStorageManager extends IgniteComponent {
      * @return Cluster time.
      */
     ClusterTime clusterTime();
+
+    /** Registers a Meta Storage revision update listener. */
+    void registerUpdateRevisionListener(UpdateRevisionListener listener);

Review Comment:
   ""revision update"", not ""update revision""



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -671,7 +677,9 @@ private CompletableFuture<Void> onRevisionApplied(WatchEvent watchEvent, HybridT
                 saveToVaultFuture = vaultMgr.putAll(batch);
             }
 
-            return saveToVaultFuture.thenRun(() -> appliedRevision = watchEvent.revision());
+            return saveToVaultFuture
+                    .thenRun(() -> appliedRevision = watchEvent.revision())
+                    .thenCompose(unused -> notifyUpdateRevisionListeners(watchEvent.revision()));

Review Comment:
   It's a wrong place, meta-storage is completely broken now



##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/UpdateRevisionListener.java:
##########
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage;
+
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * The listener which receives and handles the Meta Storage revision update.
+ */
+@FunctionalInterface
+public interface UpdateRevisionListener {

Review Comment:
   I suggest renaming this interface as well



##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -454,7 +454,7 @@ public class IgniteImpl implements Ignite {
         );
 
         Consumer<LongFunction<CompletableFuture<?>>> registry =
-                c -> clusterConfigRegistry.listenUpdateStorageRevision(c::apply);
+                c -> metaStorageMgr.registerUpdateRevisionListener(revision -> (CompletableFuture<Void>) c.apply(revision));

Review Comment:
   Why ""c::apply"" stopped working? Maybe `onUpdate` should return `CompletableFuture<?>`? Would be convenient I guess



;27/Jun/23 09:00;githubbot;600","tkalkirill commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1243613403


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -216,4 +216,10 @@ public interface MetaStorageManager extends IgniteComponent {
      * @return Cluster time.
      */
     ClusterTime clusterTime();
+
+    /** Registers a Meta Storage revision update listener. */
+    void registerUpdateRevisionListener(UpdateRevisionListener listener);

Review Comment:
   fix it



##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/UpdateRevisionListener.java:
##########
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage;
+
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * The listener which receives and handles the Meta Storage revision update.
+ */
+@FunctionalInterface
+public interface UpdateRevisionListener {

Review Comment:
   fix it



;27/Jun/23 11:56;githubbot;600","tkalkirill commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1243613669


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -671,7 +677,9 @@ private CompletableFuture<Void> onRevisionApplied(WatchEvent watchEvent, HybridT
                 saveToVaultFuture = vaultMgr.putAll(batch);
             }
 
-            return saveToVaultFuture.thenRun(() -> appliedRevision = watchEvent.revision());
+            return saveToVaultFuture
+                    .thenRun(() -> appliedRevision = watchEvent.revision())
+                    .thenCompose(unused -> notifyUpdateRevisionListeners(watchEvent.revision()));

Review Comment:
   fix it



;27/Jun/23 11:56;githubbot;600","tkalkirill commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1243614330


##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -454,7 +454,7 @@ public class IgniteImpl implements Ignite {
         );
 
         Consumer<LongFunction<CompletableFuture<?>>> registry =
-                c -> clusterConfigRegistry.listenUpdateStorageRevision(c::apply);
+                c -> metaStorageMgr.registerUpdateRevisionListener(revision -> (CompletableFuture<Void>) c.apply(revision));

Review Comment:
   It is necessary then to do refactoring, I propose to do it in a separate ticket.



##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -454,7 +454,7 @@ public class IgniteImpl implements Ignite {
         );
 
         Consumer<LongFunction<CompletableFuture<?>>> registry =
-                c -> clusterConfigRegistry.listenUpdateStorageRevision(c::apply);
+                c -> metaStorageMgr.registerUpdateRevisionListener(revision -> (CompletableFuture<Void>) c.apply(revision));

Review Comment:
   It is necessary then to do refactoring шт vv, I propose to do it in a separate ticket.



;27/Jun/23 11:57;githubbot;600","tkalkirill commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1243614330


##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -454,7 +454,7 @@ public class IgniteImpl implements Ignite {
         );
 
         Consumer<LongFunction<CompletableFuture<?>>> registry =
-                c -> clusterConfigRegistry.listenUpdateStorageRevision(c::apply);
+                c -> metaStorageMgr.registerUpdateRevisionListener(revision -> (CompletableFuture<Void>) c.apply(revision));

Review Comment:
   It is necessary then to do refactoring vv, I propose to do it in a separate ticket.



;27/Jun/23 12:11;githubbot;600","rpuch commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1244805715


##########
modules/configuration/src/main/java/org/apache/ignite/internal/configuration/notifications/ConfigurationStorageRevisionListener.java:
##########
@@ -24,6 +24,7 @@
  *
  * <p>Storage revision - monotonously increasing counter, linked to the specific storage for current configuration values.
  */
+// TODO: IGNITE-19801 Get rid of

Review Comment:
   ```suggestion
   // TODO: IGNITE-19801 Get rid of this interface
   ```



##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -222,4 +222,13 @@ public interface MetaStorageManager extends IgniteComponent {
      * The value of the future is the revision which must be used for state recovery by other components.
      */
     CompletableFuture<Long> recoveryFinishedFuture();
+
+    /** Registers a Meta Storage revision update listener. */
+    void registerRevisionUpdateListener(RevisionUpdateListener listener);
+
+    /** Unregisters a Meta Storage revision update listener. */
+    void unregisterRevisionUpdateListener(RevisionUpdateListener listener);
+
+    /** Explicitly notifies revision update listeners. */
+    CompletableFuture<Void> notifyRevisionUpdateListenerOnStart(long newRevision);

Review Comment:
   Is this method needed on the 'public' interface? Would it be enough to have it on the main implementation?



##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/WatchListener.java:
##########
@@ -37,6 +37,7 @@ public interface WatchListener {
      * @param revision Meta Storage revision.
      * @return Future that will be completed when the event is processed.
      */
+    // TODO: IGNITE-19801 Get rid of

Review Comment:
   ```suggestion
       // TODO: IGNITE-19801 Get rid of this method
   ```



##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/RevisionUpdateListener.java:
##########
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage;
+
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * The listener which receives and handles the Meta Storage revision update.

Review Comment:
   Are there any guarantees that no listener will be notified about revision N+1 before all listeners have finished processing a notification about revision N? I think it makes sense to document it somewhere, maybe here.



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/WatchProcessor.java:
##########
@@ -128,75 +131,94 @@ public void notifyWatches(List<Entry> updatedEntries, HybridTimestamp time) {
                     // Revision must be the same for all entries.
                     long newRevision = updatedEntries.get(0).revision();
 
-                    // Notify all watches in parallel, then aggregate the entries that they have processed.
-                    CompletableFuture<List<EntryEvent>>[] notificationFutures = watches.stream()
-                            .map(watch -> notifyWatch(watch, updatedEntries, newRevision, time))
-                            .toArray(CompletableFuture[]::new);
+                    // Collect all the events for each watch.
+                    CompletableFuture<List<WatchAndEvents>> watchAndEventsFuture = collectWatchAndEvents(updatedEntries, newRevision);
 
-                    return allOf(notificationFutures)
-                            .thenComposeAsync(ignored -> invokeOnRevisionCallback(notificationFutures, newRevision, time), watchExecutor);
+                    return watchAndEventsFuture
+                            .thenComposeAsync(watchAndEvents -> allOf(
+                                    notifyWatches(watchAndEvents, newRevision, time),
+                                    notifyUpdateRevisionListeners(newRevision)

Review Comment:
   So both types of notifications are run in parallel. Is this ok? I would expect the revision update listeners to be notified after all watches have been notified.



##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -754,7 +754,30 @@ public CompletableFuture<Ignite> start(Path configPath) {
                                 fut -> new ConfigurationCatchUpListener(cfgStorage, fut, LOG)
                         );
 
-                        return notifyConfigurationListeners()
+                        // Temporary workaround.
+                        // In order to avoid making a public getter for configuration revision, I read it from the startup notification.
+                        // It should be removed once we start using up-to-date meta-storage revision for node startup.

Review Comment:
   Let's add a TODO



##########
modules/configuration/src/testFixtures/java/org/apache/ignite/internal/configuration/testframework/InjectRevisionListenerHolder.java:
##########
@@ -30,5 +30,6 @@
  */
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ElementType.FIELD, ElementType.PARAMETER})
+// TODO: IGNITE-19853 Get rid of

Review Comment:
   ```suggestion
   // TODO: IGNITE-19853 Get rid of this annotation
   ```



##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/RevisionUpdateListener.java:
##########
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage;
+
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * The listener which receives and handles the Meta Storage revision update.
+ */
+@FunctionalInterface
+public interface RevisionUpdateListener {
+    /**
+     * Callback that will be invoked if a Meta Storage revision update has been received.

Review Comment:
   ```suggestion
        * Callback that will be invoked when a Meta Storage revision update has been received.
   ```



##########
modules/metastorage/src/integrationTest/java/org/apache/ignite/internal/metastorage/impl/ItMetaStorageManagerImplTest.java:
##########
@@ -284,4 +286,24 @@ void testMetaStorageStopBeforeRaftServiceStarted() throws Exception {
 
         assertThat(metaStorageManager.metaStorageServiceFuture(), willThrowFast(CancellationException.class));
     }
+
+    @Test
+    void testUpdateRevisionListener() {
+        // I'm using the future because mock+verify doesn't work.

Review Comment:
   I'm curious, what does not work here?



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/WatchProcessor.java:
##########
@@ -128,75 +131,94 @@ public void notifyWatches(List<Entry> updatedEntries, HybridTimestamp time) {
                     // Revision must be the same for all entries.
                     long newRevision = updatedEntries.get(0).revision();
 
-                    // Notify all watches in parallel, then aggregate the entries that they have processed.
-                    CompletableFuture<List<EntryEvent>>[] notificationFutures = watches.stream()
-                            .map(watch -> notifyWatch(watch, updatedEntries, newRevision, time))
-                            .toArray(CompletableFuture[]::new);
+                    // Collect all the events for each watch.
+                    CompletableFuture<List<WatchAndEvents>> watchAndEventsFuture = collectWatchAndEvents(updatedEntries, newRevision);

Review Comment:
   ```suggestion
                       CompletableFuture<List<WatchAndEvents>> watchesAndEventsFuture = collectWatchAndEvents(updatedEntries, newRevision);
   ```



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/WatchProcessor.java:
##########
@@ -128,75 +131,94 @@ public void notifyWatches(List<Entry> updatedEntries, HybridTimestamp time) {
                     // Revision must be the same for all entries.
                     long newRevision = updatedEntries.get(0).revision();
 
-                    // Notify all watches in parallel, then aggregate the entries that they have processed.
-                    CompletableFuture<List<EntryEvent>>[] notificationFutures = watches.stream()
-                            .map(watch -> notifyWatch(watch, updatedEntries, newRevision, time))
-                            .toArray(CompletableFuture[]::new);
+                    // Collect all the events for each watch.
+                    CompletableFuture<List<WatchAndEvents>> watchAndEventsFuture = collectWatchAndEvents(updatedEntries, newRevision);
 
-                    return allOf(notificationFutures)
-                            .thenComposeAsync(ignored -> invokeOnRevisionCallback(notificationFutures, newRevision, time), watchExecutor);
+                    return watchAndEventsFuture
+                            .thenComposeAsync(watchAndEvents -> allOf(
+                                    notifyWatches(watchAndEvents, newRevision, time),
+                                    notifyUpdateRevisionListeners(newRevision)
+                            ), watchExecutor)
+                            .thenComposeAsync(ignored -> invokeOnRevisionCallback(watchAndEventsFuture, newRevision, time), watchExecutor);
                 }, watchExecutor);
     }
 
-    private CompletableFuture<List<EntryEvent>> notifyWatch(Watch watch, List<Entry> updatedEntries, long revision, HybridTimestamp time) {
-        CompletableFuture<List<EntryEvent>> eventFuture = supplyAsync(() -> {
-            List<EntryEvent> entryEvents = List.of();
 
-            for (Entry newEntry : updatedEntries) {
-                byte[] newKey = newEntry.key();
+    private static CompletableFuture<Void> notifyWatches(List<WatchAndEvents> watchAndEventsList, long revision, HybridTimestamp time) {
+        if (watchAndEventsList.isEmpty()) {
+            return completedFuture(null);
+        }
 
-                assert newEntry.revision() == revision;
+        CompletableFuture<?>[] notifyWatchFutures = new CompletableFuture[watchAndEventsList.size()];
 
-                if (watch.matches(newKey, revision)) {
-                    Entry oldEntry = entryReader.get(newKey, revision - 1);
+        int i = 0;
 
-                    if (entryEvents.isEmpty()) {
-                        entryEvents = new ArrayList<>();
-                    }
+        for (WatchAndEvents watchAndEvents : watchAndEventsList) {
+            CompletableFuture<Void> notifyWatchFuture;
 
-                    entryEvents.add(new EntryEvent(oldEntry, newEntry));
-                }
+            try {
+                notifyWatchFuture = watchAndEvents.events.isEmpty()
+                        ? watchAndEvents.watch.onRevisionUpdated(revision)
+                        : watchAndEvents.watch.onUpdate(new WatchEvent(watchAndEvents.events, revision, time));
+            } catch (Throwable throwable) {
+                watchAndEvents.watch.onError(throwable);
+
+                notifyWatchFuture = failedFuture(throwable);
             }
 
-            return entryEvents;
-        }, watchExecutor);
+            notifyWatchFutures[i++] = notifyWatchFuture;
+        }
 
-        return eventFuture
-                .thenCompose(entryEvents -> {
-                    CompletableFuture<Void> eventNotificationFuture = entryEvents.isEmpty()
-                            ? watch.onRevisionUpdated(revision)
-                            : watch.onUpdate(new WatchEvent(entryEvents, revision, time));
-
-                    return eventNotificationFuture.thenApply(v -> entryEvents);
-                })
-                .whenComplete((v, e) -> {
-                    if (e != null) {
-                        if (e instanceof CompletionException) {
-                            e = e.getCause();
-                        }
+        return allOf(notifyWatchFutures);
+    }
 
-                        // TODO: IGNITE-14693 Implement Meta storage exception handling logic.
-                        LOG.error(""Error occurred when processing a watch event"", e);
+    private CompletableFuture<List<WatchAndEvents>> collectWatchAndEvents(List<Entry> updatedEntries, long revision) {

Review Comment:
   ```suggestion
       private CompletableFuture<List<WatchAndEvents>> collectWatchesAndEvents(List<Entry> updatedEntries, long revision) {
   ```



##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -754,7 +754,30 @@ public CompletableFuture<Ignite> start(Path configPath) {
                                 fut -> new ConfigurationCatchUpListener(cfgStorage, fut, LOG)
                         );
 
-                        return notifyConfigurationListeners()
+                        // Temporary workaround.

Review Comment:
   How about trying to extract this (maybe the whole 'recovery' block) to a method? It's ugly to have such long methods as this `start()`, it's really difficult to navigate. The workaround could (if possible) be extracted too, to improve readability.



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/WatchProcessor.java:
##########
@@ -128,75 +131,94 @@ public void notifyWatches(List<Entry> updatedEntries, HybridTimestamp time) {
                     // Revision must be the same for all entries.
                     long newRevision = updatedEntries.get(0).revision();
 
-                    // Notify all watches in parallel, then aggregate the entries that they have processed.
-                    CompletableFuture<List<EntryEvent>>[] notificationFutures = watches.stream()
-                            .map(watch -> notifyWatch(watch, updatedEntries, newRevision, time))
-                            .toArray(CompletableFuture[]::new);
+                    // Collect all the events for each watch.
+                    CompletableFuture<List<WatchAndEvents>> watchAndEventsFuture = collectWatchAndEvents(updatedEntries, newRevision);
 
-                    return allOf(notificationFutures)
-                            .thenComposeAsync(ignored -> invokeOnRevisionCallback(notificationFutures, newRevision, time), watchExecutor);
+                    return watchAndEventsFuture
+                            .thenComposeAsync(watchAndEvents -> allOf(
+                                    notifyWatches(watchAndEvents, newRevision, time),
+                                    notifyUpdateRevisionListeners(newRevision)
+                            ), watchExecutor)
+                            .thenComposeAsync(ignored -> invokeOnRevisionCallback(watchAndEventsFuture, newRevision, time), watchExecutor);
                 }, watchExecutor);
     }
 
-    private CompletableFuture<List<EntryEvent>> notifyWatch(Watch watch, List<Entry> updatedEntries, long revision, HybridTimestamp time) {
-        CompletableFuture<List<EntryEvent>> eventFuture = supplyAsync(() -> {
-            List<EntryEvent> entryEvents = List.of();
 
-            for (Entry newEntry : updatedEntries) {
-                byte[] newKey = newEntry.key();
+    private static CompletableFuture<Void> notifyWatches(List<WatchAndEvents> watchAndEventsList, long revision, HybridTimestamp time) {
+        if (watchAndEventsList.isEmpty()) {
+            return completedFuture(null);
+        }
 
-                assert newEntry.revision() == revision;
+        CompletableFuture<?>[] notifyWatchFutures = new CompletableFuture[watchAndEventsList.size()];
 
-                if (watch.matches(newKey, revision)) {
-                    Entry oldEntry = entryReader.get(newKey, revision - 1);
+        int i = 0;
 
-                    if (entryEvents.isEmpty()) {
-                        entryEvents = new ArrayList<>();
-                    }
+        for (WatchAndEvents watchAndEvents : watchAndEventsList) {
+            CompletableFuture<Void> notifyWatchFuture;
 
-                    entryEvents.add(new EntryEvent(oldEntry, newEntry));
-                }
+            try {
+                notifyWatchFuture = watchAndEvents.events.isEmpty()
+                        ? watchAndEvents.watch.onRevisionUpdated(revision)
+                        : watchAndEvents.watch.onUpdate(new WatchEvent(watchAndEvents.events, revision, time));

Review Comment:
   Is it ok that we invoke the listener if there are events, and 'revision updated' callback when there are no events? If this the contract?



;28/Jun/23 08:02;githubbot;600","rpuch commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1244842192


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/WatchProcessor.java:
##########
@@ -158,7 +158,7 @@ private static CompletableFuture<Void> notifyWatches(List<WatchAndEvents> watchA
 
             try {
                 notifyWatchFuture = watchAndEvents.events.isEmpty()
-                        ? watchAndEvents.watch.onRevisionUpdated(revision)
+                        ? completedFuture(null)

Review Comment:
   Why isn't `onRevisionUpdated() invoked anymore?



;28/Jun/23 08:03;githubbot;600","ibessonov commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1244848815


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -222,4 +222,13 @@ public interface MetaStorageManager extends IgniteComponent {
      * The value of the future is the revision which must be used for state recovery by other components.
      */
     CompletableFuture<Long> recoveryFinishedFuture();
+
+    /** Registers a Meta Storage revision update listener. */
+    void registerRevisionUpdateListener(RevisionUpdateListener listener);
+
+    /** Unregisters a Meta Storage revision update listener. */
+    void unregisterRevisionUpdateListener(RevisionUpdateListener listener);
+
+    /** Explicitly notifies revision update listeners. */
+    CompletableFuture<Void> notifyRevisionUpdateListenerOnStart(long newRevision);

Review Comment:
   No, we can hide it, I agree



;28/Jun/23 08:09;githubbot;600","ibessonov commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1244852795


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/RevisionUpdateListener.java:
##########
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage;
+
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * The listener which receives and handles the Meta Storage revision update.

Review Comment:
   Ok, I'll expand the documentation



;28/Jun/23 08:12;githubbot;600","ibessonov commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1244856173


##########
modules/metastorage/src/integrationTest/java/org/apache/ignite/internal/metastorage/impl/ItMetaStorageManagerImplTest.java:
##########
@@ -284,4 +286,24 @@ void testMetaStorageStopBeforeRaftServiceStarted() throws Exception {
 
         assertThat(metaStorageManager.metaStorageServiceFuture(), willThrowFast(CancellationException.class));
     }
+
+    @Test
+    void testUpdateRevisionListener() {
+        // I'm using the future because mock+verify doesn't work.

Review Comment:
   I don't know, this is Kirill's code. I'll check what can be done here



;28/Jun/23 08:15;githubbot;600","rpuch commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1244868161


##########
modules/metastorage/src/integrationTest/java/org/apache/ignite/internal/metastorage/impl/ItMetaStorageManagerImplTest.java:
##########
@@ -284,4 +286,24 @@ void testMetaStorageStopBeforeRaftServiceStarted() throws Exception {
 
         assertThat(metaStorageManager.metaStorageServiceFuture(), willThrowFast(CancellationException.class));
     }
+
+    @Test
+    void testUpdateRevisionListener() {
+        // I'm using the future because mock+verify doesn't work.

Review Comment:
   Actually, the code looks fine, just the comment caused some confusion :)



;28/Jun/23 08:25;githubbot;600","ibessonov commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1244872366


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/WatchProcessor.java:
##########
@@ -128,75 +131,94 @@ public void notifyWatches(List<Entry> updatedEntries, HybridTimestamp time) {
                     // Revision must be the same for all entries.
                     long newRevision = updatedEntries.get(0).revision();
 
-                    // Notify all watches in parallel, then aggregate the entries that they have processed.
-                    CompletableFuture<List<EntryEvent>>[] notificationFutures = watches.stream()
-                            .map(watch -> notifyWatch(watch, updatedEntries, newRevision, time))
-                            .toArray(CompletableFuture[]::new);
+                    // Collect all the events for each watch.
+                    CompletableFuture<List<WatchAndEvents>> watchAndEventsFuture = collectWatchAndEvents(updatedEntries, newRevision);
 
-                    return allOf(notificationFutures)
-                            .thenComposeAsync(ignored -> invokeOnRevisionCallback(notificationFutures, newRevision, time), watchExecutor);
+                    return watchAndEventsFuture
+                            .thenComposeAsync(watchAndEvents -> allOf(
+                                    notifyWatches(watchAndEvents, newRevision, time),
+                                    notifyUpdateRevisionListeners(newRevision)

Review Comment:
   I made the same mistake. Let me refactor this code a little bit.
   Methods are called sequentially, but because we see them as arguments of ""allOf"", we perceive them as being in parallel. At least that was my reaction



;28/Jun/23 08:27;githubbot;600","ibessonov commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1244882338


##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -754,7 +754,30 @@ public CompletableFuture<Ignite> start(Path configPath) {
                                 fut -> new ConfigurationCatchUpListener(cfgStorage, fut, LOG)
                         );
 
-                        return notifyConfigurationListeners()
+                        // Temporary workaround.

Review Comment:
   Sure, why not



;28/Jun/23 08:35;githubbot;600","ibessonov commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1244882963


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/WatchProcessor.java:
##########
@@ -128,75 +131,94 @@ public void notifyWatches(List<Entry> updatedEntries, HybridTimestamp time) {
                     // Revision must be the same for all entries.
                     long newRevision = updatedEntries.get(0).revision();
 
-                    // Notify all watches in parallel, then aggregate the entries that they have processed.
-                    CompletableFuture<List<EntryEvent>>[] notificationFutures = watches.stream()
-                            .map(watch -> notifyWatch(watch, updatedEntries, newRevision, time))
-                            .toArray(CompletableFuture[]::new);
+                    // Collect all the events for each watch.
+                    CompletableFuture<List<WatchAndEvents>> watchAndEventsFuture = collectWatchAndEvents(updatedEntries, newRevision);
 
-                    return allOf(notificationFutures)
-                            .thenComposeAsync(ignored -> invokeOnRevisionCallback(notificationFutures, newRevision, time), watchExecutor);
+                    return watchAndEventsFuture
+                            .thenComposeAsync(watchAndEvents -> allOf(
+                                    notifyWatches(watchAndEvents, newRevision, time),
+                                    notifyUpdateRevisionListeners(newRevision)
+                            ), watchExecutor)
+                            .thenComposeAsync(ignored -> invokeOnRevisionCallback(watchAndEventsFuture, newRevision, time), watchExecutor);
                 }, watchExecutor);
     }
 
-    private CompletableFuture<List<EntryEvent>> notifyWatch(Watch watch, List<Entry> updatedEntries, long revision, HybridTimestamp time) {
-        CompletableFuture<List<EntryEvent>> eventFuture = supplyAsync(() -> {
-            List<EntryEvent> entryEvents = List.of();
 
-            for (Entry newEntry : updatedEntries) {
-                byte[] newKey = newEntry.key();
+    private static CompletableFuture<Void> notifyWatches(List<WatchAndEvents> watchAndEventsList, long revision, HybridTimestamp time) {
+        if (watchAndEventsList.isEmpty()) {
+            return completedFuture(null);
+        }
 
-                assert newEntry.revision() == revision;
+        CompletableFuture<?>[] notifyWatchFutures = new CompletableFuture[watchAndEventsList.size()];
 
-                if (watch.matches(newKey, revision)) {
-                    Entry oldEntry = entryReader.get(newKey, revision - 1);
+        int i = 0;
 
-                    if (entryEvents.isEmpty()) {
-                        entryEvents = new ArrayList<>();
-                    }
+        for (WatchAndEvents watchAndEvents : watchAndEventsList) {
+            CompletableFuture<Void> notifyWatchFuture;
 
-                    entryEvents.add(new EntryEvent(oldEntry, newEntry));
-                }
+            try {
+                notifyWatchFuture = watchAndEvents.events.isEmpty()
+                        ? watchAndEvents.watch.onRevisionUpdated(revision)
+                        : watchAndEvents.watch.onUpdate(new WatchEvent(watchAndEvents.events, revision, time));

Review Comment:
   Yes, this is the contract



;28/Jun/23 08:36;githubbot;600","ibessonov commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1244884100


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/WatchProcessor.java:
##########
@@ -158,7 +158,7 @@ private static CompletableFuture<Void> notifyWatches(List<WatchAndEvents> watchA
 
             try {
                 notifyWatchFuture = watchAndEvents.events.isEmpty()
-                        ? watchAndEvents.watch.onRevisionUpdated(revision)
+                        ? completedFuture(null)

Review Comment:
   In reality, no one should use it after this commit, but we leave the code to get rid of it later, in a separate issue



;28/Jun/23 08:36;githubbot;600","ibessonov commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1244920862


##########
modules/metastorage/src/integrationTest/java/org/apache/ignite/internal/metastorage/impl/ItMetaStorageManagerImplTest.java:
##########
@@ -284,4 +286,24 @@ void testMetaStorageStopBeforeRaftServiceStarted() throws Exception {
 
         assertThat(metaStorageManager.metaStorageServiceFuture(), willThrowFast(CancellationException.class));
     }
+
+    @Test
+    void testUpdateRevisionListener() {
+        // I'm using the future because mock+verify doesn't work.

Review Comment:
   It didn't work because the code was wrong, I guess. Verifying with timeout resolved the issue. I already changed the test anyway...



;28/Jun/23 09:06;githubbot;600","rpuch commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1245012622


##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -987,6 +954,49 @@ public void init(
         cmgMgr.initCluster(metaStorageNodeNames, cmgNodeNames, clusterName, clusterConfiguration);
     }
 
+    /**
+     * Recovers components state on start by invoking configuration listeners ({@link #notifyConfigurationListeners()}
+     * and deploying watches after that.
+     */
+    private CompletableFuture<?> recoverComponentsStateOnStart(ExecutorService startupExecutor) {

Review Comment:
   The parameter could be omitted, the field seems to be accessible here



##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/RevisionUpdateListener.java:
##########
@@ -20,12 +20,15 @@
 import java.util.concurrent.CompletableFuture;
 
 /**
- * The listener which receives and handles the Meta Storage revision update.
+ * The listener which receives and handles the Meta Storage revision update. No listeners for revision {@code N+1} will be invoked until
+ * all listeners for revision {@code N} are completed.
+ * Also, this listeners is only triggered strictly after all {@link WatchListener#onUpdate(WatchEvent)} are executed, but not necessarily
+ * completed, for the specified revision.

Review Comment:
   ```suggestion
    * Also, this listener is only triggered strictly after all {@link WatchListener#onUpdate(WatchEvent)} are invoked (but the returned futures
    *  might not still be completed completed), for the specified revision.
   ```



;28/Jun/23 10:28;githubbot;600","ibessonov commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1245021456


##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -987,6 +954,49 @@ public void init(
         cmgMgr.initCluster(metaStorageNodeNames, cmgNodeNames, clusterName, clusterConfiguration);
     }
 
+    /**
+     * Recovers components state on start by invoking configuration listeners ({@link #notifyConfigurationListeners()}
+     * and deploying watches after that.
+     */
+    private CompletableFuture<?> recoverComponentsStateOnStart(ExecutorService startupExecutor) {

Review Comment:
   It's not a field, it's a local variable in ""start"" method



;28/Jun/23 10:34;githubbot;600","rpuch commented on code in PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261#discussion_r1245023160


##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -987,6 +954,49 @@ public void init(
         cmgMgr.initCluster(metaStorageNodeNames, cmgNodeNames, clusterName, clusterConfiguration);
     }
 
+    /**
+     * Recovers components state on start by invoking configuration listeners ({@link #notifyConfigurationListeners()}
+     * and deploying watches after that.
+     */
+    private CompletableFuture<?> recoverComponentsStateOnStart(ExecutorService startupExecutor) {

Review Comment:
   Oops, indeed



;28/Jun/23 10:35;githubbot;600","ibessonov merged PR #2261:
URL: https://github.com/apache/ignite-3/pull/2261


;28/Jun/23 11:26;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,0,12600,,,0,12600,,,,,,,IGNITE-19801,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-19502,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jun 28 10:46:55 UTC 2023,,,,,,,,,,"0|z1isvc:",9223372036854775807,,,rpuch,,,,,,,,,,,,,,,,,,"28/Jun/23 10:46;rpuch;The patch looks good to me;;;",,,,,
Java thin 3.0: Partition awareness uses wrong node id,IGNITE-19827,13541171,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,23/Jun/23 12:34,03/Jul/23 07:47,13/Jul/23 09:11,03/Jul/23 07:47,3.0.0-beta1,,,,,,,3.0.0-beta2,thin client,,,0,ignite-3,,,"There is a confusion between *Local Node ID* (which we get from protocolContext().clusterNode().id()) and *Consistent Node ID* (which is the same as Node Name, comes from protocolContext().clusterNode().name()). Partition assignment (returned by ClientTablePartitionAssignmentGetRequest on the server) is based on *Consistent Node ID*.

All partition awareness tests use FakeServer, so we never tested that it actually works.",,isapego,ptupitsyn,,,,"ptupitsyn opened a new pull request, #2276:
URL: https://github.com/apache/ignite-3/pull/2276

   There was a confusion between *Local Node ID* (`protocolContext().clusterNode().id()`) and *Consistent Node ID* (which is the same as Node Name, comes from `protocolContext().clusterNode().name()`). Partition assignment (returned by `ClientTablePartitionAssignmentGetRequest` on the server) must be based on *Consistent Node ID*.
   
   All partition awareness tests use `FakeIgnite`, so we never tested it on real clusters.
   
   * Remove `ClientFailoverSocket._endpointsById` and related logic, identify nodes only by Name (consistent id)
   * Add `IgniteProxy` to track request routing on real cluster, and compare results to the primary node calculated on the Java side (via Compute)


;03/Jul/23 05:51;githubbot;600","ptupitsyn merged PR #2276:
URL: https://github.com/apache/ignite-3/pull/2276


;03/Jul/23 07:47;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,IGNITE-19826,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,C#,Mon Jul 03 07:47:33 UTC 2023,,,,,,,,,,"0|z1iqqo:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"03/Jul/23 05:55;ptupitsyn;[~isapego] please review.;;;","03/Jul/23 07:22;isapego;Looks good to me.;;;","03/Jul/23 07:47;ptupitsyn;Merged to main: 468af9ef34c8e944c3835fd4972fda19fa493a53;;;",,,
.NET: Thin 3.0: Partition awareness uses wrong node id,IGNITE-19826,13541170,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,23/Jun/23 12:31,29/Jun/23 14:37,13/Jul/23 09:11,29/Jun/23 14:37,3.0.0-beta1,,,,,,,3.0.0-beta2,platforms,thin client,,0,.NET,ignite-3,,"There is a confusion between *Local Node ID* (which we get from ConnectionContext.ClusterNode.Id) and *Consistent Node ID* (which is the same as Node Name, comes from ConnectionContext.ClusterNode.Name). Partition assignment (returned by ClientTablePartitionAssignmentGetRequest on the server) is based on *Consistent Node ID*.

All partition awareness tests use FakeServer, so we never tested that it actually works.",,isapego,ptupitsyn,,,,"ptupitsyn opened a new pull request, #2268:
URL: https://github.com/apache/ignite-3/pull/2268

   (no comment)


;29/Jun/23 12:25;githubbot;600","ptupitsyn merged PR #2268:
URL: https://github.com/apache/ignite-3/pull/2268


;29/Jun/23 14:37;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,IGNITE-19827,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,C#,Thu Jun 29 14:37:25 UTC 2023,,,,,,,,,,"0|z1iqqg:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"29/Jun/23 12:56;ptupitsyn;[~isapego] please review.;;;","29/Jun/23 13:15;isapego;Looks good to me;;;","29/Jun/23 14:37;ptupitsyn;Merged to main: 947710c52c3fd6dbc7098164866b102c4658b619;;;",,,
Calcite engine. Query planning failed when cache size is too big,IGNITE-19818,13541136,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,alex_pl,alex_pl,alex_pl,23/Jun/23 07:59,06/Jul/23 16:54,13/Jul/23 09:11,06/Jul/23 16:54,,,,,,,,2.16,,,,0,ise,,,"We use cache size as estimation for row count while planning, but use {{cache.size()}} method, that returns int value. But if cache size is more than {{Integer.MAX_VALUE}} we get an wrong size or even negative sometimes, which cause assertion errors during planning.
We should fix it to {{cache.sizeLong()}}.",,alex_pl,ignitetcbot,,,,"alex-plekhanov opened a new pull request, #10804:
URL: https://github.com/apache/ignite/pull/10804

   …eeds Integer.MAX_VALUE
   
   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;26/Jun/23 15:08;githubbot;600","sonarcloud[bot] commented on PR #10804:
URL: https://github.com/apache/ignite/pull/10804#issuecomment-1607701876

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10804)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10804&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10804&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10804&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10804&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10804&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10804&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10804&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10804&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10804&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10804&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10804&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10804&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10804&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10804&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10804&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10804&metric=new_duplicated_lines_density&view=list)
   
   


;26/Jun/23 15:16;githubbot;600","asfgit closed pull request #10804: IGNITE-19818 SQL Calcite: Fix failure on planning when cache size exc…
URL: https://github.com/apache/ignite/pull/10804


;06/Jul/23 16:54;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Thu Jul 06 16:54:33 UTC 2023,,,,,,,,,,"0|z1iqiw:",9223372036854775807,SQL Calcite: Fixed failure on planning when cache size exceeds Integer.MAX_VALUE,,,,,,,,,,,,,,,,,,,,"28/Jun/23 18:46;ignitetcbot;{panel:title=Branch: [pull/10804/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10804/head] Base: [master] : New Tests (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Calcite SQL{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7231903]]
* {color:#013220}IgniteCalciteTestSuite: ServerStatisticsIntegrationTest.testSizeIntOverflow - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7231984&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","06/Jul/23 16:54;alex_pl;[~ivandasch], thank for the review! Merged to master.;;;",,,,
Make ItTableScanTest resilient ,IGNITE-19815,13541130,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,korlov,korlov,korlov,23/Jun/23 07:35,23/Jun/23 13:07,13/Jul/23 09:11,23/Jun/23 13:07,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"After IGNITE-17951 a few tests (namely ItTableScanTest and ItInternalTableReadWriteScanTest) were switched to a new scan method accepting tx id only. The difference between old method and new method is that latter lack the tx finalisation step in case of any error. This causes cascade failures of tests within the same class, since no one rollbacks the tx manually.

To make tests more resilient to cascade failures, let's restore the logic for tx finalisation in case of errors during scan.",,korlov,,,,,"korlov42 opened a new pull request, #2244:
URL: https://github.com/apache/ignite-3/pull/2244

   (no comment)


;23/Jun/23 07:51;githubbot;600","korlov42 merged PR #2244:
URL: https://github.com/apache/ignite-3/pull/2244


;23/Jun/23 13:07;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Jun 23 13:07:31 UTC 2023,,,,,,,,,,"0|z1iqhk:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"23/Jun/23 13:07;korlov;Merged to [main|https://github.com/apache/ignite-3/commit/5afdeec51e27f3ba5ecbbd8b4fc70590a64fdbe4].;;;",,,,,
Do not swallow exceptions during start of a partition,IGNITE-19812,13541064,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,rpuch,rpuch,rpuch,22/Jun/23 16:25,12/Jul/23 16:23,13/Jul/23 09:11,12/Jul/23 15:20,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Currently, such exceptions are just logged. They should be propagated.",,rpuch,sdanilov,,,,"rpuch opened a new pull request, #2240:
URL: https://github.com/apache/ignite-3/pull/2240

   https://issues.apache.org/jira/browse/IGNITE-19812


;22/Jun/23 16:29;githubbot;600","SammyVimes merged PR #2240:
URL: https://github.com/apache/ignite-3/pull/2240


;12/Jul/23 15:19;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jul 12 16:23:08 UTC 2023,,,,,,,,,,"0|z1iq2w:",9223372036854775807,,,sdanilov,,,,,,,,,,,,,,,,,,"11/Jul/23 08:35;rpuch;[~sdanilov] could you please take a look at the attached PR?;;;","12/Jul/23 15:20;sdanilov;The patch looks good to me. Thank you for the contribution, merged to the main branch.;;;","12/Jul/23 16:23;rpuch;Thanks!;;;",,,
Continuous qieries backup acknowledge message sending fails for expired entries,IGNITE-19811,13541045,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,alex_pl,alex_pl,alex_pl,22/Jun/23 14:37,06/Jul/23 16:51,13/Jul/23 09:11,06/Jul/23 16:51,,,,,,,,2.16,,,,0,ise,,,"Expire entry event has {{null}} in topology version field (see {{CacheContinuousQueryEntry}} constructor in the {{CacheContinuousQueryManager#onEntryExpired}} method). When Backup acknowledge is sending for such a message it silently (without warnings to log) fails with NPE on {{GridDiscoveryManager#cacheGroupAffinityNodes}} -> {{GridDiscoveryManager#resolveDiscoCache}} for {{null}} topology version (see {{CacheContinuousQueryHandler#sendBackupAcknowledge}}).
This can lead to leaks in query entries buffer ({{CacheContinuousQueryEventBuffer#backupQ}}).",,alex_pl,ignitetcbot,liyuj,,,"alex-plekhanov opened a new pull request, #10816:
URL: https://github.com/apache/ignite/pull/10816

   …pired entries
   
   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;29/Jun/23 07:45;githubbot;600","sonarcloud[bot] commented on PR #10816:
URL: https://github.com/apache/ignite/pull/10816#issuecomment-1612583804

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10816)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10816&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10816&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10816&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10816&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10816&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10816&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10816&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10816&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10816&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10816&resolved=false&types=CODE_SMELL) [![B](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/B-16px.png 'B')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10816&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10816&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10816&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10816&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10816&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10816&metric=new_duplicated_lines_density&view=list)
   
   
   
   ![idea](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/light_bulb-16px.png 'idea') Catch issues before they fail your Quality Gate with our IDE extension ![sonarlint](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/sonarlint-16px.png 'sonarlint') [SonarLint](https://www.sonarsource.com/products/sonarlint/features/connected-mode/?referrer=sonarcloud-welcome)


;29/Jun/23 07:55;githubbot;600","asfgit closed pull request #10816: IGNITE-19811 Fix continuous queries backup ack message sending for ex…
URL: https://github.com/apache/ignite/pull/10816


;06/Jul/23 16:48;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Thu Jul 06 16:51:08 UTC 2023,,,,,,,,,,"0|z1ipyo:",9223372036854775807,Fixed continuous queries backup ack message sending for expired entries,,,,,,,,,,,,,,,,,,,,"03/Jul/23 07:22;ignitetcbot;{panel:title=Branch: [pull/10816/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10816/head] Base: [master] : New Tests (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Continuous Query 4{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7236628]]
* {color:#013220}IgniteCacheQuerySelfTestSuite6: CacheContinuousQueryEntriesExpireTest.testBackupQOnEntriesExpire - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7236699&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","06/Jul/23 16:51;alex_pl;[~PetrovMikhail], thanks for the review! Merged to master.;;;",,,,
.NET: Thin 3.0: MetricsTests.TestHandshakesFailedTimeout is flaky,IGNITE-19808,13541012,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,22/Jun/23 10:29,03/Jul/23 16:03,13/Jul/23 09:11,03/Jul/23 16:03,3.0.0-beta1,,,,,,,3.0.0-beta2,platforms,thin client,,0,.NET,ignite-3,,"*MetricsTests.TestHandshakesFailedTimeout* is flaky:

{code}
Expected: 0
  But was:  2
   at Apache.Ignite.Tests.MetricsTests.TestHandshakesFailedTimeout() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/MetricsTests.cs:line 146
1)    at Apache.Ignite.Tests.MetricsTests.TestHandshakesFailedTimeout() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/MetricsTests.cs:line 146
{code}

https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunNetTests/7312733?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandBuildChangesSection=true&expandBuildTestsSection=true",,isapego,ptupitsyn,,,,"ptupitsyn opened a new pull request, #2277:
URL: https://github.com/apache/ignite-3/pull/2277

   (no comment)


;03/Jul/23 06:19;githubbot;600","ptupitsyn merged PR #2277:
URL: https://github.com/apache/ignite-3/pull/2277


;03/Jul/23 16:03;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,C#,Mon Jul 03 16:03:37 UTC 2023,,,,,,,,,,"0|z1iprk:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"03/Jul/23 14:59;ptupitsyn;Metric tags proved that *TestBackgroundConnectionProcessDoesNotBlockOperations* causes unrelated metrics updates while other tests run, and sometimes results in failing *TestHandshakesFailedTimeout*.;;;","03/Jul/23 14:59;ptupitsyn;50+ green builds: https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunNetTests?branch=pull%2F2277&buildTypeTab=overview&mode=builds&hideProblemsFromDependencies=false&hideTestsFromDependencies=false#7336964;;;","03/Jul/23 14:59;ptupitsyn;[~isapego] please review.;;;","03/Jul/23 15:03;isapego;Looks good to me.;;;","03/Jul/23 16:03;ptupitsyn;Merged to main: f12bbb07d5bb1f56cbd8eaffe77ab7c0369ba0eb;;;",
AssertionError in TableManager.latestTablesById,IGNITE-19805,13540992,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,ibessonov,ptupitsyn,ptupitsyn,22/Jun/23 08:13,22/Jun/23 10:34,13/Jul/23 09:11,22/Jun/23 10:34,3.0.0-beta1,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"The following assertion fails intermittently:
{code:java}
            // ""tablesByIdVv"" is always completed strictly before the ""assignmentsUpdatedVv"".
            assert tablesByIdFuture.isDone();
{code}

{code}
at org.apache.ignite.internal.table.distributed.TableManager.latestTablesById(TableManager.java:1834)
    at org.apache.ignite.internal.table.distributed.TableManager.lambda$tableAsyncInternal$85(TableManager.java:1975)
    at org.apache.ignite.internal.util.IgniteUtils.inBusyLock(IgniteUtils.java:892)
    at org.apache.ignite.internal.table.distributed.TableManager.lambda$tableAsyncInternal$86(TableManager.java:1970)
    at java.base/java.util.concurrent.CompletableFuture.uniComposeStage(CompletableFuture.java:1106)
    at java.base/java.util.concurrent.CompletableFuture.thenCompose(CompletableFuture.java:2235)
    at org.apache.ignite.internal.table.distributed.TableManager.tableAsyncInternal(TableManager.java:1970)
    at org.apache.ignite.internal.table.distributed.TableManager.lambda$tableAsyncInternal$78(TableManager.java:1949)
    at org.apache.ignite.internal.util.IgniteUtils.inBusyLock(IgniteUtils.java:892)
    at org.apache.ignite.internal.table.distributed.TableManager.lambda$tableAsyncInternal$79(TableManager.java:1944)
    at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1072)
    at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
    at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1705)
    at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
    at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
    at java.base/java.lang.Thread.run(Thread.java:834)
{code}

https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunAllTests/7311388?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandCode+Inspection=true&expandBuildProblemsSection=true&expandBuildTestsSection=true",,ptupitsyn,,,,,"ibessonov opened a new pull request, #2235:
URL: https://github.com/apache/ignite-3/pull/2235

   https://issues.apache.org/jira/browse/IGNITE-19805


;22/Jun/23 09:03;githubbot;600","ibessonov merged PR #2235:
URL: https://github.com/apache/ignite-3/pull/2235


;22/Jun/23 10:33;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-06-22 08:13:07.0,,,,,,,,,,"0|z1ipn4:",9223372036854775807,,,sdanilov,,,,,,,,,,,,,,,,,,,,,,,
Sql. Change erroneously annotated sql logic tests under ignite-15623 ,IGNITE-19803,13540990,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,zstan,zstan,zstan,22/Jun/23 07:59,26/Jun/23 07:08,13/Jul/23 09:11,26/Jun/23 07:08,3.0.0-beta1,,,,,,,,sql,,,0,calcite3-required,ignite-3,,"Some tests are erroneously annotated under already completed issue [1], need to be changed for [2].

[1] https://issues.apache.org/jira/browse/IGNITE-15623
[2] https://issues.apache.org/jira/browse/IGNITE-19804",,zstan,,,,,"zstan merged PR #2234:
URL: https://github.com/apache/ignite-3/pull/2234


;26/Jun/23 07:06;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-06-22 07:59:12.0,,,,,,,,,,"0|z1ipmo:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
Configuration prematurely executes metastore revision update listener,IGNITE-19801,13540980,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ibessonov,ktkalenko@gridgain.com,ktkalenko@gridgain.com,22/Jun/23 05:22,12/Jul/23 11:10,13/Jul/23 09:11,12/Jul/23 11:10,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Now there is a problem due to the fact that the configuration completes the *VersionedValue* on updating the revision of the metastore, even if no changes were received for the configuration.

Especially now it manifests itself when, for example, we add a table to the catalog and while listening to this event we try to update any *VersionedValue*, we get an error because the version has already been compiled.",,ktkalenko@gridgain.com,rpuch,,,,"tkalkirill opened a new pull request, #2260:
URL: https://github.com/apache/ignite-3/pull/2260

   https://issues.apache.org/jira/browse/IGNITE-19801


;27/Jun/23 08:12;githubbot;600","ibessonov closed pull request #2260: IGNITE-19801 Configuration prematurely executes metastore revision update listener
URL: https://github.com/apache/ignite-3/pull/2260


;12/Jul/23 08:13;githubbot;600","ibessonov opened a new pull request, #2307:
URL: https://github.com/apache/ignite-3/pull/2307

   https://issues.apache.org/jira/browse/IGNITE-19801


;12/Jul/23 08:14;githubbot;600","ibessonov merged PR #2307:
URL: https://github.com/apache/ignite-3/pull/2307


;12/Jul/23 11:10;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,IGNITE-19853,IGNITE-19851,IGNITE-19852,IGNITE-19500,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-19502,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jul 12 10:17:25 UTC 2023,,,,,,,,,,"0|z1ipkg:",9223372036854775807,,,rpuch,,,,,,,,,,,,,,,,,,"12/Jul/23 10:17;rpuch;The patch looks good to me;;;",,,,,
Thin 3.0: ClientMessagePacker packs binary incorrect tuples,IGNITE-19794,13540895,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,ptupitsyn,korlov,korlov,21/Jun/23 13:09,06/Jul/23 05:12,13/Jul/23 09:11,06/Jul/23 05:12,,,,,,,,3.0.0-beta2,thin client,,,0,ignite-3,,,"Take a look at the method:

{code:java}
    // org.apache.ignite.internal.client.proto.ClientMessagePacker
    public void packBinaryTuple(BinaryTupleReader binaryTupleReader, int elementCount) {
        ByteBuffer buf = binaryTupleReader.byteBuffer();
        int len = buf.limit() - buf.position();

        if (elementCount > -1) {
            binaryTupleReader.seek(elementCount - 1);
            len = binaryTupleReader.end();
            buf.limit(len + buf.position());
        }

        packBinaryHeader(len);
        writePayload(buf);
    }
{code}

If {{elementCount}} is provided (> -1), tuple will be truncated up to the element with index {{elementCount - 1}}. A truncated tuple, although retaining logical equality, is not binary equal to the same tuple, but correctly assembled, since neither offset table nor null map are adjusted.

Because {{ClientMessagePacker}} is a general purpose library to implement protocol between client and server, such behaviour is rather dangerous and should be fixed.

In the attachment there is a test that highlights the problem.",,isapego,korlov,ptupitsyn,,,"ptupitsyn opened a new pull request, #2290:
URL: https://github.com/apache/ignite-3/pull/2290

   (no comment)


;05/Jul/23 12:05;githubbot;600","ptupitsyn merged PR #2290:
URL: https://github.com/apache/ignite-3/pull/2290


;06/Jul/23 05:11;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"21/Jun/23 13:06;korlov;corrupted_tuple_test.patch;https://issues.apache.org/jira/secure/attachment/13060786/corrupted_tuple_test.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jul 06 05:12:22 UTC 2023,,,,,,,,,,"0|z1ip1k:",9223372036854775807,,,korlov,,,,,,,,,,,,,,,,,,"05/Jul/23 12:36;ptupitsyn;[~isapego] [~korlov] please review.;;;","05/Jul/23 21:21;isapego;Looks good to me.;;;","06/Jul/23 05:12;ptupitsyn;Merged to main: 5bd71009c820bf402f19d50e7b5df28238a7b846;;;",,,
Restore components state on metastorage recovery,IGNITE-19778,13540730,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,sdanilov,sdanilov,sdanilov,20/Jun/23 09:54,12/Jul/23 13:59,13/Jul/23 09:11,12/Jul/23 08:05,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Upon metastorage signalling (https://issues.apache.org/jira/browse/IGNITE-19777) that certain revision that was available when recovery started is achieved by the local metastorage storage, components should restore their state using a ""snapshot"" of the data with that specific revision. For example, TableManager might want to start tables that it sees in that snapshot. Note that tables that are missing from the data snapshot, must be destroyed as they are now obsolete.
So state must be restored and outdated remains of the previous state must be cleared out.",,ibessonov,sdanilov,,,,"SammyVimes opened a new pull request, #2266:
URL: https://github.com/apache/ignite-3/pull/2266

   https://issues.apache.org/jira/browse/IGNITE-19778


;28/Jun/23 14:59;githubbot;600","sashapolo commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1251868940


##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/DistributedConfigurationStorage.java:
##########
@@ -206,60 +194,44 @@ public CompletableFuture<Serializable> readLatest(String key) {
 
     @Override
     public CompletableFuture<Data> readDataOnRecovery() throws StorageException {
-        CompletableFuture<Data> future = vaultMgr.get(CONFIGURATION_REVISIONS_KEY)
-                .thenApplyAsync(entry -> {
-                    long revision = resolveRevision(metaStorageMgr.appliedRevision(), entry);
-
-                    return readDataOnRecovery0(revision);
-                }, threadPool);
+        CompletableFuture<Data> future = metaStorageMgr.recoveryFinishedFuture()
+                .thenApplyAsync(this::readDataOnRecovery0, threadPool);
 
         return registerFuture(future);
     }
 
-    /**
-     * Resolves current configuration revision based on the saved in the Vault revision of the metastorage and also previous and current
-     * revisions of the configuration saved in the Vault.
-     *
-     * @param metaStorageRevision Meta Storage revision.
-     * @param revisionsEntry Configuration revisions entry.
-     * @return Configuration revision.
-     */
-    private static long resolveRevision(long metaStorageRevision, @Nullable VaultEntry revisionsEntry) {
-        if (revisionsEntry != null) {
-            byte[] value = revisionsEntry.value();
-            long prevMasterKeyRevision = ByteUtils.bytesToLong(value, 0);
-            long curMasterKeyRevision = ByteUtils.bytesToLong(value, Long.BYTES);
-
-            // If current master key revision is higher than applied revision, then node failed
-            // before applied revision changed, so we have to use previous master key revision
-            return curMasterKeyRevision <= metaStorageRevision ? curMasterKeyRevision : prevMasterKeyRevision;
-        } else {
-            // Configuration has not been updated yet, so it is safe to return 0 as the revision for the master key.
-            return 0L;
-        }
-    }
-
     private Data readDataOnRecovery0(long cfgRevision) {
         var data = new HashMap<String, Serializable>();
 
-        try (Cursor<VaultEntry> entries = storedDistributedConfigKeys()) {
-            for (VaultEntry entry : entries) {
-                ByteArray key = entry.key();
+        byte[] masterKey = MASTER_KEY.bytes();
+        boolean sawMasterKey = false;
+
+        try (Cursor<Entry> cursor = metaStorageMgr.getLocally(DST_KEYS_START_RANGE, DST_KEYS_END_RANGE, cfgRevision)) {
+            for (Entry entry : cursor) {
+                if (entry.tombstone()) {
+                    continue;
+                }
+
+                byte[] key = entry.key();
                 byte[] value = entry.value();
 
-                // vault iterator should not return nulls as values
+                // MetaStorage iterator should not return nulls as values.
                 assert value != null;
 
-                if (key.equals(MASTER_KEY)) {
+                if (!sawMasterKey && Arrays.equals(masterKey, key)) {
+                    sawMasterKey = true;
+
                     continue;
                 }
 
-                String dataKey = key.toString().substring(DISTRIBUTED_PREFIX.length());
+                byte[] keyWithoutPrefix = Arrays.copyOfRange(key, DST_KEYS_START_RANGE.length(), key.length);

Review Comment:
   Wasn't there a `String` constructor that allows creating strings using an offset and length?



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/storage/ItRebalanceDistributedTest.java:
##########
@@ -256,6 +261,37 @@ void after() {
         }
     }
 
+    // TODO: https://issues.apache.org/jira/browse/IGNITE-19506 Remove.

Review Comment:
   This test is disabled under the same ticket, why is this code needed?



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/DistributedConfigurationStorage.java:
##########
@@ -296,9 +268,9 @@ public CompletableFuture<Boolean> write(Map<String, ? extends Serializable> newV
 
         operations.add(Operations.put(MASTER_KEY, ByteUtils.longToBytes(curChangeId)));
 
-        SimpleCondition condition = curChangeId == 0L
-                ? Conditions.notExists(MASTER_KEY)
-                : Conditions.revision(MASTER_KEY).eq(curChangeId);
+        Condition condition = curChangeId == 0L
+                ? notExists(MASTER_KEY)
+                : or(notExists(MASTER_KEY), revision(MASTER_KEY).le(curChangeId));

Review Comment:
   Why did the condition change here?



##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -960,44 +957,16 @@ public void init(
      * and deploying watches after that.
      */
     private CompletableFuture<?> recoverComponentsStateOnStart(ExecutorService startupExecutor) {
-        // Recovery future must be created before configuration listeners are triggered.
-        CompletableFuture<?> recoveryFuture = RecoveryCompletionFutureFactory.create(
-                clusterCfgMgr,
-                fut -> new ConfigurationCatchUpListener(cfgStorage, fut, LOG)
-        );
-
-        //TODO https://issues.apache.org/jira/browse/IGNITE-19778
-        // The order of these two lines matter, the first method relies on the second one not being called yet.
-        // After the fix, the order will most likely have to be reversed.
-        CompletableFuture<Void> startupRevisionUpdate = notifyRevisionUpdateListenerOnStart();
         CompletableFuture<Void> startupConfigurationUpdate = notifyConfigurationListeners();
+        CompletableFuture<Void> startupRevisionUpdate = ((MetaStorageManagerImpl) metaStorageMgr).notifyRevisionUpdateListenerOnStart();

Review Comment:
   Why do you need to cast to `MetaStorageManagerImpl`?



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/ItDistributedConfigurationPropertiesTest.java:
##########
@@ -228,7 +228,7 @@ void start() {
             Stream.of(clusterService, raftManager, cmgManager, metaStorageManager)
                     .forEach(IgniteComponent::start);
 
-            distributedCfgManager.start();
+            CompletableFuture.runAsync(distributedCfgManager::start);

Review Comment:
   What's this for?



;04/Jul/23 11:02;githubbot;600","ibessonov commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1251881826


##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/DistributedConfigurationStorage.java:
##########
@@ -296,9 +268,9 @@ public CompletableFuture<Boolean> write(Map<String, ? extends Serializable> newV
 
         operations.add(Operations.put(MASTER_KEY, ByteUtils.longToBytes(curChangeId)));
 
-        SimpleCondition condition = curChangeId == 0L
-                ? Conditions.notExists(MASTER_KEY)
-                : Conditions.revision(MASTER_KEY).eq(curChangeId);
+        Condition condition = curChangeId == 0L
+                ? notExists(MASTER_KEY)
+                : or(notExists(MASTER_KEY), revision(MASTER_KEY).le(curChangeId));

Review Comment:
   You forgot to return the old comment back, please do it



;04/Jul/23 11:10;githubbot;600","ibessonov commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1251885540


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -1234,7 +1236,7 @@ private CompletableFuture<?> createTableLocally(
 
         // TODO should be reworked in IGNITE-16763
         // We use the event notification future as the result so that dependent components can complete the schema updates.
-        return fireEvent(TableEvent.CREATE, new TableEventParameters(causalityToken, tableId));
+        return allOf(createPartsFut, fireEvent(TableEvent.CREATE, new TableEventParameters(causalityToken, tableId)));

Review Comment:
   This fix will significantly slow down some tests, and the system in general when creating table/changing assignments. We need a better fix, which means adding TODO and describing what's happening and why the old code didn't work



;04/Jul/23 11:14;githubbot;600","SammyVimes commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252025730


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/ItDistributedConfigurationPropertiesTest.java:
##########
@@ -228,7 +228,7 @@ void start() {
             Stream.of(clusterService, raftManager, cmgManager, metaStorageManager)
                     .forEach(IgniteComponent::start);
 
-            distributedCfgManager.start();
+            CompletableFuture.runAsync(distributedCfgManager::start);

Review Comment:
   DistributedConfigurationManager's start is blocking, that's why I run it async



;04/Jul/23 13:22;githubbot;600","SammyVimes commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252026273


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/storage/ItRebalanceDistributedTest.java:
##########
@@ -256,6 +261,37 @@ void after() {
         }
     }
 
+    // TODO: https://issues.apache.org/jira/browse/IGNITE-19506 Remove.

Review Comment:
   Oops



;04/Jul/23 13:22;githubbot;600","SammyVimes commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252027048


##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -960,44 +957,16 @@ public void init(
      * and deploying watches after that.
      */
     private CompletableFuture<?> recoverComponentsStateOnStart(ExecutorService startupExecutor) {
-        // Recovery future must be created before configuration listeners are triggered.
-        CompletableFuture<?> recoveryFuture = RecoveryCompletionFutureFactory.create(
-                clusterCfgMgr,
-                fut -> new ConfigurationCatchUpListener(cfgStorage, fut, LOG)
-        );
-
-        //TODO https://issues.apache.org/jira/browse/IGNITE-19778
-        // The order of these two lines matter, the first method relies on the second one not being called yet.
-        // After the fix, the order will most likely have to be reversed.
-        CompletableFuture<Void> startupRevisionUpdate = notifyRevisionUpdateListenerOnStart();
         CompletableFuture<Void> startupConfigurationUpdate = notifyConfigurationListeners();
+        CompletableFuture<Void> startupRevisionUpdate = ((MetaStorageManagerImpl) metaStorageMgr).notifyRevisionUpdateListenerOnStart();

Review Comment:
   Right



;04/Jul/23 13:23;githubbot;600","SammyVimes commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252030258


##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/DistributedConfigurationStorage.java:
##########
@@ -206,60 +194,44 @@ public CompletableFuture<Serializable> readLatest(String key) {
 
     @Override
     public CompletableFuture<Data> readDataOnRecovery() throws StorageException {
-        CompletableFuture<Data> future = vaultMgr.get(CONFIGURATION_REVISIONS_KEY)
-                .thenApplyAsync(entry -> {
-                    long revision = resolveRevision(metaStorageMgr.appliedRevision(), entry);
-
-                    return readDataOnRecovery0(revision);
-                }, threadPool);
+        CompletableFuture<Data> future = metaStorageMgr.recoveryFinishedFuture()
+                .thenApplyAsync(this::readDataOnRecovery0, threadPool);
 
         return registerFuture(future);
     }
 
-    /**
-     * Resolves current configuration revision based on the saved in the Vault revision of the metastorage and also previous and current
-     * revisions of the configuration saved in the Vault.
-     *
-     * @param metaStorageRevision Meta Storage revision.
-     * @param revisionsEntry Configuration revisions entry.
-     * @return Configuration revision.
-     */
-    private static long resolveRevision(long metaStorageRevision, @Nullable VaultEntry revisionsEntry) {
-        if (revisionsEntry != null) {
-            byte[] value = revisionsEntry.value();
-            long prevMasterKeyRevision = ByteUtils.bytesToLong(value, 0);
-            long curMasterKeyRevision = ByteUtils.bytesToLong(value, Long.BYTES);
-
-            // If current master key revision is higher than applied revision, then node failed
-            // before applied revision changed, so we have to use previous master key revision
-            return curMasterKeyRevision <= metaStorageRevision ? curMasterKeyRevision : prevMasterKeyRevision;
-        } else {
-            // Configuration has not been updated yet, so it is safe to return 0 as the revision for the master key.
-            return 0L;
-        }
-    }
-
     private Data readDataOnRecovery0(long cfgRevision) {
         var data = new HashMap<String, Serializable>();
 
-        try (Cursor<VaultEntry> entries = storedDistributedConfigKeys()) {
-            for (VaultEntry entry : entries) {
-                ByteArray key = entry.key();
+        byte[] masterKey = MASTER_KEY.bytes();
+        boolean sawMasterKey = false;
+
+        try (Cursor<Entry> cursor = metaStorageMgr.getLocally(DST_KEYS_START_RANGE, DST_KEYS_END_RANGE, cfgRevision)) {
+            for (Entry entry : cursor) {
+                if (entry.tombstone()) {
+                    continue;
+                }
+
+                byte[] key = entry.key();
                 byte[] value = entry.value();
 
-                // vault iterator should not return nulls as values
+                // MetaStorage iterator should not return nulls as values.
                 assert value != null;
 
-                if (key.equals(MASTER_KEY)) {
+                if (!sawMasterKey && Arrays.equals(masterKey, key)) {
+                    sawMasterKey = true;
+
                     continue;
                 }
 
-                String dataKey = key.toString().substring(DISTRIBUTED_PREFIX.length());
+                byte[] keyWithoutPrefix = Arrays.copyOfRange(key, DST_KEYS_START_RANGE.length(), key.length);

Review Comment:
   Right



;04/Jul/23 13:25;githubbot;600","SammyVimes commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252035427


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -1234,7 +1236,7 @@ private CompletableFuture<?> createTableLocally(
 
         // TODO should be reworked in IGNITE-16763
         // We use the event notification future as the result so that dependent components can complete the schema updates.
-        return fireEvent(TableEvent.CREATE, new TableEventParameters(causalityToken, tableId));
+        return allOf(createPartsFut, fireEvent(TableEvent.CREATE, new TableEventParameters(causalityToken, tableId)));

Review Comment:
   I don't really observe a slow down in tests, but ok.



;04/Jul/23 13:30;githubbot;600","ibessonov commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252100524


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -1234,7 +1236,7 @@ private CompletableFuture<?> createTableLocally(
 
         // TODO should be reworked in IGNITE-16763
         // We use the event notification future as the result so that dependent components can complete the schema updates.
-        return fireEvent(TableEvent.CREATE, new TableEventParameters(causalityToken, tableId));
+        return allOf(createPartsFut, fireEvent(TableEvent.CREATE, new TableEventParameters(causalityToken, tableId)));

Review Comment:
   You're not running the right tests. That's why I said ""some""



;04/Jul/23 14:27;githubbot;600","ibessonov commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252140674


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -84,7 +85,18 @@ public interface MetaStorageManager extends IgniteComponent {
      * @param revUpperBound The upper bound of revision.
      * @return Value corresponding to the given key.
      */
-    Entry getLocally(byte[] key, long revUpperBound);
+    Entry getLocally(ByteArray key, long revUpperBound);
+
+    /**
+     * Returns cursor by entries which correspond to the given keys range and bounded by revision number. The entries in the cursor
+     * are obtained from the local storage.
+     *
+     * @param startKey Start key of range (inclusive).
+     * @param endKey Last key of range (exclusive).
+     * @param revision Upper bound of revision.
+     * @return Cursor by entries which correspond to the given keys range.
+     */
+    Cursor<Entry> getLocally(ByteArray startKey, ByteArray endKey, long revision);

Review Comment:
   What happens if revision is too big? Will we just ignore it and read (potentially) invalid data, or will we wait for the corresponding update?
   Please document how it works, it'll only take a line (here and in previous method).



##########
modules/metastorage/src/integrationTest/java/org/apache/ignite/internal/metastorage/impl/ItMetaStorageWatchTest.java:
##########
@@ -218,6 +219,12 @@ private void startCluster(int size) throws NodeStoppingException {
         String name = nodes.get(0).name();
 
         nodes.get(0).cmgManager.initCluster(List.of(name), List.of(name), ""test"");
+
+        CompletableFuture<Void> startFut = allOf(

Review Comment:
   Why not simply make a loop? You don't have to create new future. But that's just a question



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/storage/ItRebalanceDistributedTest.java:
##########
@@ -863,40 +900,51 @@ protected CompletableFuture<Void> handleChangeStableAssignmentEvent(WatchEvent e
          * Starts the created components.
          */
         void start() {
-            nodeComponents = List.of(
+            nodeComponents = new CopyOnWriteArrayList<>();
+
+            List<IgniteComponent> firstComponents = List.of(
                     vaultManager,
                     nodeCfgMgr,
                     clusterService,
-                    raftManager,
-                    cmgManager,
-                    metaStorageManager,
-                    clusterCfgMgr,
-                    clockWaiter,
-                    catalogManager,
-                    distributionZoneManager,
-                    replicaManager,
-                    txManager,
-                    baselineMgr,
-                    dataStorageMgr,
-                    schemaManager,
-                    tableManager
+                    raftManager
             );
 
-            nodeComponents.forEach(IgniteComponent::start);
+            firstComponents.forEach(IgniteComponent::start);
+
+            nodeComponents.addAll(firstComponents);
+
+            deployWatchesFut = CompletableFuture.supplyAsync(() -> {
+                List<IgniteComponent> secondComponents = List.of(
+                        cmgManager,
+                        metaStorageManager,
+                        clusterCfgMgr,
+                        clockWaiter,
+                        catalogManager,
+                        distributionZoneManager,
+                        replicaManager,
+                        txManager,
+                        baselineMgr,
+                        dataStorageMgr,
+                        schemaManager,
+                        tableManager
+                );
 
-            assertThat(
-                    allOf(
+                secondComponents.forEach(IgniteComponent::start);
+
+                nodeComponents.addAll(secondComponents);
+
+                var configurationNotificationFut = metaStorageManager.recoveryFinishedFuture().thenCompose(rev -> {
+                    return allOf(
                             nodeCfgMgr.configurationRegistry().notifyCurrentConfigurationListeners(),
                             clusterCfgMgr.configurationRegistry().notifyCurrentConfigurationListeners(),
-                            // Why ""-1""? I don't know, it just works like that.
-                            ((MetaStorageManagerImpl) metaStorageManager).notifyRevisionUpdateListenerOnStart(
-                                    metaStorageManager.appliedRevision() - 1
-                            )
-                    ),
-                    willSucceedIn(1, TimeUnit.MINUTES)
-            );
+                            ((MetaStorageManagerImpl) metaStorageManager).notifyRevisionUpdateListenerOnStart()
+                    );
+                });
+
+                assertThat(configurationNotificationFut, willSucceedIn(1, TimeUnit.MINUTES));
 
-            deployWatchesFut = metaStorageManager.deployWatches();
+                return metaStorageManager.deployWatches();
+            }).thenCompose(fut -> fut);

Review Comment:
   Please use `Function.identity()`, maybe with a static import



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/BaseIgniteRestartTest.java:
##########
@@ -241,32 +236,17 @@ public static PartialNode partialNode(
     ) {
         AtomicLong lastRevision = new AtomicLong();
 
-        Consumer<Long> revisionCallback0 = rev -> {
-            if (revisionCallback != null) {
-                revisionCallback.accept(rev);
-            }
-
-            lastRevision.set(rev);
-        };
-
-        CompletableFuture<Void> configurationCatchUpFuture = RecoveryCompletionFutureFactory.create(
-                clusterCfgMgr,
-                fut -> new TestConfigurationCatchUpListener(cfgStorage, fut, revisionCallback0)
-        );
-
         CompletableFuture<?> startFuture = CompletableFuture.allOf(
                 nodeCfgMgr.configurationRegistry().notifyCurrentConfigurationListeners(),
                 clusterConfigRegistry.notifyCurrentConfigurationListeners()
         ).thenCompose(unused ->
                 // Deploy all registered watches because all components are ready and have registered their listeners.
-                CompletableFuture.allOf(metaStorageMgr.deployWatches(), configurationCatchUpFuture)
+                metaStorageMgr.deployWatches()
         );
 
         assertThat(""Partial node was not started"", startFuture, willCompleteSuccessfully());
 
-        log.info(""Completed recovery on partially started node, last revision applied: "" + lastRevision.get()
-                + "", acceptableDifference: "" + IgniteSystemProperties.getInteger(CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY, 100)
-        );
+        log.info(""Completed recovery on partially started node, last revision applied: "" + lastRevision.get());

Review Comment:
   I would change the ""last applied revision"" part, and use a different terminology



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -824,19 +830,7 @@ private CompletableFuture<Void> onRevisionApplied(WatchEvent watchEvent, HybridT
         clusterTime.updateSafeTime(time);
 
         try {
-            CompletableFuture<Void> saveToVaultFuture;
-
-            if (watchEvent.entryEvents().isEmpty()) {
-                saveToVaultFuture = vaultMgr.put(APPLIED_REV_KEY, longToBytes(watchEvent.revision()));
-            } else {
-                Map<ByteArray, byte[]> batch = IgniteUtils.newHashMap(watchEvent.entryEvents().size() + 1);
-
-                batch.put(APPLIED_REV_KEY, longToBytes(watchEvent.revision()));
-
-                watchEvent.entryEvents().forEach(e -> batch.put(new ByteArray(e.newEntry().key()), e.newEntry().value()));
-
-                saveToVaultFuture = vaultMgr.putAll(batch);
-            }
+            CompletableFuture<Void> saveToVaultFuture = vaultMgr.put(APPLIED_REV_KEY, longToBytes(watchEvent.revision()));

Review Comment:
   Is there anyone who reads the value? Why would they need it?
   Can we remove it completely?



;04/Jul/23 15:16;githubbot;600","SammyVimes commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252195378


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -1234,7 +1236,7 @@ private CompletableFuture<?> createTableLocally(
 
         // TODO should be reworked in IGNITE-16763
         // We use the event notification future as the result so that dependent components can complete the schema updates.
-        return fireEvent(TableEvent.CREATE, new TableEventParameters(causalityToken, tableId));
+        return allOf(createPartsFut, fireEvent(TableEvent.CREATE, new TableEventParameters(causalityToken, tableId)));

Review Comment:
   I mean that there seems to be no impact to teamcity build time



;04/Jul/23 16:03;githubbot;600","SammyVimes commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252210523


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -84,7 +85,18 @@ public interface MetaStorageManager extends IgniteComponent {
      * @param revUpperBound The upper bound of revision.
      * @return Value corresponding to the given key.
      */
-    Entry getLocally(byte[] key, long revUpperBound);
+    Entry getLocally(ByteArray key, long revUpperBound);
+
+    /**
+     * Returns cursor by entries which correspond to the given keys range and bounded by revision number. The entries in the cursor
+     * are obtained from the local storage.
+     *
+     * @param startKey Start key of range (inclusive).
+     * @param endKey Last key of range (exclusive).
+     * @param revision Upper bound of revision.
+     * @return Cursor by entries which correspond to the given keys range.
+     */
+    Cursor<Entry> getLocally(ByteArray startKey, ByteArray endKey, long revision);

Review Comment:
   Done



;04/Jul/23 16:21;githubbot;600","SammyVimes commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252211465


##########
modules/metastorage/src/integrationTest/java/org/apache/ignite/internal/metastorage/impl/ItMetaStorageWatchTest.java:
##########
@@ -218,6 +219,12 @@ private void startCluster(int size) throws NodeStoppingException {
         String name = nodes.get(0).name();
 
         nodes.get(0).cmgManager.initCluster(List.of(name), List.of(name), ""test"");
+
+        CompletableFuture<Void> startFut = allOf(

Review Comment:
   True



;04/Jul/23 16:22;githubbot;600","SammyVimes commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252212463


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -824,19 +830,7 @@ private CompletableFuture<Void> onRevisionApplied(WatchEvent watchEvent, HybridT
         clusterTime.updateSafeTime(time);
 
         try {
-            CompletableFuture<Void> saveToVaultFuture;
-
-            if (watchEvent.entryEvents().isEmpty()) {
-                saveToVaultFuture = vaultMgr.put(APPLIED_REV_KEY, longToBytes(watchEvent.revision()));
-            } else {
-                Map<ByteArray, byte[]> batch = IgniteUtils.newHashMap(watchEvent.entryEvents().size() + 1);
-
-                batch.put(APPLIED_REV_KEY, longToBytes(watchEvent.revision()));
-
-                watchEvent.entryEvents().forEach(e -> batch.put(new ByteArray(e.newEntry().key()), e.newEntry().value()));
-
-                saveToVaultFuture = vaultMgr.putAll(batch);
-            }
+            CompletableFuture<Void> saveToVaultFuture = vaultMgr.put(APPLIED_REV_KEY, longToBytes(watchEvent.revision()));

Review Comment:
   It is used in the metastorage itself and in several other components like deployment service or distribution zone service



;04/Jul/23 16:24;githubbot;600","SammyVimes commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252214544


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/BaseIgniteRestartTest.java:
##########
@@ -241,32 +236,17 @@ public static PartialNode partialNode(
     ) {
         AtomicLong lastRevision = new AtomicLong();
 
-        Consumer<Long> revisionCallback0 = rev -> {
-            if (revisionCallback != null) {
-                revisionCallback.accept(rev);
-            }
-
-            lastRevision.set(rev);
-        };
-
-        CompletableFuture<Void> configurationCatchUpFuture = RecoveryCompletionFutureFactory.create(
-                clusterCfgMgr,
-                fut -> new TestConfigurationCatchUpListener(cfgStorage, fut, revisionCallback0)
-        );
-
         CompletableFuture<?> startFuture = CompletableFuture.allOf(
                 nodeCfgMgr.configurationRegistry().notifyCurrentConfigurationListeners(),
                 clusterConfigRegistry.notifyCurrentConfigurationListeners()
         ).thenCompose(unused ->
                 // Deploy all registered watches because all components are ready and have registered their listeners.
-                CompletableFuture.allOf(metaStorageMgr.deployWatches(), configurationCatchUpFuture)
+                metaStorageMgr.deployWatches()
         );
 
         assertThat(""Partial node was not started"", startFuture, willCompleteSuccessfully());
 
-        log.info(""Completed recovery on partially started node, last revision applied: "" + lastRevision.get()
-                + "", acceptableDifference: "" + IgniteSystemProperties.getInteger(CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY, 100)
-        );
+        log.info(""Completed recovery on partially started node, last revision applied: "" + lastRevision.get());

Review Comment:
   Completed recovery is correct though



;04/Jul/23 16:28;githubbot;600","SammyVimes commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252214935


##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/DistributedConfigurationStorage.java:
##########
@@ -296,9 +268,9 @@ public CompletableFuture<Boolean> write(Map<String, ? extends Serializable> newV
 
         operations.add(Operations.put(MASTER_KEY, ByteUtils.longToBytes(curChangeId)));
 
-        SimpleCondition condition = curChangeId == 0L
-                ? Conditions.notExists(MASTER_KEY)
-                : Conditions.revision(MASTER_KEY).eq(curChangeId);
+        Condition condition = curChangeId == 0L
+                ? notExists(MASTER_KEY)
+                : or(notExists(MASTER_KEY), revision(MASTER_KEY).le(curChangeId));

Review Comment:
   Done



;04/Jul/23 16:28;githubbot;600","sashapolo commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252655302


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -67,6 +67,8 @@ public interface MetaStorageManager extends IgniteComponent {
      * Returns all entries corresponding to the given key and bounded by given revisions.
      * All these entries are ordered by revisions and have the same key.
      * The lower bound and the upper bound are inclusive.
+     * This method doesn't wait for the storage's revision to become greater or equal to the revUpperBound parameter, so it is

Review Comment:
   missing `<p>` tag here and everywhere



;05/Jul/23 07:23;githubbot;600","sashapolo commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252662032


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/ItDistributedConfigurationPropertiesTest.java:
##########
@@ -228,7 +228,7 @@ void start() {
             Stream.of(clusterService, raftManager, cmgManager, metaStorageManager)
                     .forEach(IgniteComponent::start);
 
-            distributedCfgManager.start();
+            CompletableFuture.runAsync(distributedCfgManager::start);

Review Comment:
   But we start everything synchronously, what's the point? Or do you mean that DistributedConfigurationManager's start is dependent on some other actions and it blocks forever otherwise?



;05/Jul/23 07:24;githubbot;600","SammyVimes commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1252822420


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/ItDistributedConfigurationPropertiesTest.java:
##########
@@ -228,7 +228,7 @@ void start() {
             Stream.of(clusterService, raftManager, cmgManager, metaStorageManager)
                     .forEach(IgniteComponent::start);
 
-            distributedCfgManager.start();
+            CompletableFuture.runAsync(distributedCfgManager::start);

Review Comment:
   Yes, exactly



;05/Jul/23 09:28;githubbot;600","ibessonov commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1254029147


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -1234,7 +1236,7 @@ private CompletableFuture<?> createTableLocally(
 
         // TODO should be reworked in IGNITE-16763
         // We use the event notification future as the result so that dependent components can complete the schema updates.
-        return fireEvent(TableEvent.CREATE, new TableEventParameters(causalityToken, tableId));
+        return allOf(createPartsFut, fireEvent(TableEvent.CREATE, new TableEventParameters(causalityToken, tableId)));

Review Comment:
   There is, 20-40 seconds, as far as I remember



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/DistributedConfigurationStorage.java:
##########
@@ -268,6 +270,23 @@ public CompletableFuture<Boolean> write(Map<String, ? extends Serializable> newV
 
         operations.add(Operations.put(MASTER_KEY, ByteUtils.longToBytes(curChangeId)));
 
+        // Condition for a valid MetaStorage data update. Several possibilities here:

Review Comment:
   Did you refine the comment according to your changes?



;06/Jul/23 07:12;githubbot;600","ibessonov commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1254197799


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -824,19 +830,7 @@ private CompletableFuture<Void> onRevisionApplied(WatchEvent watchEvent, HybridT
         clusterTime.updateSafeTime(time);
 
         try {
-            CompletableFuture<Void> saveToVaultFuture;
-
-            if (watchEvent.entryEvents().isEmpty()) {
-                saveToVaultFuture = vaultMgr.put(APPLIED_REV_KEY, longToBytes(watchEvent.revision()));
-            } else {
-                Map<ByteArray, byte[]> batch = IgniteUtils.newHashMap(watchEvent.entryEvents().size() + 1);
-
-                batch.put(APPLIED_REV_KEY, longToBytes(watchEvent.revision()));
-
-                watchEvent.entryEvents().forEach(e -> batch.put(new ByteArray(e.newEntry().key()), e.newEntry().value()));
-
-                saveToVaultFuture = vaultMgr.putAll(batch);
-            }
+            CompletableFuture<Void> saveToVaultFuture = vaultMgr.put(APPLIED_REV_KEY, longToBytes(watchEvent.revision()));

Review Comment:
   But why? Are there plans to remove it?



;06/Jul/23 09:42;githubbot;600","SammyVimes commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1254198798


##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/DistributedConfigurationStorage.java:
##########
@@ -268,6 +270,23 @@ public CompletableFuture<Boolean> write(Map<String, ? extends Serializable> newV
 
         operations.add(Operations.put(MASTER_KEY, ByteUtils.longToBytes(curChangeId)));
 
+        // Condition for a valid MetaStorage data update. Several possibilities here:

Review Comment:
   Done



;06/Jul/23 09:43;githubbot;600","alievmirza commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1254364235


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/distribution/zones/ItDistributionZonesFilterTest.java:
##########
@@ -95,6 +96,7 @@ protected int initialNodes() {
      *
      * @throws Exception If failed.
      */
+    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19506"")

Review Comment:
   I would be grateful if you explain how your changes caused this test to be muted, and why they was muted with https://issues.apache.org/jira/browse/IGNITE-19506?  



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/distribution/zones/ItDistributionZonesFilterTest.java:
##########
@@ -95,6 +96,7 @@ protected int initialNodes() {
      *
      * @throws Exception If failed.
      */
+    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19506"")

Review Comment:
   I would be grateful if you explain how your changes caused these tests to be muted, and why they was muted with https://issues.apache.org/jira/browse/IGNITE-19506?  



;06/Jul/23 12:26;githubbot;600","alievmirza commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1254364235


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/distribution/zones/ItDistributionZonesFilterTest.java:
##########
@@ -95,6 +96,7 @@ protected int initialNodes() {
      *
      * @throws Exception If failed.
      */
+    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19506"")

Review Comment:
   I would be grateful if you explain how your changes caused these tests to be muted, and why they were muted with https://issues.apache.org/jira/browse/IGNITE-19506?  



;06/Jul/23 12:42;githubbot;600","SammyVimes commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1254451413


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/distribution/zones/ItDistributionZonesFilterTest.java:
##########
@@ -95,6 +96,7 @@ protected int initialNodes() {
      *
      * @throws Exception If failed.
      */
+    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19506"")

Review Comment:
   My changes altered load profile (we don't write to vault anymore, so most metastorage operations should be faster) and it seems like it caused race condition with BaselineManager#nodes. We can observe incorrect topology and cause incorrect distribution, which in turn may cause a start of the duplicate raft group node



;06/Jul/23 13:34;githubbot;600","alievmirza commented on code in PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266#discussion_r1254514488


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/distribution/zones/ItDistributionZonesFilterTest.java:
##########
@@ -95,6 +96,7 @@ protected int initialNodes() {
      *
      * @throws Exception If failed.
      */
+    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19506"")

Review Comment:
   I see that test fails when we check data nodes in metastorage after we start node with index 2. How is this connected with `BaselineManager#nodes`?



;06/Jul/23 14:20;githubbot;600","SammyVimes merged PR #2266:
URL: https://github.com/apache/ignite-3/pull/2266


;12/Jul/23 08:03;githubbot;600",,,,,,,,,,,,,,,,,,,0,16800,,,0,16800,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19955,,,,,IGNITE-19965,IGNITE-19967,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Wed Jul 12 08:05:03 UTC 2023,,,,,,,,,,"0|z1io0w:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"12/Jul/23 08:04;ibessonov;Looks good to me!;;;","12/Jul/23 08:05;sdanilov;Thank you for the review. Merged to the main branch.;;;",,,,
Perform local metastorage recovery ,IGNITE-19777,13540729,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,sdanilov,sdanilov,sdanilov,20/Jun/23 09:54,27/Jun/23 10:10,13/Jul/23 09:11,27/Jun/23 10:10,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Upon recovery, metastorage should request current cluster-wide metastorage revision and wait until this revision is achieved.
After that it is safe to continue starting other components depending on the metastorage and perform their own recovery based on the metastorage data at said revision. After recovery is performed, watches must be installed with the revision + 1.",,sdanilov,,,,,"SammyVimes opened a new pull request, #2237:
URL: https://github.com/apache/ignite-3/pull/2237

   https://issues.apache.org/jira/browse/IGNITE-19777


;22/Jun/23 14:29;githubbot;600","sashapolo commented on code in PR #2237:
URL: https://github.com/apache/ignite-3/pull/2237#discussion_r1241811950


##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -691,14 +691,24 @@ public CompletableFuture<Ignite> start(Path configPath) {
             LOG.info(""Components started, joining the cluster"");
 
             return cmgMgr.joinFuture()
-                    // using the default executor to avoid blocking the CMG Manager threads
+                    // Using the default executor to avoid blocking the CMG Manager threads.

Review Comment:
   I think that this comment is no longer relevant and can be removed



##########
modules/runner/src/main/java/org/apache/ignite/internal/recovery/ConfigurationCatchUpListener.java:
##########
@@ -84,6 +84,7 @@ private boolean isConfigurationUpToDate(long targetRevision, long appliedRevisio
     private CompletableFuture<?> checkRevisionUpToDate(long appliedRevision) {
         return cfgStorage.lastRevision().thenAccept(rev -> {
             synchronized (targetRevisionUpdateMutex) {
+                // TODO: actual metastorage  revision can be higher than configuration revision

Review Comment:
   TODO without a ticket, shame on you



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -148,6 +158,60 @@ public MetaStorageManagerImpl(
         this.clusterTime = new ClusterTimeImpl(busyLock, clock);
     }
 
+    private CompletableFuture<Long> recover(MetaStorageServiceImpl service) {
+        if (!busyLock.enterBusy()) {
+            return CompletableFuture.failedFuture(new NodeStoppingException());
+        }
+
+        try {
+            CompletableFuture<Long> res = new CompletableFuture<>();
+
+            ExecutorService recoveryExecutor = Executors.newSingleThreadExecutor(
+                    NamedThreadFactory.create(clusterService.nodeName(), ""ms-start"", LOG)
+            );
+
+            service.currentRevision().whenCompleteAsync((revision, throwable) -> {
+                if (throwable != null) {
+                    res.completeExceptionally(throwable);
+
+                    return;
+                }
+
+                LOG.info(""Performing MetaStorage recovery from revision {} to {}"", storage.revision(), revision);
+
+                assert revision != null;
+
+                // Busy wait is ok here, because other threads are not doing any real work,
+                // and for node to start we must wait until storage is up to this revision.
+                while (storage.revision() < revision) {

Review Comment:
   I don't like this approach, can we introduce an async mechanism to wait for a particular revision? Like an ability to register revision listeners.



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -148,6 +158,60 @@ public MetaStorageManagerImpl(
         this.clusterTime = new ClusterTimeImpl(busyLock, clock);
     }
 
+    private CompletableFuture<Long> recover(MetaStorageServiceImpl service) {
+        if (!busyLock.enterBusy()) {
+            return CompletableFuture.failedFuture(new NodeStoppingException());
+        }
+
+        try {
+            CompletableFuture<Long> res = new CompletableFuture<>();

Review Comment:
   This explicit future can be avoided



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -364,11 +364,6 @@ public void restoreSnapshot(Path path) {
         } finally {
             rwLock.writeLock().unlock();
         }
-
-        // Replay updates if startWatches() has already been called.
-        if (recoveryStatus.compareAndSet(RecoveryStatus.PENDING, RecoveryStatus.IN_PROGRESS)) {

Review Comment:
   Looks like we need to get rid of `RecoveryStatus.PENDING` altogether



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -719,11 +732,66 @@ public void nodeWithDataTest() throws InterruptedException {
         checkTableWithData(ignite, TABLE_NAME);
     }
 
+    /**
+     * Restarts the node which stores some data.
+     */
+    @ParameterizedTest
+    @ValueSource(booleans = {true, false})
+    public void metastorageRecoveryTest(boolean useSnapshot) throws InterruptedException {
+        List<IgniteImpl> nodes = startNodes(2);
+        IgniteImpl main = nodes.get(0);
+
+        createTableWithData(List.of(main), TABLE_NAME, 1);
+
+        stopNode(1);
+
+        MetaStorageManager metaStorageManager = main.metaStorageManager();
+
+        CompletableFuture[] futs = new CompletableFuture[10];
+
+        for (int i = 0; i < 10; i++) {
+            ByteArray key = ByteArray.fromString(""some-test-key-"" + i);
+            futs[i] = metaStorageManager.put(key, new byte[]{(byte) 0});
+        }
+
+        CompletableFuture.allOf(futs).join();
+
+        if (useSnapshot) {
+            // Force log truncation, so that restarting node would request a snapshot.
+            JraftServerImpl server = (JraftServerImpl) main.raftManager().server();

Review Comment:
   Please extract this logic into a method



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -719,11 +732,66 @@ public void nodeWithDataTest() throws InterruptedException {
         checkTableWithData(ignite, TABLE_NAME);
     }
 
+    /**
+     * Restarts the node which stores some data.
+     */
+    @ParameterizedTest
+    @ValueSource(booleans = {true, false})
+    public void metastorageRecoveryTest(boolean useSnapshot) throws InterruptedException {
+        List<IgniteImpl> nodes = startNodes(2);
+        IgniteImpl main = nodes.get(0);
+
+        createTableWithData(List.of(main), TABLE_NAME, 1);
+
+        stopNode(1);
+
+        MetaStorageManager metaStorageManager = main.metaStorageManager();
+
+        CompletableFuture[] futs = new CompletableFuture[10];
+
+        for (int i = 0; i < 10; i++) {
+            ByteArray key = ByteArray.fromString(""some-test-key-"" + i);

Review Comment:
   What's the point of inserting data here? You don't check it anywhere



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -719,11 +732,66 @@ public void nodeWithDataTest() throws InterruptedException {
         checkTableWithData(ignite, TABLE_NAME);
     }
 
+    /**
+     * Restarts the node which stores some data.
+     */
+    @ParameterizedTest
+    @ValueSource(booleans = {true, false})

Review Comment:
   I think you should simply split this test in two



##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerRecoveryTest.java:
##########
@@ -0,0 +1,176 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willSucceedFast;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.command.GetCurrentRevisionCommand;
+import org.apache.ignite.internal.metastorage.server.KeyValueStorage;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.raft.service.RaftGroupService;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.network.ClusterService;
+import org.apache.ignite.network.MessagingService;
+import org.apache.ignite.network.NodeMetadata;
+import org.apache.ignite.network.TopologyService;
+import org.apache.ignite.network.serialization.MessageSerializationRegistry;
+import org.junit.jupiter.api.Test;
+
+/** Tests MetaStorage manager recovery basics. */
+public class MetaStorageManagerRecoveryTest {

Review Comment:
   Can we use `ItMetaStorageManagerImplTest` instead?



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -148,6 +158,60 @@ public MetaStorageManagerImpl(
         this.clusterTime = new ClusterTimeImpl(busyLock, clock);
     }
 
+    private CompletableFuture<Long> recover(MetaStorageServiceImpl service) {
+        if (!busyLock.enterBusy()) {
+            return CompletableFuture.failedFuture(new NodeStoppingException());
+        }
+
+        try {
+            CompletableFuture<Long> res = new CompletableFuture<>();
+
+            ExecutorService recoveryExecutor = Executors.newSingleThreadExecutor(
+                    NamedThreadFactory.create(clusterService.nodeName(), ""ms-start"", LOG)
+            );
+
+            service.currentRevision().whenCompleteAsync((revision, throwable) -> {
+                if (throwable != null) {
+                    res.completeExceptionally(throwable);
+
+                    return;
+                }
+
+                LOG.info(""Performing MetaStorage recovery from revision {} to {}"", storage.revision(), revision);
+
+                assert revision != null;
+
+                // Busy wait is ok here, because other threads are not doing any real work,
+                // and for node to start we must wait until storage is up to this revision.
+                while (storage.revision() < revision) {
+                    if (!busyLock.enterBusy()) {
+                        res.completeExceptionally(new NodeStoppingException());
+
+                        return;
+                    }
+
+                    try {
+                        Thread.sleep(10);
+                    } catch (InterruptedException ignored) {
+                        // Ignore. If we are being shut down, then busy lock will stop us.
+                    } finally {
+                        busyLock.leaveBusy();
+                    }
+                }
+
+                LOG.info(""Finished MetaStorage recovery"");
+
+                res.complete(revision);
+            }, recoveryExecutor);
+
+            return res.whenComplete((s, t) -> {
+                recoveryExecutor.shutdown();

Review Comment:
   1. Why not use a method from `IgniteUtils`?
   2. This approach is dangerous, because you actually leak this executor outside (by exposing a future)



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -719,11 +732,66 @@ public void nodeWithDataTest() throws InterruptedException {
         checkTableWithData(ignite, TABLE_NAME);
     }
 
+    /**
+     * Restarts the node which stores some data.
+     */
+    @ParameterizedTest
+    @ValueSource(booleans = {true, false})
+    public void metastorageRecoveryTest(boolean useSnapshot) throws InterruptedException {
+        List<IgniteImpl> nodes = startNodes(2);
+        IgniteImpl main = nodes.get(0);
+
+        createTableWithData(List.of(main), TABLE_NAME, 1);
+
+        stopNode(1);
+
+        MetaStorageManager metaStorageManager = main.metaStorageManager();
+
+        CompletableFuture[] futs = new CompletableFuture[10];
+
+        for (int i = 0; i < 10; i++) {
+            ByteArray key = ByteArray.fromString(""some-test-key-"" + i);
+            futs[i] = metaStorageManager.put(key, new byte[]{(byte) 0});
+        }
+
+        CompletableFuture.allOf(futs).join();

Review Comment:
   don't use `join` please



;26/Jun/23 09:03;githubbot;600","SammyVimes commented on code in PR #2237:
URL: https://github.com/apache/ignite-3/pull/2237#discussion_r1241942617


##########
modules/runner/src/main/java/org/apache/ignite/internal/recovery/ConfigurationCatchUpListener.java:
##########
@@ -84,6 +84,7 @@ private boolean isConfigurationUpToDate(long targetRevision, long appliedRevisio
     private CompletableFuture<?> checkRevisionUpToDate(long appliedRevision) {
         return cfgStorage.lastRevision().thenAccept(rev -> {
             synchronized (targetRevisionUpdateMutex) {
+                // TODO: actual metastorage  revision can be higher than configuration revision

Review Comment:
   Whoops, that was a message to myself



;26/Jun/23 10:03;githubbot;600","SammyVimes commented on code in PR #2237:
URL: https://github.com/apache/ignite-3/pull/2237#discussion_r1241943596


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -148,6 +158,60 @@ public MetaStorageManagerImpl(
         this.clusterTime = new ClusterTimeImpl(busyLock, clock);
     }
 
+    private CompletableFuture<Long> recover(MetaStorageServiceImpl service) {
+        if (!busyLock.enterBusy()) {
+            return CompletableFuture.failedFuture(new NodeStoppingException());
+        }
+
+        try {
+            CompletableFuture<Long> res = new CompletableFuture<>();
+
+            ExecutorService recoveryExecutor = Executors.newSingleThreadExecutor(
+                    NamedThreadFactory.create(clusterService.nodeName(), ""ms-start"", LOG)
+            );
+
+            service.currentRevision().whenCompleteAsync((revision, throwable) -> {
+                if (throwable != null) {
+                    res.completeExceptionally(throwable);
+
+                    return;
+                }
+
+                LOG.info(""Performing MetaStorage recovery from revision {} to {}"", storage.revision(), revision);
+
+                assert revision != null;
+
+                // Busy wait is ok here, because other threads are not doing any real work,
+                // and for node to start we must wait until storage is up to this revision.
+                while (storage.revision() < revision) {

Review Comment:
   We only need it here and there is no real benefit. The code will be more complicated and probably less performant



;26/Jun/23 10:04;githubbot;600","SammyVimes commented on code in PR #2237:
URL: https://github.com/apache/ignite-3/pull/2237#discussion_r1241946230


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -719,11 +732,66 @@ public void nodeWithDataTest() throws InterruptedException {
         checkTableWithData(ignite, TABLE_NAME);
     }
 
+    /**
+     * Restarts the node which stores some data.
+     */
+    @ParameterizedTest
+    @ValueSource(booleans = {true, false})

Review Comment:
   Why? It's the same test basically



;26/Jun/23 10:06;githubbot;600","SammyVimes commented on code in PR #2237:
URL: https://github.com/apache/ignite-3/pull/2237#discussion_r1241947584


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -719,11 +732,66 @@ public void nodeWithDataTest() throws InterruptedException {
         checkTableWithData(ignite, TABLE_NAME);
     }
 
+    /**
+     * Restarts the node which stores some data.
+     */
+    @ParameterizedTest
+    @ValueSource(booleans = {true, false})
+    public void metastorageRecoveryTest(boolean useSnapshot) throws InterruptedException {
+        List<IgniteImpl> nodes = startNodes(2);
+        IgniteImpl main = nodes.get(0);
+
+        createTableWithData(List.of(main), TABLE_NAME, 1);
+
+        stopNode(1);
+
+        MetaStorageManager metaStorageManager = main.metaStorageManager();
+
+        CompletableFuture[] futs = new CompletableFuture[10];
+
+        for (int i = 0; i < 10; i++) {
+            ByteArray key = ByteArray.fromString(""some-test-key-"" + i);

Review Comment:
   Added a comment



;26/Jun/23 10:07;githubbot;600","SammyVimes commented on code in PR #2237:
URL: https://github.com/apache/ignite-3/pull/2237#discussion_r1241952681


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerRecoveryTest.java:
##########
@@ -0,0 +1,176 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willSucceedFast;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.command.GetCurrentRevisionCommand;
+import org.apache.ignite.internal.metastorage.server.KeyValueStorage;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.raft.service.RaftGroupService;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.network.ClusterService;
+import org.apache.ignite.network.MessagingService;
+import org.apache.ignite.network.NodeMetadata;
+import org.apache.ignite.network.TopologyService;
+import org.apache.ignite.network.serialization.MessageSerializationRegistry;
+import org.junit.jupiter.api.Test;
+
+/** Tests MetaStorage manager recovery basics. */
+public class MetaStorageManagerRecoveryTest {

Review Comment:
   No, I am testing full node restart here, including the part of IgniteImpl that waits for recovery to complete



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -719,11 +732,66 @@ public void nodeWithDataTest() throws InterruptedException {
         checkTableWithData(ignite, TABLE_NAME);
     }
 
+    /**
+     * Restarts the node which stores some data.
+     */
+    @ParameterizedTest
+    @ValueSource(booleans = {true, false})
+    public void metastorageRecoveryTest(boolean useSnapshot) throws InterruptedException {
+        List<IgniteImpl> nodes = startNodes(2);
+        IgniteImpl main = nodes.get(0);
+
+        createTableWithData(List.of(main), TABLE_NAME, 1);
+
+        stopNode(1);
+
+        MetaStorageManager metaStorageManager = main.metaStorageManager();
+
+        CompletableFuture[] futs = new CompletableFuture[10];
+
+        for (int i = 0; i < 10; i++) {
+            ByteArray key = ByteArray.fromString(""some-test-key-"" + i);
+            futs[i] = metaStorageManager.put(key, new byte[]{(byte) 0});
+        }
+
+        CompletableFuture.allOf(futs).join();
+
+        if (useSnapshot) {
+            // Force log truncation, so that restarting node would request a snapshot.
+            JraftServerImpl server = (JraftServerImpl) main.raftManager().server();

Review Comment:
   Done



;26/Jun/23 10:12;githubbot;600","sashapolo commented on code in PR #2237:
URL: https://github.com/apache/ignite-3/pull/2237#discussion_r1242239452


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -148,6 +155,77 @@ public MetaStorageManagerImpl(
         this.clusterTime = new ClusterTimeImpl(busyLock, clock);
     }
 
+    private CompletableFuture<Long> recover(MetaStorageServiceImpl service) {
+        if (!busyLock.enterBusy()) {
+            return CompletableFuture.failedFuture(new NodeStoppingException());
+        }
+
+        try {
+            CompletableFuture<Long> res = new CompletableFuture<>();
+
+            service.currentRevision().whenComplete((targetRevision, throwable) -> {
+                if (throwable != null) {
+                    res.completeExceptionally(throwable);
+
+                    return;
+                }
+
+                LOG.info(""Performing MetaStorage recovery from revision {} to {}"", storage.revision(), targetRevision);
+
+                assert targetRevision != null;
+
+                listenForRecovery(res, targetRevision);
+            });
+
+            return res;
+        } finally {
+            busyLock.leaveBusy();
+        }
+    }
+
+    private void listenForRecovery(CompletableFuture<Long> res, Long targetRevision) {

Review Comment:
   why is `targetRevision` `Long` and not `long`?



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -148,6 +155,77 @@ public MetaStorageManagerImpl(
         this.clusterTime = new ClusterTimeImpl(busyLock, clock);
     }
 
+    private CompletableFuture<Long> recover(MetaStorageServiceImpl service) {
+        if (!busyLock.enterBusy()) {
+            return CompletableFuture.failedFuture(new NodeStoppingException());
+        }
+
+        try {
+            CompletableFuture<Long> res = new CompletableFuture<>();

Review Comment:
   Why don't we use `recoveryFinishedFuture` here? This way we can also get rid of the `IgniteBiTuple`!



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -311,6 +318,12 @@ protected void createDb() throws RocksDBException {
         }
     }
 
+    private void notifyRevisionUpdate() {

Review Comment:
   We should specify that this method must be called under the write lock



;26/Jun/23 18:07;githubbot;600","sashapolo commented on code in PR #2237:
URL: https://github.com/apache/ignite-3/pull/2237#discussion_r1242571976


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -719,11 +732,66 @@ public void nodeWithDataTest() throws InterruptedException {
         checkTableWithData(ignite, TABLE_NAME);
     }
 
+    /**
+     * Restarts the node which stores some data.
+     */
+    @ParameterizedTest
+    @ValueSource(booleans = {true, false})

Review Comment:
   ok, never mind



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -719,11 +732,66 @@ public void nodeWithDataTest() throws InterruptedException {
         checkTableWithData(ignite, TABLE_NAME);
     }
 
+    /**
+     * Restarts the node which stores some data.
+     */
+    @ParameterizedTest
+    @ValueSource(booleans = {true, false})
+    public void metastorageRecoveryTest(boolean useSnapshot) throws InterruptedException {
+        List<IgniteImpl> nodes = startNodes(2);
+        IgniteImpl main = nodes.get(0);
+
+        createTableWithData(List.of(main), TABLE_NAME, 1);
+
+        stopNode(1);
+
+        MetaStorageManager metaStorageManager = main.metaStorageManager();
+
+        CompletableFuture[] futs = new CompletableFuture[10];
+
+        for (int i = 0; i < 10; i++) {
+            ByteArray key = ByteArray.fromString(""some-test-key-"" + i);

Review Comment:
   Thanks!



##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerRecoveryTest.java:
##########
@@ -0,0 +1,176 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willSucceedFast;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.command.GetCurrentRevisionCommand;
+import org.apache.ignite.internal.metastorage.server.KeyValueStorage;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.raft.service.RaftGroupService;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.network.ClusterService;
+import org.apache.ignite.network.MessagingService;
+import org.apache.ignite.network.NodeMetadata;
+import org.apache.ignite.network.TopologyService;
+import org.apache.ignite.network.serialization.MessageSerializationRegistry;
+import org.junit.jupiter.api.Test;
+
+/** Tests MetaStorage manager recovery basics. */
+public class MetaStorageManagerRecoveryTest {

Review Comment:
   ok



;26/Jun/23 18:07;githubbot;600","tkalkirill commented on code in PR #2237:
URL: https://github.com/apache/ignite-3/pull/2237#discussion_r1243214953


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -170,6 +172,12 @@ public class RocksDbKeyValueStorage implements KeyValueStorage {
     /** Snapshot manager. */
     private volatile RocksSnapshotManager snapshotManager;
 
+    /**
+     * Revision listener for recovery only. Notifies {@link MetaStorageManagerImpl} of revision update.
+     * Guarded by {@link #rwLock}.
+     */
+    private LongConsumer revisionListener;

Review Comment:
   I think that the name is not quite suitable, it is better to indicate that this is a listener on recovery, plus it would be better to use the new interface instead of `LongConsumer`,



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -311,6 +318,12 @@ protected void createDb() throws RocksDBException {
         }
     }
 
+    private void notifyRevisionUpdate() {

Review Comment:
   You need to specify that the notification will be at the end of the recovery.



##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -706,14 +706,23 @@ public CompletableFuture<Ignite> start(Path configPath) {
             LOG.info(""Components started, joining the cluster"");
 
             return cmgMgr.joinFuture()
-                    // using the default executor to avoid blocking the CMG Manager threads
+                    .thenComposeAsync(unused -> {
+                        LOG.info(""Join complete, starting MetaStorage"");
+
+                        try {
+                            lifecycleManager.startComponent(metaStorageMgr);
+                        } catch (NodeStoppingException e) {
+                            throw new CompletionException(e);
+                        }
+
+                        return metaStorageMgr.recoveryFinishedFuture();

Review Comment:
   Since the recovery will end here, maybe it makes sense to get rid of `RecoveryCompletionFutureFactory` or create a ticket for this? 



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/KeyValueStorage.java:
##########
@@ -292,4 +294,11 @@ public interface KeyValueStorage extends ManuallyCloseable {
      * @return Timestamp corresponding to the revision.
      */
     HybridTimestamp timestampByRevision(long revision);
+
+    /**
+     * Sets the revision listener. This is needed only for the recovery, after that listener must be set to {@code null}.
+     *
+     * @param listener Revision listener.
+     */
+    void setRevisionListener(@Nullable LongConsumer listener);

Review Comment:
   I think that the name is not quite suitable, it is better to indicate that this is a listener on recovery, plus it would be better to use the new interface instead of `LongConsumer`,
   What is the meaning of **null** listener?



;27/Jun/23 06:51;githubbot;600","SammyVimes commented on code in PR #2237:
URL: https://github.com/apache/ignite-3/pull/2237#discussion_r1243268301


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -311,6 +318,12 @@ protected void createDb() throws RocksDBException {
         }
     }
 
+    private void notifyRevisionUpdate() {

Review Comment:
   It is called every time, not only on recovery. But listener will be invoked only on recovery.



;27/Jun/23 07:33;githubbot;600","SammyVimes commented on code in PR #2237:
URL: https://github.com/apache/ignite-3/pull/2237#discussion_r1243273689


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -170,6 +172,12 @@ public class RocksDbKeyValueStorage implements KeyValueStorage {
     /** Snapshot manager. */
     private volatile RocksSnapshotManager snapshotManager;
 
+    /**
+     * Revision listener for recovery only. Notifies {@link MetaStorageManagerImpl} of revision update.
+     * Guarded by {@link #rwLock}.
+     */
+    private LongConsumer revisionListener;

Review Comment:
   Why not LongConsumer? It is a listener of long after all, no need to create an extra interface for such a small task



;27/Jun/23 07:36;githubbot;600","SammyVimes merged PR #2237:
URL: https://github.com/apache/ignite-3/pull/2237


;27/Jun/23 10:09;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,7800,,,0,7800,,,,,,,IGNITE-19852,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Tue Jun 27 10:10:14 UTC 2023,,,,,,,,,,"0|z1io0o:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"27/Jun/23 10:10;sdanilov;Thank you for the review, [~tkalkirill] and [~apolovtcev]. Merged to the main branch;;;",,,,,
.NET: IgniteClientTests.TestToString is flaky,IGNITE-19774,13540684,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,20/Jun/23 04:17,20/Jun/23 06:31,13/Jul/23 09:11,20/Jun/23 06:31,,,,,,,,3.0.0-beta2,platforms,thin client,,0,.NET,ignite-3,,"{code}
 Expected: String containing ""Name = org.apache.ignite.internal.runner.app.PlatformTestNodeRunner, Address = 127.0.0.1:109""
  But was:  ""IgniteClientInternal { Connections = [ ClusterNode { Id = 18f19c31-ccc3-4f4f-8096-f263f2e93a59, Name = org.apache.ignite.internal.runner.app.PlatformTestNodeRunner_2, Address = 127.0.0.1:10943 } ] }""
   at Apache.Ignite.Tests.IgniteClientTests.TestToString() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/IgniteClientTests.cs:line 59
   at NUnit.Framework.Internal.TaskAwaitAdapter.GenericAdapter`1.BlockUntilCompleted()
   at NUnit.Framework.Internal.MessagePumpStrategy.NoMessagePumpStrategy.WaitForCompletion(AwaitAdapter awaiter)
   at NUnit.Framework.Internal.AsyncToSyncAdapter.Await(Func`1 invoke)
   at NUnit.Framework.Internal.Commands.TestMethodCommand.RunTestMethod(TestExecutionContext context)
   at NUnit.Framework.Internal.Commands.TestMethodCommand.Execute(TestExecutionContext context)
   at NUnit.Framework.Internal.Commands.BeforeAndAfterTestCommand.<>c__DisplayClass1_0.<Execute>b__0()
   at NUnit.Framework.Internal.Commands.DelegatingTestCommand.RunTestMethodInThreadAbortSafeZone(TestExecutionContext context, Action action)
1)    at Apache.Ignite.Tests.IgniteClientTests.TestToString() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/IgniteClientTests.cs:line 59
{code}",,isapego,ptupitsyn,,,,"ptupitsyn opened a new pull request, #2222:
URL: https://github.com/apache/ignite-3/pull/2222

   (no comment)


;20/Jun/23 04:33;githubbot;600","ptupitsyn merged PR #2222:
URL: https://github.com/apache/ignite-3/pull/2222


;20/Jun/23 06:31;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,C#,Tue Jun 20 06:31:35 UTC 2023,,,,,,,,,,"0|z1inqo:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"20/Jun/23 04:33;ptupitsyn;[~isapego] please review.;;;","20/Jun/23 06:13;isapego;Looks good to me.;;;","20/Jun/23 06:31;ptupitsyn;Merged to main: 8f62930cd6c59c2ccd5006492d3e588122a93d9a;;;",,,
Compilation error in main branch,IGNITE-19772,13540583,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,Sergey Uttsel,Sergey Uttsel,Sergey Uttsel,19/Jun/23 08:46,19/Jun/23 09:23,13/Jul/23 09:11,19/Jun/23 09:23,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"/opt/buildagent/work/b8d4df1365f1f1e5/modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneCausalityDataNodesTest.java:51: error: cannot find symbol
import org.apache.ignite.internal.distributionzones.exception.DistributionZoneNotFoundException;",,Sergey Uttsel,,,,,"sergeyuttsel opened a new pull request, #2213:
URL: https://github.com/apache/ignite-3/pull/2213

   https://issues.apache.org/jira/browse/IGNITE-19772


;19/Jun/23 08:49;githubbot;600","sk0x50 merged PR #2213:
URL: https://github.com/apache/ignite-3/pull/2213


;19/Jun/23 09:22;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-06-19 08:46:07.0,,,,,,,,,,"0|z1in48:",9223372036854775807,,,slava.koptilin,,,,,,,,,,,,,,,,,,,,,,,
FileDeployerService does not stop underlying thread pool,IGNITE-19764,13540410,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Mikhail Pochatkin,rpuch,rpuch,16/Jun/23 13:40,22/Jun/23 16:35,13/Jul/23 09:11,22/Jun/23 16:35,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"The result is that a run of tests in the runner module might have tens (or maybe even more) of ""deployment0"" threads.

Probably the class needs a method for stopping/closing it; this method would stop the thread pool.",,aleksandr.pakhomov,rpuch,,,,"Pochatkin opened a new pull request, #2208:
URL: https://github.com/apache/ignite-3/pull/2208

   https://issues.apache.org/jira/browse/IGNITE-19764


;16/Jun/23 14:28;githubbot;600","PakhomovAlexander merged PR #2208:
URL: https://github.com/apache/ignite-3/pull/2208


;22/Jun/23 16:35;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jun 22 16:35:55 UTC 2023,,,,,,,,,,"0|z1im2w:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"22/Jun/23 16:35;aleksandr.pakhomov;Thanks for the contribution, merged into main: c60eda6f86e25f074d13fe8e7ef2acfa9bb170a0;;;",,,,,
Thin 3.0: Colocation column order is not preserved,IGNITE-19756,13540370,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,16/Jun/23 10:29,06/Jul/23 04:13,13/Jul/23 09:11,06/Jul/23 04:13,3.0.0-beta1,,,,,,,3.0.0-beta2,thin client,,,0,ignite-3,,,"[ClientTableCommon#writeSchema|https://github.com/apache/ignite-3/blob/317aca963ed9c87e14dd6eebd3284408fb550c8c/modules/client-handler/src/main/java/org/apache/ignite/client/handler/requests/table/ClientTableCommon.java#L75] does not preserve the order of colocation columns. It assumes that key column order is the same as colocation column order, which is not always true.

* Fix *writeSchema* somehow to specify the order of colocation columns (maybe send their indices as a separate array)
* Fix Java client accordingly",,isapego,ptupitsyn,,,,"ptupitsyn opened a new pull request, #2289:
URL: https://github.com/apache/ignite-3/pull/2289

   (no comment)


;05/Jul/23 08:28;githubbot;600","ptupitsyn merged PR #2289:
URL: https://github.com/apache/ignite-3/pull/2289


;06/Jul/23 04:12;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,IGNITE-19914,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jul 06 04:13:09 UTC 2023,,,,,,,,,,"0|z1ilu0:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"05/Jul/23 10:35;ptupitsyn;[~isapego] please review.;;;","05/Jul/23 21:17;isapego;Looks good to me.;;;","06/Jul/23 04:13;ptupitsyn;Merged to main: 61d3b03382f34a5efd568fa6a2cb0f94c2722463;;;",,,
AccessDeniedException on Windows,IGNITE-19749,13540248,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ascherbakov,ascherbakov,15/Jun/23 15:08,19/Jun/23 11:00,13/Jul/23 09:11,19/Jun/23 11:00,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"{noformat}
org.apache.ignite.lang.IgniteInternalException: IGN-CMN-65535 TraceId:ac3ebe36-c426-4388-ba3f-02294db2cc19 org.apache.ignite.lang.IgniteInternalCheckedException: IGN-CMN-65535 TraceId:b9bc45c5-0f89-42cd-b530-b7f356ca268f Error when renaming delta file: D:\work\ignite-3\modules\ignite3-ycsb-work\1686841339026\db\db\table-1\part-0-delta-0.bin.tmp
	at org.apache.ignite.internal.pagememory.persistence.checkpoint.Checkpointer.body(Checkpointer.java:224)
	at org.apache.ignite.internal.util.worker.IgniteWorker.run(IgniteWorker.java:108)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.util.concurrent.CompletionException: org.apache.ignite.lang.IgniteInternalCheckedException: IGN-CMN-65535 TraceId:b9bc45c5-0f89-42cd-b530-b7f356ca268f Error when renaming delta file: D:\work\ignite-3\modules\ignite3-ycsb-work\1686841339026\db\db\table-1\part-0-delta-0.bin.tmp
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$BiRelay.tryFire(CompletableFuture.java:1423)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
	at org.apache.ignite.internal.pagememory.persistence.checkpoint.Checkpointer.lambda$syncUpdatedPageStores$0(Checkpointer.java:490)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	... 1 more
Caused by: org.apache.ignite.lang.IgniteInternalCheckedException: IGN-CMN-65535 TraceId:b9bc45c5-0f89-42cd-b530-b7f356ca268f Error when renaming delta file: D:\work\ignite-3\modules\ignite3-ycsb-work\1686841339026\db\db\table-1\part-0-delta-0.bin.tmp
	at org.apache.ignite.internal.pagememory.persistence.checkpoint.Checkpointer.renameDeltaFileOnCheckpointThread(Checkpointer.java:782)
	at org.apache.ignite.internal.pagememory.persistence.checkpoint.Checkpointer.fsyncDeltaFile(Checkpointer.java:521)
	at org.apache.ignite.internal.pagememory.persistence.checkpoint.Checkpointer.lambda$syncUpdatedPageStores$0(Checkpointer.java:483)
	... 3 more
Caused by: java.nio.file.FileAlreadyExistsException: D:\work\ignite-3\modules\ignite3-ycsb-work\1686841339026\db\db\table-1\part-0-delta-0.bin.tmp -> D:\work\ignite-3\modules\ignite3-ycsb-work\1686841339026\db\db\table-1\part-0-delta-0.bin
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:87)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsFileCopy.move(WindowsFileCopy.java:395)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.move(WindowsFileSystemProvider.java:292)
	at java.base/java.nio.file.Files.move(Files.java:1421)
	at org.apache.ignite.internal.util.IgniteUtils.atomicMoveFile(IgniteUtils.java:771)
	at org.apache.ignite.internal.pagememory.persistence.store.AbstractFilePageStoreIo.renameFilePath(AbstractFilePageStoreIo.java:598)
	at org.apache.ignite.internal.pagememory.persistence.checkpoint.Checkpointer.renameDeltaFileOnCheckpointThread(Checkpointer.java:780)
	... 5 more
	Suppressed: java.nio.file.AccessDeniedException: D:\work\ignite-3\modules\ignite3-ycsb-work\1686841339026\db\db\table-1\part-0-delta-0.bin.tmp -> D:\work\ignite-3\modules\ignite3-ycsb-work\1686841339026\db\db\table-1\part-0-delta-0.bin
		at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:89)
		at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
		at java.base/sun.nio.fs.WindowsFileCopy.move(WindowsFileCopy.java:309)
		at java.base/sun.nio.fs.WindowsFileSystemProvider.move(WindowsFileSystemProvider.java:292)
		at java.base/java.nio.file.Files.move(Files.java:1421)
		at org.apache.ignite.internal.util.IgniteUtils.atomicMoveFile(IgniteUtils.java:754)
		... 7 more
{noformat}

Reproducable by running ycsb benchmark:
https://github.com/gridgain/apache-ignite-3/tree/ignite3-ycsb
.\modules\ycsb\README.md
",,ascherbakov,,,,,"tkalkirill opened a new pull request, #2210:
URL: https://github.com/apache/ignite-3/pull/2210

   https://issues.apache.org/jira/browse/IGNITE-19749


;16/Jun/23 14:51;githubbot;600","tkalkirill merged PR #2210:
URL: https://github.com/apache/ignite-3/pull/2210


;19/Jun/23 11:00;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-06-15 15:08:24.0,,,,,,,,,,"0|z1il2w:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
ItRebalanceDistributedTest.testOnLeaderElectedRebalanceRestart is flacky,IGNITE-19747,13540241,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Denis Chudov,v.pyatkov,v.pyatkov,15/Jun/23 13:49,20/Jun/23 10:55,13/Jul/23 09:11,20/Jun/23 10:55,,,,,,,,,,,,0,ignite-3,,,"The test have suspicious history on TC:
[https://ci.ignite.apache.org/test/3244623774880880898?currentProjectId=ApacheIgnite3xGradle_Test_IntegrationTests]
In all cases, it is an exception like this:
{noformat}
org.apache.ignite.lang.IgniteInternalException: IGN-CMN-65535 TraceId:fcdca6b2-e939-4e79-b03f-79ac4dca5d16 No such partition 0 in table TBL1
  at app//org.apache.ignite.internal.table.distributed.storage.InternalTableImpl.partitionRaftGroupService(InternalTableImpl.java:1141)
  at app//org.apache.ignite.internal.configuration.storage.ItRebalanceDistributedTest.testOnLeaderElectedRebalanceRestart(ItRebalanceDistributedTest.java:386)
  at java.base@11.0.17/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
  at java.base@11.0.17/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
{noformat}
The root cause is we have no guaranty that a table available on each node if we got it only at one.
{code:title=Test code fragment}
TableImpl table = (TableImpl) await(nodes.get(1).tableManager.createTableAsync(
                ""TBL1"",
                zoneName,
                tblChanger -> SchemaConfigurationConverter.convert(schTbl1, tblChanger)));
...
TableImpl nonLeaderTable = (TableImpl) findNodeByConsistentId(nonLeaderNodeConsistentId).tableManager.table(""TBL1"");
...
nonLeaderTable.internalTable().partitionRaftGroupService(0)
{code}
We wait the table on node with index 1, but expected that is completed on another node (nonLeaderNodeConsistentId).",,Denis Chudov,v.pyatkov,,,,"denis-chudov opened a new pull request, #2221:
URL: https://github.com/apache/ignite-3/pull/2221

   https://issues.apache.org/jira/browse/IGNITE-19747


;19/Jun/23 20:22;githubbot;600","vldpyatkov merged PR #2221:
URL: https://github.com/apache/ignite-3/pull/2221


;20/Jun/23 10:54;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Tue Jun 20 10:55:25 UTC 2023,,,,,,,,,,"0|z1il1c:",9223372036854775807,,,v.pyatkov,,,,,,,,,,,,,,,,,,"20/Jun/23 08:22;Denis Chudov;[~v.pyatkov] could you please take a look at the patch?;;;","20/Jun/23 10:55;v.pyatkov;[~Denis Chudov] Thank you for the contribution.
Merged 6aa6c158d40b1551ea549e3c224360b251b34665;;;",,,,
control.sh --performance-statistics status doesn't not print actual status,IGNITE-19746,13540240,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,nizhikov,serge.korotkov,serge.korotkov,15/Jun/23 13:48,27/Jun/23 11:18,13/Jul/23 09:11,27/Jun/23 11:18,,,,,,,,,,,,0,IEP-81,,,"The status sub-command of the control.sh --performance-statistics doesn't not print the actual status to console.

Previously it was like (note the *Disabled.* word):
{noformat}
Control utility [ver. 15.0.0-SNAPSHOT#20230422-sha1:7f80003d]
2023 Copyright(C) Apache Software Foundation
User: ducker
Time: 2023-04-23T22:17:12.489
Command [PERFORMANCE-STATISTICS] started
Arguments: --host x.x.x.x --performance-statistics status --user admin --password *****
--------------------------------------------------------------------------------
Disabled.
Command [PERFORMANCE-STATISTICS] finished with code: 0
Control utility has completed execution at: 2023-04-23T22:17:13.271
Execution time: 782 ms
{noformat}
 

Now it's like (note the absence of the *Disabled.* word):
{noformat}
Control utility [ver. 15.0.0-SNAPSHOT#20230613-sha1:cacee58d]
2023 Copyright(C) Apache Software Foundation
User: ducker
Time: 2023-06-15T15:46:41.586
Command [PERFORMANCE-STATISTICS] started
Arguments: --host x.x.x.x --performance-statistics status  --user admin --password *****
--------------------------------------------------------------------------------
Command [PERFORMANCE-STATISTICS] finished with code: 0
Control utility has completed execution at: 2023-06-15T15:46:42.523
Execution time: 937 ms
{noformat}
 

Outputs of other sub-commands are also need to be checked.",,serge.korotkov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19676,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,2023-06-15 13:48:56.0,,,,,,,,,,"0|z1il14:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
Add ability to retrieve/scan over meta storage revisions for a specific key,IGNITE-19745,13540238,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Sergey Uttsel,Sergey Uttsel,Sergey Uttsel,15/Jun/23 13:43,22/Jun/23 18:56,13/Jul/23 09:11,22/Jun/23 18:56,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"h3. *Motivation*

Occurred that it's not possible to subscribe to old meta storage revision. Alternative solution will be a combination of subscription for new ones along with scanning/retrieving old revisions in a following way:
 # Register a watch listener that will receive new entries.
 # Read an applied revision.
 # Retrieve existing entries up to the applied revision.
 # If an existing entries list contains the expected entry then use it. Else wait when the watch listener receive the expected entry.

Currently there's no method in meta storage API that will provide an ability to scan over revisions {*}locally{*}, so that we may add such mehod, e.g.
{code:java}
private List<Entry> doGet(byte[] key, long revLowerBound, long revUpperBound) {code}
Aforementioned method is a method in RocksDbKeyValueStorage that should be both properly exposed to ms API and also implemented in KeyValueStorage.
h3. Definition of Done.

It's possible to retrieve/scan over meta storage revisions for a specific key.

 ",,alapin,Sergey Uttsel,,,,"sergeyuttsel opened a new pull request, #2217:
URL: https://github.com/apache/ignite-3/pull/2217

   https://issues.apache.org/jira/browse/IGNITE-19745


;19/Jun/23 14:55;githubbot;600","sergeyuttsel closed pull request #2217: IGNITE-19745 Prototype of revision awaiting.
URL: https://github.com/apache/ignite-3/pull/2217


;20/Jun/23 14:28;githubbot;600","sergeyuttsel opened a new pull request, #2227:
URL: https://github.com/apache/ignite-3/pull/2227

   https://issues.apache.org/jira/browse/IGNITE-19745


;20/Jun/23 14:30;githubbot;600","sanpwc commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1236521082


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -319,6 +321,19 @@ public CompletableFuture<Entry> get(ByteArray key, long revUpperBound) {
         }
     }
 
+    @Override
+    public List<Entry> getEntriesLocally(byte[] key, long revLowerBound, long revUpperBound) {

Review Comment:
   Let's be consistent with other methods naming. There are bunch of method in `MetaStorageManager`, `RocksDbKeyValueStorage` and other related places that return entries, however neither of them have entries in it's name, you on the contrary introduces getEntriesLocally. Please rename it and all related `getEntries`, `doGetEntries`, etc.



;21/Jun/23 07:42;githubbot;600","sanpwc commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1236521868


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -60,6 +61,13 @@ public interface MetaStorageManager extends IgniteComponent {
      */
     CompletableFuture<Entry> get(ByteArray key, long revUpperBound);
 
+    /**
+     * Retrieves entries for the given key and bound revisions.
+     * TODO: IGNITE-19735 move this method to another interface for interaction with local KeyValueStorage.
+     */
+    @Deprecated
+    List<Entry> getEntriesLocally(byte[] key, long revLowerBound, long revUpperBound);

Review Comment:
   Let's be consistent with other methods naming. There are bunch of method in `MetaStorageManager`, `RocksDbKeyValueStorage` and other related places that return entries, however neither of them have entries in it's name, you on the contrary introduces getEntriesLocally. Please rename it and all related `getEntries`, `doGetEntries`, etc.



;21/Jun/23 07:43;githubbot;600","sanpwc commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1236524093


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/KeyValueStorage.java:
##########
@@ -70,6 +70,16 @@ public interface KeyValueStorage extends ManuallyCloseable {
      */
     Entry get(byte[] key, long revUpperBound);
 
+    /**
+     * Returns an entries by the given key and bounded by given revisions.

Review Comment:
   an isn't suitable for the plural.



;21/Jun/23 07:45;githubbot;600","sanpwc commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1236531427


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -1215,6 +1227,54 @@ private Entry doGet(byte[] key, long revUpperBound) {
         return doGetValue(key, lastRev);
     }
 
+    /**
+     * Gets the value by key and revisions.
+     *
+     * @param key            Target key.
+     * @param revLowerBound  Target lower bound of revision.
+     * @param revUpperBound  Target upper bound of revision.
+     * @return Value.
+     */
+    private List<Entry> doGetEntries(byte[] key, long revLowerBound, long revUpperBound) {
+        assert revLowerBound >= 0 : ""Invalid arguments: [revLowerBound="" + revLowerBound + ']';
+        assert revUpperBound >= 0 : ""Invalid arguments: [revUpperBound="" + revUpperBound + ']';
+        assert revUpperBound >= revLowerBound
+                : ""Invalid arguments: [revLowerBound="" + revLowerBound + "", revUpperBound="" + revUpperBound + ']';
+        // TODO: IGNITE-19782 assert that revLowerBound is not compacted.
+
+        long[] revs;
+
+        try {
+            revs = getRevisions(key);
+        } catch (RocksDBException e) {
+            throw new MetaStorageException(OP_EXECUTION_ERR, e);
+        }
+
+        if (revs.length == 0) {
+            return Collections.emptyList();
+        }
+
+        long firstRev = minRevision(revs, revLowerBound);

Review Comment:
   I'd rather introduce a pair of new methods minRevision**Index** maxRevision**Index** in order to eliminate following checks `rev >= firstRev && rev <= lastRev` and just iterate from firstRevisionIndex to lastRevisionIndex.



;21/Jun/23 07:50;githubbot;600","sanpwc commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1236601472


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/server/BasicOperationsKeyValueStorageTest.java:
##########
@@ -190,6 +192,67 @@ void getWithRevisionBound() {
         assertFalse(key3EntryBounded5.empty());
     }
 
+    @Test
+    void getEntriesWithRevisionLowerUpperBound() {
+        byte[] key1 = key(1);
+        byte[] key2 = key(2);
+
+        byte[] val1 = keyValue(1, 1);
+        byte[] val2 = keyValue(1, 2);
+        byte[] val3 = keyValue(2, 3);
+        byte[] val4 = keyValue(1, 4);
+        byte[] val5 = keyValue(1, 5);
+        byte[] val6 = keyValue(2, 6);
+        byte[] val7 = keyValue(2, 7);
+        byte[] val8 = keyValue(1, 8);
+        byte[] val9 = keyValue(1, 9);
+
+        assertEquals(0, storage.revision());
+        assertEquals(0, storage.updateCounter());
+
+        putToMs(key1, val1);
+        putToMs(key1, val2);
+        putToMs(key2, val3);
+        putToMs(key1, val4);
+        putToMs(key1, val5);
+        putToMs(key2, val6);
+        putToMs(key2, val7);
+        putToMs(key1, val8);
+        putToMs(key1, val9);
+
+        assertEquals(9, storage.revision());
+        assertEquals(9, storage.updateCounter());
+
+        List<Entry> entries1 = storage.getEntries(key1, 2, 5);

Review Comment:
   It's difficult to understand which test scenarios are assumed here. Please add comments that will explain the details. Also seems that some tests are missing for example ones that will return empty list if there are no data in proposed revisions boundaries.



;21/Jun/23 08:23;githubbot;600","sanpwc commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1236604998


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/server/BasicOperationsKeyValueStorageTest.java:
##########
@@ -190,6 +192,67 @@ void getWithRevisionBound() {
         assertFalse(key3EntryBounded5.empty());
     }
 
+    @Test
+    void getEntriesWithRevisionLowerUpperBound() {
+        byte[] key1 = key(1);
+        byte[] key2 = key(2);
+
+        byte[] val1 = keyValue(1, 1);
+        byte[] val2 = keyValue(1, 2);
+        byte[] val3 = keyValue(2, 3);
+        byte[] val4 = keyValue(1, 4);
+        byte[] val5 = keyValue(1, 5);
+        byte[] val6 = keyValue(2, 6);
+        byte[] val7 = keyValue(2, 7);
+        byte[] val8 = keyValue(1, 8);
+        byte[] val9 = keyValue(1, 9);
+
+        assertEquals(0, storage.revision());
+        assertEquals(0, storage.updateCounter());
+
+        putToMs(key1, val1);
+        putToMs(key1, val2);
+        putToMs(key2, val3);
+        putToMs(key1, val4);
+        putToMs(key1, val5);
+        putToMs(key2, val6);
+        putToMs(key2, val7);
+        putToMs(key1, val8);
+        putToMs(key1, val9);
+
+        assertEquals(9, storage.revision());
+        assertEquals(9, storage.updateCounter());
+
+        List<Entry> entries1 = storage.getEntries(key1, 2, 5);
+        List<byte[]> values1 = entries1.stream().map(entry -> entry.value()).collect(Collectors.toList());
+
+        assertEquals(3, entries1.size());
+        assertTrue(values1.stream().anyMatch(e -> Arrays.equals(val2, e)));

Review Comment:
   Result collection is supposed to be ordered, so you should check that it contains all entries ordered by revision.



;21/Jun/23 08:25;githubbot;600","sergeyuttsel commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1236757037


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/KeyValueStorage.java:
##########
@@ -70,6 +70,16 @@ public interface KeyValueStorage extends ManuallyCloseable {
      */
     Entry get(byte[] key, long revUpperBound);
 
+    /**
+     * Returns an entries by the given key and bounded by given revisions.

Review Comment:
   Fixed



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -1215,6 +1227,54 @@ private Entry doGet(byte[] key, long revUpperBound) {
         return doGetValue(key, lastRev);
     }
 
+    /**
+     * Gets the value by key and revisions.
+     *
+     * @param key            Target key.
+     * @param revLowerBound  Target lower bound of revision.
+     * @param revUpperBound  Target upper bound of revision.
+     * @return Value.
+     */
+    private List<Entry> doGetEntries(byte[] key, long revLowerBound, long revUpperBound) {
+        assert revLowerBound >= 0 : ""Invalid arguments: [revLowerBound="" + revLowerBound + ']';
+        assert revUpperBound >= 0 : ""Invalid arguments: [revUpperBound="" + revUpperBound + ']';
+        assert revUpperBound >= revLowerBound
+                : ""Invalid arguments: [revLowerBound="" + revLowerBound + "", revUpperBound="" + revUpperBound + ']';
+        // TODO: IGNITE-19782 assert that revLowerBound is not compacted.
+
+        long[] revs;
+
+        try {
+            revs = getRevisions(key);
+        } catch (RocksDBException e) {
+            throw new MetaStorageException(OP_EXECUTION_ERR, e);
+        }
+
+        if (revs.length == 0) {
+            return Collections.emptyList();
+        }
+
+        long firstRev = minRevision(revs, revLowerBound);

Review Comment:
   Fixed



;21/Jun/23 10:20;githubbot;600","sergeyuttsel commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1236757755


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/server/BasicOperationsKeyValueStorageTest.java:
##########
@@ -190,6 +192,67 @@ void getWithRevisionBound() {
         assertFalse(key3EntryBounded5.empty());
     }
 
+    @Test
+    void getEntriesWithRevisionLowerUpperBound() {
+        byte[] key1 = key(1);
+        byte[] key2 = key(2);
+
+        byte[] val1 = keyValue(1, 1);
+        byte[] val2 = keyValue(1, 2);
+        byte[] val3 = keyValue(2, 3);
+        byte[] val4 = keyValue(1, 4);
+        byte[] val5 = keyValue(1, 5);
+        byte[] val6 = keyValue(2, 6);
+        byte[] val7 = keyValue(2, 7);
+        byte[] val8 = keyValue(1, 8);
+        byte[] val9 = keyValue(1, 9);
+
+        assertEquals(0, storage.revision());
+        assertEquals(0, storage.updateCounter());
+
+        putToMs(key1, val1);
+        putToMs(key1, val2);
+        putToMs(key2, val3);
+        putToMs(key1, val4);
+        putToMs(key1, val5);
+        putToMs(key2, val6);
+        putToMs(key2, val7);
+        putToMs(key1, val8);
+        putToMs(key1, val9);
+
+        assertEquals(9, storage.revision());
+        assertEquals(9, storage.updateCounter());
+
+        List<Entry> entries1 = storage.getEntries(key1, 2, 5);

Review Comment:
   I've added comments and some asserts in the test.



;21/Jun/23 10:20;githubbot;600","sergeyuttsel commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1236758044


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/server/BasicOperationsKeyValueStorageTest.java:
##########
@@ -190,6 +192,67 @@ void getWithRevisionBound() {
         assertFalse(key3EntryBounded5.empty());
     }
 
+    @Test
+    void getEntriesWithRevisionLowerUpperBound() {
+        byte[] key1 = key(1);
+        byte[] key2 = key(2);
+
+        byte[] val1 = keyValue(1, 1);
+        byte[] val2 = keyValue(1, 2);
+        byte[] val3 = keyValue(2, 3);
+        byte[] val4 = keyValue(1, 4);
+        byte[] val5 = keyValue(1, 5);
+        byte[] val6 = keyValue(2, 6);
+        byte[] val7 = keyValue(2, 7);
+        byte[] val8 = keyValue(1, 8);
+        byte[] val9 = keyValue(1, 9);
+
+        assertEquals(0, storage.revision());
+        assertEquals(0, storage.updateCounter());
+
+        putToMs(key1, val1);
+        putToMs(key1, val2);
+        putToMs(key2, val3);
+        putToMs(key1, val4);
+        putToMs(key1, val5);
+        putToMs(key2, val6);
+        putToMs(key2, val7);
+        putToMs(key1, val8);
+        putToMs(key1, val9);
+
+        assertEquals(9, storage.revision());
+        assertEquals(9, storage.updateCounter());
+
+        List<Entry> entries1 = storage.getEntries(key1, 2, 5);
+        List<byte[]> values1 = entries1.stream().map(entry -> entry.value()).collect(Collectors.toList());
+
+        assertEquals(3, entries1.size());
+        assertTrue(values1.stream().anyMatch(e -> Arrays.equals(val2, e)));

Review Comment:
   Fixed



;21/Jun/23 10:21;githubbot;600","sergeyuttsel commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1236949433


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -60,6 +61,13 @@ public interface MetaStorageManager extends IgniteComponent {
      */
     CompletableFuture<Entry> get(ByteArray key, long revUpperBound);
 
+    /**
+     * Retrieves entries for the given key and bound revisions.
+     * TODO: IGNITE-19735 move this method to another interface for interaction with local KeyValueStorage.
+     */
+    @Deprecated
+    List<Entry> getEntriesLocally(byte[] key, long revLowerBound, long revUpperBound);

Review Comment:
   Fixed. As we discussed I used a name `get` instead of `getEntries`



;21/Jun/23 12:50;githubbot;600","sanpwc commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1238089266


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -1215,6 +1227,50 @@ private Entry doGet(byte[] key, long revUpperBound) {
         return doGetValue(key, lastRev);
     }
 
+    /**
+     * Gets the value by key and revisions.
+     *
+     * @param key            Target key.
+     * @param revLowerBound  Target lower bound of revision.
+     * @param revUpperBound  Target upper bound of revision.
+     * @return Value.
+     */
+    private List<Entry> doGet(byte[] key, long revLowerBound, long revUpperBound) {
+        assert revLowerBound >= 0 : ""Invalid arguments: [revLowerBound="" + revLowerBound + ']';
+        assert revUpperBound >= 0 : ""Invalid arguments: [revUpperBound="" + revUpperBound + ']';
+        assert revUpperBound >= revLowerBound
+                : ""Invalid arguments: [revLowerBound="" + revLowerBound + "", revUpperBound="" + revUpperBound + ']';
+        // TODO: IGNITE-19782 assert that revLowerBound is not compacted.

Review Comment:
   It's not only about revLowerBound.



;22/Jun/23 07:04;githubbot;600","sergeyuttsel commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1238101765


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -1215,6 +1227,50 @@ private Entry doGet(byte[] key, long revUpperBound) {
         return doGetValue(key, lastRev);
     }
 
+    /**
+     * Gets the value by key and revisions.
+     *
+     * @param key            Target key.
+     * @param revLowerBound  Target lower bound of revision.
+     * @param revUpperBound  Target upper bound of revision.
+     * @return Value.
+     */
+    private List<Entry> doGet(byte[] key, long revLowerBound, long revUpperBound) {
+        assert revLowerBound >= 0 : ""Invalid arguments: [revLowerBound="" + revLowerBound + ']';
+        assert revUpperBound >= 0 : ""Invalid arguments: [revUpperBound="" + revUpperBound + ']';
+        assert revUpperBound >= revLowerBound
+                : ""Invalid arguments: [revLowerBound="" + revLowerBound + "", revUpperBound="" + revUpperBound + ']';
+        // TODO: IGNITE-19782 assert that revLowerBound is not compacted.

Review Comment:
   Why? If the lower bound is compacted, then it doesn't matter if the upper bound is compacted or not.
   If the lower bound is not compacted, then the upper bound is not compacted too.



;22/Jun/23 07:15;githubbot;600","sanpwc commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1238105469


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -1215,6 +1227,50 @@ private Entry doGet(byte[] key, long revUpperBound) {
         return doGetValue(key, lastRev);
     }
 
+    /**
+     * Gets the value by key and revisions.
+     *
+     * @param key            Target key.
+     * @param revLowerBound  Target lower bound of revision.
+     * @param revUpperBound  Target upper bound of revision.
+     * @return Value.

Review Comment:
   Just value? It's a list of revision based values ordered by revisions, isn't it. Please also address it in
   `Gets the value by key and revisions.`.



;22/Jun/23 07:18;githubbot;600","sanpwc commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1238107936


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -60,6 +61,13 @@ public interface MetaStorageManager extends IgniteComponent {
      */
     CompletableFuture<Entry> get(ByteArray key, long revUpperBound);
 
+    /**
+     * Retrieves entries for the given key and bound revisions.

Review Comment:
   Please add detailed javadoc. 
   -  boundaries included/excluded?
   - Result is a list of values ordered by revisions, isn't it?
   etc.



;22/Jun/23 07:20;githubbot;600","sanpwc commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1238111679


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -1215,6 +1227,50 @@ private Entry doGet(byte[] key, long revUpperBound) {
         return doGetValue(key, lastRev);
     }
 
+    /**
+     * Gets the value by key and revisions.
+     *
+     * @param key            Target key.
+     * @param revLowerBound  Target lower bound of revision.
+     * @param revUpperBound  Target upper bound of revision.
+     * @return Value.
+     */
+    private List<Entry> doGet(byte[] key, long revLowerBound, long revUpperBound) {
+        assert revLowerBound >= 0 : ""Invalid arguments: [revLowerBound="" + revLowerBound + ']';
+        assert revUpperBound >= 0 : ""Invalid arguments: [revUpperBound="" + revUpperBound + ']';
+        assert revUpperBound >= revLowerBound
+                : ""Invalid arguments: [revLowerBound="" + revLowerBound + "", revUpperBound="" + revUpperBound + ']';
+        // TODO: IGNITE-19782 assert that revLowerBound is not compacted.

Review Comment:
   > If the lower bound is not compacted, then the upper bound is not compacted too.
   That's not true.



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -1215,6 +1227,50 @@ private Entry doGet(byte[] key, long revUpperBound) {
         return doGetValue(key, lastRev);
     }
 
+    /**
+     * Gets the value by key and revisions.
+     *
+     * @param key            Target key.
+     * @param revLowerBound  Target lower bound of revision.
+     * @param revUpperBound  Target upper bound of revision.
+     * @return Value.
+     */
+    private List<Entry> doGet(byte[] key, long revLowerBound, long revUpperBound) {
+        assert revLowerBound >= 0 : ""Invalid arguments: [revLowerBound="" + revLowerBound + ']';
+        assert revUpperBound >= 0 : ""Invalid arguments: [revUpperBound="" + revUpperBound + ']';
+        assert revUpperBound >= revLowerBound
+                : ""Invalid arguments: [revLowerBound="" + revLowerBound + "", revUpperBound="" + revUpperBound + ']';
+        // TODO: IGNITE-19782 assert that revLowerBound is not compacted.

Review Comment:
   > If the lower bound is not compacted, then the upper bound is not compacted too.
   
   That's not true.



;22/Jun/23 07:24;githubbot;600","sanpwc commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1238112862


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -1215,6 +1227,50 @@ private Entry doGet(byte[] key, long revUpperBound) {
         return doGetValue(key, lastRev);
     }
 
+    /**
+     * Gets the value by key and revisions.
+     *
+     * @param key            Target key.
+     * @param revLowerBound  Target lower bound of revision.
+     * @param revUpperBound  Target upper bound of revision.
+     * @return Value.
+     */
+    private List<Entry> doGet(byte[] key, long revLowerBound, long revUpperBound) {
+        assert revLowerBound >= 0 : ""Invalid arguments: [revLowerBound="" + revLowerBound + ']';
+        assert revUpperBound >= 0 : ""Invalid arguments: [revUpperBound="" + revUpperBound + ']';
+        assert revUpperBound >= revLowerBound
+                : ""Invalid arguments: [revLowerBound="" + revLowerBound + "", revUpperBound="" + revUpperBound + ']';
+        // TODO: IGNITE-19782 assert that revLowerBound is not compacted.
+
+        long[] revs;
+
+        try {
+            revs = getRevisions(key);
+        } catch (RocksDBException e) {
+            throw new MetaStorageException(OP_EXECUTION_ERR, e);
+        }
+
+        if (revs.length == 0) {
+            return Collections.emptyList();
+        }
+
+        int firstRev = minRevisionIndex(revs, revLowerBound);

Review Comment:
   It's not firstRev but firstRevIndex. Same for lastRev.



;22/Jun/23 07:25;githubbot;600","sanpwc commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1238113967


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -1252,6 +1308,46 @@ private static long maxRevision(long[] revs, long upperBoundRev) {
         return -1;
     }
 
+    /**
+     * Returns index of minimum revision which must be greater or equal to {@code lowerBoundRev}.

Review Comment:
   So the **index** should be greater or equal to {@code lowerBoundRev}, is that correct? ;)



;22/Jun/23 07:26;githubbot;600","sanpwc commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1238118058


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/server/BasicOperationsKeyValueStorageTest.java:
##########
@@ -190,6 +191,88 @@ void getWithRevisionBound() {
         assertFalse(key3EntryBounded5.empty());
     }
 
+    @Test
+    void getWithRevisionLowerUpperBound() {
+        byte[] key1 = key(1);
+        byte[] key2 = key(2);
+
+        byte[] val1 = keyValue(1, 1);
+        byte[] val2 = keyValue(1, 2);
+        byte[] val3 = keyValue(2, 3);
+        byte[] val4 = keyValue(1, 4);
+        byte[] val5 = keyValue(1, 5);
+        byte[] val6 = keyValue(2, 6);
+        byte[] val7 = keyValue(2, 7);
+        byte[] val8 = keyValue(1, 8);
+        byte[] val9 = keyValue(1, 9);
+
+        assertEquals(0, storage.revision());
+        assertEquals(0, storage.updateCounter());
+
+        putToMs(key1, val1);
+        putToMs(key1, val2);
+        putToMs(key2, val3);
+        putToMs(key1, val4);
+        putToMs(key1, val5);
+        putToMs(key2, val6);
+        putToMs(key2, val7);
+        putToMs(key1, val8);
+        putToMs(key1, val9);
+
+        removeFromMs(key1);
+
+        assertEquals(10, storage.revision());
+        assertEquals(10, storage.updateCounter());
+
+        // Get entries with the lower revision and the upper revision are bound to the key.
+        // One entry from the revision range is bound to another key.

Review Comment:
   It's still unclear.



;22/Jun/23 07:30;githubbot;600","sanpwc commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1238283724


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -1215,6 +1227,50 @@ private Entry doGet(byte[] key, long revUpperBound) {
         return doGetValue(key, lastRev);
     }
 
+    /**
+     * Gets the value by key and revisions.
+     *
+     * @param key            Target key.
+     * @param revLowerBound  Target lower bound of revision.
+     * @param revUpperBound  Target upper bound of revision.
+     * @return Value.
+     */
+    private List<Entry> doGet(byte[] key, long revLowerBound, long revUpperBound) {
+        assert revLowerBound >= 0 : ""Invalid arguments: [revLowerBound="" + revLowerBound + ']';
+        assert revUpperBound >= 0 : ""Invalid arguments: [revUpperBound="" + revUpperBound + ']';
+        assert revUpperBound >= revLowerBound
+                : ""Invalid arguments: [revLowerBound="" + revLowerBound + "", revUpperBound="" + revUpperBound + ']';
+        // TODO: IGNITE-19782 assert that revLowerBound is not compacted.

Review Comment:
   My fault. You are right.



;22/Jun/23 09:48;githubbot;600","sergeyuttsel commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1238290409


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/server/BasicOperationsKeyValueStorageTest.java:
##########
@@ -190,6 +192,67 @@ void getWithRevisionBound() {
         assertFalse(key3EntryBounded5.empty());
     }
 
+    @Test
+    void getEntriesWithRevisionLowerUpperBound() {
+        byte[] key1 = key(1);
+        byte[] key2 = key(2);
+
+        byte[] val1 = keyValue(1, 1);
+        byte[] val2 = keyValue(1, 2);
+        byte[] val3 = keyValue(2, 3);
+        byte[] val4 = keyValue(1, 4);
+        byte[] val5 = keyValue(1, 5);
+        byte[] val6 = keyValue(2, 6);
+        byte[] val7 = keyValue(2, 7);
+        byte[] val8 = keyValue(1, 8);
+        byte[] val9 = keyValue(1, 9);
+
+        assertEquals(0, storage.revision());
+        assertEquals(0, storage.updateCounter());
+
+        putToMs(key1, val1);
+        putToMs(key1, val2);
+        putToMs(key2, val3);
+        putToMs(key1, val4);
+        putToMs(key1, val5);
+        putToMs(key2, val6);
+        putToMs(key2, val7);
+        putToMs(key1, val8);
+        putToMs(key1, val9);
+
+        assertEquals(9, storage.revision());
+        assertEquals(9, storage.updateCounter());
+
+        List<Entry> entries1 = storage.getEntries(key1, 2, 5);

Review Comment:
   I've updated comments.



;22/Jun/23 09:54;githubbot;600","sergeyuttsel commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1238292657


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -1215,6 +1227,50 @@ private Entry doGet(byte[] key, long revUpperBound) {
         return doGetValue(key, lastRev);
     }
 
+    /**
+     * Gets the value by key and revisions.
+     *
+     * @param key            Target key.
+     * @param revLowerBound  Target lower bound of revision.
+     * @param revUpperBound  Target upper bound of revision.
+     * @return Value.

Review Comment:
   I've updated javadoc. I tried to describe it more clearly. Not sure if I succeeded. But I can't write better.



;22/Jun/23 09:56;githubbot;600","sergeyuttsel commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1238293000


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -60,6 +61,13 @@ public interface MetaStorageManager extends IgniteComponent {
      */
     CompletableFuture<Entry> get(ByteArray key, long revUpperBound);
 
+    /**
+     * Retrieves entries for the given key and bound revisions.

Review Comment:
   I've updated javadoc. I tried to describe it more clearly. Not sure if I succeeded. But I can't write better.



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -1215,6 +1227,50 @@ private Entry doGet(byte[] key, long revUpperBound) {
         return doGetValue(key, lastRev);
     }
 
+    /**
+     * Gets the value by key and revisions.
+     *
+     * @param key            Target key.
+     * @param revLowerBound  Target lower bound of revision.
+     * @param revUpperBound  Target upper bound of revision.
+     * @return Value.
+     */
+    private List<Entry> doGet(byte[] key, long revLowerBound, long revUpperBound) {
+        assert revLowerBound >= 0 : ""Invalid arguments: [revLowerBound="" + revLowerBound + ']';
+        assert revUpperBound >= 0 : ""Invalid arguments: [revUpperBound="" + revUpperBound + ']';
+        assert revUpperBound >= revLowerBound
+                : ""Invalid arguments: [revLowerBound="" + revLowerBound + "", revUpperBound="" + revUpperBound + ']';
+        // TODO: IGNITE-19782 assert that revLowerBound is not compacted.
+
+        long[] revs;
+
+        try {
+            revs = getRevisions(key);
+        } catch (RocksDBException e) {
+            throw new MetaStorageException(OP_EXECUTION_ERR, e);
+        }
+
+        if (revs.length == 0) {
+            return Collections.emptyList();
+        }
+
+        int firstRev = minRevisionIndex(revs, revLowerBound);

Review Comment:
   Fixed



;22/Jun/23 09:56;githubbot;600","sergeyuttsel commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1238293618


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/server/BasicOperationsKeyValueStorageTest.java:
##########
@@ -190,6 +191,88 @@ void getWithRevisionBound() {
         assertFalse(key3EntryBounded5.empty());
     }
 
+    @Test
+    void getWithRevisionLowerUpperBound() {
+        byte[] key1 = key(1);
+        byte[] key2 = key(2);
+
+        byte[] val1 = keyValue(1, 1);
+        byte[] val2 = keyValue(1, 2);
+        byte[] val3 = keyValue(2, 3);
+        byte[] val4 = keyValue(1, 4);
+        byte[] val5 = keyValue(1, 5);
+        byte[] val6 = keyValue(2, 6);
+        byte[] val7 = keyValue(2, 7);
+        byte[] val8 = keyValue(1, 8);
+        byte[] val9 = keyValue(1, 9);
+
+        assertEquals(0, storage.revision());
+        assertEquals(0, storage.updateCounter());
+
+        putToMs(key1, val1);
+        putToMs(key1, val2);
+        putToMs(key2, val3);
+        putToMs(key1, val4);
+        putToMs(key1, val5);
+        putToMs(key2, val6);
+        putToMs(key2, val7);
+        putToMs(key1, val8);
+        putToMs(key1, val9);
+
+        removeFromMs(key1);
+
+        assertEquals(10, storage.revision());
+        assertEquals(10, storage.updateCounter());
+
+        // Get entries with the lower revision and the upper revision are bound to the key.
+        // One entry from the revision range is bound to another key.

Review Comment:
   I've tried to describe it more clearly. Not sure if I succeeded. But I can't write better.



;22/Jun/23 09:56;githubbot;600","sanpwc commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1238319474


##########
modules/metastorage/src/testFixtures/java/org/apache/ignite/internal/metastorage/server/SimpleInMemoryKeyValueStorage.java:
##########
@@ -646,6 +655,40 @@ private Entry doGet(byte[] key, long revUpperBound) {
         return doGetValue(key, lastRev);
     }
 
+    private List<Entry> doGet(byte[] key, long revLowerBound, long revUpperBound) {
+        assert revLowerBound >= 0 : ""Invalid arguments: [revLowerBound="" + revLowerBound + ']';
+        assert revUpperBound >= 0 : ""Invalid arguments: [revUpperBound="" + revUpperBound + ']';
+        assert revUpperBound >= revLowerBound
+                : ""Invalid arguments: [revLowerBound="" + revLowerBound + "", revUpperBound="" + revUpperBound + ']';
+        // TODO: IGNITE-19782 throw CompactedException if revLowerBound is compacted.
+
+        List<Long> revs = keysIdx.get(key);
+
+        if (revs == null || revs.isEmpty()) {
+            return Collections.emptyList();
+        }
+
+        long firstRev = minRevision(revs, revLowerBound);
+        long lastRev = maxRevision(revs, revUpperBound);
+
+        // firstRev can be -1 if minRevision return -1. lastRev can be -1 if maxRevision return -1.
+        if (firstRev == -1 || lastRev == -1) {
+            return Collections.emptyList();
+        }
+
+        List<Entry> entries = new ArrayList<>();
+
+        for (int i = 0; i < revs.size(); i++) {
+            long rev = revs.get(i);
+
+            if (rev >= firstRev && rev <= lastRev) {

Review Comment:
   I'd also use firstRevisionIndex/lastRevisionIndex as in Rocks.



;22/Jun/23 10:18;githubbot;600","sergeyuttsel commented on code in PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227#discussion_r1238334631


##########
modules/metastorage/src/testFixtures/java/org/apache/ignite/internal/metastorage/server/SimpleInMemoryKeyValueStorage.java:
##########
@@ -646,6 +655,40 @@ private Entry doGet(byte[] key, long revUpperBound) {
         return doGetValue(key, lastRev);
     }
 
+    private List<Entry> doGet(byte[] key, long revLowerBound, long revUpperBound) {
+        assert revLowerBound >= 0 : ""Invalid arguments: [revLowerBound="" + revLowerBound + ']';
+        assert revUpperBound >= 0 : ""Invalid arguments: [revUpperBound="" + revUpperBound + ']';
+        assert revUpperBound >= revLowerBound
+                : ""Invalid arguments: [revLowerBound="" + revLowerBound + "", revUpperBound="" + revUpperBound + ']';
+        // TODO: IGNITE-19782 throw CompactedException if revLowerBound is compacted.
+
+        List<Long> revs = keysIdx.get(key);
+
+        if (revs == null || revs.isEmpty()) {
+            return Collections.emptyList();
+        }
+
+        long firstRev = minRevision(revs, revLowerBound);
+        long lastRev = maxRevision(revs, revUpperBound);
+
+        // firstRev can be -1 if minRevision return -1. lastRev can be -1 if maxRevision return -1.
+        if (firstRev == -1 || lastRev == -1) {
+            return Collections.emptyList();
+        }
+
+        List<Entry> entries = new ArrayList<>();
+
+        for (int i = 0; i < revs.size(); i++) {
+            long rev = revs.get(i);
+
+            if (rev >= firstRev && rev <= lastRev) {

Review Comment:
   Sorry. Fixed.



;22/Jun/23 10:33;githubbot;600","sanpwc merged PR #2227:
URL: https://github.com/apache/ignite-3/pull/2227


;22/Jun/23 18:55;githubbot;600",,,,,,,,,,,,,,,,,,0,17400,,,0,17400,,,,,,,IGNITE-19735,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-19743,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jun 22 18:56:48 UTC 2023,,,,,,,,,,"0|z1il0o:",9223372036854775807,,,alapin,,,,,,,,,,,,,,,,,,"22/Jun/23 18:56;alapin;[~Sergey Uttsel] LGTM, thanks!;;;",,,,,
TestMvStorageUpdateHandlerTest.testConcurrentExecuteBatchGc is flacky,IGNITE-19737,13540082,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,v.pyatkov,v.pyatkov,14/Jun/23 17:07,16/Jun/23 11:50,13/Jul/23 09:11,16/Jun/23 11:50,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Look at the history over all branches:

[https://ci.ignite.apache.org/test/-4740616007659837895?currentProjectId=ApacheIgnite3xGradle_Test&expandTestHistoryChartSection=true&branch=]

{noformat}
org.opentest4j.AssertionFailedError: expected: <null> but was: <RowId [partitionId=0, uuid=3eb0684a-6d15-4c0b-bc32-1f242852d60c]>
  at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151)
  at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132)
  at app//org.junit.jupiter.api.AssertNull.failNotNull(AssertNull.java:50)
  at app//org.junit.jupiter.api.AssertNull.assertNull(AssertNull.java:35)
  at app//org.junit.jupiter.api.AssertNull.assertNull(AssertNull.java:30)
  at app//org.junit.jupiter.api.Assertions.assertNull(Assertions.java:276)
  at app//org.apache.ignite.internal.table.distributed.AbstractMvStorageUpdateHandlerTest.testConcurrentExecuteBatchGc(AbstractMvStorageUpdateHandlerTest.java:159)
  at java.base@11.0.17/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
  at java.base@11.0.17/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
  at java.base@11.0.17/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
  at java.base@11.0.17/java.lang.reflect.Method.invoke(Method.java:566)
{noformat}",,rpuch,v.pyatkov,,,,"tkalkirill opened a new pull request, #2197:
URL: https://github.com/apache/ignite-3/pull/2197

   https://issues.apache.org/jira/browse/IGNITE-19737


;15/Jun/23 07:21;githubbot;600","rpuch commented on code in PR #2197:
URL: https://github.com/apache/ignite-3/pull/2197#discussion_r1232070332


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/gc/GcUpdateHandler.java:
##########
@@ -69,41 +68,74 @@ public PendingComparableValuesTracker<HybridTimestamp, Void> getSafeTimeTracker(
      *
      * @param lowWatermark Low watermark for the vacuum.
      * @param count Count of entries to GC.
+     * @param strict {@code true} if needed to remove the strictly passed {@code count} oldest stale entries, {@code false} if a premature
+     *      exit is allowed when it is not possible to acquire a lock for the {@link RowId}.
      * @return {@code False} if there is no garbage left in the storage.
      */
-    public boolean vacuumBatch(HybridTimestamp lowWatermark, int count) {
+    public boolean vacuumBatch(HybridTimestamp lowWatermark, int count, boolean strict) {
+        if (count <= 0) {
+            return true;
+        }
+
+        IntHolder countHolder = new IntHolder(count);
+
+        while (countHolder.get() > 0) {
+            VacuumResult vacuumResult = internalVacuumBatch(lowWatermark, countHolder);
+
+            switch (vacuumResult) {
+                case NO_GARBAGE_LEFT:
+                    return false;
+                case SUCCESS:
+                    return true;
+                case FAILED_ACQUIRE_LOCK:
+                    if (strict) {
+                        continue;
+                    }
+
+                    return true;
+                default:
+                    throw new IllegalStateException(vacuumResult.toString());
+            }
+        }
+
+        return true;
+    }
+
+    private VacuumResult internalVacuumBatch(HybridTimestamp lowWatermark, IntHolder countHolder) {
         return storage.runConsistently(locker -> {
+            int count = countHolder.get();
+
             for (int i = 0; i < count; i++) {
-                if (!internalVacuum(lowWatermark, locker)) {
-                    return false;
+                // It is safe for the first iteration to use a lock instead of tryLock.
+                VacuumResult vacuumResult = internalVacuum(lowWatermark, locker, i > 0);
+
+                if (vacuumResult != VacuumResult.SUCCESS) {
+                    return vacuumResult;
                 }
+
+                countHolder.getAndDecrement();
             }
 
-            return true;
+            return VacuumResult.SUCCESS;
         });
     }
 
-    /**
-     * Attempts to collect garbage for one {@link RowId}.
-     *
-     * <p>Must be called inside a {@link PartitionDataStorage#runConsistently(WriteClosure)} closure.
-     *
-     * @param lowWatermark Low watermark for the vacuum.
-     * @param locker From {@link PartitionDataStorage#runConsistently(WriteClosure)}.
-     * @return {@code False} if there is no garbage left in the {@link #storage}.
-     */
-    private boolean internalVacuum(HybridTimestamp lowWatermark, Locker locker) {
+    private VacuumResult internalVacuum(HybridTimestamp lowWatermark, Locker locker, boolean useTryLock) {
         while (true) {
             GcEntry gcEntry = storage.peek(lowWatermark);
 
             if (gcEntry == null) {
-                return false;
+                return VacuumResult.NO_GARBAGE_LEFT;
             }
 
             RowId rowId = gcEntry.getRowId();
 
-            if (!locker.tryLock(rowId)) {
-                return true;
+            if (!useTryLock) {

Review Comment:
   How about inverting the condition (and swapping the branches)? It's a bit easier to understand a condition without a negation



##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/gc/GcUpdateHandler.java:
##########
@@ -69,41 +68,74 @@ public PendingComparableValuesTracker<HybridTimestamp, Void> getSafeTimeTracker(
      *
      * @param lowWatermark Low watermark for the vacuum.
      * @param count Count of entries to GC.
+     * @param strict {@code true} if needed to remove the strictly passed {@code count} oldest stale entries, {@code false} if a premature
+     *      exit is allowed when it is not possible to acquire a lock for the {@link RowId}.
      * @return {@code False} if there is no garbage left in the storage.
      */
-    public boolean vacuumBatch(HybridTimestamp lowWatermark, int count) {
+    public boolean vacuumBatch(HybridTimestamp lowWatermark, int count, boolean strict) {
+        if (count <= 0) {
+            return true;
+        }
+
+        IntHolder countHolder = new IntHolder(count);
+
+        while (countHolder.get() > 0) {
+            VacuumResult vacuumResult = internalVacuumBatch(lowWatermark, countHolder);
+
+            switch (vacuumResult) {
+                case NO_GARBAGE_LEFT:
+                    return false;
+                case SUCCESS:
+                    return true;
+                case FAILED_ACQUIRE_LOCK:
+                    if (strict) {
+                        continue;
+                    }
+
+                    return true;
+                default:
+                    throw new IllegalStateException(vacuumResult.toString());
+            }
+        }
+
+        return true;
+    }
+
+    private VacuumResult internalVacuumBatch(HybridTimestamp lowWatermark, IntHolder countHolder) {
         return storage.runConsistently(locker -> {
+            int count = countHolder.get();
+
             for (int i = 0; i < count; i++) {
-                if (!internalVacuum(lowWatermark, locker)) {
-                    return false;
+                // It is safe for the first iteration to use a lock instead of tryLock.

Review Comment:
   Why is it safe specifically for the first iteration?



##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/gc/GcUpdateHandler.java:
##########
@@ -69,41 +68,74 @@ public PendingComparableValuesTracker<HybridTimestamp, Void> getSafeTimeTracker(
      *
      * @param lowWatermark Low watermark for the vacuum.
      * @param count Count of entries to GC.
+     * @param strict {@code true} if needed to remove the strictly passed {@code count} oldest stale entries, {@code false} if a premature
+     *      exit is allowed when it is not possible to acquire a lock for the {@link RowId}.
      * @return {@code False} if there is no garbage left in the storage.
      */
-    public boolean vacuumBatch(HybridTimestamp lowWatermark, int count) {
+    public boolean vacuumBatch(HybridTimestamp lowWatermark, int count, boolean strict) {
+        if (count <= 0) {
+            return true;
+        }
+
+        IntHolder countHolder = new IntHolder(count);

Review Comment:
   It looks like `IntHolder` is always used for counting down. How about renaming it to `CountDown`? It could also have a method like `finished()` that would check that the count reached zero



;16/Jun/23 10:50;githubbot;600","tkalkirill commented on code in PR #2197:
URL: https://github.com/apache/ignite-3/pull/2197#discussion_r1232105667


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/gc/GcUpdateHandler.java:
##########
@@ -69,41 +68,74 @@ public PendingComparableValuesTracker<HybridTimestamp, Void> getSafeTimeTracker(
      *
      * @param lowWatermark Low watermark for the vacuum.
      * @param count Count of entries to GC.
+     * @param strict {@code true} if needed to remove the strictly passed {@code count} oldest stale entries, {@code false} if a premature
+     *      exit is allowed when it is not possible to acquire a lock for the {@link RowId}.
      * @return {@code False} if there is no garbage left in the storage.
      */
-    public boolean vacuumBatch(HybridTimestamp lowWatermark, int count) {
+    public boolean vacuumBatch(HybridTimestamp lowWatermark, int count, boolean strict) {
+        if (count <= 0) {
+            return true;
+        }
+
+        IntHolder countHolder = new IntHolder(count);
+
+        while (countHolder.get() > 0) {
+            VacuumResult vacuumResult = internalVacuumBatch(lowWatermark, countHolder);
+
+            switch (vacuumResult) {
+                case NO_GARBAGE_LEFT:
+                    return false;
+                case SUCCESS:
+                    return true;
+                case FAILED_ACQUIRE_LOCK:
+                    if (strict) {
+                        continue;
+                    }
+
+                    return true;
+                default:
+                    throw new IllegalStateException(vacuumResult.toString());
+            }
+        }
+
+        return true;
+    }
+
+    private VacuumResult internalVacuumBatch(HybridTimestamp lowWatermark, IntHolder countHolder) {
         return storage.runConsistently(locker -> {
+            int count = countHolder.get();
+
             for (int i = 0; i < count; i++) {
-                if (!internalVacuum(lowWatermark, locker)) {
-                    return false;
+                // It is safe for the first iteration to use a lock instead of tryLock.
+                VacuumResult vacuumResult = internalVacuum(lowWatermark, locker, i > 0);
+
+                if (vacuumResult != VacuumResult.SUCCESS) {
+                    return vacuumResult;
                 }
+
+                countHolder.getAndDecrement();
             }
 
-            return true;
+            return VacuumResult.SUCCESS;
         });
     }
 
-    /**
-     * Attempts to collect garbage for one {@link RowId}.
-     *
-     * <p>Must be called inside a {@link PartitionDataStorage#runConsistently(WriteClosure)} closure.
-     *
-     * @param lowWatermark Low watermark for the vacuum.
-     * @param locker From {@link PartitionDataStorage#runConsistently(WriteClosure)}.
-     * @return {@code False} if there is no garbage left in the {@link #storage}.
-     */
-    private boolean internalVacuum(HybridTimestamp lowWatermark, Locker locker) {
+    private VacuumResult internalVacuum(HybridTimestamp lowWatermark, Locker locker, boolean useTryLock) {
         while (true) {
             GcEntry gcEntry = storage.peek(lowWatermark);
 
             if (gcEntry == null) {
-                return false;
+                return VacuumResult.NO_GARBAGE_LEFT;
             }
 
             RowId rowId = gcEntry.getRowId();
 
-            if (!locker.tryLock(rowId)) {
-                return true;
+            if (!useTryLock) {

Review Comment:
   Fix it



;16/Jun/23 11:05;githubbot;600","tkalkirill commented on code in PR #2197:
URL: https://github.com/apache/ignite-3/pull/2197#discussion_r1232111009


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/gc/GcUpdateHandler.java:
##########
@@ -69,41 +68,74 @@ public PendingComparableValuesTracker<HybridTimestamp, Void> getSafeTimeTracker(
      *
      * @param lowWatermark Low watermark for the vacuum.
      * @param count Count of entries to GC.
+     * @param strict {@code true} if needed to remove the strictly passed {@code count} oldest stale entries, {@code false} if a premature
+     *      exit is allowed when it is not possible to acquire a lock for the {@link RowId}.
      * @return {@code False} if there is no garbage left in the storage.
      */
-    public boolean vacuumBatch(HybridTimestamp lowWatermark, int count) {
+    public boolean vacuumBatch(HybridTimestamp lowWatermark, int count, boolean strict) {
+        if (count <= 0) {
+            return true;
+        }
+
+        IntHolder countHolder = new IntHolder(count);
+
+        while (countHolder.get() > 0) {
+            VacuumResult vacuumResult = internalVacuumBatch(lowWatermark, countHolder);
+
+            switch (vacuumResult) {
+                case NO_GARBAGE_LEFT:
+                    return false;
+                case SUCCESS:
+                    return true;
+                case FAILED_ACQUIRE_LOCK:
+                    if (strict) {
+                        continue;
+                    }
+
+                    return true;
+                default:
+                    throw new IllegalStateException(vacuumResult.toString());
+            }
+        }
+
+        return true;
+    }
+
+    private VacuumResult internalVacuumBatch(HybridTimestamp lowWatermark, IntHolder countHolder) {
         return storage.runConsistently(locker -> {
+            int count = countHolder.get();
+
             for (int i = 0; i < count; i++) {
-                if (!internalVacuum(lowWatermark, locker)) {
-                    return false;
+                // It is safe for the first iteration to use a lock instead of tryLock.

Review Comment:
   Tried to expand the comment.



;16/Jun/23 11:11;githubbot;600","tkalkirill commented on code in PR #2197:
URL: https://github.com/apache/ignite-3/pull/2197#discussion_r1232112316


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/gc/GcUpdateHandler.java:
##########
@@ -69,41 +68,74 @@ public PendingComparableValuesTracker<HybridTimestamp, Void> getSafeTimeTracker(
      *
      * @param lowWatermark Low watermark for the vacuum.
      * @param count Count of entries to GC.
+     * @param strict {@code true} if needed to remove the strictly passed {@code count} oldest stale entries, {@code false} if a premature
+     *      exit is allowed when it is not possible to acquire a lock for the {@link RowId}.
      * @return {@code False} if there is no garbage left in the storage.
      */
-    public boolean vacuumBatch(HybridTimestamp lowWatermark, int count) {
+    public boolean vacuumBatch(HybridTimestamp lowWatermark, int count, boolean strict) {
+        if (count <= 0) {
+            return true;
+        }
+
+        IntHolder countHolder = new IntHolder(count);

Review Comment:
   I'd rather leave it as is because it's closer (as api usage) to using **AtomicInteger**.



;16/Jun/23 11:12;githubbot;600","rpuch commented on code in PR #2197:
URL: https://github.com/apache/ignite-3/pull/2197#discussion_r1232120459


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/gc/GcUpdateHandler.java:
##########
@@ -69,41 +68,74 @@ public PendingComparableValuesTracker<HybridTimestamp, Void> getSafeTimeTracker(
      *
      * @param lowWatermark Low watermark for the vacuum.
      * @param count Count of entries to GC.
+     * @param strict {@code true} if needed to remove the strictly passed {@code count} oldest stale entries, {@code false} if a premature
+     *      exit is allowed when it is not possible to acquire a lock for the {@link RowId}.
      * @return {@code False} if there is no garbage left in the storage.
      */
-    public boolean vacuumBatch(HybridTimestamp lowWatermark, int count) {
+    public boolean vacuumBatch(HybridTimestamp lowWatermark, int count, boolean strict) {
+        if (count <= 0) {
+            return true;
+        }
+
+        IntHolder countHolder = new IntHolder(count);

Review Comment:
   Why is being closer to `AtomicInteger` is an advantage? `AtomicInteger` is a general-purpose util, and `IntHolder` is in our specific package, and only used in just one place, so it could be specialized



;16/Jun/23 11:22;githubbot;600","tkalkirill merged PR #2197:
URL: https://github.com/apache/ignite-3/pull/2197


;16/Jun/23 11:50;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,4200,,,0,4200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Jun 16 11:24:21 UTC 2023,,,,,,,,,,"0|z1ik20:",9223372036854775807,,,rpuch,,,,,,,,,,,,,,,,,,"16/Jun/23 11:24;rpuch;LGTM;;;",,,,,
Do not cancel tasks in DistributionZoneManager#executor if they were created by immediate scaleUp/scaleDown events.,IGNITE-19736,13540052,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Sergey Uttsel,Sergey Uttsel,Sergey Uttsel,14/Jun/23 13:40,27/Jun/23 08:30,13/Jul/23 09:11,27/Jun/23 08:30,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"h3. *Motivation*

When topology is changed it triggers scheduling a task in the executor to update data nodes. If there is another not started task in the queue then an old task will be canceled. So even if scaleUp/scaleDown timers are immediate it is possible that some topology change will be skipped because the task will be canceled. 

We need do not cancel tasks in an executor if the task was triggered by immediate data nodes calculation.
h3. *Definition of Done*
 # Do not cancel tasks in an executor if the task was triggered by immediate data nodes calculation.
 # All data nodes calculation tasks must be executed in order of creation.",,Sergey Uttsel,,,,,"sergeyuttsel opened a new pull request, #2201:
URL: https://github.com/apache/ignite-3/pull/2201

   https://issues.apache.org/jira/browse/IGNITE-19736


;15/Jun/23 22:03;githubbot;600","alievmirza commented on code in PR #2201:
URL: https://github.com/apache/ignite-3/pull/2201#discussion_r1233604855


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneManagerScaleUpTest.java:
##########
@@ -307,312 +301,6 @@ void testDropZoneDoNotPropagateDataNodesAfterScaleDown() throws Exception {
         assertZoneScaleDownChangeTriggerKey(null, ZONE_1_ID, keyValueStorage);
     }
 
-    @Test
-    void testTwoScaleUpTimersSecondTimerRunFirst() throws Exception {

Review Comment:
   Is this a temporary solution? If yes, why did we delete this tests, not mute? 



;19/Jun/23 06:55;githubbot;600","sergeyuttsel commented on code in PR #2201:
URL: https://github.com/apache/ignite-3/pull/2201#discussion_r1233697235


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneManagerScaleUpTest.java:
##########
@@ -307,312 +301,6 @@ void testDropZoneDoNotPropagateDataNodesAfterScaleDown() throws Exception {
         assertZoneScaleDownChangeTriggerKey(null, ZONE_1_ID, keyValueStorage);
     }
 
-    @Test
-    void testTwoScaleUpTimersSecondTimerRunFirst() throws Exception {

Review Comment:
   This is a permanent solution. My algorithm needs a guarantee that tasks of each zone will be executed in the order they were added to the executor. These tests check that multiple tasks for a zone are running at the same time, so now such tests will not pass successfully. Even if I make a striped executor, it won't change this.



;19/Jun/23 08:20;githubbot;600","alievmirza commented on code in PR #2201:
URL: https://github.com/apache/ignite-3/pull/2201#discussion_r1242432274


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -282,8 +282,10 @@ public DistributionZoneManager(
 
         nodesAttributes = new ConcurrentHashMap<>();
 
+        // Use a single thread executor to avoid concurrent executing several tasks for the same zone.
+        // TODO: IGNITE-19783 Need to use a striped executor.

Review Comment:
   Let's move creation of the executor to a util method in DistributionZonesUtil snd reuse in test



;26/Jun/23 17:14;githubbot;600","sergeyuttsel commented on code in PR #2201:
URL: https://github.com/apache/ignite-3/pull/2201#discussion_r1242545958


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -282,8 +282,10 @@ public DistributionZoneManager(
 
         nodesAttributes = new ConcurrentHashMap<>();
 
+        // Use a single thread executor to avoid concurrent executing several tasks for the same zone.
+        // TODO: IGNITE-19783 Need to use a striped executor.

Review Comment:
   I agree. Moved.



;26/Jun/23 17:47;githubbot;600","sk0x50 merged PR #2201:
URL: https://github.com/apache/ignite-3/pull/2201


;27/Jun/23 08:30;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3600,,,0,3600,,,,,,,IGNITE-19506,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-19743,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-06-14 13:40:46.0,,,,,,,,,,"0|z1ijvc:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
ItTableScanTest different test failed.,IGNITE-19731,13539991,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,v.pyatkov,zstan,zstan,14/Jun/23 06:56,21/Jun/23 15:14,13/Jul/23 09:11,21/Jun/23 12:05,3.0.0-beta1,,,,,,,,general,,,0,ignite-3,,,"ItTableScanTest different tests are failed, reproduced locally (just call run until failure and on 5+ iteration it will fail) main (79a841d95247c338b80ab91a93ec18ee7) TC also decide them flaky
 !image-2023-06-14-09-56-02-062.png! ",,alapin,v.pyatkov,zstan,,,"vldpyatkov opened a new pull request, #2209:
URL: https://github.com/apache/ignite-3/pull/2209

   https://issues.apache.org/jira/browse/IGNITE-19731


;16/Jun/23 14:44;githubbot;600","sanpwc commented on code in PR #2209:
URL: https://github.com/apache/ignite-3/pull/2209#discussion_r1234877316


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/SortedIndexLocker.java:
##########
@@ -100,7 +100,12 @@ public CompletableFuture<IndexRow> locksForScan(UUID txId, Cursor<IndexRow> curs
                 return null;
             }
 
-            return peekCursor.next();
+            IndexRow nextRow = peekCursor.next();
+
+            assert rowIdMatches(indexRow, nextRow) :

Review Comment:
   What if same tx will concurrently insert one more key right in from of nextRow?



;20/Jun/23 07:50;githubbot;600","vldpyatkov commented on code in PR #2209:
URL: https://github.com/apache/ignite-3/pull/2209#discussion_r1234888953


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/SortedIndexLocker.java:
##########
@@ -100,7 +100,12 @@ public CompletableFuture<IndexRow> locksForScan(UUID txId, Cursor<IndexRow> curs
                 return null;
             }
 
-            return peekCursor.next();
+            IndexRow nextRow = peekCursor.next();
+
+            assert rowIdMatches(indexRow, nextRow) :

Review Comment:
   I have no an answer. I think it will be possible, but how we will work with this...
   This means the same code in a transaction can lead to different result.



;20/Jun/23 08:00;githubbot;600","vldpyatkov merged PR #2209:
URL: https://github.com/apache/ignite-3/pull/2209


;21/Jun/23 12:04;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"14/Jun/23 06:56;zstan;image-2023-06-14-09-56-02-062.png;https://issues.apache.org/jira/secure/attachment/13059051/image-2023-06-14-09-56-02-062.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jun 21 15:14:45 UTC 2023,,,,,,,,,,"0|z1ijhs:",9223372036854775807,,,alapin,,,,,,,,,,,,,,,,,,"14/Jun/23 10:29;v.pyatkov;In most part of these tests, we have a conflict with transaction 0188b8a2-1fd4-0005-0000-00005e7b0eac. I think the transaction got stuck and affect the rest of the tests.

As I see, we do not rollback transaction in case when _ReadWriteScanRetrieveBatchReplicaRequest_ failed:
{panel:title=grep by 0188b8a2-1fd4-0005-0000-00005e7b0eac from log}
2023-06-14 09:40:12:812 +0300 [WARNING][%itst_n_1%scan-query-executor--0][ReplicaManager] Failed to process replica request [request=ReadWriteScanRetrieveBatchReplicaRequestImpl [batchSize=1000, columnsToInclude=null, exactKey=null, flags=0, groupId=1_part_0, indexToUse=3, lowerBoundPrefix=null, scanId=81581, term=1, timestampLong=110541197332316160, transactionId=0188b8a2-1fd4-0005-0000-00005e7b0eac, upperBoundPrefix=null]]
java.util.concurrent.CompletionException: org.apache.ignite.internal.tx.LockException: IGN-TX-4 TraceId:7df614cc-180f-4b8d-b290-507453105729 Failed to acquire a lock due to a conflict [txId=0188b8a2-1fd4-0005-0000-00005e7b0eac, conflictingWaiter=WaiterImpl [txId=0188b8a2-1fd4-0004-0000-00005e7b0eac, intendedLockMode=null, lockMode=IX, ex=null, isDone=true]]
{panel};;;","21/Jun/23 08:34;alapin;[~v.pyatkov] LGTM, thanks!;;;","21/Jun/23 12:05;v.pyatkov;Merged 2c2537540ef63ba835be3f8aaf756353a5085f6f;;;","21/Jun/23 15:14;v.pyatkov;Really, the root cause of the issue was in only one test, but failed too many.
The reason by which several test may fail after a bug in one, is pending transactions. In most methods in KV API we rollback transaction automatically when a transaction exception happens (look at InternalTableImpl#postEnlist).
But specific scans methods which are used in SQL do nothing when some exception happened or closing cursor (look at parameter value onClose for PartitionScanPublisher). Due to this, behavior the transaction which is failed (by lock conflict reason, for example) can fail the transaction (hence, the corresponding test) in next tests.
;;;",,
Sql. Different tests failed in scope of ExecutionServiceImplTest,IGNITE-19730,13539974,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,zstan,zstan,zstan,14/Jun/23 06:13,06/Jul/23 07:19,13/Jul/23 09:11,06/Jul/23 07:19,3.0.0-beta1,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"different tests failed under ExecutionServiceImplTest, with :


{code:java}
Expected :true
Actual   :false
	at org.apache.ignite.internal.sql.engine.exec.ExecutionServiceImplTest.tearDown(ExecutionServiceImplTest.java:159)
{code}
reproduced in main (79a841d95247c338b80ab91a9)
Step to reproduce : run ExecutionServiceImplTest *until failure* and after 5+ run unstable tests become visible.",,zstan,,,,,"zstan opened a new pull request, #2241:
URL: https://github.com/apache/ignite-3/pull/2241

   (no comment)


;22/Jun/23 17:58;githubbot;600","zstan commented on PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#issuecomment-1609355234

   @korlov42 tests are not flaky any more, as for me code become a little bit clear for understanding. can u make a review plz ?


;27/Jun/23 11:58;githubbot;600","korlov42 commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1244714682


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/api/ItSqlAsynchronousApiTest.java:
##########
@@ -690,7 +689,7 @@ public void closeSession() {
 
         assertThrowsWithCause(
                 () -> await(ars0.fetchNextPage()),
-                ExecutionCancelledException.class
+                CursorClosedException.class

Review Comment:
   the same



##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/StopCalciteModuleTest.java:
##########
@@ -284,7 +284,7 @@ public void testStopQueryOnNodeStop() throws Exception {
         await(request.exceptionally(t -> {
             assertInstanceOf(CompletionException.class, t);
             assertInstanceOf(IgniteException.class, t.getCause());
-            assertInstanceOf(ExecutionCancelledException.class, t.getCause().getCause());
+            assertInstanceOf(CursorClosedException.class, t.getCause().getCause());

Review Comment:
   and here



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -824,47 +824,62 @@ private void enlist(SourceAwareIgniteRel rel) {
             }.visit(fragment.root());
         }
 
-        private CompletableFuture<Void> close(boolean cancel) {
+        private CompletableFuture<Void> close() {
             if (!cancelled.compareAndSet(false, true)) {
-                return cancelFut.thenApply(Function.identity());
+                return cancelFut;
             }
 
-            CompletableFuture<Void> start = closeExecNode(cancel);
+            CompletableFuture<Void> start = closeExecNode();
 
             start
-                    .thenCompose(tmp -> {
-                        CompletableFuture<Void> cancelResult = coordinator
-                                ? awaitFragmentInitialisationAndClose()
-                                : closeLocalFragments();
-
-                        var finalStepFut = cancelResult.whenComplete((r, e) -> {
-                            queryManagerMap.remove(ctx.queryId());
-
-                            try {
-                                ctx.cancel().cancel();
-                            } catch (Exception ignored) {
-                                // NO-OP
-                            }
+            .thenCompose(tmp -> {

Review Comment:
   indentation 



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -888,14 +903,6 @@ private CompletableFuture<Void> awaitFragmentInitialisationAndClose() {
 
                 cancelFuts.add(
                         CompletableFuture.allOf(entry.getValue().toArray(new CompletableFuture[0]))
-                                .handle((none2, t) -> {
-                                    // Some fragments may be completed exceptionally, and that is fine.
-                                    // Here we need to make sure that all query initialisation requests
-                                    // have been processed before sending a cancellation request. That's
-                                    // why we just ignore any exception.
-
-                                    return null;
-                                })

Review Comment:
   why did you remove this?



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/api/ItCommonApiTest.java:
##########
@@ -107,7 +105,7 @@ public void testSessionExpiration() throws Exception {
             while (rs1.hasNext()) {
                 rs1.next();
             }
-        }, ExecutionCancelledException.class);
+        }, CursorClosedException.class);

Review Comment:
   well, I think this change is not correct. In my opinion, we need to distinguish between cursor closed by users' intention and cursor closed by system intention



;28/Jun/23 06:43;githubbot;600","zstan commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1244802526


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/api/ItSqlAsynchronousApiTest.java:
##########
@@ -690,7 +689,7 @@ public void closeSession() {
 
         assertThrowsWithCause(
                 () -> await(ars0.fetchNextPage()),
-                ExecutionCancelledException.class
+                CursorClosedException.class

Review Comment:
   and what about already exist :
   https://github.com/apache/ignite-3/blob/cae90410a32ba3946d09f6a135683f9c3e231f38/modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/api/ItSqlAsynchronousApiTest.java#L636
   https://github.com/apache/ignite-3/blob/cae90410a32ba3946d09f6a135683f9c3e231f38/modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/api/ItSqlSynchronousApiTest.java#L330



;28/Jun/23 07:28;githubbot;600","zstan commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1244838075


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -888,14 +903,6 @@ private CompletableFuture<Void> awaitFragmentInitialisationAndClose() {
 
                 cancelFuts.add(
                         CompletableFuture.allOf(entry.getValue().toArray(new CompletableFuture[0]))
-                                .handle((none2, t) -> {
-                                    // Some fragments may be completed exceptionally, and that is fine.
-                                    // Here we need to make sure that all query initialisation requests
-                                    // have been processed before sending a cancellation request. That's
-                                    // why we just ignore any exception.
-
-                                    return null;
-                                })

Review Comment:
   as i can see : 1. remoteFragmentInitCompletion holder completes it`s futures only on one place 2. i don`t understand what problem solve this code if future somethere completes exceptionally. Plz give me the clue



;28/Jun/23 07:59;githubbot;600","zstan commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1244838075


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -888,14 +903,6 @@ private CompletableFuture<Void> awaitFragmentInitialisationAndClose() {
 
                 cancelFuts.add(
                         CompletableFuture.allOf(entry.getValue().toArray(new CompletableFuture[0]))
-                                .handle((none2, t) -> {
-                                    // Some fragments may be completed exceptionally, and that is fine.
-                                    // Here we need to make sure that all query initialisation requests
-                                    // have been processed before sending a cancellation request. That's
-                                    // why we just ignore any exception.
-
-                                    return null;
-                                })

Review Comment:
   as i can see : 1. remoteFragmentInitCompletion holder completes it\`s futures only on one place 2. i don\`t understand what problem solve this code if future somethere completes exceptionally. Plz give me the clue



;28/Jun/23 08:01;githubbot;600","korlov42 commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1244846036


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -888,14 +903,6 @@ private CompletableFuture<Void> awaitFragmentInitialisationAndClose() {
 
                 cancelFuts.add(
                         CompletableFuture.allOf(entry.getValue().toArray(new CompletableFuture[0]))
-                                .handle((none2, t) -> {
-                                    // Some fragments may be completed exceptionally, and that is fine.
-                                    // Here we need to make sure that all query initialisation requests
-                                    // have been processed before sending a cancellation request. That's
-                                    // why we just ignore any exception.
-
-                                    return null;
-                                })

Review Comment:
   https://en.wiktionary.org/wiki/Chesterton%27s_fence



;28/Jun/23 08:07;githubbot;600","korlov42 commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1244912561


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/api/ItSqlAsynchronousApiTest.java:
##########
@@ -690,7 +689,7 @@ public void closeSession() {
 
         assertThrowsWithCause(
                 () -> await(ars0.fetchNextPage()),
-                ExecutionCancelledException.class
+                CursorClosedException.class

Review Comment:
   what is wrong with these two assertion?



;28/Jun/23 09:00;githubbot;600","zstan commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1244990085


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -888,14 +903,6 @@ private CompletableFuture<Void> awaitFragmentInitialisationAndClose() {
 
                 cancelFuts.add(
                         CompletableFuture.allOf(entry.getValue().toArray(new CompletableFuture[0]))
-                                .handle((none2, t) -> {
-                                    // Some fragments may be completed exceptionally, and that is fine.
-                                    // Here we need to make sure that all query initialisation requests
-                                    // have been processed before sending a cancellation request. That's
-                                    // why we just ignore any exception.
-
-                                    return null;
-                                })

Review Comment:
   ))) as i can observe through history initially this section process exception handling and after just degenerate into empty block. I agree To fill the issue for this case if you ok.



;28/Jun/23 10:02;githubbot;600","korlov42 commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1245052369


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -888,14 +903,6 @@ private CompletableFuture<Void> awaitFragmentInitialisationAndClose() {
 
                 cancelFuts.add(
                         CompletableFuture.allOf(entry.getValue().toArray(new CompletableFuture[0]))
-                                .handle((none2, t) -> {
-                                    // Some fragments may be completed exceptionally, and that is fine.
-                                    // Here we need to make sure that all query initialisation requests
-                                    // have been processed before sending a cancellation request. That's
-                                    // why we just ignore any exception.
-
-                                    return null;
-                                })

Review Comment:
   have you read comment in this empty block?



;28/Jun/23 11:04;githubbot;600","zstan commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1245063024


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/api/ItCommonApiTest.java:
##########
@@ -107,7 +105,7 @@ public void testSessionExpiration() throws Exception {
             while (rs1.hasNext()) {
                 rs1.next();
             }
-        }, ExecutionCancelledException.class);
+        }, CursorClosedException.class);

Review Comment:
   got it, thanks for pointing, bloody bloody code )



;28/Jun/23 11:16;githubbot;600","zstan commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1245065903


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -888,14 +903,6 @@ private CompletableFuture<Void> awaitFragmentInitialisationAndClose() {
 
                 cancelFuts.add(
                         CompletableFuture.allOf(entry.getValue().toArray(new CompletableFuture[0]))
-                                .handle((none2, t) -> {
-                                    // Some fragments may be completed exceptionally, and that is fine.
-                                    // Here we need to make sure that all query initialisation requests
-                                    // have been processed before sending a cancellation request. That's
-                                    // why we just ignore any exception.
-
-                                    return null;
-                                })

Review Comment:
   of course, but still have no clue, i found that no one test will touch this place with not null **t**



;28/Jun/23 11:19;githubbot;600","korlov42 commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1246212126


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -826,45 +826,69 @@ private void enlist(SourceAwareIgniteRel rel) {
 
         private CompletableFuture<Void> close(boolean cancel) {
             if (!cancelled.compareAndSet(false, true)) {
-                return cancelFut.thenApply(Function.identity());
+                return cancelFut;
             }
 
             CompletableFuture<Void> start = closeExecNode(cancel);
 
-            start
-                    .thenCompose(tmp -> {
-                        CompletableFuture<Void> cancelResult = coordinator
-                                ? awaitFragmentInitialisationAndClose()
-                                : closeLocalFragments();
+            start.thenCompose(tmp -> {
+                CompletableFuture<Void> cancelResult = coordinator
+                        ? awaitFragmentInitialisationAndClose()
+                        : closeLocalFragments();
 
-                        var finalStepFut = cancelResult.whenComplete((r, e) -> {
-                            queryManagerMap.remove(ctx.queryId());
+                var finalStepFut = cancelResult.whenComplete((r, e) -> {
+                    if (e != null) {
+                        Throwable ex = unwrapCause(e);
 
-                            try {
-                                ctx.cancel().cancel();
-                            } catch (Exception ignored) {
-                                // NO-OP
-                            }
+                        LOG.warn(""Exception raised during close"", ex);
+                    }
 
-                            cancelFut.complete(null);
-                        });
+                    queryManagerMap.remove(ctx.queryId());
 
-                        return cancelResult.thenCombine(finalStepFut, (none1, none2) -> null);
-                    });
+                    ctx.cancel().cancel();
+
+                    cancelFut.complete(null);
+                });
+
+                return cancelResult.thenCombine(finalStepFut, (none1, none2) -> null);
+            })
+                    .thenRun(() -> localFragments.forEach(f -> f.context().cancel()));
 
             start.completeAsync(() -> null, taskExecutor);
 
-            return cancelFut.thenApply(Function.identity());
+            return cancelFut;
+        }
+
+        /**
+         * Synchronously closes the tree's execution iterator.
+         *
+         * @param cancel Forces execution to terminate with {@link ExecutionCancelledException}.
+         * @return Completable future that should run asynchronously.
+         */
+        private CompletableFuture<Void> closeExecNode(boolean cancel) {
+            CompletableFuture<Void> start = new CompletableFuture<>();
+
+            if (!root.completeExceptionally(new ExecutionCancelledException()) && !root.isCompletedExceptionally()) {
+                AsyncRootNode<RowT, List<Object>> node = root.getNow(null);
+
+                if (!cancel) {
+                    CompletableFuture<Void> closeFut = node.closeAsync();
+
+                    return start.thenCompose(v -> closeFut);
+                }
+
+                node.onError(new ExecutionCancelledException());
+            }
+
+            return start;

Review Comment:
   is there any reason to move this method up? If no, let's just revert this change



;29/Jun/23 07:14;githubbot;600","korlov42 commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1246227747


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -888,14 +903,6 @@ private CompletableFuture<Void> awaitFragmentInitialisationAndClose() {
 
                 cancelFuts.add(
                         CompletableFuture.allOf(entry.getValue().toArray(new CompletableFuture[0]))
-                                .handle((none2, t) -> {
-                                    // Some fragments may be completed exceptionally, and that is fine.
-                                    // Here we need to make sure that all query initialisation requests
-                                    // have been processed before sending a cancellation request. That's
-                                    // why we just ignore any exception.
-
-                                    return null;
-                                })

Review Comment:
   it's not news that we don't have comprehensive test coverage.
   
   In the very beginning, the comment states ""Some fragments may be completed exceptionally"". Therefore, we need to find out whether this invariant is conserved. There are only 5 usages `remoteFragmentInitCompletion`, so I believe it's not a rocket science to take a look at every usage. As far as I can see, `DistributedQueryManager#onNodeLeft` completes init future with exception. 
   
   Feel free to add such test to ExecutionServiceImplTest. If it will pass without mentioned `handle` block, I'm ok to remove it



;29/Jun/23 07:26;githubbot;600","korlov42 commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1246227747


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -888,14 +903,6 @@ private CompletableFuture<Void> awaitFragmentInitialisationAndClose() {
 
                 cancelFuts.add(
                         CompletableFuture.allOf(entry.getValue().toArray(new CompletableFuture[0]))
-                                .handle((none2, t) -> {
-                                    // Some fragments may be completed exceptionally, and that is fine.
-                                    // Here we need to make sure that all query initialisation requests
-                                    // have been processed before sending a cancellation request. That's
-                                    // why we just ignore any exception.
-
-                                    return null;
-                                })

Review Comment:
   it's not news that we don't have comprehensive test coverage.
   
   At the very beginning, the comment states ""Some fragments may be completed exceptionally"". Therefore, we need to find out whether this invariant is conserved. There are only 5 usages `remoteFragmentInitCompletion`, so I believe it's not a rocket science to take a look at every usage. As far as I can see, `DistributedQueryManager#onNodeLeft` completes init future with exception. 
   
   Feel free to add such test to ExecutionServiceImplTest. If it will pass without mentioned `handle` block, I'm ok to remove it



;29/Jun/23 07:27;githubbot;600","korlov42 commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1246229842


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -826,45 +826,69 @@ private void enlist(SourceAwareIgniteRel rel) {
 
         private CompletableFuture<Void> close(boolean cancel) {
             if (!cancelled.compareAndSet(false, true)) {
-                return cancelFut.thenApply(Function.identity());
+                return cancelFut;
             }
 
             CompletableFuture<Void> start = closeExecNode(cancel);
 
-            start
-                    .thenCompose(tmp -> {
-                        CompletableFuture<Void> cancelResult = coordinator
-                                ? awaitFragmentInitialisationAndClose()
-                                : closeLocalFragments();
+            start.thenCompose(tmp -> {
+                CompletableFuture<Void> cancelResult = coordinator
+                        ? awaitFragmentInitialisationAndClose()
+                        : closeLocalFragments();
 
-                        var finalStepFut = cancelResult.whenComplete((r, e) -> {
-                            queryManagerMap.remove(ctx.queryId());
+                var finalStepFut = cancelResult.whenComplete((r, e) -> {
+                    if (e != null) {
+                        Throwable ex = unwrapCause(e);
 
-                            try {
-                                ctx.cancel().cancel();
-                            } catch (Exception ignored) {
-                                // NO-OP
-                            }
+                        LOG.warn(""Exception raised during close"", ex);
+                    }
 
-                            cancelFut.complete(null);
-                        });
+                    queryManagerMap.remove(ctx.queryId());
 
-                        return cancelResult.thenCombine(finalStepFut, (none1, none2) -> null);
-                    });
+                    ctx.cancel().cancel();
+
+                    cancelFut.complete(null);
+                });
+
+                return cancelResult.thenCombine(finalStepFut, (none1, none2) -> null);
+            })
+                    .thenRun(() -> localFragments.forEach(f -> f.context().cancel()));

Review Comment:
   any reason to reformat this part?



;29/Jun/23 07:28;githubbot;600","zstan commented on PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#issuecomment-1613161296

   @korlov42 return error handling, append test.


;29/Jun/23 13:12;githubbot;600","korlov42 commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1247506243


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -838,33 +838,34 @@ private CompletableFuture<Void> close(boolean cancel) {
                                 : closeLocalFragments();
 
                         var finalStepFut = cancelResult.whenComplete((r, e) -> {
-                            queryManagerMap.remove(ctx.queryId());
+                            if (e != null) {
+                                Throwable ex = unwrapCause(e);
 
-                            try {
-                                ctx.cancel().cancel();
-                            } catch (Exception ignored) {
-                                // NO-OP
+                                LOG.warn(""Exception raised during close"", ex);
                             }
 
+                            queryManagerMap.remove(ctx.queryId());
+
+                            ctx.cancel().cancel();

Review Comment:
   why did you removed try-catch block around cancel? 



;30/Jun/23 06:57;githubbot;600","korlov42 commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1247515629


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -838,33 +838,34 @@ private CompletableFuture<Void> close(boolean cancel) {
                                 : closeLocalFragments();
 
                         var finalStepFut = cancelResult.whenComplete((r, e) -> {
-                            queryManagerMap.remove(ctx.queryId());
+                            if (e != null) {
+                                Throwable ex = unwrapCause(e);
 
-                            try {
-                                ctx.cancel().cancel();
-                            } catch (Exception ignored) {
-                                // NO-OP
+                                LOG.warn(""Exception raised during close"", ex);

Review Comment:
   Log message should be rephrased.
   
   According to our [guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Java+Logging+Guidelines#JavaLoggingGuidelines-WARN):
   ```
   WARN is what the team will need to review at the start of the next business day, at a high priority. WARN is always actionable - the user must understand how to react
   ```
   
   From the message I don't understand what I should to do. TBH, I don't even understand what was going wrong. We closed a door and exception had been raised? A window? 



;30/Jun/23 07:09;githubbot;600","zstan commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1247840507


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -838,33 +838,34 @@ private CompletableFuture<Void> close(boolean cancel) {
                                 : closeLocalFragments();
 
                         var finalStepFut = cancelResult.whenComplete((r, e) -> {
-                            queryManagerMap.remove(ctx.queryId());
+                            if (e != null) {
+                                Throwable ex = unwrapCause(e);
 
-                            try {
-                                ctx.cancel().cancel();
-                            } catch (Exception ignored) {
-                                // NO-OP
+                                LOG.warn(""Exception raised during close"", ex);
                             }
 
+                            queryManagerMap.remove(ctx.queryId());
+
+                            ctx.cancel().cancel();

Review Comment:
   revert and fill the issue https://issues.apache.org/jira/browse/IGNITE-19895



;30/Jun/23 13:04;githubbot;600","korlov42 commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1250363722


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -838,33 +838,38 @@ private CompletableFuture<Void> close(boolean cancel) {
                                 : closeLocalFragments();
 
                         var finalStepFut = cancelResult.whenComplete((r, e) -> {
+                            if (e != null) {
+                                Throwable ex = unwrapCause(e);
+
+                                LOG.warn(format(""Fragment closing processed with errors, root fragmentId={}"", rootFragmentId), ex);

Review Comment:
   I've got a few questions regarding this line of code:
   1) why don't delegate formatting to logger?
   2) how did you come up with rootFragmentId param?
   3) have you read logging guidelines?



;03/Jul/23 07:07;githubbot;600","zstan commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1250404649


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -838,33 +838,38 @@ private CompletableFuture<Void> close(boolean cancel) {
                                 : closeLocalFragments();
 
                         var finalStepFut = cancelResult.whenComplete((r, e) -> {
+                            if (e != null) {
+                                Throwable ex = unwrapCause(e);
+
+                                LOG.warn(format(""Fragment closing processed with errors, root fragmentId={}"", rootFragmentId), ex);

Review Comment:
   ok, i change it



;03/Jul/23 07:38;githubbot;600","korlov42 commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1252124233


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -838,33 +838,38 @@ private CompletableFuture<Void> close(boolean cancel) {
                                 : closeLocalFragments();
 
                         var finalStepFut = cancelResult.whenComplete((r, e) -> {
+                            if (e != null) {
+                                Throwable ex = unwrapCause(e);
+
+                                LOG.warn(""Fragment closing processed with errors, root [queryId={}]"", ex, ctx.queryId());

Review Comment:
   not sure why do we need ""root"" at the end



;04/Jul/23 14:45;githubbot;600","zstan commented on code in PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241#discussion_r1252208917


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -838,33 +838,38 @@ private CompletableFuture<Void> close(boolean cancel) {
                                 : closeLocalFragments();
 
                         var finalStepFut = cancelResult.whenComplete((r, e) -> {
+                            if (e != null) {
+                                Throwable ex = unwrapCause(e);
+
+                                LOG.warn(""Fragment closing processed with errors, root [queryId={}]"", ex, ctx.queryId());

Review Comment:
   it`s all about ""self review"" )



;04/Jul/23 16:20;githubbot;600","zstan merged PR #2241:
URL: https://github.com/apache/ignite-3/pull/2241


;06/Jul/23 07:18;githubbot;600",,,,,,,,,,,,,,,,,,,,,,0,15000,,,0,15000,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-06-14 06:13:09.0,,,,,,,,,,"0|z1ije0:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
.NET: DataStreamerTests.TestAutoFlushFrequency is flaky,IGNITE-19728,13539957,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,14/Jun/23 03:45,14/Jun/23 07:42,13/Jul/23 09:11,14/Jun/23 07:42,,,,,,,,,platforms,thin client,,0,.NET,ignite-3,,"*DataStreamerTests.TestAutoFlushFrequency(True)*:

* History: https://ci.ignite.apache.org/test/4035794459336688174?currentProjectId=ApacheIgnite3xGradle_Test&expandTestHistoryChartSection=true
* Failure: https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunNetTests/7291573?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandBuildChangesSection=true&expandBuildTestsSection=true&buildTab=overview&showLog=7291573_31617_1111.1117&logFilter=debug&logView=flowAware

{code}
 Failed TestAutoFlushFrequency(True) [256 ms]
14:54:54       Error Message:
14:54:54          Expected: True
14:54:54       But was:  False
14:54:54     
14:54:54       Stack Trace:
14:54:54          at Apache.Ignite.Tests.Table.DataStreamerTests.TestAutoFlushFrequency(Boolean enabled) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/Table/DataStreamerTests.cs:line 103
14:54:54        at NUnit.Framework.Internal.TaskAwaitAdapter.GenericAdapter`1.BlockUntilCompleted()
14:54:54        at NUnit.Framework.Internal.MessagePumpStrategy.NoMessagePumpStrategy.WaitForCompletion(AwaitAdapter awaiter)
14:54:54        at NUnit.Framework.Internal.AsyncToSyncAdapter.Await(Func`1 invoke)
14:54:54        at NUnit.Framework.Internal.Commands.TestMethodCommand.RunTestMethod(TestExecutionContext context)
14:54:54        at NUnit.Framework.Internal.Commands.TestMethodCommand.Execute(TestExecutionContext context)
14:54:54        at NUnit.Framework.Internal.Commands.BeforeAndAfterTestCommand.<>c__DisplayClass1_0.<Execute>b__0()
14:54:54        at NUnit.Framework.Internal.Commands.DelegatingTestCommand.RunTestMethodInThreadAbortSafeZone(TestExecutionContext context, Action action)
14:54:54     
14:54:54     1)    at Apache.Ignite.Tests.Table.DataStreamerTests.TestAutoFlushFrequency(Boolean enabled) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/Table/DataStreamerTests.cs:line 103
14:54:54     
14:54:54     
14:54:54       Standard Output Messages:
14:54:54      [17:54:53] [Trace] [ClientSocket-3984] Sending request [op=SchemasGet, remoteAddress=127.0.0.1:10942, requestId=3]
14:54:54      [17:54:53] [Debug] [Table] Schema loaded [tableId=1, schemaVersion=1]
14:54:54      [17:54:53] [Trace] [ClientSocket-3985] Sending request [op=PartitionAssignmentGet, remoteAddress=127.0.0.1:10943, requestId=2]
14:54:54      [17:54:53] [Trace] [ClientSocket-3984] Sending request [op=TupleDeleteAll, remoteAddress=127.0.0.1:10942, requestId=4]
14:54:54      [17:54:53] [Trace] [ClientSocket-3985] Sending request [op=TupleUpsertAll, remoteAddress=127.0.0.1:10943, requestId=3]
14:54:54      [17:54:53] [Trace] [ClientSocket-3984] Sending request [op=TupleContainsKey, remoteAddress=127.0.0.1:10942, requestId=5]
{code}",,isapego,ptupitsyn,,,,"ptupitsyn opened a new pull request, #2189:
URL: https://github.com/apache/ignite-3/pull/2189

   (no comment)


;14/Jun/23 04:04;githubbot;600","ptupitsyn merged PR #2189:
URL: https://github.com/apache/ignite-3/pull/2189


;14/Jun/23 07:42;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jun 14 07:42:45 UTC 2023,,,,,,,,,,"0|z1ija8:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"14/Jun/23 04:21;ptupitsyn;[~isapego] please review.;;;","14/Jun/23 07:25;isapego;Looks good to me.;;;","14/Jun/23 07:42;ptupitsyn;Merged to main: fa76d246f58a1d12952f4ebda8464f9e5d08c4ac;;;",,,
Some tests failed because of AssertionError,IGNITE-19716,13539825,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,slava.koptilin,slava.koptilin,slava.koptilin,13/Jun/23 10:16,20/Jun/23 10:23,13/Jul/23 09:11,20/Jun/23 10:23,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Some tests of Ignite3 fail with the following AssertionError:
{noformat}
    at org.apache.ignite.internal.raft.RaftGroupServiceImpl.randomNode(RaftGroupServiceImpl.java:681)
    at org.apache.ignite.internal.raft.RaftGroupServiceImpl.randomNode(RaftGroupServiceImpl.java:668)
    at org.apache.ignite.internal.raft.RaftGroupServiceImpl.refreshLeader(RaftGroupServiceImpl.java:222)
    at org.apache.ignite.internal.raft.RaftGroupServiceImpl.start(RaftGroupServiceImpl.java:178)
    at org.apache.ignite.internal.raft.client.TopologyAwareRaftGroupService.start(TopologyAwareRaftGroupService.java:180)
    at org.apache.ignite.internal.raft.client.TopologyAwareRaftGroupServiceFactory.startRaftGroupService(TopologyAwareRaftGroupServiceFactory.java:71)
    at org.apache.ignite.internal.raft.Loza.startRaftGroupService(Loza.java:310)
    at org.apache.ignite.internal.table.distributed.TableManager.lambda$createTablePartitionsLocally$13(TableManager.java:834)
    at org.apache.ignite.internal.util.IgniteUtils.inBusyLock(IgniteUtils.java:892)
    at org.apache.ignite.internal.table.distributed.TableManager.lambda$createTablePartitionsLocally$14(TableManager.java:831)
    at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1072){noformat}
The proper fix will be available under IGNITE-19466. The main goal of this ticket is to try to suppress the AssertionError until IGNITE-19466 is resolved.

 ",,slava.koptilin,,,,,"sk0x50 opened a new pull request, #2212:
URL: https://github.com/apache/ignite-3/pull/2212

   https://issues.apache.org/jira/browse/IGNITE-19716


;19/Jun/23 08:31;githubbot;600","sk0x50 merged PR #2212:
URL: https://github.com/apache/ignite-3/pull/2212


;20/Jun/23 10:23;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-06-13 10:16:27.0,,,,,,,,,,"0|z1iigw:",9223372036854775807,,,maliev,,,,,,,,,,,,,,,,,,,,,,,
Thin client operations can take a long time if PA is enabled and some cluster nodes are not network reachable.,IGNITE-19715,13539812,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,PetrovMikhail,PetrovMikhail,PetrovMikhail,13/Jun/23 09:06,14/Jun/23 13:19,13/Jul/23 09:11,14/Jun/23 13:18,,,,,,,,2.16,,,,0,ise,,,"Thin client operations can take a long time if PA is enabled and some cluster nodes are not reachable over network.

Consider the following scenario:

1. The thin client have already sucessfully established connection to all configured node addresses.
2. A particular cluster node becomes unreachable over network. It can be reproduced with iptables -A INPUT -p tcp --dport for Linux.
3. The thin client periodically sends put request which is mapped by PA to the unreachable node.
4. Firstly  all attempts to perform put will lead to `ClientException: Timeout was reached before computation completed.` exception. But eventually the connection to the unreachable node will be closed by OS (see tcp_keepalive_time for Linux).

This will lead to reestablishing connection to the unreachable node during handling of the next put (see ReliableChannel.java:1012)

We currently do not set a timeout for the open connection operation (see GridNioClientConnectionMultiplexer#open, here we use Integer.MAX_VALUE for Socket#connect(java.net.SocketAddress, int))

As a result socket#connect operation (and hence put operation) hangs for a significant amount of time (it depends on OS parameters, usually it is couple of minutes). This is confusing for users because a single put may take much longer than the configured ClientConfiguration#setTimeout property.",,ignitetcbot,PetrovMikhail,,,,"petrov-mg opened a new pull request, #10770:
URL: https://github.com/apache/ignite/pull/10770

   
   
   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;13/Jun/23 14:11;githubbot;600","sonarcloud[bot] commented on PR #10770:
URL: https://github.com/apache/ignite/pull/10770#issuecomment-1589412385

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10770)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10770&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10770&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10770&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10770&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10770&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10770&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10770&metric=new_duplicated_lines_density&view=list)
   
   


;13/Jun/23 14:19;githubbot;600","sonarcloud[bot] commented on PR #10770:
URL: https://github.com/apache/ignite/pull/10770#issuecomment-1590594553

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10770)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10770&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10770&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10770&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10770&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10770&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10770&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10770&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10770&metric=new_duplicated_lines_density&view=list)
   
   


;14/Jun/23 07:04;githubbot;600","petrov-mg merged PR #10770:
URL: https://github.com/apache/ignite/pull/10770


;14/Jun/23 13:12;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Wed Jun 14 13:11:10 UTC 2023,,,,,,,,,,"0|z1iie0:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"14/Jun/23 13:11;ignitetcbot;{panel:title=Branch: [pull/10770/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10770/head] Base: [master] : No new tests found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7216123&amp;buildTypeId=IgniteTests24Java8_RunAll];;;",,,,,
AssertionError: Data nodes was not initialized in testStaleWatchEvent,IGNITE-19714,13539787,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,maliev,ptupitsyn,ptupitsyn,13/Jun/23 06:46,14/Jun/23 10:56,13/Jul/23 09:11,14/Jun/23 10:56,3.0.0-beta1,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Assertion error in *DistributionZoneManagerWatchListenerTest#testStaleWatchEvent*

{code}
DistributionZoneManagerWatchListenerTest > testStaleWatchEvent() STANDARD_ERROR
06:29:54         2023-06-13 09:29:54:748 +0300 [ERROR][%test%metastorage-watch-executor-3][WatchProcessor] Error occurred when processing a watch event
06:29:54         java.lang.AssertionError: Data nodes was not initialized.
06:29:54           at org.apache.ignite.internal.distributionzones.DistributionZoneManager$3.onUpdate(DistributionZoneManager.java:1396)
06:29:54           at org.apache.ignite.internal.metastorage.server.Watch.onUpdate(Watch.java:67)
06:29:54           at org.apache.ignite.internal.metastorage.server.WatchProcessor.lambda$notifyWatch$7(WatchProcessor.java:168)
06:29:54           at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1072)
06:29:54           at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
06:29:54           at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1705)
06:29:54           at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
06:29:54           at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
06:29:54           at java.base/java.lang.Thread.run(Thread.java:834)
06:29:54         2023-06-13 09:29:54:749 +0300 [WARNING][%test%metastorage-watch-executor-3][DistributionZoneManager] Unable to process data nodes event
06:29:54         java.lang.AssertionError: Data nodes was not initialized.
06:29:54           at org.apache.ignite.internal.distributionzones.DistributionZoneManager$3.onUpdate(DistributionZoneManager.java:1396)
06:29:54           at org.apache.ignite.internal.metastorage.server.Watch.onUpdate(Watch.java:67)
06:29:54           at org.apache.ignite.internal.metastorage.server.WatchProcessor.lambda$notifyWatch$7(WatchProcessor.java:168)
06:29:54           at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1072)
06:29:54           at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
06:29:54           at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1705)
06:29:54           at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
06:29:54           at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
06:29:54           at java.base/java.lang.Thread.run(Thread.java:834)
{code}

https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunAllTests/7290145?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandBuildChangesSection=true&expandCode+Inspection=true&expandBuildProblemsSection=true&showLog=7290143_52135_98.50904&logFilter=debug&logView=flowAware",,ptupitsyn,,,,,"alievmirza opened a new pull request, #2185:
URL: https://github.com/apache/ignite-3/pull/2185

   https://issues.apache.org/jira/browse/IGNITE-19714


;13/Jun/23 10:22;githubbot;600","ptupitsyn merged PR #2185:
URL: https://github.com/apache/ignite-3/pull/2185


;14/Jun/23 10:56;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19707,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jun 14 10:56:27 UTC 2023,,,,,,,,,,"0|z1ii8g:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"14/Jun/23 10:56;ptupitsyn;Merged to main: 7e1f785e21c9e37a60c941e75cd8a392c84b7e7c;;;",,,,,
AssertionError: Data nodes was not initialized in testScaleDownDidNotChangeDataNodesWhenTriggerKeyWasConcurrentlyChanged,IGNITE-19707,13539640,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,maliev,ptupitsyn,ptupitsyn,12/Jun/23 10:00,13/Jun/23 06:47,13/Jul/23 09:11,13/Jun/23 06:18,3.0.0-beta1,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Assertion error in *DistributionZoneManagerScaleUpTest#testScaleDownDidNotChangeDataNodesWhenTriggerKeyWasConcurrentlyChanged*

{code}
DistributionZoneManagerScaleUpTest > testScaleDownDidNotChangeDataNodesWhenTriggerKeyWasConcurrentlyChanged() STANDARD_ERROR
09:33:57         2023-06-12 12:33:57:775 +0300 [INFO][Test worker][LogicalTopologyImpl] Node added to logical topology [node=LogicalNode [nodeAttributes=EmptyMap {}, super=ClusterNode [id=1, name=node1, address=localhost:123, nodeMetadata=null]], topology=LogicalTopologySnapshot [version=1, nodes=Set12 [LogicalNode [nodeAttributes=EmptyMap {}, super=ClusterNode [id=1, name=node1, address=localhost:123, nodeMetadata=null]]]]]
09:33:57         2023-06-12 12:33:57:886 +0300 [INFO][Test worker][LogicalTopologyImpl] Node removed from logical topology [node=LogicalNode [nodeAttributes=EmptyMap {}, super=ClusterNode [id=1, name=node1, address=localhost:123, nodeMetadata=null]], topology=LogicalTopologySnapshot [version=2, nodes=SetN []]]
09:33:57         2023-06-12 12:33:57:890 +0300 [ERROR][%test%metastorage-watch-executor-3][WatchProcessor] Error occurred when processing a watch event
09:33:57         java.lang.AssertionError: Data nodes was not initialized.
09:33:57           at org.apache.ignite.internal.distributionzones.DistributionZoneManager$3.onUpdate(DistributionZoneManager.java:1396)
09:33:57           at org.apache.ignite.internal.metastorage.server.Watch.onUpdate(Watch.java:67)
09:33:57           at org.apache.ignite.internal.metastorage.server.WatchProcessor.lambda$notifyWatch$7(WatchProcessor.java:168)
09:33:57           at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1072)
09:33:57           at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
09:33:57           at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1705)
09:33:57           at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
09:33:57           at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
09:33:57           at java.base/java.lang.Thread.run(Thread.java:834)
09:33:57         2023-06-12 12:33:57:891 +0300 [WARNING][%test%metastorage-watch-executor-3][DistributionZoneManager] Unable to process data nodes event
09:33:57         java.lang.AssertionError: Data nodes was not initialized.
09:33:57           at org.apache.ignite.internal.distributionzones.DistributionZoneManager$3.onUpdate(DistributionZoneManager.java:1396)
09:33:57           at org.apache.ignite.internal.metastorage.server.Watch.onUpdate(Watch.java:67)
09:33:57           at org.apache.ignite.internal.metastorage.server.WatchProcessor.lambda$notifyWatch$7(WatchProcessor.java:168)
09:33:57           at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1072)
09:33:57           at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
09:33:57           at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1705)
09:33:57           at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
09:33:57           at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
09:33:57           at java.base/java.lang.Thread.run(Thread.java:834)
{code}

https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunUnitTests/7288160?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandBuildProblemsSection=true&expandBuildChangesSection=true&showLog=7288160_51209_86.50902&logFilter=debug&logView=flowAware",,ptupitsyn,Sergey Uttsel,,,,"alievmirza opened a new pull request, #2180:
URL: https://github.com/apache/ignite-3/pull/2180

   https://issues.apache.org/jira/browse/IGNITE-19707


;12/Jun/23 11:46;githubbot;600","ptupitsyn merged PR #2180:
URL: https://github.com/apache/ignite-3/pull/2180


;13/Jun/23 06:18;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19714,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Jun 13 06:18:46 UTC 2023,,,,,,,,,,"0|z1ihbs:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"12/Jun/23 12:52;Sergey Uttsel;[~maliev]  LGTM;;;","13/Jun/23 06:18;ptupitsyn;Merged to main: 17d53e99cfe708375c8f2fcfb164a928a895a619;;;",,,,
RocksDB scan time spikes up at some moments,IGNITE-19700,13539458,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,ibessonov,Denis Chudov,Denis Chudov,09/Jun/23 16:27,20/Jun/23 10:51,13/Jul/23 09:11,20/Jun/23 10:51,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Motivation:

We have ItSqlLogicTest which performs user load with creation and desctruction of the tables, and need to have background load on meta storage to be able to refresh leases, but seems that this additional load causes weird behavior of meta storage's underlying rocksdb storage, which leads to timeouts on DDL operations. Actually, there are too long range scans in rocksdb storage, which don't correlate with number of entries (including tombstones) and amount of lease data written in background.

It can be reproduced on RocksDBKeyValueStorage.

Prerequisites:

RocksDBKeyValueStorage filled with 1000 random keys and values, 5000 random tombstones, 100 values with prefix ""tables"", 5000 tombstones with prefix ""tables"".

Load profile:
 * Thread1: performs storage.invoke with the same key and value of size 500k bytes, once per 100 ms.
 * Thread2: performs storage.range for prefix ""tables"" once per 200 ms, collects all entries from cursor.
 * Thread3: performs storage.get with random key once per 3 ms.

Each operation performed by Thread2 mostly takes 20-50 ms, but sometimes ({*}after 5+ minutes of test running{*}) this time spikes up to hundreds of milliseconds (or even seconds): and this lasts for some time (I observed up to half of a minute), after that the time returns to normal values:
{code:java}
2023-06-09 17:09:05:971 +0300 [INFO][Thread-5][RocksDBLoadTest] time 31, size 100
2023-06-09 17:09:06:223 +0300 [INFO][Thread-5][RocksDBLoadTest] time 50, size 100
2023-06-09 17:09:06:471 +0300 [INFO][Thread-5][RocksDBLoadTest] time 47, size 100
2023-06-09 17:09:06:715 +0300 [INFO][Thread-5][RocksDBLoadTest] time 44, size 100
2023-06-09 17:09:07:483 +0300 [INFO][Thread-5][RocksDBLoadTest] time 566, size 100
2023-06-09 17:09:08:228 +0300 [INFO][Thread-5][RocksDBLoadTest] time 543, size 100
2023-06-09 17:09:09:000 +0300 [INFO][Thread-5][RocksDBLoadTest] time 571, size 100
2023-06-09 17:09:09:774 +0300 [INFO][Thread-5][RocksDBLoadTest] time 572, size 100
2023-06-09 17:09:10:570 +0300 [INFO][Thread-5][RocksDBLoadTest] time 596, size 100
2023-06-09 17:09:11:323 +0300 [INFO][Thread-5][RocksDBLoadTest] time 552, size 100
2023-06-09 17:09:12:103 +0300 [INFO][Thread-5][RocksDBLoadTest] time 579, size 100
2023-06-09 17:09:12:861 +0300 [INFO][Thread-5][RocksDBLoadTest] time 556, size 100{code}
On teamcity it was even over 6 seconds:

[https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunUnitTests/7283421?buildTab=log&focusLine=46540&expandAll=true&logFilter=debug&logView=flowAware]

 

Reproducer:
{code:java}
package org.apache.ignite.internal.metastorage;

import static org.apache.ignite.internal.metastorage.dsl.Conditions.notExists;
import static org.apache.ignite.internal.metastorage.dsl.Conditions.or;
import static org.apache.ignite.internal.metastorage.dsl.Conditions.value;
import static org.apache.ignite.internal.metastorage.dsl.Operations.noop;
import static org.apache.ignite.internal.metastorage.dsl.Operations.put;
import static org.apache.ignite.internal.metastorage.server.Value.TOMBSTONE;

import java.io.ObjectStreamException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Logger;
import org.apache.ignite.internal.hlc.HybridClock;
import org.apache.ignite.internal.hlc.HybridClockImpl;
import org.apache.ignite.internal.logger.IgniteLogger;
import org.apache.ignite.internal.logger.Loggers;
import org.apache.ignite.internal.metastorage.dsl.CompoundCondition;
import org.apache.ignite.internal.metastorage.dsl.ConditionType;
import org.apache.ignite.internal.metastorage.dsl.SimpleCondition;
import org.apache.ignite.internal.metastorage.server.AndCondition;
import org.apache.ignite.internal.metastorage.server.Condition;
import org.apache.ignite.internal.metastorage.server.ExistenceCondition;
import org.apache.ignite.internal.metastorage.server.OrCondition;
import org.apache.ignite.internal.metastorage.server.RevisionCondition;
import org.apache.ignite.internal.metastorage.server.TombstoneCondition;
import org.apache.ignite.internal.metastorage.server.ValueCondition;
import org.apache.ignite.internal.metastorage.server.persistence.RocksDbKeyValueStorage;
import org.apache.ignite.internal.testframework.WorkDirectory;
import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
import org.apache.ignite.internal.util.Cursor;
import org.apache.ignite.lang.ByteArray;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

@ExtendWith(WorkDirectoryExtension.class)
public class RocksDBLoadTest {
    private static final IgniteLogger LOG = Loggers.forClass(RocksDBLoadTest.class);

    private byte[] randomBytes() {
        return UUID.randomUUID().toString().getBytes(StandardCharsets.UTF_8);
    }

    private byte[] randomBytes(String prefix) {
        return (prefix + UUID.randomUUID()).getBytes(StandardCharsets.UTF_8);
    }

    /**
     * Increments the last character of the given string.
     */
    private static String incrementLastChar(String str) {
        char lastChar = str.charAt(str.length() - 1);

        return str.substring(0, str.length() - 1) + (char) (lastChar + 1);
    }


    @Test
    public void test(@WorkDirectory Path path) throws InterruptedException {
        System.out.println(""start"");
        HybridClock clock = new HybridClockImpl();
        RocksDbKeyValueStorage storage = new RocksDbKeyValueStorage(""asd"", path.resolve(""rocksdbtest""));
        storage.start();
        for (int i = 0; i < 1000; i++) {
            storage.put(randomBytes(), randomBytes(), clock.now());
        }
        for (int i = 0; i < 5000; i++) {
            storage.put(randomBytes(), TOMBSTONE, clock.now());
        }
        for (int i = 0; i < 100; i++) {
            storage.put(randomBytes(""tables""), randomBytes(), clock.now());
        }
        for (int i = 0; i < 5000; i++) {
            storage.put(randomBytes(""tables""), TOMBSTONE, clock.now());
        }

        ByteArray leaseKey = ByteArray.fromString(""placementdriver.leases"");
        AtomicBoolean leasesStopped = new AtomicBoolean();
        AtomicBoolean rangeStopped = new AtomicBoolean();
        Thread leases = new Thread(() -> {
            byte[] leaseRaw = new byte[500_000];
            byte a = 0;
            while (!leasesStopped.get()) {
                byte[] renewedLease = new byte[500_000];
                renewedLease[0] = ++a;
                storage.invoke(
                        toCondition(or(notExists(leaseKey), value(leaseKey).eq(leaseRaw))),
                        List.of(put(leaseKey, renewedLease)),
                        List.of(noop()),
                        clock.now()
                );
                leaseRaw = renewedLease;

                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        });
        leases.start();

        Thread range = new Thread(() -> {
            while (!rangeStopped.get()) {
                long start = System.currentTimeMillis();
                Cursor<Entry> cursor =
                        storage.range(""tables"".getBytes(StandardCharsets.UTF_8), incrementLastChar(""tables"").getBytes(StandardCharsets.UTF_8));
                List<Object> list = new ArrayList<>();
                for(Entry e : cursor) {
                    if (!e.tombstone()) {
                        list.add(e.value());
                    }
                }
                LOG.info(""time "" + (System.currentTimeMillis() - start) + "", size "" + list.size());
                cursor.close();

                try {
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        });
        range.start();

        for (int i = 0; i < 180_000; i++) {
            storage.get(randomBytes());
            Thread.sleep(3);
        }

        leasesStopped.set(true);
        rangeStopped.set(true);
        leases.join();
        range.join();
    }



    private static Condition toCondition(org.apache.ignite.internal.metastorage.dsl.Condition condition) {
        if (condition instanceof SimpleCondition.ValueCondition) {
            var valueCondition = (SimpleCondition.ValueCondition) condition;

            return new ValueCondition(
                    toValueConditionType(valueCondition.type()),
                    valueCondition.key(),
                    valueCondition.value()
            );
        } else if (condition instanceof SimpleCondition.RevisionCondition) {
            var revisionCondition = (SimpleCondition.RevisionCondition) condition;

            return new RevisionCondition(
                    toRevisionConditionType(revisionCondition.type()),
                    revisionCondition.key(),
                    revisionCondition.revision()
            );
        } else if (condition instanceof SimpleCondition) {
            var simpleCondition = (SimpleCondition) condition;

            switch (simpleCondition.type()) {
                case KEY_EXISTS:
                    return new ExistenceCondition(ExistenceCondition.Type.EXISTS, simpleCondition.key());

                case KEY_NOT_EXISTS:
                    return new ExistenceCondition(ExistenceCondition.Type.NOT_EXISTS, simpleCondition.key());

                case TOMBSTONE:
                    return new TombstoneCondition(simpleCondition.key());

                default:
                    throw new IllegalArgumentException(""Unexpected simple condition type "" + simpleCondition.type());
            }
        } else if (condition instanceof CompoundCondition) {
            CompoundCondition compoundCondition = (CompoundCondition) condition;

            Condition leftCondition = toCondition(compoundCondition.leftCondition());
            Condition rightCondition = toCondition(compoundCondition.rightCondition());

            switch (compoundCondition.type()) {
                case AND:
                    return new AndCondition(leftCondition, rightCondition);

                case OR:
                    return new OrCondition(leftCondition, rightCondition);

                default:
                    throw new IllegalArgumentException(""Unexpected compound condition type "" + compoundCondition.type());
            }
        } else {
            throw new IllegalArgumentException(""Unknown condition "" + condition);
        }
    }

    private static ValueCondition.Type toValueConditionType(ConditionType type) {
        switch (type) {
            case VAL_EQUAL:
                return ValueCondition.Type.EQUAL;
            case VAL_NOT_EQUAL:
                return ValueCondition.Type.NOT_EQUAL;
            case VAL_GREATER:
                return ValueCondition.Type.GREATER;
            case VAL_GREATER_OR_EQUAL:
                return ValueCondition.Type.GREATER_OR_EQUAL;
            case VAL_LESS:
                return ValueCondition.Type.LESS;
            case VAL_LESS_OR_EQUAL:
                return ValueCondition.Type.LESS_OR_EQUAL;
            default:
                throw new IllegalArgumentException(""Unexpected value condition type "" + type);
        }
    }

    private static RevisionCondition.Type toRevisionConditionType(ConditionType type) {
        switch (type) {
            case REV_EQUAL:
                return RevisionCondition.Type.EQUAL;
            case REV_NOT_EQUAL:
                return RevisionCondition.Type.NOT_EQUAL;
            case REV_GREATER:
                return RevisionCondition.Type.GREATER;
            case REV_GREATER_OR_EQUAL:
                return RevisionCondition.Type.GREATER_OR_EQUAL;
            case REV_LESS:
                return RevisionCondition.Type.LESS;
            case REV_LESS_OR_EQUAL:
                return RevisionCondition.Type.LESS_OR_EQUAL;
            default:
                throw new IllegalArgumentException(""Unexpected revision condition type "" + type);
        }
    }
} {code}",,Denis Chudov,ibessonov,rpuch,,,"ibessonov opened a new pull request, #2218:
URL: https://github.com/apache/ignite-3/pull/2218

   https://issues.apache.org/jira/browse/IGNITE-19700


;19/Jun/23 15:28;githubbot;600","rpuch commented on code in PR #2218:
URL: https://github.com/apache/ignite-3/pull/2218#discussion_r1234918926


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -427,7 +436,7 @@ private void updateKeysIndex(WriteBatch batch, byte[] key, long curRev) {
      * @throws RocksDBException If failed.
      */
     private void fillAndWriteBatch(WriteBatch batch, long newRev, long newCntr, @Nullable HybridTimestamp ts) throws RocksDBException {
-        try (WriteOptions opts = new WriteOptions()) {
+        try (WriteOptions opts = new WriteOptions().setDisableWAL(true)) {

Review Comment:
   Could you please leave a comment on why we need (and can) disable the WAL to make it explicit?



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -239,20 +243,25 @@ public void start() {
     }
 
     private static List<ColumnFamilyDescriptor> cfDescriptors() {
-        Options dataOptions = new Options().setCreateIfMissing(true)
+        Options sharedOptions = new Options()
+                .setCreateIfMissing(true)
+                .setNumLevels(4)

Review Comment:
   I think it will be useful to comment the options that were chosen and write a justification for the specific options and values chosen; otherwise, in the future, it will become difficult to remember why the configuration is as it is now.
   
   I'm not sure whether we need to make these configurable by the user. Maybe we should leave the values hard-coded for now as they seem to be very specific to our Meta-Storage scenarios (and the load profile will not necessarily change from cluster to cluster).



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -239,20 +243,25 @@ public void start() {
     }
 
     private static List<ColumnFamilyDescriptor> cfDescriptors() {
-        Options dataOptions = new Options().setCreateIfMissing(true)
+        Options sharedOptions = new Options()

Review Comment:
   BasicOptions/BaseOptions?



;20/Jun/23 08:29;githubbot;600","ibessonov commented on code in PR #2218:
URL: https://github.com/apache/ignite-3/pull/2218#discussion_r1234962972


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -427,7 +436,7 @@ private void updateKeysIndex(WriteBatch batch, byte[] key, long curRev) {
      * @throws RocksDBException If failed.
      */
     private void fillAndWriteBatch(WriteBatch batch, long newRev, long newCntr, @Nullable HybridTimestamp ts) throws RocksDBException {
-        try (WriteOptions opts = new WriteOptions()) {
+        try (WriteOptions opts = new WriteOptions().setDisableWAL(true)) {

Review Comment:
   Sure



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -239,20 +243,25 @@ public void start() {
     }
 
     private static List<ColumnFamilyDescriptor> cfDescriptors() {
-        Options dataOptions = new Options().setCreateIfMissing(true)
+        Options sharedOptions = new Options()

Review Comment:
   ""baseOptions"", thank you



;20/Jun/23 08:59;githubbot;600","ibessonov commented on code in PR #2218:
URL: https://github.com/apache/ignite-3/pull/2218#discussion_r1234971871


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -239,20 +243,25 @@ public void start() {
     }
 
     private static List<ColumnFamilyDescriptor> cfDescriptors() {
-        Options dataOptions = new Options().setCreateIfMissing(true)
+        Options sharedOptions = new Options()
+                .setCreateIfMissing(true)
+                .setNumLevels(4)

Review Comment:
   Done



;20/Jun/23 09:07;githubbot;600","ibessonov merged PR #2218:
URL: https://github.com/apache/ignite-3/pull/2218


;20/Jun/23 10:51;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,,IGNITE-19578,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Jun 20 10:45:08 UTC 2023,,,,,,,,,,"0|z1ig7c:",9223372036854775807,,,rpuch,,,,,,,,,,,,,,,,,,"20/Jun/23 07:03;ibessonov;Tests on TC show, that with settings from the PR, maximum time of the scan is decreased below 60ms, which is about the best I could do:
[https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunAllTests/7304902?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandCode+Inspection=true&expandBuildProblemsSection=true]

The idea was to reduce disk IO. Poor scan time was due to excessive random reads.

Introducing bloom filters and page cache resolved the issue, in the provided test at least.

Target number of LSM levels is also decreased, this setting proved to be quite useful;;;","20/Jun/23 10:45;rpuch;The patch looks good to me;;;",,,,
getAll does not preserve order and does not return nulls for missing keys,IGNITE-19693,13539400,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,ktkalenko@gridgain.com,ptupitsyn,ptupitsyn,09/Jun/23 09:30,26/Jun/23 07:32,13/Jul/23 09:11,26/Jun/23 07:32,3.0.0-beta1,,,,,,,3.0.0-beta2,cache,,,0,ignite-3,,,"* getAll does not preserve element order.
* getAll does not return nulls for non-existent records.

This is specified in Javadoc  in [RecordView|https://github.com/apache/ignite-3/blob/0c68cbe3f016e508bd9d53ce5320c88acba1acff/modules/api/src/main/java/org/apache/ignite/table/RecordView.java#L56-L60]:
{code}
Records with all columns filled from the table. The order of collection elements is guaranteed to be the same as the order of {@code keyRecs}. If a record does not exist, the element at the corresponding index of the resulting collection is null.
{code}

Without those properties, *getAll* is not very useful: it is hard to correspond the results with the original collection.

h2. Reproducer

Add the following code to *ItTableApiContractTest*:
{code:java}
    @Test
    public void testGetAll() {
        RecordView<Tuple> tbl = ignite.tables().table(TABLE_NAME).recordView();
        // recordView.insert(tx, Tuple.create().set(""name"", ""k1"").set(""balance"", 1));

        var recs = IntStream.range(1, 50)
                .mapToObj(i -> Tuple.create().set(""name"", ""id_"" + i * 2).set(""balance"", i * 2))
                .collect(Collectors.toList());

        tbl.upsertAll(null, recs);

        var keys = IntStream.range(1, 100)
                .mapToObj(i -> Tuple.create().set(""name"", ""id_"" + i))
                .collect(Collectors.toList());

        List<Tuple> res = (List<Tuple>) tbl.getAll(null, keys);

        assertNull(res.get(0));
        assertEquals(2L, res.get(1).longValue(0));
        assertEquals(100, res.size());
    }
{code}

Tuples are returned in random order, and only 50 of them, not 100",,ptupitsyn,rpuch,,,,"tkalkirill opened a new pull request, #2233:
URL: https://github.com/apache/ignite-3/pull/2233

   https://issues.apache.org/jira/browse/IGNITE-19693


;21/Jun/23 18:24;githubbot;600","rpuch commented on code in PR #2233:
URL: https://github.com/apache/ignite-3/pull/2233#discussion_r1241713092


##########
modules/api/src/main/java/org/apache/ignite/table/RecordView.java:
##########
@@ -55,18 +56,20 @@ public interface RecordView<R> extends DataStreamerTarget<R> {
      * @param keyRecs Records with key columns set. The records cannot be {@code null}.
      * @return Records with all columns filled from the table. The order of collection elements is
      *     guaranteed to be the same as the order of {@code keyRecs}. If a record does not exist, the
-     *     element at the corresponding index of the resulting collection is null.
+     *     element at the corresponding index of the resulting collection is {@code null}.
      */
-    Collection<R> getAll(@Nullable Transaction tx, @NotNull Collection<R> keyRecs);
+    List<R> getAll(@Nullable Transaction tx, Collection<R> keyRecs);
 
     /**
      * Asynchronously gets records from a table.
      *
      * @param tx      Transaction or {@code null} to auto-commit.
      * @param keyRecs Records with the key columns set. The records cannot be {@code null}.
-     * @return Future that represents the pending completion of the operation.
+     * @return Future that will return records with all columns filled from the table. The order of collection elements is
+     *      guaranteed to be the same as the order of {@code keyRecs}. If a record does not exist, the
+     *      element at the corresponding index of the resulting collection is {@code null}.
      */
-    @NotNull CompletableFuture<Collection<R>> getAllAsync(@Nullable Transaction tx, @NotNull Collection<R> keyRecs);
+    CompletableFuture<List<R>> getAllAsync(@Nullable Transaction tx, Collection<R> keyRecs);

Review Comment:
   Same question about the type change



##########
modules/api/src/main/java/org/apache/ignite/table/RecordView.java:
##########
@@ -55,18 +56,20 @@ public interface RecordView<R> extends DataStreamerTarget<R> {
      * @param keyRecs Records with key columns set. The records cannot be {@code null}.
      * @return Records with all columns filled from the table. The order of collection elements is
      *     guaranteed to be the same as the order of {@code keyRecs}. If a record does not exist, the
-     *     element at the corresponding index of the resulting collection is null.
+     *     element at the corresponding index of the resulting collection is {@code null}.
      */
-    Collection<R> getAll(@Nullable Transaction tx, @NotNull Collection<R> keyRecs);
+    List<R> getAll(@Nullable Transaction tx, Collection<R> keyRecs);

Review Comment:
   Wny is type change needed here? The whole API seems to consistently use `Collection`. Even if we return `Collection`, we may guarantee the order internally by actually returning a `List` or something else, if we want.



##########
modules/client/src/main/java/org/apache/ignite/internal/client/table/ClientRecordBinaryView.java:
##########
@@ -76,27 +78,26 @@ public Tuple get(@Nullable Transaction tx, @NotNull Tuple keyRec) {
                 ClientTupleSerializer.getPartitionAwarenessProvider(tx, keyRec));
     }
 
-    /** {@inheritDoc} */
     @Override
-    public Collection<Tuple> getAll(@Nullable Transaction tx, @NotNull Collection<Tuple> keyRecs) {
+    public List<Tuple> getAll(@Nullable Transaction tx, Collection<Tuple> keyRecs) {

Review Comment:
   List?



##########
modules/client/src/main/java/org/apache/ignite/internal/client/table/ClientRecordView.java:
##########
@@ -76,27 +78,26 @@ public R get(@Nullable Transaction tx, @NotNull R keyRec) {
                 ClientTupleSerializer.getPartitionAwarenessProvider(tx, ser.mapper(), keyRec));
     }
 
-    /** {@inheritDoc} */
     @Override
-    public Collection<R> getAll(@Nullable Transaction tx, @NotNull Collection<R> keyRecs) {
+    public List<R> getAll(@Nullable Transaction tx, Collection<R> keyRecs) {

Review Comment:
   List?



##########
modules/client/src/main/java/org/apache/ignite/internal/client/table/ClientKeyValueView.java:
##########
@@ -464,11 +464,12 @@ private HashMap<K, V> readGetAllResponse(ClientSchema schema, ClientMessageUnpac
 
         try {
             for (int i = 0; i < cnt; i++) {
-                in.unpackBoolean(); // TODO: Optimize (IGNITE-16022).
-
-                var tupleReader = new BinaryTupleReader(schema.columns().length, in.readBinaryUnsafe());
-                var reader = new ClientMarshallerReader(tupleReader);
-                res.put((K) keyMarsh.readObject(reader, null), (V) valMarsh.readObject(reader, null));
+                // TODO: Optimize (IGNITE-16022).
+                if (in.unpackBoolean()) {

Review Comment:
   Does this boolean mean that the following value is not null?



;26/Jun/23 07:20;githubbot;600","tkalkirill commented on code in PR #2233:
URL: https://github.com/apache/ignite-3/pull/2233#discussion_r1241745285


##########
modules/client/src/main/java/org/apache/ignite/internal/client/table/ClientKeyValueView.java:
##########
@@ -464,11 +464,12 @@ private HashMap<K, V> readGetAllResponse(ClientSchema schema, ClientMessageUnpac
 
         try {
             for (int i = 0; i < cnt; i++) {
-                in.unpackBoolean(); // TODO: Optimize (IGNITE-16022).
-
-                var tupleReader = new BinaryTupleReader(schema.columns().length, in.readBinaryUnsafe());
-                var reader = new ClientMarshallerReader(tupleReader);
-                res.put((K) keyMarsh.readObject(reader, null), (V) valMarsh.readObject(reader, null));
+                // TODO: Optimize (IGNITE-16022).
+                if (in.unpackBoolean()) {

Review Comment:
   I think yes, this part was done by @ptupitsyn 



;26/Jun/23 07:28;githubbot;600","tkalkirill merged PR #2233:
URL: https://github.com/apache/ignite-3/pull/2233


;26/Jun/23 07:32;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,IGNITE-16022,,,,,,,,,,,,,,IGNITE-16004,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,Java,Mon Jun 26 07:32:06 UTC 2023,,,,,,,,,,"0|z1ifug:",9223372036854775807,,,rpuch,,,,,,,,,,,,,,,,,,"26/Jun/23 07:32;rpuch;The patch looks good to me;;;",,,,,
NPE in ItNodeTest#testChangePeersStepsDownInJointConsensus,IGNITE-19688,13539281,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,maliev,jooger,jooger,08/Jun/23 13:29,10/Jul/23 13:42,13/Jul/23 09:11,10/Jul/23 13:42,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"org.apache.ignite.raft.jraft.core.ItNodeTest#testChangePeersStepsDownInJointConsensus
{noformat}
java.lang.NullPointerException  
 at org.apache.ignite.raft.jraft.core.ItNodeTest.testChangePeersStepsDownInJointConsensus(ItNodeTest.java:3385)  
 at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  
 at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
 at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)  
 at java.base/java.lang.reflect.Method.invoke(Method.java:566) 
{noformat}

*Motivation*
The root cause of the issue is the method of getting leader (_TestCluster#getLeader_) might return _null_ even if the test waits a leader before (_TestCluster#waitLeader_).

*Implementation Notes*
Create a new method that returns a leader just after it has waited it (_TestCluster#waitAndGetLeader_).

*Definition of Done*
Verify all places where method of waiting leader is used and replace it to new one in that case where getting leader is not expected to receive _null_.

",,jooger,maliev,v.pyatkov,,,"alievmirza opened a new pull request, #2259:
URL: https://github.com/apache/ignite-3/pull/2259

   https://issues.apache.org/jira/browse/IGNITE-19688


;27/Jun/23 07:46;githubbot;600","vldpyatkov commented on code in PR #2259:
URL: https://github.com/apache/ignite-3/pull/2259#discussion_r1245270944


##########
modules/raft/src/testFixtures/java/org/apache/ignite/raft/jraft/core/TestCluster.java:
##########
@@ -408,6 +408,26 @@ public void waitLeader() throws InterruptedException {
         }
     }
 
+    /**
+     * Wait until a leader is elected.
+     * @throws InterruptedException
+     * @return Leader
+     */
+    public Node waitAndGetLeader() throws InterruptedException {
+        Node node;
+
+        while (true) {

Review Comment:
   Do you sure about need an infinity loop here?



;28/Jun/23 14:06;githubbot;600","alievmirza commented on code in PR #2259:
URL: https://github.com/apache/ignite-3/pull/2259#discussion_r1257863933


##########
modules/raft/src/testFixtures/java/org/apache/ignite/raft/jraft/core/TestCluster.java:
##########
@@ -408,6 +408,26 @@ public void waitLeader() throws InterruptedException {
         }
     }
 
+    /**
+     * Wait until a leader is elected.
+     * @throws InterruptedException
+     * @return Leader
+     */
+    public Node waitAndGetLeader() throws InterruptedException {
+        Node node;
+
+        while (true) {

Review Comment:
   changed to an assertion



;10/Jul/23 07:55;githubbot;600","vldpyatkov merged PR #2259:
URL: https://github.com/apache/ignite-3/pull/2259


;10/Jul/23 12:30;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Mon Jul 10 12:31:08 UTC 2023,,,,,,,,,,"0|z1if40:",9223372036854775807,,,vpyatkov,,,,,,,,,,,,,,,,,,"27/Jun/23 19:00;maliev;[~vpyatkov] Could you please take a look? ;;;","28/Jun/23 15:35;v.pyatkov;Except the comment, I left in PR I think, waitLeadet method is completely replaced and could be removed.;;;","10/Jul/23 12:29;v.pyatkov;LGTM;;;","10/Jul/23 12:31;v.pyatkov;Merged d13553ebdaa80ab440be487ff882e279bed37c19
[~maliev] thank you for the contribution.;;;",,
Provide an ability to restart StandaloneMetaStorageManager with the recovered data,IGNITE-19674,13539095,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,maliev,maliev,maliev,07/Jun/23 13:40,08/Jun/23 09:37,13/Jul/23 09:11,08/Jun/23 09:37,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Currently if we use {{StandaloneMetaStorageManager#create()}} with {{RocksDbKeyValueStorage}} in a scenarios when a node is restarted, data in a metastorage is not recovering, because the logic in {{RocksDbKeyValueStorage#start}} is the following: when we restart {{RocksDbKeyValueStorage}}, we call {{recreateDb}} which deletes existing data, recovery is relying on the raft's snapshot and log playback.

When we use {{StandaloneMetaStorageManager}} we mock raft layer, meaning that we do not restore metastorage using raft's snapshot.

I propose to create a test version of {{RocksDbKeyValueStorage}} so it won't delete data when it is used in tests scenarios.",,maliev,,,,,"alievmirza opened a new pull request, #2165:
URL: https://github.com/apache/ignite-3/pull/2165

   https://issues.apache.org/jira/browse/IGNITE-19674


;07/Jun/23 18:09;githubbot;600","ibessonov commented on code in PR #2165:
URL: https://github.com/apache/ignite-3/pull/2165#discussion_r1222555363


##########
modules/metastorage/src/testFixtures/java/org/apache/ignite/internal/metastorage/server/TestRocksDbKeyValueStorage.java:
##########
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.server;
+
+import static org.apache.ignite.internal.util.ByteUtils.bytesToLong;
+import static org.apache.ignite.lang.ErrorGroups.MetaStorage.STARTING_STORAGE_ERR;
+
+import java.nio.file.Path;
+import org.apache.ignite.internal.metastorage.exceptions.MetaStorageException;
+import org.apache.ignite.internal.metastorage.server.persistence.RocksDbKeyValueStorage;
+import org.jetbrains.annotations.TestOnly;
+import org.rocksdb.RocksDBException;
+
+/**
+ * Test version of {@link RocksDbKeyValueStorage}, but behavior on a start differs. In this version, storage is not destroyed on
+ * a restart, so it can be used in {@link org.apache.ignite.internal.metastorage.impl.StandaloneMetaStorageManager}, where raft
+ * layer is mocked and there are no raft's snapshot installing and log playback.
+ */
+@TestOnly
+public class TestRocksDbKeyValueStorage extends RocksDbKeyValueStorage {
+    /**
+     * Constructor.
+     *
+     * @param nodeName Node name.
+     * @param dbPath RocksDB path.
+     */
+    public TestRocksDbKeyValueStorage(String nodeName, Path dbPath) {
+        super(nodeName, dbPath);
+    }
+
+    @Override
+    public void start() {
+        try {
+            createDb();
+
+            byte[] revision = getData().get(REVISION_KEY);
+
+            if (revision != null) {
+                setRev(bytesToLong(revision));
+            }

Review Comment:
   You could move this to parent class and simply override ""destroyRocksDb"" with empty body. This way it would take less code and would be less confusing when it comes to abundance of ""TestOnly"" methods



;08/Jun/23 07:11;githubbot;600","ibessonov commented on code in PR #2165:
URL: https://github.com/apache/ignite-3/pull/2165#discussion_r1222600477


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/persistence/RocksDbKeyValueStorage.java:
##########
@@ -116,7 +117,7 @@ public class RocksDbKeyValueStorage implements KeyValueStorage {
     private static final long SYSTEM_REVISION_MARKER_VALUE = 0;
 
     /** Revision key. */
-    private static final byte[] REVISION_KEY = keyToRocksKey(
+    protected static final byte[] REVISION_KEY = keyToRocksKey(

Review Comment:
   This no longer needs to be protected



;08/Jun/23 07:57;githubbot;600","ibessonov merged PR #2165:
URL: https://github.com/apache/ignite-3/pull/2165


;08/Jun/23 09:37;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-06-07 13:40:04.0,,,,,,,,,,"0|z1idyo:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
Support boxed long in direct marshaller,IGNITE-19669,13539027,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,,sdanilov,sdanilov,07/Jun/23 08:50,07/Jun/23 08:55,13/Jul/23 09:11,07/Jun/23 08:55,,,,,,,,,,,,0,ignite-3,,,,,sdanilov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19452,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,2023-06-07 08:50:09.0,,,,,,,,,,"0|z1idjk:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
Sql. testLengthExpressionWithDynamicParameter failed after check fix,IGNITE-19668,13539016,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,zstan,zstan,zstan,07/Jun/23 07:35,28/Jun/23 13:10,13/Jul/23 09:11,28/Jun/23 13:10,,,,,,,,3.0.0-beta2,sql,,,0,calcite3-required,ignite-3,,"ItVarBinaryExpressionTest#testLengthExpressionWithDynamicParameter no *.check()* is called, after fix it become broken.

ItVarBinaryExpressionTest#testLengthExpression need to be fixed too.",,korlov,zstan,,,,"zstan opened a new pull request, #2223:
URL: https://github.com/apache/ignite-3/pull/2223

   (no comment)


;20/Jun/23 07:32;githubbot;600","zstan commented on PR #2223:
URL: https://github.com/apache/ignite-3/pull/2223#issuecomment-1598372074

   @lowka can u make a review plz ?


;20/Jun/23 08:48;githubbot;600","korlov42 commented on code in PR #2223:
URL: https://github.com/apache/ignite-3/pull/2223#discussion_r1238013978


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/datatypes/varbinary/ItVarBinaryExpressionTest.java:
##########
@@ -67,24 +67,32 @@ public void testPositionExpressionWithDynamicParameter() {
                 .check();
     }
 
-    /** {@code LENGTH} expression. */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19668"")
+    /** {@code LENGTH} and {@code OCTET_LENGTH} expression. */
     @Test
     public void testLengthExpression() {
         checkQuery(""SELECT LENGTH(x'010203')"")
-                .withParams(varBinary(new byte[]{2}))
+                .returns(3).check();
+
+        checkQuery(""SELECT OCTET_LENGTH(x'010203')"")
                 .returns(3).check();
     }
 
-    /** {@code LENGTH} expression. */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19668"")
+    /** {@code LENGTH} and {@code OCTET_LENGTH} expression with dynamic params. */
     @Test
     public void testLengthExpressionWithDynamicParameter() {
-        checkQuery(""SELECT LENGTH(?)"")
+        checkQuery(""SELECT OCTET_LENGTH(?)"")
+                .withParams(varBinary(new byte[]{1, 2, 3}))
+                .returns(3).check();
+
+        checkQuery(""SELECT OCTET_LENGTH(?)"")
+                .withParams(varBinary(new byte[0]))
+                .returns(0).check();
+
+        checkQuery(""SELECT LENGTH(CAST (? AS VARCHAR))"")
                 .withParams(varBinary(new byte[]{1, 2, 3}))
                 .returns(3).check();
 
-        checkQuery(""SELECT LENGTH(?)"")
+        checkQuery(""SELECT LENGTH(CAST (? AS VARCHAR))"")

Review Comment:
   why do you put CAST operator for last two cases?



;22/Jun/23 05:32;githubbot;600","zstan commented on code in PR #2223:
URL: https://github.com/apache/ignite-3/pull/2223#discussion_r1238120187


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/datatypes/varbinary/ItVarBinaryExpressionTest.java:
##########
@@ -67,24 +67,32 @@ public void testPositionExpressionWithDynamicParameter() {
                 .check();
     }
 
-    /** {@code LENGTH} expression. */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19668"")
+    /** {@code LENGTH} and {@code OCTET_LENGTH} expression. */
     @Test
     public void testLengthExpression() {
         checkQuery(""SELECT LENGTH(x'010203')"")
-                .withParams(varBinary(new byte[]{2}))
+                .returns(3).check();
+
+        checkQuery(""SELECT OCTET_LENGTH(x'010203')"")
                 .returns(3).check();
     }
 
-    /** {@code LENGTH} expression. */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19668"")
+    /** {@code LENGTH} and {@code OCTET_LENGTH} expression with dynamic params. */
     @Test
     public void testLengthExpressionWithDynamicParameter() {
-        checkQuery(""SELECT LENGTH(?)"")
+        checkQuery(""SELECT OCTET_LENGTH(?)"")
+                .withParams(varBinary(new byte[]{1, 2, 3}))
+                .returns(3).check();
+
+        checkQuery(""SELECT OCTET_LENGTH(?)"")
+                .withParams(varBinary(new byte[0]))
+                .returns(0).check();
+
+        checkQuery(""SELECT LENGTH(CAST (? AS VARCHAR))"")
                 .withParams(varBinary(new byte[]{1, 2, 3}))
                 .returns(3).check();
 
-        checkQuery(""SELECT LENGTH(?)"")
+        checkQuery(""SELECT LENGTH(CAST (? AS VARCHAR))"")

Review Comment:
   just to make sure that it works with cast too



;22/Jun/23 07:31;githubbot;600","korlov42 commented on code in PR #2223:
URL: https://github.com/apache/ignite-3/pull/2223#discussion_r1238165703


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/datatypes/varbinary/ItVarBinaryExpressionTest.java:
##########
@@ -67,24 +67,32 @@ public void testPositionExpressionWithDynamicParameter() {
                 .check();
     }
 
-    /** {@code LENGTH} expression. */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19668"")
+    /** {@code LENGTH} and {@code OCTET_LENGTH} expression. */
     @Test
     public void testLengthExpression() {
         checkQuery(""SELECT LENGTH(x'010203')"")
-                .withParams(varBinary(new byte[]{2}))
+                .returns(3).check();
+
+        checkQuery(""SELECT OCTET_LENGTH(x'010203')"")
                 .returns(3).check();
     }
 
-    /** {@code LENGTH} expression. */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19668"")
+    /** {@code LENGTH} and {@code OCTET_LENGTH} expression with dynamic params. */
     @Test
     public void testLengthExpressionWithDynamicParameter() {
-        checkQuery(""SELECT LENGTH(?)"")
+        checkQuery(""SELECT OCTET_LENGTH(?)"")
+                .withParams(varBinary(new byte[]{1, 2, 3}))
+                .returns(3).check();
+
+        checkQuery(""SELECT OCTET_LENGTH(?)"")
+                .withParams(varBinary(new byte[0]))
+                .returns(0).check();
+
+        checkQuery(""SELECT LENGTH(CAST (? AS VARCHAR))"")
                 .withParams(varBinary(new byte[]{1, 2, 3}))
                 .returns(3).check();
 
-        checkQuery(""SELECT LENGTH(?)"")
+        checkQuery(""SELECT LENGTH(CAST (? AS VARCHAR))"")

Review Comment:
   by ""it"" did you mean LENGTH?



;22/Jun/23 08:11;githubbot;600","zstan commented on code in PR #2223:
URL: https://github.com/apache/ignite-3/pull/2223#discussion_r1238192918


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/datatypes/varbinary/ItVarBinaryExpressionTest.java:
##########
@@ -67,24 +67,32 @@ public void testPositionExpressionWithDynamicParameter() {
                 .check();
     }
 
-    /** {@code LENGTH} expression. */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19668"")
+    /** {@code LENGTH} and {@code OCTET_LENGTH} expression. */
     @Test
     public void testLengthExpression() {
         checkQuery(""SELECT LENGTH(x'010203')"")
-                .withParams(varBinary(new byte[]{2}))
+                .returns(3).check();
+
+        checkQuery(""SELECT OCTET_LENGTH(x'010203')"")
                 .returns(3).check();
     }
 
-    /** {@code LENGTH} expression. */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19668"")
+    /** {@code LENGTH} and {@code OCTET_LENGTH} expression with dynamic params. */
     @Test
     public void testLengthExpressionWithDynamicParameter() {
-        checkQuery(""SELECT LENGTH(?)"")
+        checkQuery(""SELECT OCTET_LENGTH(?)"")
+                .withParams(varBinary(new byte[]{1, 2, 3}))
+                .returns(3).check();
+
+        checkQuery(""SELECT OCTET_LENGTH(?)"")
+                .withParams(varBinary(new byte[0]))
+                .returns(0).check();
+
+        checkQuery(""SELECT LENGTH(CAST (? AS VARCHAR))"")
                 .withParams(varBinary(new byte[]{1, 2, 3}))
                 .returns(3).check();
 
-        checkQuery(""SELECT LENGTH(?)"")
+        checkQuery(""SELECT LENGTH(CAST (? AS VARCHAR))"")

Review Comment:
   yes, cast from varbinary to varchar returns the expected result.



;22/Jun/23 08:33;githubbot;600","korlov42 commented on code in PR #2223:
URL: https://github.com/apache/ignite-3/pull/2223#discussion_r1238225571


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/datatypes/varbinary/ItVarBinaryExpressionTest.java:
##########
@@ -67,24 +67,32 @@ public void testPositionExpressionWithDynamicParameter() {
                 .check();
     }
 
-    /** {@code LENGTH} expression. */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19668"")
+    /** {@code LENGTH} and {@code OCTET_LENGTH} expression. */
     @Test
     public void testLengthExpression() {
         checkQuery(""SELECT LENGTH(x'010203')"")
-                .withParams(varBinary(new byte[]{2}))
+                .returns(3).check();
+
+        checkQuery(""SELECT OCTET_LENGTH(x'010203')"")
                 .returns(3).check();
     }
 
-    /** {@code LENGTH} expression. */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19668"")
+    /** {@code LENGTH} and {@code OCTET_LENGTH} expression with dynamic params. */
     @Test
     public void testLengthExpressionWithDynamicParameter() {
-        checkQuery(""SELECT LENGTH(?)"")
+        checkQuery(""SELECT OCTET_LENGTH(?)"")
+                .withParams(varBinary(new byte[]{1, 2, 3}))
+                .returns(3).check();
+
+        checkQuery(""SELECT OCTET_LENGTH(?)"")
+                .withParams(varBinary(new byte[0]))
+                .returns(0).check();
+
+        checkQuery(""SELECT LENGTH(CAST (? AS VARCHAR))"")
                 .withParams(varBinary(new byte[]{1, 2, 3}))
                 .returns(3).check();
 
-        checkQuery(""SELECT LENGTH(?)"")
+        checkQuery(""SELECT LENGTH(CAST (? AS VARCHAR))"")

Review Comment:
   well, and what is expected result in this case? 
   



;22/Jun/23 08:58;githubbot;600","zstan commented on PR #2223:
URL: https://github.com/apache/ignite-3/pull/2223#issuecomment-1609439821

   @lowka @korlov42 new approach is ready for review, can u take a look plz ?


;27/Jun/23 12:50;githubbot;600","AMashenkov merged PR #2223:
URL: https://github.com/apache/ignite-3/pull/2223


;28/Jun/23 13:10;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,5400,,,0,5400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jun 22 05:33:59 UTC 2023,,,,,,,,,,"0|z1idh4:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"20/Jun/23 07:33;zstan;<length expression> returns the length of a given character string, as an exact numeric value, in
characters, octets, or bits according to the choice of function.;;;","21/Jun/23 15:01;korlov;[~zstan], I'm not sure I understand your comment. May you elaborate please?;;;","22/Jun/23 05:33;zstan;concrete this comment is the quote from sql standard;;;",,,
High performance drop in key-value put() operations introduced between May 23 and June 5,IGNITE-19665,13538935,Bug,Closed,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,rpuch,Artukhov,Artukhov,06/Jun/23 14:28,23/Jun/23 08:51,13/Jul/23 09:11,16/Jun/23 12:58,,,,,,,,,,,,0,ignite-3,performance,,"This ticket is a product of subsequent work on https://issues.apache.org/jira/browse/IGNITE-19664.

There are high (more than 4x on my local machine) performance drop in {{KeyValueView#put}} operations introduced somewhere between the following commit:

{noformat}
commit 0c68cbe3f016e508bd9d53ce5320c88acba1acff (HEAD)
Author: Slava Koptilin <slava.koptilin@gmail.com>
Date:   Tue May 23 10:17:53 2023 +0300

    IGNITE-17883 Removed not implemented 'invoke' functionality (#2090)
{noformat}

and the following one:

{code:java}
commit a2254434c403bc54685f05e0d6f51bef56abea2a (HEAD -> main, origin/main, origin/HEAD)
Author: Vadim Pakhnushev <8614891+valepakh@users.noreply.github.com>
Date:   Mon Jun 5 17:43:07 2023 +0300

    IGNITE-19559 NPE in deploy/undeploy calls in non-REPL mode (#2131)

{code}

The test is the ""Test 1"" from https://issues.apache.org/jira/browse/IGNITE-19664, i.e.: 
1. Start an Ignite 3 server node with attached {{ignite-config.conf}}. {{raft.fsync=false}} is set in the config.
2. Start YCSB client which makes {{KeyValueView#put}} operations within a ""100% insert"" profile.

Results for {{0c68cbe3f016e508bd9d53ce5320c88acba1acff}} were as follows:

{noformat}
[OVERALL], RunTime(ms), 282482
[OVERALL], Throughput(ops/sec), 3540.048569466373
[INSERT], Operations, 1000000
[INSERT], AverageLatency(us), 1067.488346
[INSERT], MinLatency(us), 492
[INSERT], MaxLatency(us), 421375
[INSERT], 95thPercentileLatency(us), 2059
[INSERT], 99thPercentileLatency(us), 5151
[INSERT], Return=OK, 1000000
{noformat}

Results for {{a2254434c403bc54685f05e0d6f51bef56abea2a}} are more than 4x worse in terms of throughput:

{code:java}
[OVERALL], RunTime(ms), 1325870
[OVERALL], Throughput(ops/sec), 754.2217562807816
[INSERT], Operations, 1000000
[INSERT], AverageLatency(us), 5229.54584
[INSERT], MinLatency(us), 1297
[INSERT], MaxLatency(us), 164223
[INSERT], 95thPercentileLatency(us), 9871
[INSERT], 99thPercentileLatency(us), 14271
[INSERT], Return=OK, 1000000
{code}

Logs for {{0c68cbe3f016e508bd9d53ce5320c88acba1acff}}: see https://issues.apache.org/jira/browse/IGNITE-19664

Logs for {{a2254434c403bc54685f05e0d6f51bef56abea2a}}:
- node's config:  [^ignite-config.conf] 
- node's log:  [^ignite3db-0.log] 
- node's GC log:  [^gc.log.20230606_075104] 
- YCSB client log:  [^ycsb-run10.log] ",,akhitrin,Artukhov,ptupitsyn,rpuch,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19732,,,,,,,,IGNITE-19531,,,,,IGNITE-19664,,,,,"06/Jun/23 14:53;Artukhov;ai3_embedded_20230606_144606.jfr.zip;https://issues.apache.org/jira/secure/attachment/13058834/ai3_embedded_20230606_144606.jfr.zip","06/Jun/23 14:37;Artukhov;ai3_thin_client_20230606_075104.jfr.zip;https://issues.apache.org/jira/secure/attachment/13058833/ai3_thin_client_20230606_075104.jfr.zip","06/Jun/23 14:27;Artukhov;gc.log.20230606_075104;https://issues.apache.org/jira/secure/attachment/13058832/gc.log.20230606_075104","06/Jun/23 14:27;Artukhov;ignite-config.conf;https://issues.apache.org/jira/secure/attachment/13058830/ignite-config.conf","06/Jun/23 14:27;Artukhov;ignite3db-0.log;https://issues.apache.org/jira/secure/attachment/13058831/ignite3db-0.log","06/Jun/23 14:53;Artukhov;run11-new-emb-jfr.txt;https://issues.apache.org/jira/secure/attachment/13058835/run11-new-emb-jfr.txt","06/Jun/23 14:27;Artukhov;ycsb-run10.log;https://issues.apache.org/jira/secure/attachment/13058829/ycsb-run10.log",,7.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Jun 23 08:50:52 UTC 2023,,,,,,,,,,"0|z1icz4:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"06/Jun/23 14:54;Artukhov;Results of the ""Test 2. Embedded mode"" from for the ""new"" commit {{a2254434c403bc54685f05e0d6f51bef56abea2a}} are the same as for ""old"" {{0c68cbe3f016e508bd9d53ce5320c88acba1acff}} from https://issues.apache.org/jira/browse/IGNITE-19664:

{code:java}
[OVERALL], RunTime(ms), 175194
[OVERALL], Throughput(ops/sec), 5707.958035092526
[INSERT], Operations, 1000000
[INSERT], AverageLatency(us), 638.186869
[INSERT], MinLatency(us), 253
[INSERT], MaxLatency(us), 479487
[INSERT], 95thPercentileLatency(us), 1342
[INSERT], 99thPercentileLatency(us), 3825
[INSERT], Return=OK, 1000000
{code}

YCSB log:  [^run11-new-emb-jfr.txt] 
JFR:  [^ai3_embedded_20230606_144606.jfr.zip] ;;;","07/Jun/23 08:27;ptupitsyn;Caused by IGNITE-19531: table lookup by ID got a lot slower;;;","08/Jun/23 12:12;rpuch;There are two problems:
 # We go to the configuration to check for table existence each time we obtain the table
 # The check was made less efficient due to changes introduced in IGNITE-19531

Introduction of Catalog and Schema sync will allow us to remove the checks in item 1 completely, which will automaticlly solve the problem in item 2.

It is suggested to leave this on hold for now until Catalog and Schema sync arrive or it suddenly turns out that we need all the performance we might get 'right here, right now'.;;;","16/Jun/23 12:58;rpuch;Fixed in IGNITE-19732;;;","23/Jun/23 08:50;Artukhov;[~rpuch] I've re-run the benchmarks on {{027dcea77}} from June 21 and see that the performance has increased, i.e. it is now similar to the performance of {{0c68cbe3}}. Thanks for your work!;;;",
NullPointerException in ClusterConfigRegistryImpl.fetchConfig,IGNITE-19659,13538888,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,vpakhnushev,ptupitsyn,ptupitsyn,06/Jun/23 08:53,07/Jun/23 15:54,13/Jul/23 09:11,07/Jun/23 15:54,3.0.0-beta1,,,,,,,3.0.0-beta2,cli,,,0,ignite-3,,,"*ItSslTest.connectToSecuredNode*
{code:java}
2023-06-06 07:43:15:455 +0300 [WARNING][ForkJoinPool.commonPool-worker-31][LazyObjectRef] Got exception when fetch from source
    java.util.concurrent.CompletionException: java.lang.NullPointerException
      at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:314)
      at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:319)
      at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1702)
      at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1692)
      at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
      at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1020)
      at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1656)
      at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1594)
      at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)
    Caused by: java.lang.NullPointerException
      at org.apache.ignite.internal.cli.core.repl.registry.impl.ClusterConfigRegistryImpl.fetchConfig(ClusterConfigRegistryImpl.java:50)
      at org.apache.ignite.internal.cli.core.repl.registry.impl.ClusterConfigRegistryImpl.lambda$onConnect$0(ClusterConfigRegistryImpl.java:43)
      at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1700)
      ... 6 more
    2023-06-06 07:43:15:461 +0300 [ERROR][Test worker][ExceptionHandler] Unhandled exception
    java.lang.NullPointerException: factory
      at picocli.CommandLine$Assert.notNull(CommandLine.java:18266)
      at picocli.CommandLine.<init>(CommandLine.java:228)
      at picocli.CommandLine.<init>(CommandLine.java:224)
      at org.apache.ignite.internal.cli.core.repl.executor.ReplExecutor.createPicocliCommands(ReplExecutor.java:177)
      at org.apache.ignite.internal.cli.core.repl.executor.ReplExecutor.execute(ReplExecutor.java:114)
      at org.apache.ignite.internal.cli.ReplManager.startReplMode(ReplManager.java:53)
      at org.apache.ignite.internal.cli.commands.connect.ConnectCommand.call(ConnectCommand.java:61)
      at org.apache.ignite.internal.cli.commands.connect.ConnectCommand.call(ConnectCommand.java:37)
      at picocli.CommandLine.executeUserObject(CommandLine.java:2041)
      at picocli.CommandLine.access$1500(CommandLine.java:148)
      at picocli.CommandLine$RunLast.executeUserObjectOfLastSubcommandWithSameParent(CommandLine.java:2461)
      at picocli.CommandLine$RunLast.handle(CommandLine.java:2453)
      at picocli.CommandLine$RunLast.handle(CommandLine.java:2415)
      at picocli.CommandLine$AbstractParseResultHandler.execute(CommandLine.java:2273)
      at picocli.CommandLine$RunLast.execute(CommandLine.java:2417)
      at picocli.CommandLine.execute(CommandLine.java:2170)
      at org.apache.ignite.internal.cli.commands.CliCommandTestNotInitializedIntegrationBase.execute(CliCommandTestNotInitializedIntegrationBase.java:123)
      at org.apache.ignite.internal.cli.ssl.ItSslTest.connectToSecuredNode(ItSslTest.java:53){code}
[https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_IntegrationTests_ModuleCli/7273149?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandBuildProblemsSection=true&expandBuildChangesSection=true]",,aleksandr.pakhomov,ptupitsyn,,,,"valepakh opened a new pull request, #2156:
URL: https://github.com/apache/ignite-3/pull/2156

   https://issues.apache.org/jira/browse/IGNITE-19659
   
   First NPE is shown in the logs when we connect to uninitialized cluster.
   Second NPE is shown when we run non-REPL `connect` command without proper environment.


;06/Jun/23 16:11;githubbot;600","PakhomovAlexander merged PR #2156:
URL: https://github.com/apache/ignite-3/pull/2156


;07/Jun/23 15:45;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jun 07 15:54:38 UTC 2023,,,,,,,,,,"0|z1icoo:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"07/Jun/23 15:54;aleksandr.pakhomov;Thanks for the contribution, merged into main: 0f902c0697606f7f741b845fddbfb4ba6884035b;;;",,,,,
NullPointerException in MetaStorageListener.handlePaginationCommand,IGNITE-19658,13538886,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,apolovtcev,ptupitsyn,ptupitsyn,06/Jun/23 08:51,08/Jun/23 05:54,13/Jul/23 09:11,07/Jun/23 08:46,,,,,,,,3.0.0-beta2,networking,,,0,ignite-3,,,"*ItMetaStorageServiceTest.testRangeWithNullAsKeyTo*

{code}
2023-06-06 07:40:23:613 +0300 [INFO][%imsst_trwnakt_20000%JRaft-ReadOnlyService-Disruptor-_stripe_1-0][ActionRequestProcessor] Error occurred on a user's state machine
    java.lang.NullPointerException
      at org.apache.ignite.internal.metastorage.server.raft.MetaStorageListener.handlePaginationCommand(MetaStorageListener.java:131)
      at org.apache.ignite.internal.metastorage.server.raft.MetaStorageListener.onRead(MetaStorageListener.java:99)
      at org.apache.ignite.raft.jraft.rpc.impl.ActionRequestProcessor$2.run(ActionRequestProcessor.java:130)
      at org.apache.ignite.raft.jraft.closure.ReadIndexClosure.run(ReadIndexClosure.java:95)
      at org.apache.ignite.raft.jraft.core.ReadOnlyServiceImpl.notifySuccess(ReadOnlyServiceImpl.java:446)
      at org.apache.ignite.raft.jraft.core.ReadOnlyServiceImpl$ReadIndexResponseClosure.run(ReadOnlyServiceImpl.java:194)
      at org.apache.ignite.raft.jraft.core.NodeImpl.readLeader(NodeImpl.java:1777)
      at org.apache.ignite.raft.jraft.core.NodeImpl.handleReadIndexRequest(NodeImpl.java:1722)
      at org.apache.ignite.raft.jraft.core.ReadOnlyServiceImpl.executeReadIndexEvents(ReadOnlyServiceImpl.java:245)
      at org.apache.ignite.raft.jraft.core.ReadOnlyServiceImpl$ReadIndexEventHandler.onEvent(ReadOnlyServiceImpl.java:138)
      at org.apache.ignite.raft.jraft.core.ReadOnlyServiceImpl$ReadIndexEventHandler.onEvent(ReadOnlyServiceImpl.java:121)
      at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:217)
      at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:181)
      at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:137)
      at java.base/java.lang.Thread.run(Thread.java:834)
{code}

https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_IntegrationTests_ModuleMetastorageClient/7273154?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandBuildProblemsSection=true&expandBuildChangesSection=true",,apolovtcev,ptupitsyn,sdanilov,,,"sashapolo opened a new pull request, #2158:
URL: https://github.com/apache/ignite-3/pull/2158

   https://issues.apache.org/jira/browse/IGNITE-19658


;07/Jun/23 08:00;githubbot;600","SammyVimes merged PR #2158:
URL: https://github.com/apache/ignite-3/pull/2158


;07/Jun/23 08:45;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19678,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jun 08 05:53:10 UTC 2023,,,,,,,,,,"0|z1ico8:",9223372036854775807,,,sdanilov,,,,,,,,,,,,,,,,,,"07/Jun/23 08:46;sdanilov;The patch looks good to me. Thank you for the contribution, merged to the main branch.;;;","08/Jun/23 03:32;ptupitsyn;[~apolovtcev] the exception seems to be still there after the fix, can you please have a look?
https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_IntegrationTests_ModuleMetastorageClient/7277195?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandBuildProblemsSection=true&expandBuildChangesSection=true

*testRangeWithKeyToAndUpperBound*

{code}
2023-06-07 19:21:21:845 +0300 [INFO][%imsst_trnnsee_20000%JRaft-ReadOnlyService-Disruptor-_stripe_11-0][ActionRequestProcessor] Error occurred on a user's state machine
  java.util.NoSuchElementException
    at org.apache.ignite.internal.util.IteratorCursor.next(IteratorCursor.java:44)
    at org.apache.ignite.internal.metastorage.server.raft.MetaStorageListener.handlePaginationCommand(MetaStorageListener.java:131)
    at org.apache.ignite.internal.metastorage.server.raft.MetaStorageListener.onRead(MetaStorageListener.java:99)
    at org.apache.ignite.raft.jraft.rpc.impl.ActionRequestProcessor$2.run(ActionRequestProcessor.java:130)
    at org.apache.ignite.raft.jraft.closure.ReadIndexClosure.run(ReadIndexClosure.java:95)
    at org.apache.ignite.raft.jraft.core.ReadOnlyServiceImpl.notifySuccess(ReadOnlyServiceImpl.java:446)
    at org.apache.ignite.raft.jraft.core.ReadOnlyServiceImpl$ReadIndexResponseClosure.run(ReadOnlyServiceImpl.java:194)
    at org.apache.ignite.raft.jraft.core.NodeImpl.readLeader(NodeImpl.java:1777)
    at org.apache.ignite.raft.jraft.core.NodeImpl.handleReadIndexRequest(NodeImpl.java:1722)
    at org.apache.ignite.raft.jraft.core.ReadOnlyServiceImpl.executeReadIndexEvents(ReadOnlyServiceImpl.java:245)
    at org.apache.ignite.raft.jraft.core.ReadOnlyServiceImpl$ReadIndexEventHandler.onEvent(ReadOnlyServiceImpl.java:138)
    at org.apache.ignite.raft.jraft.core.ReadOnlyServiceImpl$ReadIndexEventHandler.onEvent(ReadOnlyServiceImpl.java:121)
    at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:217)
    at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:181)
    at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:137)
    at java.base/java.lang.Thread.run(Thread.java:834)
{code};;;","08/Jun/23 05:53;apolovtcev;[~ptupitsyn] Thank you for pointing it out! The attached stacktrace is not related, though, it's valid because it comes from a test that validates exceptional behavior. I'll fix the remaining NPEs in a separate ticket.;;;",,,
Distributed Sql keeps mapping query fragments to a node that has already left,IGNITE-19655,13538871,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,mzhuravkov,rpuch,rpuch,06/Jun/23 07:36,08/Jun/23 14:48,13/Jul/23 09:11,08/Jun/23 14:48,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"There are two test failures: [https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunAllTests/7271211?expandCode+Inspection=true&expandBuildProblemsSection=true&hideProblemsFromDependencies=false&expandBuildTestsSection=true&hideTestsFromDependencies=false] and [https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunAllTests/7272905?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandCode+Inspection=true&expandBuildProblemsSection=true&expandBuildChangesSection=true&expandBuildTestsSection=true] (org.apache.ignite.internal.raftsnapshot.ItTableRaftSnapshotsTest.entriesKeepAppendedAfterSnapshotInstallation and org.apache.ignite.internal.raftsnapshot.ItTableRaftSnapshotsTest.snapshotInstallTimeoutDoesNotBreakSubsequentInstallsWhenSecondAttemptIsIdenticalToFirst, correspondingly).

In both cases, the test code creates a table with 3 replicas on a cluster of 3 nodes, then it stops the last node and tries to make an insert using one of the 2 remaining nodes. The RAFT majority (2 of 3) is still preserved, so the insert should succeed. It's understood that the insert might be issued before the remaining nodes understand that the third node has left, so we have a retry mechanism in place, it makes up to 5 attempts for almost 8 seconds (in total).

But in both the failed runs, each of 5 attempts failed because a fragment of the INSERT query was mapped to the missing node. This seems to be a bad luck (as the tests pass most of the time, fail rate is about 2.5%), but anyway: the SQL engine does not seem to care about the fact that the node has already left.

Probably, the SQL engine should track the Logical Topology events and avoid mapping query fragments to the missing nodes.",,korlov,rpuch,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19685,,,,,,,,IGNITE-19685,IGNITE-19656,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jun 08 14:47:08 UTC 2023,,,,,,,,,,"0|z1ickw:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"06/Jun/23 09:49;korlov;{quote}
the SQL engine does not seem to care about the fact that the node has already left.
{quote}

It's true. But SQL doesn't have to.

SQL engine uses TopologyService (TS) to get all live members of a cluster. So it's responsibility of TS to keep track of members of the cluster and provide valid state for those who asking for it.

I run mentioned test locally and found rather peculiar log sequence:


{noformat}
2023-06-06 12:25:50:581 +0300 [INFO][sc-cluster-3344-1][ScaleCubeTopologyService] Node joined [node=ClusterNode [id=6f399661-6f3f-4d8a-ae79-ec2ad758c80a, name=itrst_sitdnbsiwsaiitf_1, address=192.168.8.104:3345, nodeMetadata=null]]
2023-06-06 12:25:50:582 +0300 [INFO][sc-cluster-3344-1][ScaleCubeTopologyService] Topology snapshot [nodes=[itrst_sitdnbsiwsaiitf_1, itrst_sitdnbsiwsaiitf_0]]
2023-06-06 12:25:51:558 +0300 [INFO][sc-cluster-3344-1][ScaleCubeTopologyService] Topology snapshot [nodes=[itrst_sitdnbsiwsaiitf_1, itrst_sitdnbsiwsaiitf_0]]
2023-06-06 12:25:51:904 +0300 [INFO][sc-cluster-3344-1][ScaleCubeTopologyService] Node joined [node=ClusterNode [id=c015b0a9-aa4b-4a27-b42b-ba611b46978b, name=itrst_sitdnbsiwsaiitf_2, address=192.168.8.104:3346, nodeMetadata=null]]
2023-06-06 12:25:51:904 +0300 [INFO][sc-cluster-3344-1][ScaleCubeTopologyService] Topology snapshot [nodes=[itrst_sitdnbsiwsaiitf_2, itrst_sitdnbsiwsaiitf_1, itrst_sitdnbsiwsaiitf_0]]
2023-06-06 12:25:52:870 +0300 [INFO][sc-cluster-3344-1][ScaleCubeTopologyService] Topology snapshot [nodes=[itrst_sitdnbsiwsaiitf_2, itrst_sitdnbsiwsaiitf_1, itrst_sitdnbsiwsaiitf_0]]
2023-06-06 12:25:58:668 +0300 [INFO][sc-cluster-3344-1][ScaleCubeTopologyService] Topology snapshot [nodes=[itrst_sitdnbsiwsaiitf_2, itrst_sitdnbsiwsaiitf_1, itrst_sitdnbsiwsaiitf_0]]
2023-06-06 12:26:06:408 +0300 [INFO][sc-cluster-3344-1][ScaleCubeTopologyService] Node joined [node=ClusterNode [id=21182b57-f6fa-4129-94fe-c2f78a06296c, name=itrst_sitdnbsiwsaiitf_2, address=192.168.8.104:3346, nodeMetadata=null]]
2023-06-06 12:26:06:408 +0300 [INFO][sc-cluster-3344-1][ScaleCubeTopologyService] Topology snapshot [nodes=[itrst_sitdnbsiwsaiitf_2, itrst_sitdnbsiwsaiitf_1, itrst_sitdnbsiwsaiitf_0]]
2023-06-06 12:26:07:204 +0300 [INFO][sc-cluster-3344-1][ScaleCubeTopologyService] Topology snapshot [nodes=[itrst_sitdnbsiwsaiitf_2, itrst_sitdnbsiwsaiitf_1, itrst_sitdnbsiwsaiitf_0]]
2023-06-06 12:26:07:261 +0300 [INFO][sc-cluster-3344-1][ScaleCubeTopologyService] Node left [member=ClusterNode [id=c015b0a9-aa4b-4a27-b42b-ba611b46978b, name=itrst_sitdnbsiwsaiitf_2, address=192.168.8.104:3346, nodeMetadata=null]]
2023-06-06 12:26:07:303 +0300 [INFO][sc-cluster-3344-1][ScaleCubeTopologyService] Topology snapshot [nodes=[itrst_sitdnbsiwsaiitf_2, itrst_sitdnbsiwsaiitf_1, itrst_sitdnbsiwsaiitf_0]]
2023-06-06 12:26:29:460 +0300 [INFO][sc-cluster-3344-1][Transport] Stopping [address=192.168.8.104:3344]
2023-06-06 12:26:29:461 +0300 [INFO][sc-cluster-3344-1][Transport] Stopped [address=192.168.8.104:3344]
{noformat}

In the log, the node {{itrst_sitdnbsiwsaiitf_2}} is joined twice: first time with ID={{c015...}}, and then with ID={{2118...}}. Then Node left was fired for this node with ID={{c015...}}. Since this node had been re-registered with new ID, this event just ignored leaving topology snapshot without change: {{Topology snapshot [nodes=[itrst_sitdnbsiwsaiitf_2, itrst_sitdnbsiwsaiitf_1, itrst_sitdnbsiwsaiitf_0]]}}.

I believe this is root cause of tests flakiness.
;;;","07/Jun/23 15:08;rpuch;There are 2 weirdnesses:
 # Why does it take 10 seconds for a node to be removed from the physical topology if it left gracefully?
 # Why didn't the size of the topology shrink to 2 nodes when the node has actually left the topology?

The second weirdness is harmless, it just looks weird in the logs. The thing is that the node re-joined before it was considered as left, so the 'Node left' was about an outdated version of the node (that was already replaced with the new one on the second join). Logically, it's all ok: a node was 'detected' to be missing too late, so there was no time window when the cluster would know that the node was gone.

The first weirdness is really weird. I'm digging this, but we should probably remove the node from the topology as soon as it says 'good bye' (LEAVING event) as otherwise the suspicion check mechanism is used for it.;;;","08/Jun/23 14:47;rpuch;The first weirdness was fixed in IGNITE-19685. To make the situation with removal of an outdated node less confusing, I've changed logging a bit to make this case stand out and differ from the normal 'node left' case.;;;",,,
Java thin: NullPointerException logged from testRequestsMetrics,IGNITE-19653,13538853,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,06/Jun/23 03:53,06/Jun/23 09:34,13/Jul/23 09:11,06/Jun/23 09:34,,,,,,,,3.0.0-beta2,thin client,,,0,ignite-3,,,"TeamCity now triggers a failure condition on *NullReferenceException* in the log - it usually indicates a bug.
*ClientMetricsTest.testRequestsMetrics* logs NPE:
{code}
org.apache.ignite.client.ClientMetricsTest
03:43:58     ClientMetricsTest > testRequestsMetrics() STANDARD_ERROR
03:43:58         2023-06-06 06:43:58:466 +0300 [WARNING][TestServer--srv-worker-1][ClientInboundMessageHandler] Error processing client request [id=2, op=50, remoteAddress=/127.0.0.1:50230]:null
03:43:58         java.lang.NullPointerException
03:43:58           at org.apache.ignite.client.handler.requests.sql.ClientSqlExecuteRequest.readSession(ClientSqlExecuteRequest.java:168)
03:43:58           at org.apache.ignite.client.handler.requests.sql.ClientSqlExecuteRequest.process(ClientSqlExecuteRequest.java:72)
03:43:58           at org.apache.ignite.client.handler.ClientInboundMessageHandler.processOperation(ClientInboundMessageHandler.java:613)
03:43:58           at org.apache.ignite.client.handler.ClientInboundMessageHandler.processOperation(ClientInboundMessageHandler.java:451)
03:43:58           at org.apache.ignite.client.handler.ClientInboundMessageHandler.channelRead(ClientInboundMessageHandler.java:250)
03:43:58           at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
03:43:58           at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
03:43:58           at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
03:43:58           at io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:93)
{code}

It is caused by mocked *IgniteSql* at *TestClientHandlerModule:197*.",,isapego,ptupitsyn,,,,"ptupitsyn opened a new pull request, #2147:
URL: https://github.com/apache/ignite-3/pull/2147

   (no comment)


;06/Jun/23 04:02;githubbot;600","ptupitsyn merged PR #2147:
URL: https://github.com/apache/ignite-3/pull/2147


;06/Jun/23 09:34;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,Java,Tue Jun 06 09:34:37 UTC 2023,,,,,,,,,,"0|z1icgw:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"06/Jun/23 05:18;ptupitsyn;[~isapego] please review.;;;","06/Jun/23 09:32;isapego;Looks good to me.;;;","06/Jun/23 09:34;ptupitsyn;87c7bb43cf03297a0c9d051cc62f098b1226dd63;;;",,,
Ignite is not working on JDK 21,IGNITE-19652,13538786,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,,wendigo,wendigo,05/Jun/23 14:13,16/Jun/23 10:39,13/Jul/23 09:11,15/Jun/23 08:44,2.15,,,,,,,2.16,,,,0,,,,ByteBuffer constructor in JDK 21 has different arguments: https://github.com/openjdk/jdk/commit/a56598f5a534cc9223367e7faa8433ea38661db9,,ignitetcbot,ptupitsyn,wendigo,,,"wendigo opened a new pull request, #10764:
URL: https://github.com/apache/ignite/pull/10764

   Signature has changed in https://github.com/openjdk/jdk/commit/a56598f5a534cc9223367e7faa8433ea38661db9
   
   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [x] There is a single JIRA ticket related to the pull request. 
   - [x] The web-link to the pull request is attached to the JIRA ticket.
   - [x] The JIRA ticket has the _Patch Available_ state.
   - [x] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [x] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;05/Jun/23 14:16;githubbot;600","sonarcloud[bot] commented on PR #10764:
URL: https://github.com/apache/ignite/pull/10764#issuecomment-1576905327

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10764)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10764&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10764&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10764&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10764&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10764&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10764&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10764&metric=new_duplicated_lines_density&view=list)
   
   


;05/Jun/23 14:23;githubbot;600","wendigo commented on PR #10764:
URL: https://github.com/apache/ignite/pull/10764#issuecomment-1579042508

   Ping @NSAmelchev @alex-plekhanov 


;06/Jun/23 16:00;githubbot;600","NSAmelchev commented on code in PR #10764:
URL: https://github.com/apache/ignite/pull/10764#discussion_r1221802767


##########
modules/core/src/main/java/org/apache/ignite/internal/util/GridUnsafe.java:
##########
@@ -1660,6 +1661,12 @@ private static Method newDirectBufferMethod(Object nioAccessObj) {
         return javaVer < 9 ? ""sun"" : ""jdk.internal"";
     }
 
+    @NotNull private static boolean directByteBufferLongLongCtor() {

Review Comment:
   I suggest to declare a local var in static class initialization and pass it to methods:
   
   ```
   boolean isDirectBufLongCap = majorJavaVersion(jdkVersion()) >= 21;
   ```



;07/Jun/23 15:31;githubbot;600","NSAmelchev commented on PR #10764:
URL: https://github.com/apache/ignite/pull/10764#issuecomment-1581078508

   Hello, @wendigo.
   Please, fix the codestyle.
   I suggest writing to the dev list to ask for help with running CI on a new JDK.


;07/Jun/23 15:36;githubbot;600","sonarcloud[bot] commented on PR #10764:
URL: https://github.com/apache/ignite/pull/10764#issuecomment-1581490608

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10764)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10764&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10764&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10764&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=CODE_SMELL) [1 Code Smell](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10764&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10764&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10764&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10764&metric=new_duplicated_lines_density&view=list)
   
   


;07/Jun/23 20:51;githubbot;600","sonarcloud[bot] commented on PR #10764:
URL: https://github.com/apache/ignite/pull/10764#issuecomment-1581506634

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10764)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10764&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10764&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10764&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10764&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10764&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10764&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10764&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10764&metric=new_duplicated_lines_density&view=list)
   
   


;07/Jun/23 21:02;githubbot;600","wendigo commented on PR #10764:
URL: https://github.com/apache/ignite/pull/10764#issuecomment-1586823354

   @NSAmelchev ping


;12/Jun/23 08:19;githubbot;600","ptupitsyn merged PR #10764:
URL: https://github.com/apache/ignite/pull/10764


;15/Jun/23 08:44;githubbot;600","wendigo commented on PR #10764:
URL: https://github.com/apache/ignite/pull/10764#issuecomment-1594400383

   @ptupitsyn do you happen to know when the next minor release is happening?


;16/Jun/23 09:33;githubbot;600","ptupitsyn commented on PR #10764:
URL: https://github.com/apache/ignite/pull/10764#issuecomment-1594445955

   @wendigo there is no set date, but I would expect it by the end of the year.


;16/Jun/23 10:10;githubbot;600","wendigo commented on PR #10764:
URL: https://github.com/apache/ignite/pull/10764#issuecomment-1594476880

   @ptupitsyn that’s too late for us in Trino. I guess that I’ll need to patch it somehow


;16/Jun/23 10:39;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,7200,,,0,7200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Thu Jun 15 08:44:33 UTC 2023,,,,,,,,,,"0|z1ic20:",9223372036854775807,Fixed startup on Java 21.,,,,,,,,,,,,,,,,,,,,"05/Jun/23 14:17;wendigo;https://github.com/apache/ignite/pull/10764;;;","15/Jun/23 06:26;ignitetcbot;{panel:title=Branch: [pull/10764/head] Base: [master] : Possible Blockers (6)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}
{color:#d04437}Snapshots{color} [[tests 0 Exit Code , Failure on metric |https://ci.ignite.apache.org/viewLog.html?buildId=7294598]]

{color:#d04437}[Check Code Style Ducktests]{color} [[tests 0 Exit Code |https://ci.ignite.apache.org/viewLog.html?buildId=7294540]]

{color:#d04437}Disk Page Compressions 1{color} [[tests 0 Exit Code , Failure on metric |https://ci.ignite.apache.org/viewLog.html?buildId=7294616]]

{color:#d04437}Disk Page Compressions 2{color} [[tests 0 TIMEOUT , Exit Code , Failure on metric |https://ci.ignite.apache.org/viewLog.html?buildId=7294617]]

{color:#d04437}Platform .NET (Windows){color} [[tests 1|https://ci.ignite.apache.org/viewLog.html?buildId=7294586]]
* exe: CachePartitionedAtomicNearEnabledTest.TestCacheConfigurationExpiryPolicy - Test has low fail rate in base branch 0,0% and is not flaky

{color:#d04437}Queries 2 (lazy=true){color} [[tests 1|https://ci.ignite.apache.org/viewLog.html?buildId=7294590]]
* IgniteBinaryCacheQueryLazyTestSuite2: IgniteCacheQueryNodeRestartDistributedJoinSelfTest.testRestartsBroadcast - Test has low fail rate in base branch 0,0% and is not flaky

{panel}
{panel:title=Branch: [pull/10764/head] Base: [master] : No new tests found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci.ignite.apache.org/viewLog.html?buildId=7294619&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","15/Jun/23 08:44;ptupitsyn;Merged to master: fc51f0e43275953ab6a77c7f4d10ba32d1a640b6;;;",,,
ignite-code-deployment module shouldn't depends on ignite-rest-api,IGNITE-19651,13538782,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ivan.gagarkin,ivan.gagarkin,ivan.gagarkin,05/Jun/23 13:53,20/Jun/23 14:19,13/Jul/23 09:11,20/Jun/23 14:19,,,,,,,,3.0.0-beta2,compute,,,0,ignite-3,,,"Currently, ignite-code-deployment module depends on ignite-rest-api module due to needing for org.apache.ignite.internal.rest.api.deployment.DeploymentStatus. 

We need to split the internal and external presentation of deployment status. ",,aleksandr.pakhomov,ivan.gagarkin,,,,"Flaugh24 opened a new pull request, #2211:
URL: https://github.com/apache/ignite-3/pull/2211

   https://issues.apache.org/jira/browse/IGNITE-19651


;18/Jun/23 19:24;githubbot;600","PakhomovAlexander merged PR #2211:
URL: https://github.com/apache/ignite-3/pull/2211


;20/Jun/23 14:17;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-18728,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Tue Jun 20 14:19:23 UTC 2023,,,,,,,,,,"0|z1ic14:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"20/Jun/23 14:19;aleksandr.pakhomov;Thanks for the contribution, merged into main: 2b4e7b0ee143f464300a4f458edf73d105212a17 ;;;",,,,,
Broken serialization of communication messages due to incorrect GridCacheQueryRequest class marshalling.,IGNITE-19650,13538712,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,PetrovMikhail,PetrovMikhail,PetrovMikhail,04/Jun/23 20:22,07/Jun/23 17:45,13/Jul/23 09:11,07/Jun/23 17:43,2.12,2.13,2.14,2.15,,,,2.16,,,,0,ise,,,"GridCacheQueryRequest class writeTo/readForm methods does not increment message writer/reader state sequentially. Currently idxQryDescBytes field corresponds message reader/writer state with number 27. But state number 26 is skipped. This can lead to the following situation:

We write on sender node all fields preceding idxQryDescBytes to byte buffer. But no  space remains for idxQryDescBytes. So we save the state with number 26 and returns.
When enough free space become available - we do not find any field that corresponds 26 state and complete serialization without idxQryDescBytes field being recorded.

Receiver node tries to read all fields including  idxQryDescBytes which was not recorded in the byte buffer by the sender node. As a result receiver node can read a part of the next message stored in the byte buffer while trying to read skipped idxQryDescBytes field. This results in corrupted serialization of communication messages.

User can face the following exceptions in this case. The concrete exception depends on the message that come after GridCacheQueryRequest.
{code:java}
2023-05-31 14:49:02.249 [ERROR][grid-nio-worker-tcp-comm-15-#134%TcpCommunicationSpi%][org.apache.ignite.internal.util.nio.GridDirectParser] Failed to read message [msg=GridIoMessage [plc=0, topic=null, topicOrd=-1, ordered=false, timeout=0, skipOnTimeout=false, msg=null], buf=java.nio.DirectByteBuffer[pos=2 lim=16384 cap=132678], reader=DirectMessageReader [state=DirectMessageState [pos=0, stack=[StateItem [stream=DirectByteBufferStreamImplV2 [baseOff=139878897874032, arrOff=-1, tmpArrOff=0, valReadBytes=0, tmpArrBytes=0, msgTypeDone=true, msg=GridDhtAtomicNearResponse [partId=0, futId=0, primaryId=null, errs=null, flags=], mapIt=null, it=null, arrPos=-1, keyDone=false, readSize=-1, readItems=0, prim=0, primShift=0, uuidState=0, uuidMost=0, uuidLeast=0, uuidLocId=0], state=0], StateItem [stream=DirectByteBufferStreamImplV2 [baseOff=139878897874032, arrOff=-1, tmpArrOff=0, valReadBytes=0, tmpArrBytes=0, msgTypeDone=false, msg=null, mapIt=null, it=null, arrPos=-1, keyDone=false, readSize=-1, readItems=0, prim=0, primShift=0, uuidState=0, uuidMost=0, uuidLeast=0, uuidLocId=0], state=0], StateItem [stream=DirectByteBufferStreamImplV2 [baseOff=16, arrOff=-1, tmpArrOff=0, valReadBytes=0, tmpArrBytes=0, msgTypeDone=false, msg=null, mapIt=null, it=null, arrPos=-1, keyDone=false, readSize=-1, readItems=0, prim=0, primShift=0, uuidState=0, uuidMost=0, uuidLeast=0, uuidLocId=0], state=0], StateItem [stream=DirectByteBufferStreamImplV2 [baseOff=16, arrOff=-1, tmpArrOff=0, valReadBytes=0, tmpArrBytes=0, msgTypeDone=false, msg=null, mapIt=null, it=null, arrPos=-1, keyDone=false, readSize=-1, readItems=0, prim=0, primShift=0, uuidState=0, uuidMost=0, uuidLeast=0, uuidLocId=0], state=0], null, null, null, null, null, null]], protoVer=3, lastRead=false], ses=GridSelectorNioSessionImpl [worker=DirectNioClientWorker [super=AbstractNioClientWorker [idx=15, bytesRcvd=183689349864, bytesSent=0, bytesRcvd0=24790, bytesSent0=0, select=true, super=GridWorker [name=grid-nio-worker-tcp-comm-15, igniteInstanceName=TcpCommunicationSpi, finished=false, heartbeatTs=1685533742239, hashCode=864882861, interrupted=false, runner=grid-nio-worker-tcp-comm-15-#134%TcpCommunicationSpi%]]], writeBuf=java.nio.DirectByteBuffer[pos=0 lim=32768 cap=32768], readBuf=java.nio.DirectByteBuffer[pos=24790 lim=24790 cap=32768], inRecovery=GridNioRecoveryDescriptor [acked=713638068, resendCnt=532, rcvCnt=738238432, sentCnt=713638600, reserved=true, lastAck=738238432, nodeLeft=false, node=TcpDiscoveryNode [id=0881a6ed-5a62-4564-99ad-7cf1bc8e0288, consistentId=tps_ise_pplad-pprbtspm0053.ca.sbrf.ru, addrs=ArrayList [10.127.119.241, 127.0.0.1, 192.168.122.1], sockAddrs=HashSet [/192.168.122.1:47500, /10.127.119.241:47500, /127.0.0.1:47500], discPort=47500, order=6, intOrder=6, lastExchangeTime=1685394761595, loc=false, ver=14.1.0#20221221-sha1:24506aa7, isClient=false], connected=false, connectCnt=21, queueLimit=4096, reserveCnt=22, pairedConnections=false], outRecovery=GridNioRecoveryDescriptor [acked=713638068, resendCnt=532, rcvCnt=738238432, sentCnt=713638600, reserved=true, lastAck=738238432, nodeLeft=false, node=TcpDiscoveryNode [id=0881a6ed-5a62-4564-99ad-7cf1bc8e0288, consistentId=tps_ise_pplad-pprbtspm0053.ca.sbrf.ru, addrs=ArrayList [10.127.119.241, 127.0.0.1, 192.168.122.1], sockAddrs=HashSet [/192.168.122.1:47500, /10.127.119.241:47500, /127.0.0.1:47500], discPort=47500, order=6, intOrder=6, lastExchangeTime=1685394761595, loc=false, ver=14.1.0#20221221-sha1:24506aa7, isClient=false], connected=false, connectCnt=21, queueLimit=4096, reserveCnt=22, pairedConnections=false], closeSocket=true, outboundMessagesQueueSizeMetric=o.a.i.i.processors.metric.impl.LongAdderMetric@69a257d1, super=GridNioSessionImpl [locAddr=/10.97.19.164:31489, rmtAddr=/10.127.119.241:47100, createTime=1685533742239, closeTime=0, bytesSent=0, bytesRcvd=24790, bytesSent0=0, bytesRcvd0=24790, sndSchedTime=1685533742239, lastSndTime=1685533742239, lastRcvTime=1685533742239, readsPaused=false, filterChain=FilterChain[filters=[GridNioCodecFilter [parser=o.a.i.i.util.nio.GridDirectParser@7529b084, directMode=true], GridConnectionBytesVerifyFilter, SSL filter], accepted=false, markedForClose=false]]]
org.apache.ignite.IgniteException: Invalid message type: 384
    at org.apache.ignite.internal.managers.communication.IgniteMessageFactoryImpl.create(IgniteMessageFactoryImpl.java:133) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.spi.communication.tcp.internal.GridNioServerWrapper$2.create(GridNioServerWrapper.java:813) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.direct.stream.v2.DirectByteBufferStreamImplV2.readMessage(DirectByteBufferStreamImplV2.java:1189) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.direct.DirectMessageReader.readMessage(DirectMessageReader.java:336) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.processors.cache.GridCacheMessage.readFrom(GridCacheMessage.java:710) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.processors.cache.GridCacheIdMessage.readFrom(GridCacheIdMessage.java:91) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.processors.cache.distributed.dht.atomic.GridDhtAtomicNearResponse.readFrom(GridDhtAtomicNearResponse.java:255) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.direct.stream.v2.DirectByteBufferStreamImplV2.readMessage(DirectByteBufferStreamImplV2.java:1200) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.direct.DirectMessageReader.readMessage(DirectMessageReader.java:336) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.managers.communication.GridIoMessage.readFrom(GridIoMessage.java:271) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.managers.communication.GridIoSecurityAwareMessage.readFrom(GridIoSecurityAwareMessage.java:123) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridDirectParser.decode(GridDirectParser.java:90) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioCodecFilter.onMessageReceived(GridNioCodecFilter.java:113) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterAdapter.proceedMessageReceived(GridNioFilterAdapter.java:109) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridConnectionBytesVerifyFilter.onMessageReceived(GridConnectionBytesVerifyFilter.java:88) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterAdapter.proceedMessageReceived(GridNioFilterAdapter.java:109) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter.onMessageReceived(GridNioSslFilter.java:408) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterAdapter.proceedMessageReceived(GridNioFilterAdapter.java:109) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioServer$HeadFilter.onMessageReceived(GridNioServer.java:3752) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterChain.onMessageReceived(GridNioFilterChain.java:175) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioServer$DirectNioClientWorker.processRead(GridNioServer.java:1379) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioServer$AbstractNioClientWorker.processSelectedKeysOptimized(GridNioServer.java:2526) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioServer$AbstractNioClientWorker.bodyInternal(GridNioServer.java:2281) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioServer$AbstractNioClientWorker.body(GridNioServer.java:1910) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:125) ~[ignite-core-14.1.0.jar:14.1.0]
    at java.lang.Thread.run(Thread.java:829) ~[?:?] {code}
 
{code:java}
2023-05-31 00:26:50.270 [ERROR][grid-nio-worker-tcp-comm-7-#126%TcpCommunicationSpi%][org.apache.ignite.spi.communication.tcp.TcpCommunicationSpi] Failed to process selector key [ses=GridSelectorNioSessionImpl [worker=DirectNioClientWorker [super=AbstractNioClientWorker [idx=7, bytesRcvd=307961844272, bytesSent=0, bytesRcvd0=788711, bytesSent0=0, select=true, super=GridWorker [name=grid-nio-worker-tcp-comm-7, igniteInstanceName=TcpCommunicationSpi, finished=false, heartbeatTs=1685482009267, hashCode=1355815730, interrupted=false, runner=grid-nio-worker-tcp-comm-7-#126%TcpCommunicationSpi%]]], writeBuf=java.nio.DirectByteBuffer[pos=0 lim=32594 cap=32768], readBuf=java.nio.DirectByteBuffer[pos=11514 lim=11514 cap=32768], inRecovery=GridNioRecoveryDescriptor [acked=435904000, resendCnt=0, rcvCnt=478893674, sentCnt=435904020, reserved=true, lastAck=478893664, nodeLeft=false, node=TcpDiscoveryNode [id=6dbee697-1202-4d6c-b077-f0b00ec69adf, consistentId=tps_ise_pplad-pprbtspm0049.ca.sbrf.ru, addrs=ArrayList [10.97.19.163, 127.0.0.1, 192.168.122.1], sockAddrs=null, discPort=47500, order=3, intOrder=3, lastExchangeTime=1685394761693, loc=false, ver=14.1.0#20221221-sha1:24506aa7, isClient=false], connected=true, connectCnt=0, queueLimit=4096, reserveCnt=2, pairedConnections=false], outRecovery=GridNioRecoveryDescriptor [acked=435904000, resendCnt=0, rcvCnt=478893674, sentCnt=435904020, reserved=true, lastAck=478893664, nodeLeft=false, node=TcpDiscoveryNode [id=6dbee697-1202-4d6c-b077-f0b00ec69adf, consistentId=tps_ise_pplad-pprbtspm0049.ca.sbrf.ru, addrs=ArrayList [10.97.19.163, 127.0.0.1, 192.168.122.1], sockAddrs=null, discPort=47500, order=3, intOrder=3, lastExchangeTime=1685394761693, loc=false, ver=14.1.0#20221221-sha1:24506aa7, isClient=false], connected=true, connectCnt=0, queueLimit=4096, reserveCnt=2, pairedConnections=false], closeSocket=true, outboundMessagesQueueSizeMetric=o.a.i.i.processors.metric.impl.LongAdderMetric@69a257d1, super=GridNioSessionImpl [locAddr=/10.127.119.240:47100, rmtAddr=/10.97.19.163:44182, createTime=1685398068848, closeTime=0, bytesSent=270613275246, bytesRcvd=307961844272, bytesSent0=870481, bytesRcvd0=788711, sndSchedTime=1685398068848, lastSndTime=1685482009267, lastRcvTime=1685482009267, readsPaused=false, filterChain=FilterChain[filters=[GridNioCodecFilter [parser=o.a.i.i.util.nio.GridDirectParser@8f4fb5a, directMode=true], GridConnectionBytesVerifyFilter, SSL filter], accepted=true, markedForClose=false]]]
java.lang.AssertionError: null
    at org.apache.ignite.internal.binary.GridBinaryMarshaller.deserialize(GridBinaryMarshaller.java:299) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.binary.BinaryMarshaller.unmarshal0(BinaryMarshaller.java:101) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.marshaller.AbstractNodeNameAwareMarshaller.unmarshal(AbstractNodeNameAwareMarshaller.java:80) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.IgniteUtils.unmarshal(IgniteUtils.java:10742) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.managers.communication.GridIoManager.onMessage0(GridIoManager.java:1273) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.managers.communication.GridIoManager.access$300(GridIoManager.java:243) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.managers.communication.GridIoManager$2.onMessage(GridIoManager.java:509) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.spi.communication.tcp.TcpCommunicationSpi.notifyListener(TcpCommunicationSpi.java:1220) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.spi.communication.tcp.TcpCommunicationSpi$1.onMessage(TcpCommunicationSpi.java:689) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.spi.communication.tcp.TcpCommunicationSpi$1.onMessage(TcpCommunicationSpi.java:687) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.spi.communication.tcp.internal.InboundConnectionHandler.onMessage(InboundConnectionHandler.java:393) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.spi.communication.tcp.internal.InboundConnectionHandler.onMessage(InboundConnectionHandler.java:79) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterChain$TailFilter.onMessageReceived(GridNioFilterChain.java:279) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterAdapter.proceedMessageReceived(GridNioFilterAdapter.java:109) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioCodecFilter.onMessageReceived(GridNioCodecFilter.java:116) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterAdapter.proceedMessageReceived(GridNioFilterAdapter.java:109) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridConnectionBytesVerifyFilter.onMessageReceived(GridConnectionBytesVerifyFilter.java:133) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterAdapter.proceedMessageReceived(GridNioFilterAdapter.java:109) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter.onMessageReceived(GridNioSslFilter.java:408) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterAdapter.proceedMessageReceived(GridNioFilterAdapter.java:109) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioServer$HeadFilter.onMessageReceived(GridNioServer.java:3752) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterChain.onMessageReceived(GridNioFilterChain.java:175) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioServer$DirectNioClientWorker.processRead(GridNioServer.java:1379) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioServer$AbstractNioClientWorker.processSelectedKeysOptimized(GridNioServer.java:2526) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioServer$AbstractNioClientWorker.bodyInternal(GridNioServer.java:2281) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioServer$AbstractNioClientWorker.body(GridNioServer.java:1910) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:125) ~[ignite-core-14.1.0.jar:14.1.0]
    at java.lang.Thread.run(Thread.java:829) ~[?:?]
2023-05-31 00:26:50.271 [ERROR][grid-nio-worker-tcp-comm-7-#126%TcpCommunicationSpi%][org.apache.ignite.spi.communication.tcp.TcpCommunicationSpi] Closing NIO session because of unhandled exception.
org.apache.ignite.internal.util.nio.GridNioException: null
    at org.apache.ignite.internal.util.nio.GridNioServer$AbstractNioClientWorker.processSelectedKeysOptimized(GridNioServer.java:2552) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioServer$AbstractNioClientWorker.bodyInternal(GridNioServer.java:2281) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioServer$AbstractNioClientWorker.body(GridNioServer.java:1910) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:125) ~[ignite-core-14.1.0.jar:14.1.0]
    at java.lang.Thread.run(Thread.java:829) ~[?:?]
Caused by: java.lang.AssertionError
    at org.apache.ignite.internal.binary.GridBinaryMarshaller.deserialize(GridBinaryMarshaller.java:299) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.binary.BinaryMarshaller.unmarshal0(BinaryMarshaller.java:101) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.marshaller.AbstractNodeNameAwareMarshaller.unmarshal(AbstractNodeNameAwareMarshaller.java:80) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.IgniteUtils.unmarshal(IgniteUtils.java:10742) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.managers.communication.GridIoManager.onMessage0(GridIoManager.java:1273) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.managers.communication.GridIoManager.access$300(GridIoManager.java:243) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.managers.communication.GridIoManager$2.onMessage(GridIoManager.java:509) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.spi.communication.tcp.TcpCommunicationSpi.notifyListener(TcpCommunicationSpi.java:1220) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.spi.communication.tcp.TcpCommunicationSpi$1.onMessage(TcpCommunicationSpi.java:689) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.spi.communication.tcp.TcpCommunicationSpi$1.onMessage(TcpCommunicationSpi.java:687) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.spi.communication.tcp.internal.InboundConnectionHandler.onMessage(InboundConnectionHandler.java:393) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.spi.communication.tcp.internal.InboundConnectionHandler.onMessage(InboundConnectionHandler.java:79) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterChain$TailFilter.onMessageReceived(GridNioFilterChain.java:279) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterAdapter.proceedMessageReceived(GridNioFilterAdapter.java:109) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioCodecFilter.onMessageReceived(GridNioCodecFilter.java:116) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterAdapter.proceedMessageReceived(GridNioFilterAdapter.java:109) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridConnectionBytesVerifyFilter.onMessageReceived(GridConnectionBytesVerifyFilter.java:133) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterAdapter.proceedMessageReceived(GridNioFilterAdapter.java:109) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.ssl.GridNioSslFilter.onMessageReceived(GridNioSslFilter.java:408) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterAdapter.proceedMessageReceived(GridNioFilterAdapter.java:109) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioServer$HeadFilter.onMessageReceived(GridNioServer.java:3752) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioFilterChain.onMessageReceived(GridNioFilterChain.java:175) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioServer$DirectNioClientWorker.processRead(GridNioServer.java:1379) ~[ignite-core-14.1.0.jar:14.1.0]
    at org.apache.ignite.internal.util.nio.GridNioServer$AbstractNioClientWorker.processSelectedKeysOptimized(GridNioServer.java:2526) ~[ignite-core-14.1.0.jar:14.1.0]
    ... 4 more {code}
 ",,ignitetcbot,PetrovMikhail,,,,"petrov-mg opened a new pull request, #10768:
URL: https://github.com/apache/ignite/pull/10768

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;06/Jun/23 15:34;githubbot;600","sonarcloud[bot] commented on PR #10768:
URL: https://github.com/apache/ignite/pull/10768#issuecomment-1579010585

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10768)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10768&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10768&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10768&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_duplicated_lines_density&view=list)
   
   


;06/Jun/23 15:42;githubbot;600","sonarcloud[bot] commented on PR #10768:
URL: https://github.com/apache/ignite/pull/10768#issuecomment-1579053629

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10768)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10768&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10768&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10768&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_duplicated_lines_density&view=list)
   
   


;06/Jun/23 16:06;githubbot;600","sonarcloud[bot] commented on PR #10768:
URL: https://github.com/apache/ignite/pull/10768#issuecomment-1579140723

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10768)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10768&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10768&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10768&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_duplicated_lines_density&view=list)
   
   


;06/Jun/23 17:02;githubbot;600","alex-plekhanov commented on code in PR #10768:
URL: https://github.com/apache/ignite/pull/10768#discussion_r1221414869


##########
modules/core/src/test/java/org/apache/ignite/internal/managers/communication/IgniteMessageFactoryImplTest.java:
##########
@@ -112,6 +132,75 @@ public void testRegisterTheSameType() {
         new IgniteMessageFactoryImpl(factories);
     }
 
+    /** */
+    @Test
+    public void testIoMessageSerializationAndDeserializationConsistency() throws Exception {
+        TestMessageReader oneFieldReader = new TestMessageReader(1);
+        TestMessageWriter oneFieldWriter = new TestMessageWriter(1);
+
+        TestMessageReader unboundedReader = new TestMessageReader(MAX_VALUE);
+        TestMessageWriter unboundedWriter = new TestMessageWriter(MAX_VALUE);
+
+        IgniteMessageFactoryImpl msgFactory = new IgniteMessageFactoryImpl(new MessageFactory[]{new GridIoMessageFactory()});

Review Comment:
   What about `GridH2ValueMessageFactory` and `CalciteMessageFactory`?



##########
modules/core/src/test/java/org/apache/ignite/internal/managers/communication/IgniteMessageFactoryImplTest.java:
##########
@@ -112,6 +132,75 @@ public void testRegisterTheSameType() {
         new IgniteMessageFactoryImpl(factories);
     }
 
+    /** */
+    @Test
+    public void testIoMessageSerializationAndDeserializationConsistency() throws Exception {
+        TestMessageReader oneFieldReader = new TestMessageReader(1);
+        TestMessageWriter oneFieldWriter = new TestMessageWriter(1);
+
+        TestMessageReader unboundedReader = new TestMessageReader(MAX_VALUE);
+        TestMessageWriter unboundedWriter = new TestMessageWriter(MAX_VALUE);
+
+        IgniteMessageFactoryImpl msgFactory = new IgniteMessageFactoryImpl(new MessageFactory[]{new GridIoMessageFactory()});
+
+        for (short msgType : msgFactory.registeredDirectTypes()) {
+            checkSerializationAndDeserializationConsistency(msgFactory, msgType, oneFieldWriter, unboundedReader);
+
+            checkSerializationAndDeserializationConsistency(msgFactory, msgType, unboundedWriter, oneFieldReader);
+
+            checkSerializationAndDeserializationConsistency(msgFactory, msgType, oneFieldWriter, oneFieldReader);
+
+            checkSerializationAndDeserializationConsistency(msgFactory, msgType, unboundedWriter, unboundedReader);
+        }
+    }
+
+    /** */
+    private void checkSerializationAndDeserializationConsistency(
+        IgniteMessageFactory msgFactory,
+        short msgType,
+        TestMessageWriter writer,
+        TestMessageReader reader
+    ) throws Exception {
+        writer.reset();
+        reader.reset();
+
+        Message msg = msgFactory.create(msgType);
+
+        initializeMessage(msg);
+
+        while (!msg.writeTo(TEST_BYTE_BUFFER, writer)) {
+            // No-op.
+        }
+
+        msg = msgFactory.create(msgType);
+
+        reader.setCurrentReadClass(msg.getClass());
+
+        while (!msg.readFrom(TEST_BYTE_BUFFER, reader)) {
+            // No-op.
+        }
+
+        assertEquals(""The serialization and deserialization protocol is not consistent for the message [cls=""
+            + msg.getClass().getName() + ']', writer.writtenFields, reader.readFields);
+    }
+
+    /** */
+    private Message initializeMessage(Message msg) throws Exception {
+        if (msg instanceof NodeIdMessage) {
+            int msgSize = U.field(NodeIdMessage.class, ""MESSAGE_SIZE"");
+
+            FieldUtils.writeField(msg, ""nodeIdBytes"", new byte[msgSize], true);
+        }
+        else if (msg instanceof BinaryObjectImpl)

Review Comment:
   Perhaps, it's better to fix BinaryObjectImpl and use method `writeByteArray(""valBytes"", valBytes)` instead of `writeByteArray(""valBytes"", valBytes, 0, valBytes.length)` with the same result, but removing exception in test. WDYT?



;07/Jun/23 11:24;githubbot;600","sonarcloud[bot] commented on PR #10768:
URL: https://github.com/apache/ignite/pull/10768#issuecomment-1580855044

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10768)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10768&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10768&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10768&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10768&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_coverage&view=list)  
   [![0.1%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.1%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_duplicated_lines_density&view=list) [0.1% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10768&metric=new_duplicated_lines_density&view=list)
   
   


;07/Jun/23 13:44;githubbot;600","petrov-mg merged PR #10768:
URL: https://github.com/apache/ignite/pull/10768


;07/Jun/23 17:40;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,4200,,,0,4200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jun 07 17:45:11 UTC 2023,,,,,,,,,,"0|z1iblk:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"07/Jun/23 17:37;ignitetcbot;{panel:title=Branch: [pull/10768/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10768/head] Base: [master] : New Tests (4)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Queries 3 (lazy=true){color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7206206]]
* {color:#013220}IgniteBinaryCacheQueryLazyTestSuite3: H2CommunicationMessageSerializationTest.testMessageSerializationAndDeserializationConsistency - PASSED{color}

{color:#00008b}Queries 3{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7206205]]
* {color:#013220}IgniteBinaryCacheQueryTestSuite3: H2CommunicationMessageSerializationTest.testMessageSerializationAndDeserializationConsistency - PASSED{color}

{color:#00008b}Calcite SQL{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7206152]]
* {color:#013220}IgniteCalciteTestSuite: CalciteCommunicationMessageSerializationTest.testMessageSerializationAndDeserializationConsistency - PASSED{color}

{color:#00008b}Cache 10{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7206128]]
* {color:#013220}IgniteCacheTestSuite10: IgniteIoCommunicationMessageSerializationTest.testMessageSerializationAndDeserializationConsistency - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7206233&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","07/Jun/23 17:45;PetrovMikhail;[~alexpl], Thank you for the review.;;;",,,,
Failed to cancel rebalance,IGNITE-19648,13538615,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ibessonov,ibessonov,02/Jun/23 14:16,07/Jun/23 08:50,13/Jul/23 09:11,07/Jun/23 08:50,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"{noformat}
Caused by: org.apache.ignite.internal.storage.StorageRebalanceException: IGN-STORAGE-4 TraceId:8e22c456-103e-4445-9b35-e021e22cd615 Storage in the process of starting a rebalance: [table=TEST, partitionId=0]
    at org.apache.ignite.internal.storage.util.MvPartitionStorages.throwExceptionDependingOnOperationForRebalance(MvPartitionStorages.java:400)
    at org.apache.ignite.internal.storage.util.MvPartitionStorages.lambda$abortRebalance$16(MvPartitionStorages.java:265)
    at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1932)
    at org.apache.ignite.internal.storage.util.MvPartitionStorages.abortRebalance(MvPartitionStorages.java:261)
    at org.apache.ignite.internal.storage.pagememory.AbstractPageMemoryTableStorage.lambda$abortRebalancePartition$17(AbstractPageMemoryTableStorage.java:250)
    at org.apache.ignite.internal.util.IgniteUtils.inBusyLock(IgniteUtils.java:897)
    at org.apache.ignite.internal.storage.pagememory.AbstractPageMemoryTableStorage.abortRebalancePartition(AbstractPageMemoryTableStorage.java:250)    at org.apache.ignite.internal.table.distributed.raft.snapshot.PartitionAccessImpl.abortRebalance(PartitionAccessImpl.java:221){noformat}
Unfortunately, the entire log is lost. Issue occurred in one of org.apache.ignite.internal.raftsnapshot.ItTableRaftSnapshotsTest tests.",,ibessonov,rpuch,,,,"tkalkirill opened a new pull request, #2155:
URL: https://github.com/apache/ignite-3/pull/2155

   https://issues.apache.org/jira/browse/IGNITE-19648


;06/Jun/23 15:10;githubbot;600","rpuch commented on code in PR #2155:
URL: https://github.com/apache/ignite-3/pull/2155#discussion_r1221006155


##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/StorageOperation.java:
##########
@@ -109,6 +109,34 @@ String inProcessErrorMessage(String storageInfo) {
      * Storage rebalancing start operation.
      */
     static class StartRebalanceStorageOperation extends StorageOperation {
+        private final AtomicReference<AbortRebalanceStorageOperation> abortRebalanceOperation = new AtomicReference<>();
+
+        private final CompletableFuture<Void> startRebalanceFuture = new CompletableFuture<>();
+
+        /**
+         * Attempts to set the abort rebalance operation.
+         *
+         * @param abortRebalanceOperation Abort rebalance operation.
+         * @return {@code True} if the operation was set by current method invocation, {@code false} if by another method invocation.
+         */
+        boolean setAbortOperation(AbortRebalanceStorageOperation abortRebalanceOperation) {
+            return this.abortRebalanceOperation.compareAndSet(null, abortRebalanceOperation);
+        }
+
+        /**
+         * Returns {@link #setAbortOperation(AbortRebalanceStorageOperation) set} a abort rebalance operation.

Review Comment:
   ```suggestion
            * Returns the {@link #setAbortOperation(AbortRebalanceStorageOperation) set} abort rebalance operation.
   ```



##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/MvPartitionStorages.java:
##########
@@ -415,7 +430,15 @@ private String createStorageInProgressOfRebalanceErrorMessage(int partitionId) {
             return operation;
         }
 
-        return operation instanceof DestroyStorageOperation ? ((DestroyStorageOperation) operation).getCreateStorageOperation() : null;
+        if (operation instanceof DestroyStorageOperation) {
+            return ((DestroyStorageOperation) operation).getCreateStorageOperation();
+        }
+
+        if (operation instanceof StartRebalanceStorageOperation) {
+            return ((StartRebalanceStorageOperation) operation).getAbortRebalanceOperation();
+        }
+
+        return null;

Review Comment:
   It seems that `completeOperation()` does not describe very accurately what this method does. It's more about choosing the 'next' operation. How about renaming it? Maybe, to `nextOperationIfAvailable()`?



##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/MvPartitionStorages.java:
##########
@@ -238,14 +240,16 @@ public CompletableFuture<Void> startRebalance(int partitionId, Function<T, Compl
                     assert old == null : createStorageInfo(partitionId);
 
                     return startRebalanceFuture;
-                }).whenComplete((unused, throwable) ->
-                        operationByPartitionId.compute(partitionId, (partId, operation) -> {
-                            assert operation instanceof StartRebalanceStorageOperation :
-                                    createStorageInfo(partitionId) + "", op="" + operation;
+                }).whenComplete((unused, throwable) -> {
+                    operationByPartitionId.compute(partitionId, (partId, operation) -> {
+                        assert operation instanceof StartRebalanceStorageOperation : createStorageInfo(partitionId) + "", op="" + operation;
 
-                            return completeOperation(operation);
-                        })
-                );
+                        return completeOperation(operation);
+                    });
+
+                    // Even if an error occurs, we must be able to abort the rebalance, so we do not report the error.

Review Comment:
   Does this mean that we swallow the error?



##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/StorageOperation.java:
##########
@@ -109,6 +109,34 @@ String inProcessErrorMessage(String storageInfo) {
      * Storage rebalancing start operation.
      */
     static class StartRebalanceStorageOperation extends StorageOperation {
+        private final AtomicReference<AbortRebalanceStorageOperation> abortRebalanceOperation = new AtomicReference<>();

Review Comment:
   It looks like a comment explaining why we need this (an abortion waiting for the start to ... ahem... finish, probably) could be useful



##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/StorageOperation.java:
##########
@@ -109,6 +109,34 @@ String inProcessErrorMessage(String storageInfo) {
      * Storage rebalancing start operation.
      */
     static class StartRebalanceStorageOperation extends StorageOperation {
+        private final AtomicReference<AbortRebalanceStorageOperation> abortRebalanceOperation = new AtomicReference<>();
+
+        private final CompletableFuture<Void> startRebalanceFuture = new CompletableFuture<>();
+
+        /**
+         * Attempts to set the abort rebalance operation.
+         *
+         * @param abortRebalanceOperation Abort rebalance operation.
+         * @return {@code True} if the operation was set by current method invocation, {@code false} if by another method invocation.

Review Comment:
   ```suggestion
            * @return {@code true} if the operation was set by the current method invocation, {@code false} if by another method invocation.
   ```



##########
modules/storage-api/src/test/java/org/apache/ignite/internal/storage/util/MvPartitionStoragesTest.java:
##########
@@ -326,8 +326,6 @@ void testStartRebalance() {
 
         assertThrowsWithMessage(StorageRebalanceException.class, () -> startRebalanceMvStorage(0),
                 ""Storage in the process of starting a rebalance"");
-        assertThrowsWithMessage(StorageRebalanceException.class, () -> abortRebalanceMvStorage(0),
-                ""Storage in the process of starting a rebalance"");

Review Comment:
   Should we instead assert that it does NOT throw such an exception?



;07/Jun/23 07:28;githubbot;600","tkalkirill commented on code in PR #2155:
URL: https://github.com/apache/ignite-3/pull/2155#discussion_r1221075045


##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/StorageOperation.java:
##########
@@ -109,6 +109,34 @@ String inProcessErrorMessage(String storageInfo) {
      * Storage rebalancing start operation.
      */
     static class StartRebalanceStorageOperation extends StorageOperation {
+        private final AtomicReference<AbortRebalanceStorageOperation> abortRebalanceOperation = new AtomicReference<>();
+
+        private final CompletableFuture<Void> startRebalanceFuture = new CompletableFuture<>();
+
+        /**
+         * Attempts to set the abort rebalance operation.
+         *
+         * @param abortRebalanceOperation Abort rebalance operation.
+         * @return {@code True} if the operation was set by current method invocation, {@code false} if by another method invocation.
+         */
+        boolean setAbortOperation(AbortRebalanceStorageOperation abortRebalanceOperation) {
+            return this.abortRebalanceOperation.compareAndSet(null, abortRebalanceOperation);
+        }
+
+        /**
+         * Returns {@link #setAbortOperation(AbortRebalanceStorageOperation) set} a abort rebalance operation.

Review Comment:
   fix it



;07/Jun/23 07:46;githubbot;600","tkalkirill commented on code in PR #2155:
URL: https://github.com/apache/ignite-3/pull/2155#discussion_r1221076805


##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/MvPartitionStorages.java:
##########
@@ -415,7 +430,15 @@ private String createStorageInProgressOfRebalanceErrorMessage(int partitionId) {
             return operation;
         }
 
-        return operation instanceof DestroyStorageOperation ? ((DestroyStorageOperation) operation).getCreateStorageOperation() : null;
+        if (operation instanceof DestroyStorageOperation) {
+            return ((DestroyStorageOperation) operation).getCreateStorageOperation();
+        }
+
+        if (operation instanceof StartRebalanceStorageOperation) {
+            return ((StartRebalanceStorageOperation) operation).getAbortRebalanceOperation();
+        }
+
+        return null;

Review Comment:
   Why not.



;07/Jun/23 07:47;githubbot;600","tkalkirill commented on code in PR #2155:
URL: https://github.com/apache/ignite-3/pull/2155#discussion_r1221078830


##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/MvPartitionStorages.java:
##########
@@ -238,14 +240,16 @@ public CompletableFuture<Void> startRebalance(int partitionId, Function<T, Compl
                     assert old == null : createStorageInfo(partitionId);
 
                     return startRebalanceFuture;
-                }).whenComplete((unused, throwable) ->
-                        operationByPartitionId.compute(partitionId, (partId, operation) -> {
-                            assert operation instanceof StartRebalanceStorageOperation :
-                                    createStorageInfo(partitionId) + "", op="" + operation;
+                }).whenComplete((unused, throwable) -> {
+                    operationByPartitionId.compute(partitionId, (partId, operation) -> {
+                        assert operation instanceof StartRebalanceStorageOperation : createStorageInfo(partitionId) + "", op="" + operation;
 
-                            return completeOperation(operation);
-                        })
-                );
+                        return completeOperation(operation);
+                    });
+
+                    // Even if an error occurs, we must be able to abort the rebalance, so we do not report the error.

Review Comment:
   We don't need to handle an error on abort the rebalance, this error will be thrown to the code that triggered the rebalance.



;07/Jun/23 07:48;githubbot;600","tkalkirill commented on code in PR #2155:
URL: https://github.com/apache/ignite-3/pull/2155#discussion_r1221084037


##########
modules/storage-api/src/test/java/org/apache/ignite/internal/storage/util/MvPartitionStoragesTest.java:
##########
@@ -326,8 +326,6 @@ void testStartRebalance() {
 
         assertThrowsWithMessage(StorageRebalanceException.class, () -> startRebalanceMvStorage(0),
                 ""Storage in the process of starting a rebalance"");
-        assertThrowsWithMessage(StorageRebalanceException.class, () -> abortRebalanceMvStorage(0),
-                ""Storage in the process of starting a rebalance"");

Review Comment:
   I do not think that this is necessary, since this cancellation will abort the previously pushed rebalance.
   This behavior is being tested in the new test **testAbortRebalanceBeforeFinishStartRebalance**.



;07/Jun/23 07:51;githubbot;600","tkalkirill commented on code in PR #2155:
URL: https://github.com/apache/ignite-3/pull/2155#discussion_r1221087363


##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/StorageOperation.java:
##########
@@ -109,6 +109,34 @@ String inProcessErrorMessage(String storageInfo) {
      * Storage rebalancing start operation.
      */
     static class StartRebalanceStorageOperation extends StorageOperation {
+        private final AtomicReference<AbortRebalanceStorageOperation> abortRebalanceOperation = new AtomicReference<>();
+
+        private final CompletableFuture<Void> startRebalanceFuture = new CompletableFuture<>();
+
+        /**
+         * Attempts to set the abort rebalance operation.
+         *
+         * @param abortRebalanceOperation Abort rebalance operation.
+         * @return {@code True} if the operation was set by current method invocation, {@code false} if by another method invocation.

Review Comment:
   fix it



;07/Jun/23 07:52;githubbot;600","tkalkirill commented on code in PR #2155:
URL: https://github.com/apache/ignite-3/pull/2155#discussion_r1221113719


##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/StorageOperation.java:
##########
@@ -109,6 +109,34 @@ String inProcessErrorMessage(String storageInfo) {
      * Storage rebalancing start operation.
      */
     static class StartRebalanceStorageOperation extends StorageOperation {
+        private final AtomicReference<AbortRebalanceStorageOperation> abortRebalanceOperation = new AtomicReference<>();

Review Comment:
   Try to fix it.



;07/Jun/23 08:07;githubbot;600","rpuch commented on code in PR #2155:
URL: https://github.com/apache/ignite-3/pull/2155#discussion_r1221124867


##########
modules/storage-api/src/test/java/org/apache/ignite/internal/storage/util/MvPartitionStoragesTest.java:
##########
@@ -326,8 +326,6 @@ void testStartRebalance() {
 
         assertThrowsWithMessage(StorageRebalanceException.class, () -> startRebalanceMvStorage(0),
                 ""Storage in the process of starting a rebalance"");
-        assertThrowsWithMessage(StorageRebalanceException.class, () -> abortRebalanceMvStorage(0),
-                ""Storage in the process of starting a rebalance"");

Review Comment:
   Great!



;07/Jun/23 08:14;githubbot;600","tkalkirill merged PR #2155:
URL: https://github.com/apache/ignite-3/pull/2155


;07/Jun/23 08:50;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,6000,,,0,6000,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jun 07 08:16:09 UTC 2023,,,,,,,,,,"0|z1ib00:",9223372036854775807,,,rpuch,,,,,,,,,,,,,,,,,,"07/Jun/23 08:16;rpuch;The patch looks good to me;;;",,,,,
CatalogService should use HybridClock to register new Catalog version.,IGNITE-19642,13538579,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,amashenkov,amashenkov,amashenkov,02/Jun/23 11:24,09/Jun/23 14:28,13/Jul/23 09:11,09/Jun/23 14:28,,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,tech-debt,,"As of now we use System.currentTimestamp to assign timestamp for a new Catalog version.
Let's use HybridClock instead.

Also, there are bunch of Thread.sleep(5) in CatalogServiceSelftTest tests as a workaround for this issue. Let's also remove any waiting in tests.",,amashenkov,,,,,"AMashenkov opened a new pull request, #2154:
URL: https://github.com/apache/ignite-3/pull/2154

   https://issues.apache.org/jira/browse/IGNITE-19642


;06/Jun/23 14:44;githubbot;600","AMashenkov commented on PR #2154:
URL: https://github.com/apache/ignite-3/pull/2154#issuecomment-1579010127

   @rpuch , could you please review the PR.
   


;06/Jun/23 15:41;githubbot;600","rpuch commented on PR #2154:
URL: https://github.com/apache/ignite-3/pull/2154#issuecomment-1579095787

   Sure, I'll do it tomorrow


;06/Jun/23 16:32;githubbot;600","rpuch commented on code in PR #2154:
URL: https://github.com/apache/ignite-3/pull/2154#discussion_r1221353399


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/CatalogServiceImpl.java:
##########
@@ -519,7 +536,7 @@ public void handle(VersionedUpdate update) {
                 if (entry instanceof NewTableEntry) {
                     catalog = new Catalog(
                             version,
-                            System.currentTimeMillis(),
+                            activationTimestamp(),

Review Comment:
   If I'm not mistaken, `UpdateLog` acts like a WAL, and this code executes the commands contained in the `UpdateLog`.
   
   1. It looks like a command might be executed a few times during the lifetime of the cluster (and probably it will be executed on each node separately), so same schema update might get different activation ts throught its existence. This is not right: each schema update must have an immutable activation moment, and it must be the same on any node of the cluster.
   2. Activation timestamp must be bound to the Metastorage SafeTime; namely, an MS 'message' (from the leader to any cluster node) that transports a schema update must contain the 'message ts' (which, when consumed and fully processed by a node [so, after it makes all modifications to the in-memory Catalog representation], gets assigned to the node's local MS SafeTime variable) and also it must contain the schema update activation ts, and these two timestamps must be connected by the following equality: messageTs+DD=activationTs.
   
   So the activation moment should not be computed here, but in `saveUpdate()` (and it should probably be a part of `VersionedUpdate`).



;07/Jun/23 10:41;githubbot;600","AMashenkov commented on PR #2154:
URL: https://github.com/apache/ignite-3/pull/2154#issuecomment-1580800975

   > Another question is about `CatalogService` API: it's still using `long` to accept/pass timestamps, not `HybridTimestamp`. Is it planned to change this? Is it intentional that in the current PR this has not been changed?
   
   The CatalogService API is not final as we have no consumers for CatalogService API. So, I didn't change API intentionally.
   We use long instead of HybridTimestamp, because rw TX had no hybrid timestamps at a time we started working on the API.
   


;07/Jun/23 13:18;githubbot;600","AMashenkov merged PR #2154:
URL: https://github.com/apache/ignite-3/pull/2154


;09/Jun/23 14:27;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3600,,,0,3600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-19502,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-06-02 11:24:53.0,,,,,,,,,,"0|z1ias0:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
Catalog events are triggered too early.,IGNITE-19641,13538578,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,amashenkov,amashenkov,02/Jun/23 11:21,23/Jun/23 07:22,13/Jul/23 09:11,23/Jun/23 07:22,,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"As of now, Catalog events are triggered before a new version of Catalog is registered.
Catalog events doesn’t provide a new version of Catalog itself, but only a version number.
Thus, events doesn’t contain enough information in a context, which some components may need, and Catalog doesn’t contains a new version.",,amashenkov,,,,,"tkalkirill opened a new pull request, #2231:
URL: https://github.com/apache/ignite-3/pull/2231

   https://issues.apache.org/jira/browse/IGNITE-19641


;21/Jun/23 11:41;githubbot;600","AMashenkov commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1237074963


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/CatalogServiceImpl.java:
##########
@@ -651,18 +456,12 @@ public CompletableFuture<Void> createDistributionZone(CreateZoneParams params) {
         });
     }
 
-    /** {@inheritDoc} */
     @Override
     public CompletableFuture<Void> dropDistributionZone(DropZoneParams params) {
         return saveUpdate(catalog -> {
-            String zoneName = Objects.requireNonNull(params.zoneName(), ""zone"");
+            CatalogZoneDescriptor zone = getZone(catalog, params.zoneName());
 
-            CatalogZoneDescriptor zone = catalog.zone(zoneName);
-
-            if (zone == null) {
-                throw new DistributionZoneNotFoundException(zoneName);
-            }
-            if (zone.name().equals(CatalogService.DEFAULT_ZONE_NAME)) {
+            if (zone.name().equals(DEFAULT_ZONE_NAME)) {
                 //TODO IGNITE-19082 Can default zone be dropped?

Review Comment:
   Default zone can't be dropped. Later, we may allow to change default zone
   https://issues.apache.org/jira/browse/IGNITE-19687
   
   Let's just drop the todo.



;21/Jun/23 14:13;githubbot;600","AMashenkov commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1237108035


##########
modules/catalog/src/test/java/org/apache/ignite/internal/catalog/CatalogServiceSelfTest.java:
##########
@@ -1248,19 +1275,22 @@ public void testCreateIndexEvents() {
 
         // Create index.
         assertThat(service.createIndex(createIndexParams), willCompleteSuccessfully());
-        verify(eventListener).notify(any(CreateIndexEventParameters.class), ArgumentMatchers.isNull());
+        verify(eventListener, times(2)).notify(any(CreateIndexEventParameters.class), isNull());
 
         // Drop index.
         assertThat(service.dropIndex(dropIndexParams), willCompleteSuccessfully());
-        verify(eventListener).notify(any(DropIndexEventParameters.class), ArgumentMatchers.isNull());
+        verify(eventListener).notify(any(DropIndexEventParameters.class), isNull());
+
+        clearInvocations(eventListener);
 
         // Drop table.
         assertThat(service.dropTable(dropTableparams), willCompleteSuccessfully());
 
         // Try drop index once again.
         assertThat(service.dropIndex(dropIndexParams), willThrow(IndexNotFoundException.class));
 
-        verifyNoMoreInteractions(eventListener);
+        // Should have destroyed the pk index.
+        verify(eventListener).notify(any(DropIndexEventParameters.class), isNull());

Review Comment:
   It is not clear, if `DropIndexEventParameters` was caused by `dropTable` or `dropIndex` call.
   Let's move this higher.



;21/Jun/23 14:30;githubbot;600","AMashenkov commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1237108035


##########
modules/catalog/src/test/java/org/apache/ignite/internal/catalog/CatalogServiceSelfTest.java:
##########
@@ -1248,19 +1275,22 @@ public void testCreateIndexEvents() {
 
         // Create index.
         assertThat(service.createIndex(createIndexParams), willCompleteSuccessfully());
-        verify(eventListener).notify(any(CreateIndexEventParameters.class), ArgumentMatchers.isNull());
+        verify(eventListener, times(2)).notify(any(CreateIndexEventParameters.class), isNull());
 
         // Drop index.
         assertThat(service.dropIndex(dropIndexParams), willCompleteSuccessfully());
-        verify(eventListener).notify(any(DropIndexEventParameters.class), ArgumentMatchers.isNull());
+        verify(eventListener).notify(any(DropIndexEventParameters.class), isNull());
+
+        clearInvocations(eventListener);
 
         // Drop table.
         assertThat(service.dropTable(dropTableparams), willCompleteSuccessfully());
 
         // Try drop index once again.
         assertThat(service.dropIndex(dropIndexParams), willThrow(IndexNotFoundException.class));
 
-        verifyNoMoreInteractions(eventListener);
+        // Should have destroyed the pk index.
+        verify(eventListener).notify(any(DropIndexEventParameters.class), isNull());

Review Comment:
   It is not clear, if `DropIndexEventParameters` was caused by `dropTable` or `dropIndex` call.
   Let's move this to few lines higher.



;21/Jun/23 14:31;githubbot;600","ibessonov commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1237119534


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/CatalogServiceImpl.java:
##########
@@ -277,82 +259,62 @@ private Catalog catalogAt(long timestamp) {
         return entry.getValue();
     }
 
-    /** {@inheritDoc} */
     @Override
     public CompletableFuture<Void> createTable(CreateTableParams params) {
         return saveUpdate(catalog -> {
-            String schemaName = Objects.requireNonNullElse(params.schemaName(), CatalogService.PUBLIC);
-
-            CatalogSchemaDescriptor schema = Objects.requireNonNull(catalog.schema(schemaName), ""No schema found: "" + schemaName);
+            CatalogSchemaDescriptor schema = getSchema(catalog, params.schemaName());
 
             if (schema.table(params.tableName()) != null) {
-                throw new TableAlreadyExistsException(schemaName, params.tableName());
+                throw new TableAlreadyExistsException(schema.name(), params.tableName());
             }
 
-            params.columns().stream().map(ColumnParams::name).filter(Predicate.not(new HashSet<>()::add))
-                    .findAny().ifPresent(columnName -> {
-                        throw new IgniteInternalException(
-                                ErrorGroups.Index.INVALID_INDEX_DEFINITION_ERR, ""Can't create table with duplicate columns: ""
-                                + params.columns().stream().map(ColumnParams::name).collect(Collectors.joining("", ""))
-                        );
-                    });
+            validateParams(params);
+
+            CatalogZoneDescriptor zone = getZone(catalog, Objects.requireNonNullElse(params.zone(), DEFAULT_ZONE_NAME));
 
-            String zoneName = Objects.requireNonNullElse(params.zone(), CatalogService.DEFAULT_ZONE_NAME);
+            int id = catalog.objectIdGenState();
 
-            CatalogZoneDescriptor zone = Objects.requireNonNull(catalog.zone(zoneName), ""No zone found: "" + zoneName);
+            CatalogTableDescriptor table = CatalogUtils.fromParams(id++, zone.id(), params);
 
-            CatalogTableDescriptor table = CatalogUtils.fromParams(catalog.objectIdGenState(), zone.id(), params);
+            CatalogHashIndexDescriptor pkIndex = createHashIndexDescriptor(createPkIndexParams(params), table, id++);
 
             return List.of(
                     new NewTableEntry(table),
-                    new ObjectIdGenUpdateEntry(1)
+                    new NewIndexEntry(pkIndex),
+                    new ObjectIdGenUpdateEntry(id - catalog.objectIdGenState())
             );
         });
     }
 
-    /** {@inheritDoc} */
     @Override
     public CompletableFuture<Void> dropTable(DropTableParams params) {
         return saveUpdate(catalog -> {
-            String schemaName = Objects.requireNonNullElse(params.schemaName(), CatalogService.PUBLIC);
-
-            CatalogSchemaDescriptor schema = Objects.requireNonNull(catalog.schema(schemaName), ""No schema found: "" + schemaName);
+            CatalogSchemaDescriptor schema = getSchema(catalog, params.schemaName());
 
-            CatalogTableDescriptor table = schema.table(params.tableName());
-
-            if (table == null) {
-                throw new TableNotFoundException(schemaName, params.tableName());
-            }
+            CatalogTableDescriptor table = getTable(schema, params.tableName());
 
             List<UpdateEntry> updateEntries = new ArrayList<>();
 
             Arrays.stream(schema.indexes())
                     .filter(index -> index.tableId() == table.id())
-                    .forEach(index -> updateEntries.add(new DropIndexEntry(index.id())));
+                    .forEach(index -> updateEntries.add(new DropIndexEntry(index.id(), index.tableId())));

Review Comment:
   Why do you need a tableId here?



##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/commands/AbstractIndexCommandParams.java:
##########
@@ -41,6 +47,20 @@ public String schemaName() {
         return schema;
     }
 
+    /**
+     * Gets table name.
+     */
+    public String tableName() {
+        return tableName;
+    }
+
+    /**
+     * Returns {@code true} if index is unique, {@code false} otherwise.
+     */
+    public boolean unique() {

Review Comment:
   What does this have to do with current fix?



##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/CatalogServiceImpl.java:
##########
@@ -277,82 +259,62 @@ private Catalog catalogAt(long timestamp) {
         return entry.getValue();
     }
 
-    /** {@inheritDoc} */
     @Override
     public CompletableFuture<Void> createTable(CreateTableParams params) {
         return saveUpdate(catalog -> {
-            String schemaName = Objects.requireNonNullElse(params.schemaName(), CatalogService.PUBLIC);
-
-            CatalogSchemaDescriptor schema = Objects.requireNonNull(catalog.schema(schemaName), ""No schema found: "" + schemaName);
+            CatalogSchemaDescriptor schema = getSchema(catalog, params.schemaName());
 
             if (schema.table(params.tableName()) != null) {
-                throw new TableAlreadyExistsException(schemaName, params.tableName());
+                throw new TableAlreadyExistsException(schema.name(), params.tableName());
             }
 
-            params.columns().stream().map(ColumnParams::name).filter(Predicate.not(new HashSet<>()::add))
-                    .findAny().ifPresent(columnName -> {
-                        throw new IgniteInternalException(
-                                ErrorGroups.Index.INVALID_INDEX_DEFINITION_ERR, ""Can't create table with duplicate columns: ""
-                                + params.columns().stream().map(ColumnParams::name).collect(Collectors.joining("", ""))
-                        );
-                    });
+            validateParams(params);
+
+            CatalogZoneDescriptor zone = getZone(catalog, Objects.requireNonNullElse(params.zone(), DEFAULT_ZONE_NAME));

Review Comment:
   This and similar refactorings could have been done in another PR, they have nothing to do with the fix itself.



##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/events/AddColumnEventParameters.java:
##########
@@ -24,25 +24,27 @@
  * Add column event parameters contains descriptors of added columns.
  */
 public class AddColumnEventParameters extends CatalogEventParameters {
-
     private final int tableId;
-    private final List<CatalogTableColumnDescriptor> columnDescriptors;
+    private final List<CatalogTableColumnDescriptor> descriptors;

Review Comment:
   Why did you rename it? Old name was fine



##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/events/AlterZoneEventParameters.java:
##########
@@ -23,25 +23,25 @@
  * Alter zone event parameters contains a distribution zone descriptor for newly created distribution zone.
  */
 public class AlterZoneEventParameters extends CatalogEventParameters {
-
-    private final CatalogZoneDescriptor zoneDescriptor;
+    private final CatalogZoneDescriptor descriptor;

Review Comment:
   Same here. Why did you rename all these fields?



##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/events/AlterColumnEventParameters.java:
##########
@@ -23,32 +23,36 @@
  * Create table event parameters contains a column descriptor for the modified column.
  */
 public class AlterColumnEventParameters extends CatalogEventParameters {
-
     private final int tableId;
 
-    private final CatalogTableColumnDescriptor columnDescriptor;
+    private final CatalogTableColumnDescriptor descriptor;
 
     /**
      * Constructor.
      *
      * @param causalityToken Causality token.
-     * @param tableId Returns an id the table to be modified.
-     * @param columnDescriptor Descriptor for the column to be replaced.
+     * @param catalogVersion Catalog version.
+     * @param tableId Returns ID the table to be modified.
+     * @param descriptor Descriptor for the column to be replaced.
      */
-    public AlterColumnEventParameters(long causalityToken, int tableId, CatalogTableColumnDescriptor columnDescriptor) {
-        super(causalityToken);
+    public AlterColumnEventParameters(long causalityToken, int catalogVersion, int tableId, CatalogTableColumnDescriptor descriptor) {
+        super(causalityToken, catalogVersion);
 
         this.tableId = tableId;
-        this.columnDescriptor = columnDescriptor;
+        this.descriptor = descriptor;
     }
 
-    /** Returns an id of a modified table. */
+    /**
+     * Returns ID of a modified table.
+     */

Review Comment:
   Was this necessary? Do we have code style guide that recommends this formatting?
   If not, then you simply change someone-else's code by your own preference, without any other objective reason.
   I wouldn't mind it, but this PR is 1000+ lines of changes, and some of them are completely unnecessary. This forces me to look at more code than I should.



##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/events/AlterColumnEventParameters.java:
##########
@@ -23,32 +23,36 @@
  * Create table event parameters contains a column descriptor for the modified column.
  */
 public class AlterColumnEventParameters extends CatalogEventParameters {
-
     private final int tableId;
 
-    private final CatalogTableColumnDescriptor columnDescriptor;
+    private final CatalogTableColumnDescriptor descriptor;

Review Comment:
   And here. These are changes for the sake of changes



##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/storage/UpdateLogImpl.java:
##########
@@ -167,7 +169,7 @@ private void restoreStateFromVault(OnUpdateHandler handler) {
 
             VersionedUpdate update = fromBytes(entry.value());
 
-            handler.handle(update);
+            handler.handle(update, metastore.appliedRevision());

Review Comment:
   This has nothing to do with the fix. Please do it in a separate issue.



##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/storage/CatalogFireEvent.java:
##########
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.catalog.storage;
+
+import org.apache.ignite.internal.catalog.events.CatalogEvent;
+import org.apache.ignite.internal.catalog.events.CatalogEventParameters;
+
+/**
+ * Interface for firing events.

Review Comment:
   for updates that require firing events, I guess



##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/storage/AlterZoneEntry.java:
##########
@@ -37,12 +43,36 @@ public AlterZoneEntry(CatalogZoneDescriptor descriptor) {
         this.descriptor = descriptor;
     }
 
-    /** Returns descriptor of a zone to alter. */
+    /**
+     * Returns descriptor of a zone to alter.
+     */
     public CatalogZoneDescriptor descriptor() {
         return descriptor;
     }
 
-    /** {@inheritDoc} */
+    @Override
+    public CatalogEvent eventType() {
+        return CatalogEvent.ZONE_ALTER;
+    }
+
+    @Override
+    public CatalogEventParameters createEventParameters(long causalityToken, int catalogVersion) {
+        return new AlterZoneEventParameters(causalityToken, catalogVersion, descriptor);
+    }
+
+    @Override
+    public Catalog applyUpdate(Catalog catalog, VersionedUpdate update) {
+        return new Catalog(
+                update.version(),
+                update.activationTimestamp(),
+                catalog.objectIdGenState(),
+                catalog.zones().stream()
+                        .map(z -> z.id() == descriptor.id() ? descriptor : z)

Review Comment:
   `z`, is this the original name?



##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/events/AlterZoneEventParameters.java:
##########
@@ -23,25 +23,25 @@
  * Alter zone event parameters contains a distribution zone descriptor for newly created distribution zone.
  */
 public class AlterZoneEventParameters extends CatalogEventParameters {
-
-    private final CatalogZoneDescriptor zoneDescriptor;
+    private final CatalogZoneDescriptor descriptor;

Review Comment:
   I won't be leaving the same comment over and over again. I see these renames multiple times later.



##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/storage/UpdateEntry.java:
##########
@@ -18,9 +18,11 @@
 package org.apache.ignite.internal.catalog.storage;
 
 import java.io.Serializable;
+import org.apache.ignite.internal.catalog.Catalog;
 
 /**
- * A marker interface describing a particular change within the {@link VersionedUpdate group}.
+ * Interface describing a particular change within the {@link VersionedUpdate group}.
  */
 public interface UpdateEntry extends Serializable {
+    Catalog applyUpdate(Catalog catalog, VersionedUpdate update);

Review Comment:
   Where's javadoc?



;21/Jun/23 14:55;githubbot;600","tkalkirill commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1237456344


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/CatalogServiceImpl.java:
##########
@@ -651,18 +456,12 @@ public CompletableFuture<Void> createDistributionZone(CreateZoneParams params) {
         });
     }
 
-    /** {@inheritDoc} */
     @Override
     public CompletableFuture<Void> dropDistributionZone(DropZoneParams params) {
         return saveUpdate(catalog -> {
-            String zoneName = Objects.requireNonNull(params.zoneName(), ""zone"");
+            CatalogZoneDescriptor zone = getZone(catalog, params.zoneName());
 
-            CatalogZoneDescriptor zone = catalog.zone(zoneName);
-
-            if (zone == null) {
-                throw new DistributionZoneNotFoundException(zoneName);
-            }
-            if (zone.name().equals(CatalogService.DEFAULT_ZONE_NAME)) {
+            if (zone.name().equals(DEFAULT_ZONE_NAME)) {
                 //TODO IGNITE-19082 Can default zone be dropped?

Review Comment:
   Fix it



;21/Jun/23 18:57;githubbot;600","tkalkirill commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1237464401


##########
modules/catalog/src/test/java/org/apache/ignite/internal/catalog/CatalogServiceSelfTest.java:
##########
@@ -1248,19 +1275,22 @@ public void testCreateIndexEvents() {
 
         // Create index.
         assertThat(service.createIndex(createIndexParams), willCompleteSuccessfully());
-        verify(eventListener).notify(any(CreateIndexEventParameters.class), ArgumentMatchers.isNull());
+        verify(eventListener, times(2)).notify(any(CreateIndexEventParameters.class), isNull());
 
         // Drop index.
         assertThat(service.dropIndex(dropIndexParams), willCompleteSuccessfully());
-        verify(eventListener).notify(any(DropIndexEventParameters.class), ArgumentMatchers.isNull());
+        verify(eventListener).notify(any(DropIndexEventParameters.class), isNull());
+
+        clearInvocations(eventListener);
 
         // Drop table.
         assertThat(service.dropTable(dropTableparams), willCompleteSuccessfully());
 
         // Try drop index once again.
         assertThat(service.dropIndex(dropIndexParams), willThrow(IndexNotFoundException.class));
 
-        verifyNoMoreInteractions(eventListener);
+        // Should have destroyed the pk index.
+        verify(eventListener).notify(any(DropIndexEventParameters.class), isNull());

Review Comment:
   Before dropping the table, I call `clearInvocations(eventListener);`



;21/Jun/23 19:00;githubbot;600","tkalkirill commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1237469616


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/CatalogServiceImpl.java:
##########
@@ -277,82 +259,62 @@ private Catalog catalogAt(long timestamp) {
         return entry.getValue();
     }
 
-    /** {@inheritDoc} */
     @Override
     public CompletableFuture<Void> createTable(CreateTableParams params) {
         return saveUpdate(catalog -> {
-            String schemaName = Objects.requireNonNullElse(params.schemaName(), CatalogService.PUBLIC);
-
-            CatalogSchemaDescriptor schema = Objects.requireNonNull(catalog.schema(schemaName), ""No schema found: "" + schemaName);
+            CatalogSchemaDescriptor schema = getSchema(catalog, params.schemaName());
 
             if (schema.table(params.tableName()) != null) {
-                throw new TableAlreadyExistsException(schemaName, params.tableName());
+                throw new TableAlreadyExistsException(schema.name(), params.tableName());
             }
 
-            params.columns().stream().map(ColumnParams::name).filter(Predicate.not(new HashSet<>()::add))
-                    .findAny().ifPresent(columnName -> {
-                        throw new IgniteInternalException(
-                                ErrorGroups.Index.INVALID_INDEX_DEFINITION_ERR, ""Can't create table with duplicate columns: ""
-                                + params.columns().stream().map(ColumnParams::name).collect(Collectors.joining("", ""))
-                        );
-                    });
+            validateParams(params);
+
+            CatalogZoneDescriptor zone = getZone(catalog, Objects.requireNonNullElse(params.zone(), DEFAULT_ZONE_NAME));

Review Comment:
   What exactly should be done in another ticket I don't understand.



;21/Jun/23 19:00;githubbot;600","tkalkirill commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1237515837


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/CatalogServiceImpl.java:
##########
@@ -277,82 +259,62 @@ private Catalog catalogAt(long timestamp) {
         return entry.getValue();
     }
 
-    /** {@inheritDoc} */
     @Override
     public CompletableFuture<Void> createTable(CreateTableParams params) {
         return saveUpdate(catalog -> {
-            String schemaName = Objects.requireNonNullElse(params.schemaName(), CatalogService.PUBLIC);
-
-            CatalogSchemaDescriptor schema = Objects.requireNonNull(catalog.schema(schemaName), ""No schema found: "" + schemaName);
+            CatalogSchemaDescriptor schema = getSchema(catalog, params.schemaName());
 
             if (schema.table(params.tableName()) != null) {
-                throw new TableAlreadyExistsException(schemaName, params.tableName());
+                throw new TableAlreadyExistsException(schema.name(), params.tableName());
             }
 
-            params.columns().stream().map(ColumnParams::name).filter(Predicate.not(new HashSet<>()::add))
-                    .findAny().ifPresent(columnName -> {
-                        throw new IgniteInternalException(
-                                ErrorGroups.Index.INVALID_INDEX_DEFINITION_ERR, ""Can't create table with duplicate columns: ""
-                                + params.columns().stream().map(ColumnParams::name).collect(Collectors.joining("", ""))
-                        );
-                    });
+            validateParams(params);
+
+            CatalogZoneDescriptor zone = getZone(catalog, Objects.requireNonNullElse(params.zone(), DEFAULT_ZONE_NAME));
 
-            String zoneName = Objects.requireNonNullElse(params.zone(), CatalogService.DEFAULT_ZONE_NAME);
+            int id = catalog.objectIdGenState();
 
-            CatalogZoneDescriptor zone = Objects.requireNonNull(catalog.zone(zoneName), ""No zone found: "" + zoneName);
+            CatalogTableDescriptor table = CatalogUtils.fromParams(id++, zone.id(), params);
 
-            CatalogTableDescriptor table = CatalogUtils.fromParams(catalog.objectIdGenState(), zone.id(), params);
+            CatalogHashIndexDescriptor pkIndex = createHashIndexDescriptor(createPkIndexParams(params), table, id++);
 
             return List.of(
                     new NewTableEntry(table),
-                    new ObjectIdGenUpdateEntry(1)
+                    new NewIndexEntry(pkIndex),
+                    new ObjectIdGenUpdateEntry(id - catalog.objectIdGenState())
             );
         });
     }
 
-    /** {@inheritDoc} */
     @Override
     public CompletableFuture<Void> dropTable(DropTableParams params) {
         return saveUpdate(catalog -> {
-            String schemaName = Objects.requireNonNullElse(params.schemaName(), CatalogService.PUBLIC);
-
-            CatalogSchemaDescriptor schema = Objects.requireNonNull(catalog.schema(schemaName), ""No schema found: "" + schemaName);
+            CatalogSchemaDescriptor schema = getSchema(catalog, params.schemaName());
 
-            CatalogTableDescriptor table = schema.table(params.tableName());
-
-            if (table == null) {
-                throw new TableNotFoundException(schemaName, params.tableName());
-            }
+            CatalogTableDescriptor table = getTable(schema, params.tableName());
 
             List<UpdateEntry> updateEntries = new ArrayList<>();
 
             Arrays.stream(schema.indexes())
                     .filter(index -> index.tableId() == table.id())
-                    .forEach(index -> updateEntries.add(new DropIndexEntry(index.id())));
+                    .forEach(index -> updateEntries.add(new DropIndexEntry(index.id(), index.tableId())));

Review Comment:
   Made a separate ticket for this https://issues.apache.org/jira/browse/IGNITE-19798



;21/Jun/23 19:08;githubbot;600","tkalkirill commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1237551575


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/commands/AbstractIndexCommandParams.java:
##########
@@ -41,6 +47,20 @@ public String schemaName() {
         return schema;
     }
 
+    /**
+     * Gets table name.
+     */
+    public String tableName() {
+        return tableName;
+    }
+
+    /**
+     * Returns {@code true} if index is unique, {@code false} otherwise.
+     */
+    public boolean unique() {

Review Comment:
   Create ticket for this https://issues.apache.org/jira/browse/IGNITE-19799



;21/Jun/23 19:15;githubbot;600","tkalkirill commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1237557975


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/events/AddColumnEventParameters.java:
##########
@@ -24,25 +24,27 @@
  * Add column event parameters contains descriptors of added columns.
  */
 public class AddColumnEventParameters extends CatalogEventParameters {
-
     private final int tableId;
-    private final List<CatalogTableColumnDescriptor> columnDescriptors;
+    private final List<CatalogTableColumnDescriptor> descriptors;

Review Comment:
   But not for me.



##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/events/AlterColumnEventParameters.java:
##########
@@ -23,32 +23,36 @@
  * Create table event parameters contains a column descriptor for the modified column.
  */
 public class AlterColumnEventParameters extends CatalogEventParameters {
-
     private final int tableId;
 
-    private final CatalogTableColumnDescriptor columnDescriptor;
+    private final CatalogTableColumnDescriptor descriptor;

Review Comment:
   But not for me.



;21/Jun/23 19:16;githubbot;600","tkalkirill commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1237562111


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/events/AlterColumnEventParameters.java:
##########
@@ -23,32 +23,36 @@
  * Create table event parameters contains a column descriptor for the modified column.
  */
 public class AlterColumnEventParameters extends CatalogEventParameters {
-
     private final int tableId;
 
-    private final CatalogTableColumnDescriptor columnDescriptor;
+    private final CatalogTableColumnDescriptor descriptor;
 
     /**
      * Constructor.
      *
      * @param causalityToken Causality token.
-     * @param tableId Returns an id the table to be modified.
-     * @param columnDescriptor Descriptor for the column to be replaced.
+     * @param catalogVersion Catalog version.
+     * @param tableId Returns ID the table to be modified.
+     * @param descriptor Descriptor for the column to be replaced.
      */
-    public AlterColumnEventParameters(long causalityToken, int tableId, CatalogTableColumnDescriptor columnDescriptor) {
-        super(causalityToken);
+    public AlterColumnEventParameters(long causalityToken, int catalogVersion, int tableId, CatalogTableColumnDescriptor descriptor) {
+        super(causalityToken, catalogVersion);
 
         this.tableId = tableId;
-        this.columnDescriptor = columnDescriptor;
+        this.descriptor = descriptor;
     }
 
-    /** Returns an id of a modified table. */
+    /**
+     * Returns ID of a modified table.
+     */

Review Comment:
   It is grammatically correct to use ID.



;21/Jun/23 19:18;githubbot;600","tkalkirill commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1237563034


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/events/AlterZoneEventParameters.java:
##########
@@ -23,25 +23,25 @@
  * Alter zone event parameters contains a distribution zone descriptor for newly created distribution zone.
  */
 public class AlterZoneEventParameters extends CatalogEventParameters {
-
-    private final CatalogZoneDescriptor zoneDescriptor;
+    private final CatalogZoneDescriptor descriptor;

Review Comment:
   But not for me.



##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/storage/AlterZoneEntry.java:
##########
@@ -37,12 +43,36 @@ public AlterZoneEntry(CatalogZoneDescriptor descriptor) {
         this.descriptor = descriptor;
     }
 
-    /** Returns descriptor of a zone to alter. */
+    /**
+     * Returns descriptor of a zone to alter.
+     */
     public CatalogZoneDescriptor descriptor() {
         return descriptor;
     }
 
-    /** {@inheritDoc} */
+    @Override
+    public CatalogEvent eventType() {
+        return CatalogEvent.ZONE_ALTER;
+    }
+
+    @Override
+    public CatalogEventParameters createEventParameters(long causalityToken, int catalogVersion) {
+        return new AlterZoneEventParameters(causalityToken, catalogVersion, descriptor);
+    }
+
+    @Override
+    public Catalog applyUpdate(Catalog catalog, VersionedUpdate update) {
+        return new Catalog(
+                update.version(),
+                update.activationTimestamp(),
+                catalog.objectIdGenState(),
+                catalog.zones().stream()
+                        .map(z -> z.id() == descriptor.id() ? descriptor : z)

Review Comment:
   Yep



;21/Jun/23 19:18;githubbot;600","tkalkirill commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1237583162


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/storage/CatalogFireEvent.java:
##########
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.catalog.storage;
+
+import org.apache.ignite.internal.catalog.events.CatalogEvent;
+import org.apache.ignite.internal.catalog.events.CatalogEventParameters;
+
+/**
+ * Interface for firing events.

Review Comment:
   fix it



;21/Jun/23 19:26;githubbot;600","tkalkirill commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1237587629


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/storage/UpdateLogImpl.java:
##########
@@ -167,7 +169,7 @@ private void restoreStateFromVault(OnUpdateHandler handler) {
 
             VersionedUpdate update = fromBytes(entry.value());
 
-            handler.handle(update);
+            handler.handle(update, metastore.appliedRevision());

Review Comment:
   But the catalog creates events that are descendants of `org.apache.ignite.internal.manager.EventParameters` that require `causalityToken`, the catalog now passes the correct value.



;21/Jun/23 19:30;githubbot;600","tkalkirill commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238002599


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/storage/UpdateEntry.java:
##########
@@ -18,9 +18,11 @@
 package org.apache.ignite.internal.catalog.storage;
 
 import java.io.Serializable;
+import org.apache.ignite.internal.catalog.Catalog;
 
 /**
- * A marker interface describing a particular change within the {@link VersionedUpdate group}.
+ * Interface describing a particular change within the {@link VersionedUpdate group}.
  */
 public interface UpdateEntry extends Serializable {
+    Catalog applyUpdate(Catalog catalog, VersionedUpdate update);

Review Comment:
   Trie to fix it



;22/Jun/23 05:16;githubbot;600","korlov42 commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238017426


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/events/AddColumnEventParameters.java:
##########
@@ -24,25 +24,27 @@
  * Add column event parameters contains descriptors of added columns.
  */
 public class AddColumnEventParameters extends CatalogEventParameters {
-
     private final int tableId;
-    private final List<CatalogTableColumnDescriptor> columnDescriptors;
+    private final List<CatalogTableColumnDescriptor> descriptors;

Review Comment:
   what is wrong with original name? 



;22/Jun/23 05:38;githubbot;600","korlov42 commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238018549


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/events/AddColumnEventParameters.java:
##########
@@ -24,25 +24,27 @@
  * Add column event parameters contains descriptors of added columns.
  */
 public class AddColumnEventParameters extends CatalogEventParameters {
-
     private final int tableId;
-    private final List<CatalogTableColumnDescriptor> columnDescriptors;
+    private final List<CatalogTableColumnDescriptor> descriptors;
 
     /**
      * Constructor.
      *
      * @param causalityToken Causality token.
-     * @param tableId An id of table, which columns are added to.
-     * @param columnDescriptors New columns descriptors.
+     * @param catalogVersion Catalog version.
+     * @param tableId ID of table, which columns are added to.
+     * @param descriptors New columns descriptors.
      */
-    public AddColumnEventParameters(long causalityToken, int tableId, List<CatalogTableColumnDescriptor> columnDescriptors) {
-        super(causalityToken);
+    public AddColumnEventParameters(long causalityToken, int catalogVersion, int tableId, List<CatalogTableColumnDescriptor> descriptors) {
+        super(causalityToken, catalogVersion);
 
         this.tableId = tableId;
-        this.columnDescriptors = columnDescriptors;
+        this.descriptors = descriptors;
     }
 
-    /** Returns table id. */
+    /**
+     * Returns table ID.
+     */

Review Comment:
   single-line javadocs are perfectly fine, so, please, revert all such changes



;22/Jun/23 05:40;githubbot;600","korlov42 commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238020934


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/CatalogServiceImpl.java:
##########
@@ -150,66 +138,61 @@ public CatalogServiceImpl(UpdateLog updateLog, HybridClock clock, long delayDura
         this.delayDurationMs = delayDurationMs;
     }
 
-    /** {@inheritDoc} */

Review Comment:
   why did you remove this? 



;22/Jun/23 05:44;githubbot;600","korlov42 commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238021635


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/CatalogService.java:
##########
@@ -36,7 +36,7 @@
  * <p>TBD: events
  */
 public interface CatalogService {
-    String PUBLIC = ""PUBLIC"";

Review Comment:
   was it really necessary to rename this constant?



;22/Jun/23 05:46;githubbot;600","korlov42 commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238025041


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/CatalogServiceImpl.java:
##########
@@ -277,29 +254,18 @@ private Catalog catalogAt(long timestamp) {
         return entry.getValue();
     }
 
-    /** {@inheritDoc} */
     @Override
     public CompletableFuture<Void> createTable(CreateTableParams params) {
         return saveUpdate(catalog -> {
-            String schemaName = Objects.requireNonNullElse(params.schemaName(), CatalogService.PUBLIC);
-
-            CatalogSchemaDescriptor schema = Objects.requireNonNull(catalog.schema(schemaName), ""No schema found: "" + schemaName);
+            CatalogSchemaDescriptor schema = getSchema(catalog, params.schemaName());
 
             if (schema.table(params.tableName()) != null) {
-                throw new TableAlreadyExistsException(schemaName, params.tableName());
+                throw new TableAlreadyExistsException(schema.name(), params.tableName());
             }
 
-            params.columns().stream().map(ColumnParams::name).filter(Predicate.not(new HashSet<>()::add))
-                    .findAny().ifPresent(columnName -> {
-                        throw new IgniteInternalException(
-                                ErrorGroups.Index.INVALID_INDEX_DEFINITION_ERR, ""Can't create table with duplicate columns: ""
-                                + params.columns().stream().map(ColumnParams::name).collect(Collectors.joining("", ""))
-                        );
-                    });
+            validateParams(params);
 
-            String zoneName = Objects.requireNonNullElse(params.zone(), CatalogService.DEFAULT_ZONE_NAME);
-
-            CatalogZoneDescriptor zone = Objects.requireNonNull(catalog.zone(zoneName), ""No zone found: "" + zoneName);
+            CatalogZoneDescriptor zone = getZone(catalog, Objects.requireNonNullElse(params.zone(), DEFAULT_ZONE_NAME));

Review Comment:
   All this refactoring has nothing to do with problem to be solved within the ticket (IGNITE-19641). So, please, move it to another patch



;22/Jun/23 05:51;githubbot;600","korlov42 commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238029989


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/CatalogServiceImpl.java:
##########
@@ -1089,4 +644,195 @@ private static void throwUnsupportedDdl(String msg, Object... params) {
     interface UpdateProducer {
         List<UpdateEntry> get(Catalog catalog);
     }
+
+    private static CatalogSchemaDescriptor getSchema(Catalog catalog, @Nullable String schemaName) {

Review Comment:
   all this new lines have nothing to do with the problem described in ticket, so, please, move it to another patch



;22/Jun/23 05:58;githubbot;600","korlov42 commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238031732


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/events/CatalogEventParameters.java:
##########
@@ -23,12 +23,24 @@
  * Base class for Catalog event parameters.
  */
 public abstract class CatalogEventParameters extends EventParameters {
+    private final int catalogVersion;
+
     /**
      * Constructor.
      *
      * @param causalityToken Causality token.
+     * @param catalogVersion Catalog version.
      */
-    public CatalogEventParameters(long causalityToken) {
+    public CatalogEventParameters(long causalityToken, int catalogVersion) {

Review Comment:
   why version of the catalog can't be causality token?



;22/Jun/23 06:01;githubbot;600","tkalkirill commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238047928


##########
modules/catalog/src/test/java/org/apache/ignite/internal/catalog/CatalogServiceSelfTest.java:
##########
@@ -1248,19 +1275,22 @@ public void testCreateIndexEvents() {
 
         // Create index.
         assertThat(service.createIndex(createIndexParams), willCompleteSuccessfully());
-        verify(eventListener).notify(any(CreateIndexEventParameters.class), ArgumentMatchers.isNull());
+        verify(eventListener, times(2)).notify(any(CreateIndexEventParameters.class), isNull());
 
         // Drop index.
         assertThat(service.dropIndex(dropIndexParams), willCompleteSuccessfully());
-        verify(eventListener).notify(any(DropIndexEventParameters.class), ArgumentMatchers.isNull());
+        verify(eventListener).notify(any(DropIndexEventParameters.class), isNull());
+
+        clearInvocations(eventListener);
 
         // Drop table.
         assertThat(service.dropTable(dropTableparams), willCompleteSuccessfully());
 
         // Try drop index once again.
         assertThat(service.dropIndex(dropIndexParams), willThrow(IndexNotFoundException.class));
 
-        verifyNoMoreInteractions(eventListener);
+        // Should have destroyed the pk index.
+        verify(eventListener).notify(any(DropIndexEventParameters.class), isNull());

Review Comment:
   Revert it



;22/Jun/23 06:19;githubbot;600","korlov42 commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238050421


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/storage/CatalogFireEvent.java:
##########
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.catalog.storage;
+
+import org.apache.ignite.internal.catalog.events.CatalogEvent;
+import org.apache.ignite.internal.catalog.events.CatalogEventParameters;
+
+/**
+ * Interface for updates that require firing events.
+ */
+public interface CatalogFireEvent {

Review Comment:
   Within the package 'storage' there is no single class whose name has prefix ""Catalog"", thus let's make naming consistent.
   Also, `fireEvent` is a good name for method to fire event, but not for the object that provides the event. Have you considered the names like `Fireable`, `EventSource`, or `EventProvider`?



;22/Jun/23 06:22;githubbot;600","ibessonov commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238084242


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/events/CatalogEventParameters.java:
##########
@@ -23,12 +23,24 @@
  * Base class for Catalog event parameters.
  */
 public abstract class CatalogEventParameters extends EventParameters {
+    private final int catalogVersion;
+
     /**
      * Constructor.
      *
      * @param causalityToken Causality token.
+     * @param catalogVersion Catalog version.
      */
-    public CatalogEventParameters(long causalityToken) {
+    public CatalogEventParameters(long causalityToken, int catalogVersion) {

Review Comment:
   I was involved in it. Right now we only have meta-storage revision as a causality token. If we use two different entities, calling it the same name, it will lead to confusion. It's easier and safer to migrate meta-storage revision into a catalog version later with a single commit



;22/Jun/23 06:58;githubbot;600","ibessonov commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238085646


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/events/AlterColumnEventParameters.java:
##########
@@ -23,32 +23,36 @@
  * Create table event parameters contains a column descriptor for the modified column.
  */
 public class AlterColumnEventParameters extends CatalogEventParameters {
-
     private final int tableId;
 
-    private final CatalogTableColumnDescriptor columnDescriptor;
+    private final CatalogTableColumnDescriptor descriptor;

Review Comment:
   Please justify it then, providing a good argument.
   Again, this would be fine if you didn't have another 1000 lines of refactoring here



;22/Jun/23 07:00;githubbot;600","ibessonov commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238087675


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/CatalogServiceImpl.java:
##########
@@ -277,82 +259,62 @@ private Catalog catalogAt(long timestamp) {
         return entry.getValue();
     }
 
-    /** {@inheritDoc} */
     @Override
     public CompletableFuture<Void> createTable(CreateTableParams params) {
         return saveUpdate(catalog -> {
-            String schemaName = Objects.requireNonNullElse(params.schemaName(), CatalogService.PUBLIC);
-
-            CatalogSchemaDescriptor schema = Objects.requireNonNull(catalog.schema(schemaName), ""No schema found: "" + schemaName);
+            CatalogSchemaDescriptor schema = getSchema(catalog, params.schemaName());
 
             if (schema.table(params.tableName()) != null) {
-                throw new TableAlreadyExistsException(schemaName, params.tableName());
+                throw new TableAlreadyExistsException(schema.name(), params.tableName());
             }
 
-            params.columns().stream().map(ColumnParams::name).filter(Predicate.not(new HashSet<>()::add))
-                    .findAny().ifPresent(columnName -> {
-                        throw new IgniteInternalException(
-                                ErrorGroups.Index.INVALID_INDEX_DEFINITION_ERR, ""Can't create table with duplicate columns: ""
-                                + params.columns().stream().map(ColumnParams::name).collect(Collectors.joining("", ""))
-                        );
-                    });
+            validateParams(params);
+
+            CatalogZoneDescriptor zone = getZone(catalog, Objects.requireNonNullElse(params.zone(), DEFAULT_ZONE_NAME));

Review Comment:
   Refactoring that has nothing to do with the fix you provide. `createTable` is not related to anything described in the original issue, just as any other ""alter"" methods. You only changed the part where updates are being converted to events. I'm all for refactoring that part, it's good, but everything else is just confusing and unnecessary



;22/Jun/23 07:02;githubbot;600","ibessonov commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238089630


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/events/AlterColumnEventParameters.java:
##########
@@ -23,32 +23,36 @@
  * Create table event parameters contains a column descriptor for the modified column.
  */
 public class AlterColumnEventParameters extends CatalogEventParameters {
-
     private final int tableId;
 
-    private final CatalogTableColumnDescriptor columnDescriptor;
+    private final CatalogTableColumnDescriptor descriptor;
 
     /**
      * Constructor.
      *
      * @param causalityToken Causality token.
-     * @param tableId Returns an id the table to be modified.
-     * @param columnDescriptor Descriptor for the column to be replaced.
+     * @param catalogVersion Catalog version.
+     * @param tableId Returns ID the table to be modified.
+     * @param descriptor Descriptor for the column to be replaced.
      */
-    public AlterColumnEventParameters(long causalityToken, int tableId, CatalogTableColumnDescriptor columnDescriptor) {
-        super(causalityToken);
+    public AlterColumnEventParameters(long causalityToken, int catalogVersion, int tableId, CatalogTableColumnDescriptor descriptor) {
+        super(causalityToken, catalogVersion);
 
         this.tableId = tableId;
-        this.columnDescriptor = columnDescriptor;
+        this.descriptor = descriptor;
     }
 
-    /** Returns an id of a modified table. */
+    /**
+     * Returns ID of a modified table.
+     */

Review Comment:
   Ok, but converting
   ```
   /** Foo. */
   ```
   into
   ```
   /**
    * Foo.
    */
   ```
   is not related to grammar



;22/Jun/23 07:04;githubbot;600","ibessonov commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238092368


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/storage/UpdateLogImpl.java:
##########
@@ -167,7 +169,7 @@ private void restoreStateFromVault(OnUpdateHandler handler) {
 
             VersionedUpdate update = fromBytes(entry.value());
 
-            handler.handle(update);
+            handler.handle(update, metastore.appliedRevision());

Review Comment:
   It's only required now because you added it, but ok, this change is not as big as the rest



;22/Jun/23 07:07;githubbot;600","ibessonov commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238093227


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/CatalogService.java:
##########
@@ -36,7 +36,7 @@
  * <p>TBD: events
  */
 public interface CatalogService {
-    String PUBLIC = ""PUBLIC"";

Review Comment:
   I would say that this remove is justified, but in another PR maybe. Name ""PUBLIC"" says nothing about what it is, and there's no javadoc to clarify things either.



;22/Jun/23 07:08;githubbot;600","korlov42 commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1238615534


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/storage/UpdateEntry.java:
##########
@@ -18,9 +18,18 @@
 package org.apache.ignite.internal.catalog.storage;
 
 import java.io.Serializable;
+import org.apache.ignite.internal.catalog.Catalog;
 
 /**
- * A marker interface describing a particular change within the {@link VersionedUpdate group}.
+ * Interface describing a particular change within the {@link VersionedUpdate group}.
  */
 public interface UpdateEntry extends Serializable {
+    /**
+     * Applies own change to the catalog.
+     *
+     * @param catalog Current catalog.
+     * @param update Group of changes that relates to specified version.
+     * @return New catalog.
+     */
+    Catalog applyUpdate(Catalog catalog, VersionedUpdate update);

Review Comment:
   this signature doesn't feel right. Which update should I apply to the catalog? Why do I need VersionedUpdate at all? Should I verify that current entry is part of VersionedUpdate.
   
   If you need to bump version, it's better to do as post processing of all updates



;22/Jun/23 15:35;githubbot;600","tkalkirill commented on code in PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231#discussion_r1239353061


##########
modules/catalog/src/main/java/org/apache/ignite/internal/catalog/storage/UpdateEntry.java:
##########
@@ -18,9 +18,18 @@
 package org.apache.ignite.internal.catalog.storage;
 
 import java.io.Serializable;
+import org.apache.ignite.internal.catalog.Catalog;
 
 /**
- * A marker interface describing a particular change within the {@link VersionedUpdate group}.
+ * Interface describing a particular change within the {@link VersionedUpdate group}.
  */
 public interface UpdateEntry extends Serializable {
+    /**
+     * Applies own change to the catalog.
+     *
+     * @param catalog Current catalog.
+     * @param update Group of changes that relates to specified version.
+     * @return New catalog.
+     */
+    Catalog applyUpdate(Catalog catalog, VersionedUpdate update);

Review Comment:
   Fix it



;23/Jun/23 06:01;githubbot;600","tkalkirill merged PR #2231:
URL: https://github.com/apache/ignite-3/pull/2231


;23/Jun/23 07:22;githubbot;600",,,,,,,,,,,,,0,20400,,,0,20400,,,,,,,IGNITE-19500,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-19502,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-06-02 11:21:52.0,,,,,,,,,,"0|z1iars:",9223372036854775807,,,korlov,,,,,,,,,,,,,,,,,,,,,,,
Fix PMD error when building the SQL module,IGNITE-19634,13538562,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Trivial,Fixed,apolovtcev,apolovtcev,apolovtcev,02/Jun/23 10:09,02/Jun/23 12:34,13/Jul/23 09:11,02/Jun/23 12:34,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"When building the project, I get the following error when executing the {{:ignite-sql-engine:pmdMain}} task:

{noformat}
PMDException: Error while parsing modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/exp/RexToLixTranslator.java
{noformat}

Looks like updating the PMD plugin solves this issue.",,apolovtcev,sdanilov,,,,"sashapolo opened a new pull request, #2139:
URL: https://github.com/apache/ignite-3/pull/2139

   https://issues.apache.org/jira/browse/IGNITE-19634


;02/Jun/23 12:22;githubbot;600","SammyVimes merged PR #2139:
URL: https://github.com/apache/ignite-3/pull/2139


;02/Jun/23 12:34;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Jun 02 12:34:54 UTC 2023,,,,,,,,,,"0|z1iao8:",9223372036854775807,,,sdanilov,,,,,,,,,,,,,,,,,,"02/Jun/23 12:34;sdanilov;The patch looks good to me. Thank you for the contribution, merged to the main branch;;;",,,,,
Fix ItReadOnlyTransactionTest failed tests,IGNITE-19627,13538437,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,maliev,maliev,maliev,01/Jun/23 15:20,01/Jun/23 16:08,13/Jul/23 09:11,01/Jun/23 16:08,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Tests from {{ItReadOnlyTransactionTest}} started to fail

https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_IntegrationTests_ModuleRunner/7264289?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandBuildProblemsSection=true&expandBuildChangesSection=true&expandBuildTestsSection=true


{code:java}
org.opentest4j.AssertionFailedError: Too long to execute [delay=306] ==> expected: <true> but was: <false>
{code}



{code:java}
org.opentest4j.AssertionFailedError: expected: <str 100> but was: <new str 100>
{code}


The root cause is that the tests were sharing the same table, and when one test failed ({{testFutureRead}}), the second one ({{testPastRead}}) started to fail because table state was wrong. Previously the state of the table was cleaned at the tests itself, not in the {{@ AfterEach}} block.

The {{testFutureRead()}} test failure was connected with the fact that test run was too slow and invariant for read from future was violated. I propose to increase a bit {{FUTURE_GAP}} -- the gap for read in future for RO tx. ",,maliev,,,,,"alievmirza opened a new pull request, #2133:
URL: https://github.com/apache/ignite-3/pull/2133

   https://issues.apache.org/jira/browse/IGNITE-19627


;01/Jun/23 15:35;githubbot;600","sk0x50 merged PR #2133:
URL: https://github.com/apache/ignite-3/pull/2133


;01/Jun/23 16:06;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-06-01 15:20:49.0,,,,,,,,,,"0|z1i9wo:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
Slow query planning,IGNITE-19621,13538413,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,zstan,Berkov,Berkov,01/Jun/23 12:45,23/Jun/23 14:23,13/Jul/23 09:11,23/Jun/23 14:23,3.0,3.0.0-beta1,,,,,,3.0.0-beta2,sql,,,0,calcite3-required,ignite-3,,"Query from the TPC-H benchmark took 13 to 18 seconds to plan (try to execute on an empty TPCH tables)

Problem query is:
{code:java}
select   sum(case when nation = 'aaaa' then volume else 0 end) / sum(volume) as mkt_share , o_year
from ( 
   select floor(UNIX_MILLIS(o_orderdate) / (cast (365 as bigint) * 86400000))  as o_year, 
   l_extendedprice * (1 - l_discount) as volume, 
   n2.n_name as nation 
   from part, supplier, lineitem, orders, customer, nation n1, nation n2, region 
   where p_partkey = l_partkey and s_suppkey = l_suppkey and l_orderkey = o_orderkey and o_custkey = c_custkey and c_nationkey = n1.n_nationkey 
       and n1.n_regionkey = r_regionkey and r_name = 'rrr2' and s_nationkey = n2.n_nationkey 
       and o_orderdate between '2020-01-01' and '2020-03-01'
       and p_type = 1111
) as all_nations 
group by o_year 
order by o_year     
{code}
Second run took about 50ms (query cache works fine).

See ddl in attachment.",,Berkov,,,,,"zstan opened a new pull request, #2202:
URL: https://github.com/apache/ignite-3/pull/2202

   =


;16/Jun/23 06:28;githubbot;600","korlov42 commented on code in PR #2202:
URL: https://github.com/apache/ignite-3/pull/2202#discussion_r1233749832


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/rule/logical/ExposeIndexRule.java:
##########
@@ -79,6 +83,14 @@ public void onMatch(RelOptRuleCall call) {
         call.transformTo(indexes.get(0), equivMap);
     }
 
+    /** Filter pre known not applicable variants. Significant shrink search space in some cases. */
+    private static boolean filter(IgniteTable table, String idxName, List<SearchBounds> searchBounds) {

Review Comment:
   With such approach pk index won't be chosen for CNLJ



;19/Jun/23 09:03;githubbot;600","korlov42 commented on code in PR #2202:
URL: https://github.com/apache/ignite-3/pull/2202#discussion_r1234092338


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/rule/logical/ExposeIndexRule.java:
##########
@@ -79,6 +83,14 @@ public void onMatch(RelOptRuleCall call) {
         call.transformTo(indexes.get(0), equivMap);
     }
 
+    /** Filter pre known not applicable variants. Significant shrink search space in some cases. */
+    private static boolean filter(IgniteTable table, String idxName, List<SearchBounds> searchBounds) {

Review Comment:
   seems I was wrong about pk index would not being chosen for CNLJ... Please ignore message above...



;19/Jun/23 13:47;githubbot;600","AMashenkov merged PR #2202:
URL: https://github.com/apache/ignite-3/pull/2202


;23/Jun/23 14:23;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"01/Jun/23 12:47;Berkov;ddl-ignite3.sql;https://issues.apache.org/jira/secure/attachment/13058705/ddl-ignite3.sql",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-19479,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,2023-06-01 12:45:17.0,,,,,,,,,,"0|z1i9rk:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
Index is not used while performing SELECT over an indexed column,IGNITE-19615,13538374,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,mzhuravkov,Artukhov,Artukhov,01/Jun/23 08:44,04/Jul/23 15:19,13/Jul/23 09:11,04/Jul/23 15:19,,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"Apache Ignite 3, rev. faac3854f687daab2de4580fd9666fb227bf4c3a
 
Performing SELECT on an indexed column does not utilize the index. This is shown on EXPLAIN query.
 
{noformat}
11:35:27.760 [Test worker] INFO org.gridgain.ai3tests.tests.IndexTests – Update: create table index_test_table_1(id INTEGER not null, field_1 TINYINT, field_2 SMALLINT, field_3 INTEGER, field_4 FLOAT, field_5 VARCHAR(50), primary key (id))
11:35:28.924 [Test worker] INFO org.gridgain.ai3tests.tests.IndexTests – Update: CREATE INDEX index_test_index_1_1 ON index_test_table_1 (field_2)
Jun 01, 2023 11:35:28 AM org.apache.ignite.internal.logger.IgniteLogger logInternal
INFO: Partition assignment change notification received [remoteAddress=localhost:10801]
11:35:29.003 [Test worker] INFO org.gridgain.ai3tests.tests.IndexTests – Update: INSERT INTO index_test_table_1 (id, field_1, field_2, field_3, field_4, field_5) VALUES (0, 0, 0, 0, 0.0, 'string_value_0')
11:35:30.529 [Test worker] INFO org.gridgain.ai3tests.tests.IndexTests – Update: INSERT INTO index_test_table_1 (id, field_1, field_2, field_3, field_4, field_5) VALUES (1, 1, 1, 1, 1.1, 'string_value_1')
11:35:30.571 [Test worker] INFO org.gridgain.ai3tests.tests.IndexTests – Update: INSERT INTO index_test_table_1 (id, field_1, field_2, field_3, field_4, field_5) VALUES (2, 2, 2, 2, 2.2, 'string_value_2')
...
11:35:33.189 [Test worker] INFO org.gridgain.ai3tests.tests.IndexTests – Update: INSERT INTO index_test_table_1 (id, field_1, field_2, field_3, field_4, field_5) VALUES (97, 97, 97, 97, 106.7, 'string_value_97')
11:35:33.212 [Test worker] INFO org.gridgain.ai3tests.tests.IndexTests – Update: INSERT INTO index_test_table_1 (id, field_1, field_2, field_3, field_4, field_5) VALUES (98, 98, 98, 98, 107.80000000000001, 'string_value_98')
11:35:33.236 [Test worker] INFO org.gridgain.ai3tests.tests.IndexTests – Update: INSERT INTO index_test_table_1 (id, field_1, field_2, field_3, field_4, field_5) VALUES (99, 99, 99, 99, 108.9, 'string_value_99')
11:35:33.258 [Test worker] INFO org.gridgain.ai3tests.tests.IndexTests – Query: SELECT * FROM index_test_table_1 WHERE field_2 = 50
11:35:33.513 [Test worker] INFO org.gridgain.ai3tests.tests.IndexTests – Query: explain plan for SELECT * FROM index_test_table_1 WHERE field_2 = 50
11:35:33.565 [Test worker] INFO org.gridgain.ai3tests.tests.IndexTests – Result: IgniteExchange(distribution=[single]): rowcount = 1500.0, cumulative cost = IgniteCost [rowCount=11500.0, cpu=41500.0, memory=0.0, io=240000.0, network=36000.0], id = 10103
IgniteTableScan(table=[[PUBLIC, INDEX_TEST_TABLE_1]], tableId=[8239005d-346b-40d9-afe7-c15923ef3020], filters=[=(CAST($t2):INTEGER, 50)], requiredColumns=[

{0, 1, 2, 3, 4, 5}

]): rowcount = 1500.0, cumulative cost = IgniteCost [rowCount=10000.0, cpu=40000.0, memory=0.0, io=240000.0, network=0.0], id = 10102
{noformat}


It is expected that {{explain plan for SELECT * FROM index_test_table_1 WHERE field_2 = 50}} query will contain {{IgniteIndexScan` with `index_test_index_1_1}}.",,akhitrin,Artukhov,korlov,,,"lowka opened a new pull request, #2196:
URL: https://github.com/apache/ignite-3/pull/2196

   Removed int type / interval type checks from TypeCoercion::needToCast(Type, Type) - it behaves exactly the same way as TypeUtils::needToCast (which was removed in https://issues.apache.org/jira/browse/IGNITE-19128).
   
   
   
   


;15/Jun/23 06:49;githubbot;600","lowka commented on PR #2196:
URL: https://github.com/apache/ignite-3/pull/2196#issuecomment-1604399991

   > After this patch an index is used indeed. But resulting plan is rather invalid. For a query like `SELECT val FROM my WHERE id = 100500`, where `id` is of type TINYINT, I've got following plan:
   > 
   > ```
   > IgniteExchange<...>
   >   IgniteIndexScan(<...>, searchBounds=[[ExactBounds [bound=CAST(100500):TINYINT NOT NULL]]], filters=[=(CAST($t0):INTEGER NOT NULL, 100500)]<...>
   > ```
   > 
   > this results in RuntimeException, since 100500 is out of range of TINYINT
   @korlov42 
   I going to look into it. I looked at the result of `IgniteSqlValidator` and it add `INTEGER` casts to both id and literal (this is expected). But somehow the bounds are still use `TINYINT`.


;23/Jun/23 14:55;githubbot;600","lowka commented on PR #2196:
URL: https://github.com/apache/ignite-3/pull/2196#issuecomment-1604448948

   Optimiser starts from:
   
   > LogicalProject(VAL=[$1]), id = 116
   >   LogicalFilter(condition=[=(CAST($0):INTEGER NOT NULL, 100500)]), id = 114
   >     IgniteLogicalTableScan(table=[[PUBLIC, MY]]), id = 113
       
   And produces:
   
   > IgniteExchange(distribution=[single]), id = 144
   >  IgniteTableScan(table=[[PUBLIC, MY]], filters=[=(CAST($t0):INTEGER NOT NULL, 100500)], projects=[[$t1]], requiredColumns=[{0, 1}]), id = 143    
   
   


;23/Jun/23 15:30;githubbot;600","lowka commented on PR #2196:
URL: https://github.com/apache/ignite-3/pull/2196#issuecomment-1604466190

   Yep. Types are correct.
   
   > SqlValidator BINARY_COMPARISON: CAST(`MY`.`ID` AS INTEGER) = 100500 types: INTEGER INTEGER
   
   So the problem should be in SearchBound assembly code.
   
   
   
   
   


;23/Jun/23 15:43;githubbot;600","lowka commented on PR #2196:
URL: https://github.com/apache/ignite-3/pull/2196#issuecomment-1611162176

   >The second problem is that it deals with literals only, while leaving dynamic params and columns references out of scope for some reason
   What makes you think so? Search bounds are built from arbitrary expression, optimizer wouldn't be able to select an index.
   But nonetheless I have reverted the changes to the state as were copied from ignite2.
   


;28/Jun/23 10:31;githubbot;600","lowka commented on PR #2196:
URL: https://github.com/apache/ignite-3/pull/2196#issuecomment-1611269431

   >I have reverted the changes to the state as were copied from ignite2.
   That would not work. Left all as it is - just renamed a method to `needToCastInIndex`.


;28/Jun/23 11:57;githubbot;600","lowka commented on PR #2196:
URL: https://github.com/apache/ignite-3/pull/2196#issuecomment-1613217462

   * Partially reverted changes, that were made in https://issues.apache.org/jira/browse/IGNITE-19128 and moved type cast checks to TypeUtils.
   * Added test cases with indexes to ImplicitCastsTest.
   


;29/Jun/23 13:49;githubbot;600","korlov42 commented on code in PR #2196:
URL: https://github.com/apache/ignite-3/pull/2196#discussion_r1247545689


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/TypeUtils.java:
##########
@@ -533,6 +535,55 @@ public static NativeType columnType2NativeType(ColumnType columnType, int precis
         }
     }
 
+    /** Checks whether cast operation is necessary in {@code SearchBound}. */
+    public static boolean needCastInSearchBounds(IgniteTypeFactory typeFactory, RelDataType fromType, RelDataType toType) {
+        // Check custom data types first.
+        if (toType.getSqlTypeName() == SqlTypeName.ANY || fromType.getSqlTypeName() == SqlTypeName.ANY) {
+            return customDataTypeNeedCast(typeFactory, fromType, toType);
+        }
+
+        // No need to cast between char and varchar.
+        if (SqlTypeUtil.isCharacter(toType) && SqlTypeUtil.isCharacter(fromType)) {
+            return false;
+        }
+
+        // No need to cast if the source type precedence list
+        // contains target type. i.e. do not cast from
+        // tinyint to int or int to bigint.
+        if (fromType.getPrecedenceList().containsType(toType)
+                && SqlTypeUtil.isIntType(fromType)
+                && SqlTypeUtil.isIntType(toType)) {
+            return false;
+        }
+
+        // Implicit type coercion does not handle nullability.
+        if (SqlTypeUtil.equalSansNullability(typeFactory, fromType, toType)) {
+            return false;
+        }
+        // Should keep sync with rules in SqlTypeCoercionRule.
+        assert SqlTypeUtil.canCastFrom(toType, fromType, true);
+        return true;
+    }
+
+    /**
+     * Checks whether one type can be casted to another if one of type is a custom data type.
+     * This method expects at least one of its arguments to be a custom data type.

Review Comment:
   ```suggestion
        * Checks whether one type can be casted to another if one of type is a custom data type.
        *
        * <p>This method expects at least one of its arguments to be a custom data type.
   ```



;30/Jun/23 07:42;githubbot;600","korlov42 commented on code in PR #2196:
URL: https://github.com/apache/ignite-3/pull/2196#discussion_r1247547914


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/TypeUtils.java:
##########
@@ -533,6 +535,55 @@ public static NativeType columnType2NativeType(ColumnType columnType, int precis
         }
     }
 
+    /** Checks whether cast operation is necessary in {@code SearchBound}. */
+    public static boolean needCastInSearchBounds(IgniteTypeFactory typeFactory, RelDataType fromType, RelDataType toType) {
+        // Check custom data types first.
+        if (toType.getSqlTypeName() == SqlTypeName.ANY || fromType.getSqlTypeName() == SqlTypeName.ANY) {
+            return customDataTypeNeedCast(typeFactory, fromType, toType);
+        }
+
+        // No need to cast between char and varchar.
+        if (SqlTypeUtil.isCharacter(toType) && SqlTypeUtil.isCharacter(fromType)) {
+            return false;
+        }
+
+        // No need to cast if the source type precedence list
+        // contains target type. i.e. do not cast from
+        // tinyint to int or int to bigint.
+        if (fromType.getPrecedenceList().containsType(toType)
+                && SqlTypeUtil.isIntType(fromType)
+                && SqlTypeUtil.isIntType(toType)) {
+            return false;
+        }
+
+        // Implicit type coercion does not handle nullability.
+        if (SqlTypeUtil.equalSansNullability(typeFactory, fromType, toType)) {
+            return false;
+        }
+        // Should keep sync with rules in SqlTypeCoercionRule.
+        assert SqlTypeUtil.canCastFrom(toType, fromType, true);
+        return true;
+    }
+
+    /**
+     * Checks whether one type can be casted to another if one of type is a custom data type.
+     * This method expects at least one of its arguments to be a custom data type.
+     */
+    public static boolean customDataTypeNeedCast(IgniteTypeFactory factory, RelDataType fromType, RelDataType toType) {
+        assert fromType.getSqlTypeName() == SqlTypeName.ANY || toType.getSqlTypeName() == SqlTypeName.ANY :

Review Comment:
   why do we need both this assertion and one on line 584? Let's leave only one on line 584 with improved message



;30/Jun/23 07:45;githubbot;600","korlov42 commented on code in PR #2196:
URL: https://github.com/apache/ignite-3/pull/2196#discussion_r1247553130


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/TypeUtils.java:
##########
@@ -533,6 +535,55 @@ public static NativeType columnType2NativeType(ColumnType columnType, int precis
         }
     }
 
+    /** Checks whether cast operation is necessary in {@code SearchBound}. */
+    public static boolean needCastInSearchBounds(IgniteTypeFactory typeFactory, RelDataType fromType, RelDataType toType) {
+        // Check custom data types first.
+        if (toType.getSqlTypeName() == SqlTypeName.ANY || fromType.getSqlTypeName() == SqlTypeName.ANY) {

Review Comment:
   this predicate doesn't seem right... Method `customDataTypeNeedCast` actually expects that at least one of the argument is instance of IgniteCustomType. If there is an invariant that there should not be any ANY type but IgniteCustomType, it's better to check it explicitly



;30/Jun/23 07:51;githubbot;600","lowka commented on code in PR #2196:
URL: https://github.com/apache/ignite-3/pull/2196#discussion_r1247555482


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/TypeUtils.java:
##########
@@ -533,6 +535,55 @@ public static NativeType columnType2NativeType(ColumnType columnType, int precis
         }
     }
 
+    /** Checks whether cast operation is necessary in {@code SearchBound}. */
+    public static boolean needCastInSearchBounds(IgniteTypeFactory typeFactory, RelDataType fromType, RelDataType toType) {
+        // Check custom data types first.
+        if (toType.getSqlTypeName() == SqlTypeName.ANY || fromType.getSqlTypeName() == SqlTypeName.ANY) {

Review Comment:
   @korlov42 yeap. I removed the first assertion since the second one is the only one that is needed.



;30/Jun/23 07:53;githubbot;600","korlov42 commented on code in PR #2196:
URL: https://github.com/apache/ignite-3/pull/2196#discussion_r1247560089


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/TypeUtils.java:
##########
@@ -533,6 +535,55 @@ public static NativeType columnType2NativeType(ColumnType columnType, int precis
         }
     }
 
+    /** Checks whether cast operation is necessary in {@code SearchBound}. */
+    public static boolean needCastInSearchBounds(IgniteTypeFactory typeFactory, RelDataType fromType, RelDataType toType) {
+        // Check custom data types first.
+        if (toType.getSqlTypeName() == SqlTypeName.ANY || fromType.getSqlTypeName() == SqlTypeName.ANY) {
+            return customDataTypeNeedCast(typeFactory, fromType, toType);

Review Comment:
   why do even need call in needCastInSearchBounds? This is the very same rule as in TypeCoercion 



;30/Jun/23 07:58;githubbot;600","lowka commented on code in PR #2196:
URL: https://github.com/apache/ignite-3/pull/2196#discussion_r1247659288


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/TypeUtils.java:
##########
@@ -533,6 +535,55 @@ public static NativeType columnType2NativeType(ColumnType columnType, int precis
         }
     }
 
+    /** Checks whether cast operation is necessary in {@code SearchBound}. */
+    public static boolean needCastInSearchBounds(IgniteTypeFactory typeFactory, RelDataType fromType, RelDataType toType) {
+        // Check custom data types first.
+        if (toType.getSqlTypeName() == SqlTypeName.ANY || fromType.getSqlTypeName() == SqlTypeName.ANY) {
+            return customDataTypeNeedCast(typeFactory, fromType, toType);

Review Comment:
   Fixed.



;30/Jun/23 09:28;githubbot;600","korlov42 merged PR #2196:
URL: https://github.com/apache/ignite-3/pull/2196


;04/Jul/23 15:18;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,8400,,,0,8400,,,,,,,,,,,,,,,,,,,,,IGNITE-19128,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Jul 04 15:19:30 UTC 2023,,,,,,,,,,"0|z1i9j4:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"04/Jul/23 15:19;korlov;[~mzhuravkov], thanks for contribution! 

Merged to [main|https://github.com/apache/ignite-3/commit/566458faa63f485b9c2439aed408b58f69e34f1e].;;;",,,,,
Flaky test fix - testStreamingIntoInMemoryDoesntAffectSnapshot(),IGNITE-19607,13538257,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,vladsz83,vladsz83,vladsz83,31/May/23 11:55,01/Jun/23 11:02,13/Jul/23 09:11,01/Jun/23 11:02,,,,,,,,2.16,,,,0,,,,"+
{code:java}
awaitPartitionMapExchange();
{code}
after
{code:java}
destroyCache()
{code}
to avoid
{code:java}
IgniteCheckedException: Unable to restore cache group - directory is not empty.
{code}
",,ignitetcbot,NSAmelchev,vladsz83,,,"Vladsz83 opened a new pull request, #10754:
URL: https://github.com/apache/ignite/pull/10754

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;31/May/23 12:04;githubbot;600","Vladsz83 closed pull request #10754: IGNITE-19607 : fix test streaming into in memory doesnt affect snapshot()
URL: https://github.com/apache/ignite/pull/10754


;31/May/23 12:07;githubbot;600","Vladsz83 opened a new pull request, #10755:
URL: https://github.com/apache/ignite/pull/10755

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;31/May/23 12:08;githubbot;600","Vladsz83 commented on PR #10754:
URL: https://github.com/apache/ignite/pull/10754#issuecomment-1570094098

   Moved to https://github.com/apache/ignite/pull/10755


;31/May/23 12:09;githubbot;600","NSAmelchev merged PR #10755:
URL: https://github.com/apache/ignite/pull/10755


;01/Jun/23 11:01;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jun 01 11:02:10 UTC 2023,,,,,,,,,,"0|z1i8t4:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"01/Jun/23 10:44;ignitetcbot;{panel:title=Branch: [pull/10755/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10755/head] Base: [master] : No new tests found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7197064&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","01/Jun/23 11:02;NSAmelchev;Merged into the master.

[~vladsz83] Thank you for the contribution.;;;",,,,
Linearize metaStorageManager.deployWatches and metaStorageManager.start(),IGNITE-19606,13538235,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,v.pyatkov,alapin,alapin,31/May/23 09:19,15/Jun/23 14:01,13/Jul/23 09:11,15/Jun/23 14:01,,,,,,,,,,,,0,ignite-3,,,"h3. Motivation

Occurred that in some tests deployWatches was called on not started metaStorageManager which leads to failures and unpredictable artifacts. In order to prevent such possibility it's required to linearize it though metaStorageSvcFut.
h3. Definition of Done

Calling deployWatches will chain with metaStorageManager.start().
h3. Implementation Notes
 * I don't think that it's worth to prepare some general solution for all IgniteComponents that will prevent calling their methods before start, for now, it's only about MetaStorage and deployWatches.
 * MetaStorageManager has two implementations MetaStorageManagerImpl and StandaloneMetaStorageManager, so we should have two tests for a given logic.
 * Linearization itself might be implemented though `metaStorageSvcFut.thenRun(() -> \{storage.startWatches(this::onRevisionApplied);});`

 ",,alapin,v.pyatkov,,,,"vldpyatkov opened a new pull request, #2183:
URL: https://github.com/apache/ignite-3/pull/2183

   …geManager.start()


;13/Jun/23 07:18;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228259420


##########
modules/distribution-zones/src/testFixtures/java/org/apache/ignite/internal/distributionzones/DistributionZonesTestUtil.java:
##########
@@ -313,17 +313,17 @@ public static void deployWatchesAndUpdateMetaStorageRevision(MetaStorageManager
             throws NodeStoppingException, InterruptedException {
         // Watches are deployed before distributionZoneManager start in order to update Meta Storage revision before
         // distributionZoneManager's recovery.
-        metaStorageManager.deployWatches();
+        var deployWatchesFut = metaStorageManager.deployWatches();

Review Comment:
   AFAIK it's not valid to use var here.



;13/Jun/23 14:50;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228270424


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -170,8 +170,10 @@ public interface MetaStorageManager extends IgniteComponent {
      * Starts all registered watches.
      *
      * <p>Should be called after all Ignite components have registered required watches and they are ready to process Meta Storage events.
+     *
+     * @return Future to complete.

Review Comment:
   Please add meaningful comment here.



;13/Jun/23 14:54;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228276622


##########
modules/distribution-zones/src/testFixtures/java/org/apache/ignite/internal/distributionzones/DistributionZonesTestUtil.java:
##########
@@ -313,17 +313,17 @@ public static void deployWatchesAndUpdateMetaStorageRevision(MetaStorageManager
             throws NodeStoppingException, InterruptedException {
         // Watches are deployed before distributionZoneManager start in order to update Meta Storage revision before
         // distributionZoneManager's recovery.
-        metaStorageManager.deployWatches();
+        var deployWatchesFut = metaStorageManager.deployWatches();
 
         // Bump Meta Storage applied revision by modifying a fake key. DistributionZoneManager breaks on start if Vault is not empty, but
         // Meta Storage revision is equal to 0.
         var fakeKey = new ByteArray(""foobar"");
 
-        CompletableFuture<Boolean> invokeFuture = metaStorageManager.invoke(
+        CompletableFuture<Boolean> invokeFuture = deployWatchesFut.thenCompose(unused -> metaStorageManager.invoke(

Review Comment:
   Is it the only place we should await deployWatches? 



;13/Jun/23 14:58;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228286531


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageDeployWatchesCorrectnessTest.java:
##########
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.lang.NodeStoppingException;
+import org.apache.ignite.network.ClusterService;
+import org.junit.jupiter.api.Test;
+
+/**
+ * There are tests of correctness invocation {@link MetaStorageManager#deployWatches()}.

Review Comment:
   It's just ""Test that checks correctness of an invocation ..."" without ""There are"".



;13/Jun/23 15:02;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228289667


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageDeployWatchesCorrectnessTest.java:
##########
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.lang.NodeStoppingException;
+import org.apache.ignite.network.ClusterService;
+import org.junit.jupiter.api.Test;
+
+/**
+ * There are tests of correctness invocation {@link MetaStorageManager#deployWatches()}.
+ */
+public class MetaStorageDeployWatchesCorrectnessTest extends IgniteAbstractTest {
+    @Test
+    public void tesMetaStorageManager() throws Exception {
+        HybridClock clock = new HybridClockImpl();
+        String mcNodeName = ""mc-node-1"";
+
+        ClusterManagementGroupManager cmgManager = mock(ClusterManagementGroupManager.class);
+        ClusterService clusterService = mock(ClusterService.class);
+        LogicalTopologyService logicalTopologyService = mock(LogicalTopologyService.class);
+        RaftManager raftManager = mock(RaftManager.class);
+
+        when(cmgManager.metaStorageNodes()).thenReturn(completedFuture(Set.of(mcNodeName)));
+        when(clusterService.nodeName()).thenReturn(mcNodeName);
+        when(raftManager.startRaftGroupNodeAndWaitNodeReadyFuture(any(), any(), any(), any(), any())).thenReturn(completedFuture(null));
+
+        var metastore = new MetaStorageManagerImpl(
+                new VaultManager(new InMemoryVaultService()),

Review Comment:
   VaultManager is an Ignite service, so please either start/stop it or use mock instead.



;13/Jun/23 15:04;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228294924


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageDeployWatchesCorrectnessTest.java:
##########
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.lang.NodeStoppingException;
+import org.apache.ignite.network.ClusterService;
+import org.junit.jupiter.api.Test;
+
+/**
+ * There are tests of correctness invocation {@link MetaStorageManager#deployWatches()}.
+ */
+public class MetaStorageDeployWatchesCorrectnessTest extends IgniteAbstractTest {
+    @Test
+    public void tesMetaStorageManager() throws Exception {
+        HybridClock clock = new HybridClockImpl();
+        String mcNodeName = ""mc-node-1"";
+
+        ClusterManagementGroupManager cmgManager = mock(ClusterManagementGroupManager.class);
+        ClusterService clusterService = mock(ClusterService.class);
+        LogicalTopologyService logicalTopologyService = mock(LogicalTopologyService.class);
+        RaftManager raftManager = mock(RaftManager.class);
+
+        when(cmgManager.metaStorageNodes()).thenReturn(completedFuture(Set.of(mcNodeName)));
+        when(clusterService.nodeName()).thenReturn(mcNodeName);
+        when(raftManager.startRaftGroupNodeAndWaitNodeReadyFuture(any(), any(), any(), any(), any())).thenReturn(completedFuture(null));
+
+        var metastore = new MetaStorageManagerImpl(
+                new VaultManager(new InMemoryVaultService()),
+                clusterService,
+                cmgManager,
+                logicalTopologyService,
+                raftManager,
+                new SimpleInMemoryKeyValueStorage(mcNodeName),
+                clock
+        );
+
+        checkCorrectness(metastore);

Review Comment:
   I'd rather use parametrized test here with method source (MethodSource) that will either return StandaloneMetaStorageManager or General meta storage. In that case checkCorrectness should be refactored to parametrized test itself.



;13/Jun/23 15:07;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228302585


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageDeployWatchesCorrectnessTest.java:
##########
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.lang.NodeStoppingException;
+import org.apache.ignite.network.ClusterService;
+import org.junit.jupiter.api.Test;
+
+/**
+ * There are tests of correctness invocation {@link MetaStorageManager#deployWatches()}.
+ */
+public class MetaStorageDeployWatchesCorrectnessTest extends IgniteAbstractTest {
+    @Test
+    public void tesMetaStorageManager() throws Exception {
+        HybridClock clock = new HybridClockImpl();
+        String mcNodeName = ""mc-node-1"";
+
+        ClusterManagementGroupManager cmgManager = mock(ClusterManagementGroupManager.class);
+        ClusterService clusterService = mock(ClusterService.class);
+        LogicalTopologyService logicalTopologyService = mock(LogicalTopologyService.class);
+        RaftManager raftManager = mock(RaftManager.class);
+
+        when(cmgManager.metaStorageNodes()).thenReturn(completedFuture(Set.of(mcNodeName)));
+        when(clusterService.nodeName()).thenReturn(mcNodeName);
+        when(raftManager.startRaftGroupNodeAndWaitNodeReadyFuture(any(), any(), any(), any(), any())).thenReturn(completedFuture(null));
+
+        var metastore = new MetaStorageManagerImpl(
+                new VaultManager(new InMemoryVaultService()),
+                clusterService,
+                cmgManager,
+                logicalTopologyService,
+                raftManager,
+                new SimpleInMemoryKeyValueStorage(mcNodeName),
+                clock
+        );
+
+        checkCorrectness(metastore);
+    }
+
+    @Test
+    public void tesStandaloneMetaStorageManager() throws Exception {
+        var metastore = StandaloneMetaStorageManager.create(new VaultManager(new InMemoryVaultService()));
+
+        checkCorrectness(metastore);
+    }
+
+    /**
+     * Invokes {@link MetaStorageManager#deployWatches()} and checks result.
+     *
+     * @param metastore Meta storage.
+     * @throws NodeStoppingException If failed.
+     */
+    private static void checkCorrectness(MetaStorageManager metastore) throws NodeStoppingException {
+        var deployWatchesFut = metastore.deployWatches();
+
+        assertFalse(deployWatchesFut.isDone());
+
+        metastore.start();

Review Comment:
    metastore.start() is  async thus `deployWatchesFut.isDone()` isn't guaranteed without some awaiting logic. Please use 
   `org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher#willSucceedFast` or similar instead.



;13/Jun/23 15:10;githubbot;600","vldpyatkov commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228308032


##########
modules/distribution-zones/src/testFixtures/java/org/apache/ignite/internal/distributionzones/DistributionZonesTestUtil.java:
##########
@@ -313,17 +313,17 @@ public static void deployWatchesAndUpdateMetaStorageRevision(MetaStorageManager
             throws NodeStoppingException, InterruptedException {
         // Watches are deployed before distributionZoneManager start in order to update Meta Storage revision before
         // distributionZoneManager's recovery.
-        metaStorageManager.deployWatches();
+        var deployWatchesFut = metaStorageManager.deployWatches();

Review Comment:
   This is a test classe. I think it is possible for test purposes.



##########
modules/distribution-zones/src/testFixtures/java/org/apache/ignite/internal/distributionzones/DistributionZonesTestUtil.java:
##########
@@ -313,17 +313,17 @@ public static void deployWatchesAndUpdateMetaStorageRevision(MetaStorageManager
             throws NodeStoppingException, InterruptedException {
         // Watches are deployed before distributionZoneManager start in order to update Meta Storage revision before
         // distributionZoneManager's recovery.
-        metaStorageManager.deployWatches();
+        var deployWatchesFut = metaStorageManager.deployWatches();

Review Comment:
   This is a test class. I think it is possible for test purposes.



;13/Jun/23 15:13;githubbot;600","vldpyatkov commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228313489


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageDeployWatchesCorrectnessTest.java:
##########
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.lang.NodeStoppingException;
+import org.apache.ignite.network.ClusterService;
+import org.junit.jupiter.api.Test;
+
+/**
+ * There are tests of correctness invocation {@link MetaStorageManager#deployWatches()}.
+ */
+public class MetaStorageDeployWatchesCorrectnessTest extends IgniteAbstractTest {
+    @Test
+    public void tesMetaStorageManager() throws Exception {
+        HybridClock clock = new HybridClockImpl();
+        String mcNodeName = ""mc-node-1"";
+
+        ClusterManagementGroupManager cmgManager = mock(ClusterManagementGroupManager.class);
+        ClusterService clusterService = mock(ClusterService.class);
+        LogicalTopologyService logicalTopologyService = mock(LogicalTopologyService.class);
+        RaftManager raftManager = mock(RaftManager.class);
+
+        when(cmgManager.metaStorageNodes()).thenReturn(completedFuture(Set.of(mcNodeName)));
+        when(clusterService.nodeName()).thenReturn(mcNodeName);
+        when(raftManager.startRaftGroupNodeAndWaitNodeReadyFuture(any(), any(), any(), any(), any())).thenReturn(completedFuture(null));
+
+        var metastore = new MetaStorageManagerImpl(
+                new VaultManager(new InMemoryVaultService()),
+                clusterService,
+                cmgManager,
+                logicalTopologyService,
+                raftManager,
+                new SimpleInMemoryKeyValueStorage(mcNodeName),
+                clock
+        );
+
+        checkCorrectness(metastore);
+    }
+
+    @Test
+    public void tesStandaloneMetaStorageManager() throws Exception {
+        var metastore = StandaloneMetaStorageManager.create(new VaultManager(new InMemoryVaultService()));
+
+        checkCorrectness(metastore);
+    }
+
+    /**
+     * Invokes {@link MetaStorageManager#deployWatches()} and checks result.
+     *
+     * @param metastore Meta storage.
+     * @throws NodeStoppingException If failed.
+     */
+    private static void checkCorrectness(MetaStorageManager metastore) throws NodeStoppingException {
+        var deployWatchesFut = metastore.deployWatches();
+
+        assertFalse(deployWatchesFut.isDone());
+
+        metastore.start();

Review Comment:
   It is just a unit test, I know the behavior here.
   I am sure we will invoke the listener in the same thread where the start future is completed. 



;13/Jun/23 15:17;githubbot;600","vldpyatkov commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228322151


##########
modules/distribution-zones/src/testFixtures/java/org/apache/ignite/internal/distributionzones/DistributionZonesTestUtil.java:
##########
@@ -313,17 +313,17 @@ public static void deployWatchesAndUpdateMetaStorageRevision(MetaStorageManager
             throws NodeStoppingException, InterruptedException {
         // Watches are deployed before distributionZoneManager start in order to update Meta Storage revision before
         // distributionZoneManager's recovery.
-        metaStorageManager.deployWatches();
+        var deployWatchesFut = metaStorageManager.deployWatches();
 
         // Bump Meta Storage applied revision by modifying a fake key. DistributionZoneManager breaks on start if Vault is not empty, but
         // Meta Storage revision is equal to 0.
         var fakeKey = new ByteArray(""foobar"");
 
-        CompletableFuture<Boolean> invokeFuture = metaStorageManager.invoke(
+        CompletableFuture<Boolean> invokeFuture = deployWatchesFut.thenCompose(unused -> metaStorageManager.invoke(

Review Comment:
   I do not know. I add explicit waiting here because it is a common test class, which might be used in different circumstances.
   Other places probably have internal guaranties or should wait to this future.



;13/Jun/23 15:23;githubbot;600","vldpyatkov commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228354015


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -170,8 +170,10 @@ public interface MetaStorageManager extends IgniteComponent {
      * Starts all registered watches.
      *
      * <p>Should be called after all Ignite components have registered required watches and they are ready to process Meta Storage events.
+     *
+     * @return Future to complete.

Review Comment:
   Could you provide something what you want to see here?



;13/Jun/23 15:45;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228359724


##########
modules/distribution-zones/src/testFixtures/java/org/apache/ignite/internal/distributionzones/DistributionZonesTestUtil.java:
##########
@@ -313,17 +313,17 @@ public static void deployWatchesAndUpdateMetaStorageRevision(MetaStorageManager
             throws NodeStoppingException, InterruptedException {
         // Watches are deployed before distributionZoneManager start in order to update Meta Storage revision before
         // distributionZoneManager's recovery.
-        metaStorageManager.deployWatches();
+        var deployWatchesFut = metaStorageManager.deployWatches();

Review Comment:
   > I think it is possible for test purposes.
   I've never heard about such possibilities for test classes. Is it allowed by our coding conventions?



##########
modules/distribution-zones/src/testFixtures/java/org/apache/ignite/internal/distributionzones/DistributionZonesTestUtil.java:
##########
@@ -313,17 +313,17 @@ public static void deployWatchesAndUpdateMetaStorageRevision(MetaStorageManager
             throws NodeStoppingException, InterruptedException {
         // Watches are deployed before distributionZoneManager start in order to update Meta Storage revision before
         // distributionZoneManager's recovery.
-        metaStorageManager.deployWatches();
+        var deployWatchesFut = metaStorageManager.deployWatches();

Review Comment:
   > I think it is possible for test purposes.
   
   I've never heard about such possibilities for test classes. Is it allowed by our coding conventions?



;13/Jun/23 15:50;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228365449


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -170,8 +170,10 @@ public interface MetaStorageManager extends IgniteComponent {
      * Starts all registered watches.
      *
      * <p>Should be called after all Ignite components have registered required watches and they are ready to process Meta Storage events.
+     *
+     * @return Future to complete.

Review Comment:
   Something like: ""future that'll completed when meta storage manager is started and deploying watches is finished.""



;13/Jun/23 15:54;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228369000


##########
modules/distribution-zones/src/testFixtures/java/org/apache/ignite/internal/distributionzones/DistributionZonesTestUtil.java:
##########
@@ -313,17 +313,17 @@ public static void deployWatchesAndUpdateMetaStorageRevision(MetaStorageManager
             throws NodeStoppingException, InterruptedException {
         // Watches are deployed before distributionZoneManager start in order to update Meta Storage revision before
         // distributionZoneManager's recovery.
-        metaStorageManager.deployWatches();
+        var deployWatchesFut = metaStorageManager.deployWatches();
 
         // Bump Meta Storage applied revision by modifying a fake key. DistributionZoneManager breaks on start if Vault is not empty, but
         // Meta Storage revision is equal to 0.
         var fakeKey = new ByteArray(""foobar"");
 
-        CompletableFuture<Boolean> invokeFuture = metaStorageManager.invoke(
+        CompletableFuture<Boolean> invokeFuture = deployWatchesFut.thenCompose(unused -> metaStorageManager.invoke(

Review Comment:
   Well, seems that you've substituted sync method with an async one and thus it's your aim to check whether you break the guaranties in any other places and add chaining or join wherever needed (if needed).



;13/Jun/23 15:57;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228373071


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageDeployWatchesCorrectnessTest.java:
##########
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.lang.NodeStoppingException;
+import org.apache.ignite.network.ClusterService;
+import org.junit.jupiter.api.Test;
+
+/**
+ * There are tests of correctness invocation {@link MetaStorageManager#deployWatches()}.
+ */
+public class MetaStorageDeployWatchesCorrectnessTest extends IgniteAbstractTest {
+    @Test
+    public void tesMetaStorageManager() throws Exception {
+        HybridClock clock = new HybridClockImpl();
+        String mcNodeName = ""mc-node-1"";
+
+        ClusterManagementGroupManager cmgManager = mock(ClusterManagementGroupManager.class);
+        ClusterService clusterService = mock(ClusterService.class);
+        LogicalTopologyService logicalTopologyService = mock(LogicalTopologyService.class);
+        RaftManager raftManager = mock(RaftManager.class);
+
+        when(cmgManager.metaStorageNodes()).thenReturn(completedFuture(Set.of(mcNodeName)));
+        when(clusterService.nodeName()).thenReturn(mcNodeName);
+        when(raftManager.startRaftGroupNodeAndWaitNodeReadyFuture(any(), any(), any(), any(), any())).thenReturn(completedFuture(null));
+
+        var metastore = new MetaStorageManagerImpl(
+                new VaultManager(new InMemoryVaultService()),
+                clusterService,
+                cmgManager,
+                logicalTopologyService,
+                raftManager,
+                new SimpleInMemoryKeyValueStorage(mcNodeName),
+                clock
+        );
+
+        checkCorrectness(metastore);
+    }
+
+    @Test
+    public void tesStandaloneMetaStorageManager() throws Exception {
+        var metastore = StandaloneMetaStorageManager.create(new VaultManager(new InMemoryVaultService()));
+
+        checkCorrectness(metastore);
+    }
+
+    /**
+     * Invokes {@link MetaStorageManager#deployWatches()} and checks result.
+     *
+     * @param metastore Meta storage.
+     * @throws NodeStoppingException If failed.
+     */
+    private static void checkCorrectness(MetaStorageManager metastore) throws NodeStoppingException {
+        var deployWatchesFut = metastore.deployWatches();
+
+        assertFalse(deployWatchesFut.isDone());
+
+        metastore.start();

Review Comment:
   Why should we exposes such implementation details (e.g. the one that there's no executors or similar inside metaStorage.start) instead of writing guaranteed code based on willSucceedFast?



;13/Jun/23 16:00;githubbot;600","vldpyatkov commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228646350


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -170,8 +170,10 @@ public interface MetaStorageManager extends IgniteComponent {
      * Starts all registered watches.
      *
      * <p>Should be called after all Ignite components have registered required watches and they are ready to process Meta Storage events.
+     *
+     * @return Future to complete.

Review Comment:
   Ok, but I wouldn't write this because it is just an interface. Another implementation might not connect the method with start process.



;13/Jun/23 20:11;githubbot;600","vldpyatkov commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1228652145


##########
modules/distribution-zones/src/testFixtures/java/org/apache/ignite/internal/distributionzones/DistributionZonesTestUtil.java:
##########
@@ -313,17 +313,17 @@ public static void deployWatchesAndUpdateMetaStorageRevision(MetaStorageManager
             throws NodeStoppingException, InterruptedException {
         // Watches are deployed before distributionZoneManager start in order to update Meta Storage revision before
         // distributionZoneManager's recovery.
-        metaStorageManager.deployWatches();
+        var deployWatchesFut = metaStorageManager.deployWatches();
 
         // Bump Meta Storage applied revision by modifying a fake key. DistributionZoneManager breaks on start if Vault is not empty, but
         // Meta Storage revision is equal to 0.
         var fakeKey = new ByteArray(""foobar"");
 
-        CompletableFuture<Boolean> invokeFuture = metaStorageManager.invoke(
+        CompletableFuture<Boolean> invokeFuture = deployWatchesFut.thenCompose(unused -> metaStorageManager.invoke(

Review Comment:
   I think, if before, we have no guarantees that MC start earlier than watches subscribe, it means thus tests are buggy.
   Ok, add synchronous waiting in every invocation.



;13/Jun/23 20:18;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1229131388


##########
modules/distribution-zones/src/testFixtures/java/org/apache/ignite/internal/distributionzones/DistributionZonesTestUtil.java:
##########
@@ -313,17 +313,17 @@ public static void deployWatchesAndUpdateMetaStorageRevision(MetaStorageManager
             throws NodeStoppingException, InterruptedException {
         // Watches are deployed before distributionZoneManager start in order to update Meta Storage revision before
         // distributionZoneManager's recovery.
-        metaStorageManager.deployWatches();
+        var deployWatchesFut = metaStorageManager.deployWatches();
 
         // Bump Meta Storage applied revision by modifying a fake key. DistributionZoneManager breaks on start if Vault is not empty, but
         // Meta Storage revision is equal to 0.
         var fakeKey = new ByteArray(""foobar"");
 
-        CompletableFuture<Boolean> invokeFuture = metaStorageManager.invoke(
+        CompletableFuture<Boolean> invokeFuture = deployWatchesFut.thenCompose(unused -> metaStorageManager.invoke(

Review Comment:
   > Ok, add synchronous waiting in every invocation.
   Well, in tests I'd rather add assertThat(willSucceedFast()) with proper message in order to have a meaningful explanation if synchronous waiting will hang instead of simple join.



;14/Jun/23 07:18;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1229131388


##########
modules/distribution-zones/src/testFixtures/java/org/apache/ignite/internal/distributionzones/DistributionZonesTestUtil.java:
##########
@@ -313,17 +313,17 @@ public static void deployWatchesAndUpdateMetaStorageRevision(MetaStorageManager
             throws NodeStoppingException, InterruptedException {
         // Watches are deployed before distributionZoneManager start in order to update Meta Storage revision before
         // distributionZoneManager's recovery.
-        metaStorageManager.deployWatches();
+        var deployWatchesFut = metaStorageManager.deployWatches();
 
         // Bump Meta Storage applied revision by modifying a fake key. DistributionZoneManager breaks on start if Vault is not empty, but
         // Meta Storage revision is equal to 0.
         var fakeKey = new ByteArray(""foobar"");
 
-        CompletableFuture<Boolean> invokeFuture = metaStorageManager.invoke(
+        CompletableFuture<Boolean> invokeFuture = deployWatchesFut.thenCompose(unused -> metaStorageManager.invoke(

Review Comment:
   > Ok, add synchronous waiting in every invocation.
   
   Well, in tests I'd rather add assertThat(willSucceedFast()) with proper message in order to have a meaningful explanation if synchronous waiting will hang instead of simple join.



;14/Jun/23 07:18;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1229137383


##########
modules/metastorage-api/src/main/java/org/apache/ignite/internal/metastorage/MetaStorageManager.java:
##########
@@ -170,8 +170,10 @@ public interface MetaStorageManager extends IgniteComponent {
      * Starts all registered watches.
      *
      * <p>Should be called after all Ignite components have registered required watches and they are ready to process Meta Storage events.
+     *
+     * @return Future to complete.

Review Comment:
   You're joking right? The core idea of the current ticket (IGNITE-19606) is to linearise ms.start() and ms.deployWatches().
   Do we still have an implementation with unconnected start and deployWatches? 



;14/Jun/23 07:23;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230576501


##########
modules/metastorage/src/integrationTest/java/org/apache/ignite/internal/metastorage/impl/ItMetaStorageMultipleNodesAbstractTest.java:
##########
@@ -228,6 +233,8 @@ void testLearnerJoin(TestInfo testInfo) throws NodeStoppingException {
 
         firstNode.cmgManager.initCluster(List.of(firstNode.name()), List.of(firstNode.name()), ""test"");
 
+        firstNode.deployWatches();

Review Comment:
   It seems incorrect. deployWatches is a part of node start procedure.



;15/Jun/23 07:40;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230577663


##########
modules/metastorage/src/integrationTest/java/org/apache/ignite/internal/metastorage/impl/ItMetaStorageManagerImplTest.java:
##########
@@ -118,7 +118,7 @@ void setUp(TestInfo testInfo, @InjectConfiguration RaftConfiguration raftConfigu
         raftManager.start();
         metaStorageManager.start();
 
-        metaStorageManager.deployWatches();
+        assertThat(""Watches were not deployed"", metaStorageManager.deployWatches(), willCompleteSuccessfully());

Review Comment:
   Please add full stop at the end of the sentence. Related to all such messages.



;15/Jun/23 07:41;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230576501


##########
modules/metastorage/src/integrationTest/java/org/apache/ignite/internal/metastorage/impl/ItMetaStorageMultipleNodesAbstractTest.java:
##########
@@ -228,6 +233,8 @@ void testLearnerJoin(TestInfo testInfo) throws NodeStoppingException {
 
         firstNode.cmgManager.initCluster(List.of(firstNode.name()), List.of(firstNode.name()), ""test"");
 
+        firstNode.deployWatches();

Review Comment:
   It seems incorrect. deployWatches is a part of node start procedure, that will be completed after cmg init, so that, basically it's still required to call deployWathces within node start and assert it completion after 
   `firstNode.cmgManager.initCluster(List.of(firstNode.name()), List.of(firstNode.name()), ""test"");`



;15/Jun/23 07:43;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230582451


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -277,14 +278,16 @@ public void unregisterWatch(WatchListener lsnr) {
     }
 
     @Override
-    public void deployWatches() throws NodeStoppingException {
+    public CompletableFuture<Void> deployWatches() {
         if (!busyLock.enterBusy()) {
-            throw new NodeStoppingException();
+            return CompletableFuture.failedFuture(new NodeStoppingException());

Review Comment:
   Good catch!



;15/Jun/23 07:45;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230583163


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageDeployWatchesCorrectnessTest.java:
##########
@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import java.util.stream.Stream;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.network.ClusterService;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests that check correctness of an invocation {@link MetaStorageManager#deployWatches()}.
+ */
+public class MetaStorageDeployWatchesCorrectnessTest extends IgniteAbstractTest {
+

Review Comment:
   Unnecessary blank line.



;15/Jun/23 07:46;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230585833


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageDeployWatchesCorrectnessTest.java:
##########
@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import java.util.stream.Stream;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.network.ClusterService;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests that check correctness of an invocation {@link MetaStorageManager#deployWatches()}.
+ */
+public class MetaStorageDeployWatchesCorrectnessTest extends IgniteAbstractTest {
+
+    /** Vault manager. */
+    private static VaultManager vaultManager;
+
+    @BeforeAll
+    public static void init() {
+        vaultManager = new VaultManager(new InMemoryVaultService());
+
+        vaultManager.start();
+    }
+
+    @AfterAll
+    public static void deInit() {
+        vaultManager.stop();

Review Comment:
   Despite the fact that Vault.beforeNodeStop() is no-op, it's still required to call it before calling vaultManager.stop();



;15/Jun/23 07:48;githubbot;600","vldpyatkov commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230602732


##########
modules/metastorage/src/integrationTest/java/org/apache/ignite/internal/metastorage/impl/ItMetaStorageManagerImplTest.java:
##########
@@ -118,7 +118,7 @@ void setUp(TestInfo testInfo, @InjectConfiguration RaftConfiguration raftConfigu
         raftManager.start();
         metaStorageManager.start();
 
-        metaStorageManager.deployWatches();
+        assertThat(""Watches were not deployed"", metaStorageManager.deployWatches(), willCompleteSuccessfully());

Review Comment:
   As I know, we do not have to use dot int the end of sentences in log.



;15/Jun/23 07:59;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230607232


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageDeployWatchesCorrectnessTest.java:
##########
@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import java.util.stream.Stream;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.network.ClusterService;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests that check correctness of an invocation {@link MetaStorageManager#deployWatches()}.
+ */
+public class MetaStorageDeployWatchesCorrectnessTest extends IgniteAbstractTest {
+
+    /** Vault manager. */
+    private static VaultManager vaultManager;
+
+    @BeforeAll
+    public static void init() {
+        vaultManager = new VaultManager(new InMemoryVaultService());
+
+        vaultManager.start();
+    }
+
+    @AfterAll
+    public static void deInit() {
+        vaultManager.stop();
+    }
+
+    /**
+     * Returns a stream with test arguments.
+     *
+     * @return Stream of different types of Meta storages to to check.
+     * @throws Exception If failed.
+     */
+    private static Stream<MetaStorageManager> metaStorageProvider() throws Exception {
+        HybridClock clock = new HybridClockImpl();
+        String mcNodeName = ""mc-node-1"";
+
+        ClusterManagementGroupManager cmgManager = mock(ClusterManagementGroupManager.class);
+        ClusterService clusterService = mock(ClusterService.class);
+        LogicalTopologyService logicalTopologyService = mock(LogicalTopologyService.class);
+        RaftManager raftManager = mock(RaftManager.class);
+
+        when(cmgManager.metaStorageNodes()).thenReturn(completedFuture(Set.of(mcNodeName)));
+        when(clusterService.nodeName()).thenReturn(mcNodeName);
+        when(raftManager.startRaftGroupNodeAndWaitNodeReadyFuture(any(), any(), any(), any(), any())).thenReturn(completedFuture(null));
+
+        return Stream.of(
+                new MetaStorageManagerImpl(
+                        vaultManager,
+                        clusterService,
+                        cmgManager,
+                        logicalTopologyService,
+                        raftManager,
+                        new SimpleInMemoryKeyValueStorage(mcNodeName),
+                        clock
+                ),
+                StandaloneMetaStorageManager.create(vaultManager)
+        );
+    }
+
+    /**
+     * Invokes {@link MetaStorageManager#deployWatches()} and checks result.
+     *
+     * @param metastore Meta storage.
+     */
+    @ParameterizedTest
+    @MethodSource(""metaStorageProvider"")
+    public void testCheckCorrectness(MetaStorageManager metastore) {
+        var deployWatchesFut = metastore.deployWatches();
+
+        assertFalse(deployWatchesFut.isDone());
+
+        metastore.start();

Review Comment:
   Same as for vault, MetaStorageManager is an IgniteCompoment thus it's required not only to start it but also call beforeNodeStop and stop. All in all, I'd suggest adding vault and ms to some components list and close it (beforeNodeStop + stop). From my point of view, it also may worth to change @Before**All**/@After**All** to Before**Each**/After**Each**.



;15/Jun/23 08:03;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230609913


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/ItDistributedConfigurationPropertiesTest.java:
##########
@@ -286,6 +287,8 @@ void setUp(@WorkDirectory Path workDir, TestInfo testInfo) throws Exception {
         Stream.of(firstNode, secondNode).parallel().forEach(Node::start);
 
         firstNode.cmgManager.initCluster(List.of(firstNode.name()), List.of(), ""cluster"");
+
+        Stream.of(firstNode, secondNode).parallel().forEach(Node::deployWatches);

Review Comment:
   Same as above. It's required to call deployWatches within node's startup process and assert deployWatches' future completion after init.



;15/Jun/23 08:05;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230610405


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/storage/ItDistributedConfigurationStorageTest.java:
##########
@@ -216,6 +223,8 @@ void testRestartWithPds(@WorkDirectory Path workDir, TestInfo testInfo) throws E
         try {
             node2.start();
 
+            node2.deployWatches();

Review Comment:
   Same as above.



;15/Jun/23 08:05;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230613375


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/storage/ItRebalanceDistributedTest.java:
##########
@@ -514,6 +516,8 @@ void testDestroyPartitionStoragesOnRestartEvictedNode(TestInfo testInfo) throws
 
         newNode.start();
 
+        newNode.deployWatches();

Review Comment:
   Same as above.



;15/Jun/23 08:08;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230616314


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -494,24 +492,15 @@ private PartialNode startPartialNode(
                 fut -> new TestConfigurationCatchUpListener(cfgStorage, fut, revisionCallback0)
         );
 
-        CompletableFuture<?> notificationFuture = CompletableFuture.allOf(
+        CompletableFuture<?> startFuture = CompletableFuture.allOf(
                 nodeCfgMgr.configurationRegistry().notifyCurrentConfigurationListeners(),
-                clusterCfgMgr.configurationRegistry().notifyCurrentConfigurationListeners()
+                clusterCfgMgr.configurationRegistry().notifyCurrentConfigurationListeners(),
+                // Deploy all registered watches because all components are ready and have registered their listeners.
+                metaStorageMgr.deployWatches(),
+                configurationCatchUpFuture
         );
 
-        CompletableFuture<?> startFuture = notificationFuture
-                .thenCompose(v -> {
-                    // Deploy all registered watches because all components are ready and have registered their listeners.
-                    try {
-                        metaStorageMgr.deployWatches();
-                    } catch (NodeStoppingException e) {
-                        throw new CompletionException(e);
-                    }
-
-                    return configurationCatchUpFuture;
-                });
-
-        assertThat(startFuture, willCompleteSuccessfully());
+        assertThat(""Partial node was not started"", startFuture, willCompleteSuccessfully());

Review Comment:
   Why you've changed the order of the processes?



;15/Jun/23 08:10;githubbot;600","vldpyatkov commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230636232


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -494,24 +492,15 @@ private PartialNode startPartialNode(
                 fut -> new TestConfigurationCatchUpListener(cfgStorage, fut, revisionCallback0)
         );
 
-        CompletableFuture<?> notificationFuture = CompletableFuture.allOf(
+        CompletableFuture<?> startFuture = CompletableFuture.allOf(
                 nodeCfgMgr.configurationRegistry().notifyCurrentConfigurationListeners(),
-                clusterCfgMgr.configurationRegistry().notifyCurrentConfigurationListeners()
+                clusterCfgMgr.configurationRegistry().notifyCurrentConfigurationListeners(),
+                // Deploy all registered watches because all components are ready and have registered their listeners.
+                metaStorageMgr.deployWatches(),
+                configurationCatchUpFuture
         );
 
-        CompletableFuture<?> startFuture = notificationFuture
-                .thenCompose(v -> {
-                    // Deploy all registered watches because all components are ready and have registered their listeners.
-                    try {
-                        metaStorageMgr.deployWatches();
-                    } catch (NodeStoppingException e) {
-                        throw new CompletionException(e);
-                    }
-
-                    return configurationCatchUpFuture;
-                });
-
-        assertThat(startFuture, willCompleteSuccessfully());
+        assertThat(""Partial node was not started"", startFuture, willCompleteSuccessfully());

Review Comment:
   I just add a message here, because the assertion relates to deploy watches future.



;15/Jun/23 08:26;githubbot;600","vldpyatkov commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230638363


##########
modules/metastorage/src/integrationTest/java/org/apache/ignite/internal/metastorage/impl/ItMetaStorageMultipleNodesAbstractTest.java:
##########
@@ -228,6 +233,8 @@ void testLearnerJoin(TestInfo testInfo) throws NodeStoppingException {
 
         firstNode.cmgManager.initCluster(List.of(firstNode.name()), List.of(firstNode.name()), ""test"");
 
+        firstNode.deployWatches();

Review Comment:
   Fixed



;15/Jun/23 08:27;githubbot;600","vldpyatkov commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230653470


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageDeployWatchesCorrectnessTest.java:
##########
@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import java.util.stream.Stream;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.network.ClusterService;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests that check correctness of an invocation {@link MetaStorageManager#deployWatches()}.
+ */
+public class MetaStorageDeployWatchesCorrectnessTest extends IgniteAbstractTest {
+
+    /** Vault manager. */
+    private static VaultManager vaultManager;
+
+    @BeforeAll
+    public static void init() {
+        vaultManager = new VaultManager(new InMemoryVaultService());
+
+        vaultManager.start();
+    }
+
+    @AfterAll
+    public static void deInit() {
+        vaultManager.stop();
+    }
+
+    /**
+     * Returns a stream with test arguments.
+     *
+     * @return Stream of different types of Meta storages to to check.
+     * @throws Exception If failed.
+     */
+    private static Stream<MetaStorageManager> metaStorageProvider() throws Exception {
+        HybridClock clock = new HybridClockImpl();
+        String mcNodeName = ""mc-node-1"";
+
+        ClusterManagementGroupManager cmgManager = mock(ClusterManagementGroupManager.class);
+        ClusterService clusterService = mock(ClusterService.class);
+        LogicalTopologyService logicalTopologyService = mock(LogicalTopologyService.class);
+        RaftManager raftManager = mock(RaftManager.class);
+
+        when(cmgManager.metaStorageNodes()).thenReturn(completedFuture(Set.of(mcNodeName)));
+        when(clusterService.nodeName()).thenReturn(mcNodeName);
+        when(raftManager.startRaftGroupNodeAndWaitNodeReadyFuture(any(), any(), any(), any(), any())).thenReturn(completedFuture(null));
+
+        return Stream.of(
+                new MetaStorageManagerImpl(
+                        vaultManager,
+                        clusterService,
+                        cmgManager,
+                        logicalTopologyService,
+                        raftManager,
+                        new SimpleInMemoryKeyValueStorage(mcNodeName),
+                        clock
+                ),
+                StandaloneMetaStorageManager.create(vaultManager)
+        );
+    }
+
+    /**
+     * Invokes {@link MetaStorageManager#deployWatches()} and checks result.
+     *
+     * @param metastore Meta storage.
+     */
+    @ParameterizedTest
+    @MethodSource(""metaStorageProvider"")
+    public void testCheckCorrectness(MetaStorageManager metastore) {
+        var deployWatchesFut = metastore.deployWatches();
+
+        assertFalse(deployWatchesFut.isDone());
+
+        metastore.start();

Review Comment:
   I added the methods' invocation for MC. But I do not think that have to be implemented in suggested manner.



;15/Jun/23 08:39;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230681891


##########
modules/metastorage/src/integrationTest/java/org/apache/ignite/internal/metastorage/impl/ItMetaStorageManagerImplTest.java:
##########
@@ -118,7 +118,7 @@ void setUp(TestInfo testInfo, @InjectConfiguration RaftConfiguration raftConfigu
         raftManager.start();
         metaStorageManager.start();
 
-        metaStorageManager.deployWatches();
+        assertThat(""Watches were not deployed"", metaStorageManager.deployWatches(), willCompleteSuccessfully());

Review Comment:
   AFAIK that was revised from Ignite 2 times, and now we follow common grammar rules.



;15/Jun/23 08:59;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230684148


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageDeployWatchesCorrectnessTest.java:
##########
@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import java.util.stream.Stream;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.network.ClusterService;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests that check correctness of an invocation {@link MetaStorageManager#deployWatches()}.
+ */
+public class MetaStorageDeployWatchesCorrectnessTest extends IgniteAbstractTest {
+
+    /** Vault manager. */
+    private static VaultManager vaultManager;
+
+    @BeforeAll
+    public static void init() {
+        vaultManager = new VaultManager(new InMemoryVaultService());
+
+        vaultManager.start();
+    }
+
+    @AfterAll
+    public static void deInit() {
+        vaultManager.stop();
+    }
+
+    /**
+     * Returns a stream with test arguments.
+     *
+     * @return Stream of different types of Meta storages to to check.
+     * @throws Exception If failed.
+     */
+    private static Stream<MetaStorageManager> metaStorageProvider() throws Exception {
+        HybridClock clock = new HybridClockImpl();
+        String mcNodeName = ""mc-node-1"";
+
+        ClusterManagementGroupManager cmgManager = mock(ClusterManagementGroupManager.class);
+        ClusterService clusterService = mock(ClusterService.class);
+        LogicalTopologyService logicalTopologyService = mock(LogicalTopologyService.class);
+        RaftManager raftManager = mock(RaftManager.class);
+
+        when(cmgManager.metaStorageNodes()).thenReturn(completedFuture(Set.of(mcNodeName)));
+        when(clusterService.nodeName()).thenReturn(mcNodeName);
+        when(raftManager.startRaftGroupNodeAndWaitNodeReadyFuture(any(), any(), any(), any(), any())).thenReturn(completedFuture(null));
+
+        return Stream.of(
+                new MetaStorageManagerImpl(
+                        vaultManager,
+                        clusterService,
+                        cmgManager,
+                        logicalTopologyService,
+                        raftManager,
+                        new SimpleInMemoryKeyValueStorage(mcNodeName),
+                        clock
+                ),
+                StandaloneMetaStorageManager.create(vaultManager)
+        );
+    }
+
+    /**
+     * Invokes {@link MetaStorageManager#deployWatches()} and checks result.
+     *
+     * @param metastore Meta storage.
+     */
+    @ParameterizedTest
+    @MethodSource(""metaStorageProvider"")
+    public void testCheckCorrectness(MetaStorageManager metastore) {
+        var deployWatchesFut = metastore.deployWatches();
+
+        assertFalse(deployWatchesFut.isDone());
+
+        metastore.start();

Review Comment:
   Well, did you add meta storage beforeNodeStop/stop? 



;15/Jun/23 09:00;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230688779


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -494,24 +492,15 @@ private PartialNode startPartialNode(
                 fut -> new TestConfigurationCatchUpListener(cfgStorage, fut, revisionCallback0)
         );
 
-        CompletableFuture<?> notificationFuture = CompletableFuture.allOf(
+        CompletableFuture<?> startFuture = CompletableFuture.allOf(
                 nodeCfgMgr.configurationRegistry().notifyCurrentConfigurationListeners(),
-                clusterCfgMgr.configurationRegistry().notifyCurrentConfigurationListeners()
+                clusterCfgMgr.configurationRegistry().notifyCurrentConfigurationListeners(),
+                // Deploy all registered watches because all components are ready and have registered their listeners.
+                metaStorageMgr.deployWatches(),
+                configurationCatchUpFuture
         );
 
-        CompletableFuture<?> startFuture = notificationFuture
-                .thenCompose(v -> {
-                    // Deploy all registered watches because all components are ready and have registered their listeners.
-                    try {
-                        metaStorageMgr.deployWatches();
-                    } catch (NodeStoppingException e) {
-                        throw new CompletionException(e);
-                    }
-
-                    return configurationCatchUpFuture;
-                });
-
-        assertThat(startFuture, willCompleteSuccessfully());
+        assertThat(""Partial node was not started"", startFuture, willCompleteSuccessfully());

Review Comment:
   Really? Seems that originally there was notificationFuture(notifyCurrentConfigurationListeners, notifyCurrentConfigurationListeners).thenCompose(deployWatches) and now it's startFuture(notifyCurrentConfigurationListeners, notifyCurrentConfigurationListeners, deployWatches) in other words originally deployWatches was called after notificationFutures and now it's called concurrently. Am I mistaken?



;15/Jun/23 09:04;githubbot;600","vldpyatkov commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230692169


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageDeployWatchesCorrectnessTest.java:
##########
@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import java.util.stream.Stream;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.network.ClusterService;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests that check correctness of an invocation {@link MetaStorageManager#deployWatches()}.
+ */
+public class MetaStorageDeployWatchesCorrectnessTest extends IgniteAbstractTest {
+
+    /** Vault manager. */
+    private static VaultManager vaultManager;
+
+    @BeforeAll
+    public static void init() {
+        vaultManager = new VaultManager(new InMemoryVaultService());
+
+        vaultManager.start();
+    }
+
+    @AfterAll
+    public static void deInit() {
+        vaultManager.stop();
+    }
+
+    /**
+     * Returns a stream with test arguments.
+     *
+     * @return Stream of different types of Meta storages to to check.
+     * @throws Exception If failed.
+     */
+    private static Stream<MetaStorageManager> metaStorageProvider() throws Exception {
+        HybridClock clock = new HybridClockImpl();
+        String mcNodeName = ""mc-node-1"";
+
+        ClusterManagementGroupManager cmgManager = mock(ClusterManagementGroupManager.class);
+        ClusterService clusterService = mock(ClusterService.class);
+        LogicalTopologyService logicalTopologyService = mock(LogicalTopologyService.class);
+        RaftManager raftManager = mock(RaftManager.class);
+
+        when(cmgManager.metaStorageNodes()).thenReturn(completedFuture(Set.of(mcNodeName)));
+        when(clusterService.nodeName()).thenReturn(mcNodeName);
+        when(raftManager.startRaftGroupNodeAndWaitNodeReadyFuture(any(), any(), any(), any(), any())).thenReturn(completedFuture(null));
+
+        return Stream.of(
+                new MetaStorageManagerImpl(
+                        vaultManager,
+                        clusterService,
+                        cmgManager,
+                        logicalTopologyService,
+                        raftManager,
+                        new SimpleInMemoryKeyValueStorage(mcNodeName),
+                        clock
+                ),
+                StandaloneMetaStorageManager.create(vaultManager)
+        );
+    }
+
+    /**
+     * Invokes {@link MetaStorageManager#deployWatches()} and checks result.
+     *
+     * @param metastore Meta storage.
+     */
+    @ParameterizedTest
+    @MethodSource(""metaStorageProvider"")
+    public void testCheckCorrectness(MetaStorageManager metastore) {
+        var deployWatchesFut = metastore.deployWatches();
+
+        assertFalse(deployWatchesFut.isDone());
+
+        metastore.start();

Review Comment:
   Storage is not a component at all.



;15/Jun/23 09:06;githubbot;600","vldpyatkov commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230693349


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageDeployWatchesCorrectnessTest.java:
##########
@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import java.util.stream.Stream;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.network.ClusterService;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests that check correctness of an invocation {@link MetaStorageManager#deployWatches()}.
+ */
+public class MetaStorageDeployWatchesCorrectnessTest extends IgniteAbstractTest {
+
+    /** Vault manager. */
+    private static VaultManager vaultManager;
+
+    @BeforeAll
+    public static void init() {
+        vaultManager = new VaultManager(new InMemoryVaultService());
+
+        vaultManager.start();
+    }
+
+    @AfterAll
+    public static void deInit() {
+        vaultManager.stop();
+    }
+
+    /**
+     * Returns a stream with test arguments.
+     *
+     * @return Stream of different types of Meta storages to to check.
+     * @throws Exception If failed.
+     */
+    private static Stream<MetaStorageManager> metaStorageProvider() throws Exception {
+        HybridClock clock = new HybridClockImpl();
+        String mcNodeName = ""mc-node-1"";
+
+        ClusterManagementGroupManager cmgManager = mock(ClusterManagementGroupManager.class);
+        ClusterService clusterService = mock(ClusterService.class);
+        LogicalTopologyService logicalTopologyService = mock(LogicalTopologyService.class);
+        RaftManager raftManager = mock(RaftManager.class);
+
+        when(cmgManager.metaStorageNodes()).thenReturn(completedFuture(Set.of(mcNodeName)));
+        when(clusterService.nodeName()).thenReturn(mcNodeName);
+        when(raftManager.startRaftGroupNodeAndWaitNodeReadyFuture(any(), any(), any(), any(), any())).thenReturn(completedFuture(null));
+
+        return Stream.of(
+                new MetaStorageManagerImpl(
+                        vaultManager,
+                        clusterService,
+                        cmgManager,
+                        logicalTopologyService,
+                        raftManager,
+                        new SimpleInMemoryKeyValueStorage(mcNodeName),
+                        clock
+                ),
+                StandaloneMetaStorageManager.create(vaultManager)
+        );
+    }
+
+    /**
+     * Invokes {@link MetaStorageManager#deployWatches()} and checks result.
+     *
+     * @param metastore Meta storage.
+     */
+    @ParameterizedTest
+    @MethodSource(""metaStorageProvider"")
+    public void testCheckCorrectness(MetaStorageManager metastore) {
+        var deployWatchesFut = metastore.deployWatches();
+
+        assertFalse(deployWatchesFut.isDone());
+
+        metastore.start();

Review Comment:
   No, I add this in the test body.



;15/Jun/23 09:07;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230728268


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageDeployWatchesCorrectnessTest.java:
##########
@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import java.util.stream.Stream;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.network.ClusterService;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests that check correctness of an invocation {@link MetaStorageManager#deployWatches()}.
+ */
+public class MetaStorageDeployWatchesCorrectnessTest extends IgniteAbstractTest {
+
+    /** Vault manager. */
+    private static VaultManager vaultManager;
+
+    @BeforeAll
+    public static void init() {
+        vaultManager = new VaultManager(new InMemoryVaultService());
+
+        vaultManager.start();
+    }
+
+    @AfterAll
+    public static void deInit() {
+        vaultManager.stop();
+    }
+
+    /**
+     * Returns a stream with test arguments.
+     *
+     * @return Stream of different types of Meta storages to to check.
+     * @throws Exception If failed.
+     */
+    private static Stream<MetaStorageManager> metaStorageProvider() throws Exception {
+        HybridClock clock = new HybridClockImpl();
+        String mcNodeName = ""mc-node-1"";
+
+        ClusterManagementGroupManager cmgManager = mock(ClusterManagementGroupManager.class);
+        ClusterService clusterService = mock(ClusterService.class);
+        LogicalTopologyService logicalTopologyService = mock(LogicalTopologyService.class);
+        RaftManager raftManager = mock(RaftManager.class);
+
+        when(cmgManager.metaStorageNodes()).thenReturn(completedFuture(Set.of(mcNodeName)));
+        when(clusterService.nodeName()).thenReturn(mcNodeName);
+        when(raftManager.startRaftGroupNodeAndWaitNodeReadyFuture(any(), any(), any(), any(), any())).thenReturn(completedFuture(null));
+
+        return Stream.of(
+                new MetaStorageManagerImpl(
+                        vaultManager,
+                        clusterService,
+                        cmgManager,
+                        logicalTopologyService,
+                        raftManager,
+                        new SimpleInMemoryKeyValueStorage(mcNodeName),
+                        clock
+                ),
+                StandaloneMetaStorageManager.create(vaultManager)
+        );
+    }
+
+    /**
+     * Invokes {@link MetaStorageManager#deployWatches()} and checks result.
+     *
+     * @param metastore Meta storage.
+     */
+    @ParameterizedTest
+    @MethodSource(""metaStorageProvider"")
+    public void testCheckCorrectness(MetaStorageManager metastore) {
+        var deployWatchesFut = metastore.deployWatches();
+
+        assertFalse(deployWatchesFut.isDone());
+
+        metastore.start();

Review Comment:
   Not sure that I got you. I will add, or you've already added? I'm asking because currently I can see only vault's stop.



;15/Jun/23 09:30;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230728268


##########
modules/metastorage/src/test/java/org/apache/ignite/internal/metastorage/impl/MetaStorageDeployWatchesCorrectnessTest.java:
##########
@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.metastorage.impl;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Set;
+import java.util.stream.Stream;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalTopologyService;
+import org.apache.ignite.internal.hlc.HybridClock;
+import org.apache.ignite.internal.hlc.HybridClockImpl;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.raft.RaftManager;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.inmemory.InMemoryVaultService;
+import org.apache.ignite.network.ClusterService;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests that check correctness of an invocation {@link MetaStorageManager#deployWatches()}.
+ */
+public class MetaStorageDeployWatchesCorrectnessTest extends IgniteAbstractTest {
+
+    /** Vault manager. */
+    private static VaultManager vaultManager;
+
+    @BeforeAll
+    public static void init() {
+        vaultManager = new VaultManager(new InMemoryVaultService());
+
+        vaultManager.start();
+    }
+
+    @AfterAll
+    public static void deInit() {
+        vaultManager.stop();
+    }
+
+    /**
+     * Returns a stream with test arguments.
+     *
+     * @return Stream of different types of Meta storages to to check.
+     * @throws Exception If failed.
+     */
+    private static Stream<MetaStorageManager> metaStorageProvider() throws Exception {
+        HybridClock clock = new HybridClockImpl();
+        String mcNodeName = ""mc-node-1"";
+
+        ClusterManagementGroupManager cmgManager = mock(ClusterManagementGroupManager.class);
+        ClusterService clusterService = mock(ClusterService.class);
+        LogicalTopologyService logicalTopologyService = mock(LogicalTopologyService.class);
+        RaftManager raftManager = mock(RaftManager.class);
+
+        when(cmgManager.metaStorageNodes()).thenReturn(completedFuture(Set.of(mcNodeName)));
+        when(clusterService.nodeName()).thenReturn(mcNodeName);
+        when(raftManager.startRaftGroupNodeAndWaitNodeReadyFuture(any(), any(), any(), any(), any())).thenReturn(completedFuture(null));
+
+        return Stream.of(
+                new MetaStorageManagerImpl(
+                        vaultManager,
+                        clusterService,
+                        cmgManager,
+                        logicalTopologyService,
+                        raftManager,
+                        new SimpleInMemoryKeyValueStorage(mcNodeName),
+                        clock
+                ),
+                StandaloneMetaStorageManager.create(vaultManager)
+        );
+    }
+
+    /**
+     * Invokes {@link MetaStorageManager#deployWatches()} and checks result.
+     *
+     * @param metastore Meta storage.
+     */
+    @ParameterizedTest
+    @MethodSource(""metaStorageProvider"")
+    public void testCheckCorrectness(MetaStorageManager metastore) {
+        var deployWatchesFut = metastore.deployWatches();
+
+        assertFalse(deployWatchesFut.isDone());
+
+        metastore.start();

Review Comment:
   Not sure that I get you. I will add, or you've already added? I'm asking because currently I can see only vault's stop.



;15/Jun/23 09:30;githubbot;600","sanpwc commented on code in PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183#discussion_r1230975872


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/storage/ItRebalanceDistributedTest.java:
##########
@@ -681,6 +688,8 @@ private class Node {
                     hybridClock
             );
 
+            deployWatchesFut = metaStorageManager.deployWatches();

Review Comment:
   It's not a proper place, deployWatches should be called after all components start, so basically it should be called where it was called originally. 



;15/Jun/23 13:00;githubbot;600","vldpyatkov merged PR #2183:
URL: https://github.com/apache/ignite-3/pull/2183


;15/Jun/23 14:01;githubbot;600",,0,27000,,,0,27000,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jun 15 14:01:45 UTC 2023,,,,,,,,,,"0|z1i8o8:",9223372036854775807,,,alapin,,,,,,,,,,,,,,,,,,"15/Jun/23 13:02;alapin;[~v.pyatkov] LGTM, thanks!;;;","15/Jun/23 14:01;v.pyatkov;Merged f5f2c658273efaf98b5df156690f3b1afe10876d;;;",,,,
ItDeploymentUnitTest is flaky,IGNITE-19605,13538226,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,vpakhnushev,vpakhnushev,31/May/23 08:55,02/Jun/23 09:53,13/Jul/23 09:11,02/Jun/23 09:53,,,,,,,,3.0.0-beta2,compute,,,0,ignite-3,,,"Even after the IGNITE-19139 was fixed, the {{ItDeploymentUnitTest}} is still flaky, the root cause is still looks like the Micronaut's shared converters registry. We should look for a better workaround.",,aleksandr.pakhomov,vpakhnushev,,,,"valepakh opened a new pull request, #2125:
URL: https://github.com/apache/ignite-3/pull/2125

   https://issues.apache.org/jira/browse/IGNITE-19605


;31/May/23 10:38;githubbot;600","PakhomovAlexander merged PR #2125:
URL: https://github.com/apache/ignite-3/pull/2125


;02/Jun/23 09:52;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Jun 02 09:53:34 UTC 2023,,,,,,,,,,"0|z1i8m8:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"02/Jun/23 09:53;aleksandr.pakhomov;Thank you, merged into main: cdf51cdfb4d1cc4d60e216e8e50b173fcdf7efc1;;;","02/Jun/23 09:53;aleksandr.pakhomov;This test fail happens when previous test used connect command without paired disconnect, which leaves the periodic session task running.
When starting the nodes in the next test, it so happens that the request for the node configuration from the JdbcUrlRegistryImpl or any other periodic task is received while the Micronaut's context is starting in the RestController for the second node. In this case the io.micronaut.core.convert.ConversionService#SHARED is cleared and is not yet populated.
It's not entirely clear what happens next, but most probably the HTTP server caches the state where there's no corresponding type converter and this leaves the node in the broken state.

It doesn't seem possible to properly fix this outside of Micronaut, so there's just a workaround which adds missing disconnect calls.;;;",,,,
API and tests for causality data nodes in DistributionZoneManager,IGNITE-19602,13538210,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Sergey Uttsel,Sergey Uttsel,Sergey Uttsel,31/May/23 07:38,19/Jun/23 07:42,13/Jul/23 09:11,19/Jun/23 07:42,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"h3. *Motivation*

In https://issues.apache.org/jira/browse/IGNITE-19506 we will create implementation for getting data nodes from zone manager with causality token. In this ticket we need to create API, test plan and implement tests with test infrastructure.
h3. *Definition of Done*

API and tests for causality data nodes in DistributionZoneManager are implemented.

 

*Test plan*

*Test1* topologyLeapUpdate
Prerequisite:
1. zonesByRevision contains [revision=5, zoneId==1 -> [nodeA, nodeB]]
2. zonesByRevision contains [revision=5, zoneId==2 -> [nodeA, nodeB]]
3. A zone1 with immediate scaleUp and immediate scaleDown.
4. A zone2 with scaleUp=1 and scaleDown=1 timers.

Test steps:
1. Invoke `fut1=versionedDataNodes(zoneId=1, revision=6)`
2. Invoke `fut2=versionedDataNodes(zoneId=2, revision=6)`
3. Check that `!fut1.isDone()`.
4. Check that `!fut2.isDone()`.
5. Change topology to [nodeA, nodeC]. Topology revision is 6.
6. assertThat(fut1, willSucceedFast())
7. assertThat(fut2, willSucceedFast())
8. Check that fut1 is completed with [nodeA, nodeC]
9. Check that fut2 is completed with [nodeA, nodeB].
10. Wait when data nodes for zone2 is updated in the metastorage (with revision x).
11. Invoke `fut3=versionedDataNodes(zoneId=2, revision=x)`
12. Check that fut3 is completed with [nodeA, nodeC].

Check this test case for a zone with default and custom zones.

*Test2* topologyLeapUpdateScaleUpNotImmediateAndScaleDownImmediate
Prerequisite:
1. zonesByRevision contains [revision=5, zoneId==1 -> [nodeA, nodeB]]
4. A zone1 with scaleUp=1 and scaleDown=immediate timers.

Test steps:
1. Invoke `fut1=versionedDataNodes(zoneId=1, revision=6)`
2. Check that `!fut1.isDone()`.
3. Change topology to [nodeA, nodeC]. Topology revision is 6.
4. assertThat(fut1, willSucceedFast())
5. Check that fut1 is completed with [nodeA, nodeB, nodeC].
6. Wait when data nodes for zone2 is updated in the metastorage (with revision x).
7. Invoke `fut2=versionedDataNodes(zoneId=1, revision=x)`
8. Check that fut2 is completed with [nodeA, nodeC].

Check this test case for a zone with default and custom zone.

*Test3* topologyLeapUpdateScaleUpImmediateAndScaleDownNotImmediate
Prerequisite:
1. zonesByRevision contains [revision=5, zoneId==1 -> [nodeA, nodeB]]
2. A zone1 with scaleUp=immediate and scaleDown=1 timers.

Test steps:
1. Invoke `fut1=versionedDataNodes(zoneId=1, revision=6)`
2. Check that `!fut1.isDone()`.
3. Change topology to [nodeA, nodeC]. Topology revision is 6.
4. assertThat(fut1, willSucceedFast())
5. Check that fut1 is completed with [nodeA].
6. Wait when data nodes for zone1 is updated in the metastorage (with revision x).
7. Invoke `fut2=versionedDataNodes(zoneId=1, revision=x)`
8. Check that fut2 is completed with [nodeA, nodeC].

Check this test case for a zone with default and custom zone.

*Test4* (Change scaleUp to immediate) dataNodesUpdatedAfterScaleUpChanged
Prerequisite:
1. zonesByRevision contains [revision=5, zoneId==1 -> [nodeA]]
2. A zone1 with scaleUp=10000 timer and immediate scaleDown timer.

Test steps:
1. Invoke `fut1=versionedDataNodes(zoneId=1, revision=6)`
2. Check that `!fut1.isDone()`.
3. Change topology to [nodeA, nodeB]. Topology revision is 6.
4. assertThat(fut1, willSucceedFast()) with [nodeA].
5. Change scaleUp to immediate. The configuration change revision is 7.
6. Invoke `fut2=versionedDataNodes(zoneId=1, revision=6)`. Check that fut2 is completed with [nodeA].
7. Invoke `fut3=versionedDataNodes(zoneId=1, revision=7)`. Check that fut3 is completed with [nodeA, nodeB].

Check this test case for a zone with default and custom zone.

*Test5* (Change scaleDown to immediate) dataNodesUpdatedAfterScaleDownChanged
Prerequisite:
1. zonesByRevision contains [revision=5, zoneId==1 -> [nodeA, nodeB]]
2. A zone1 with immediate scaleUp timer and scaleDown=10000.

Test steps:
1. Invoke `fut1=versionedDataNodes(zoneId=1, revision=6)`
2. Check that `!fut1.isDone()`.
3. Change topology to [nodeA]. Topology revision is 6.
4. assertThat(fut1, willSucceedFast()) with [nodeA, nodeB].
5. Change scaleDown to immediate. The configuration change revision is 7.
6. Invoke `fut2=versionedDataNodes(zoneId=1, revision=6)`. Check that fut2 is completed with [nodeA, nodeB].
7. Invoke `fut3=versionedDataNodes(zoneId=1, revision=7)`. Check that fut3 is completed with [nodeA].

Check this test case for a zone with default and custom zone.

*Test6* (drop zone) scheduleScaleUpTaskThenDropZone
Prerequisite:
1. zonesByRevision contains [revision=5, zoneId==1 -> [nodeA]]
2. A zone1 with scaleUp=10000 timer and immediate scaleDown timer.

Test steps:
1. Invoke `fut1=versionedDataNodes(zoneId=1, revision=6)`
2. Check that `!fut1.isDone()`.
3. Change topology to [nodeA, nodeB]. Topology revision is 6.
4. assertThat(fut1, willSucceedFast()) with [nodeA].
5. Drop the zone. The drop event revision is 7.
6. Invoke `fut2=versionedDataNodes(zoneId=1, revision=6)`. Check that fut2 is completed with [nodeA].
7. Invoke `fut3=versionedDataNodes(zoneId=1, revision=7)`. Check that fut3 is completed with exception DistributionZoneNotFoundException.

Check this test case for a zone with default and custom zone.

*Test7* (drop zone) scheduleScaleDownTaskThenDropZone
Prerequisite:
1. zonesByRevision contains [revision=5, zoneId==1 -> [nodeA, nodeB]]
2. A zone1 with immediate scaleUp timer and scaleDown=10000 timer.

Test steps:
1. Invoke `fut1=versionedDataNodes(zoneId=1, revision=6)`
2. Check that `!fut1.isDone()`.
3. Change topology to [nodeA]. Topology revision is 6.
4. assertThat(fut1, willSucceedFast()) with [nodeA, nodeB].
5. Drop the zone. The drop event revision is 7.
6. Invoke `fut2=versionedDataNodes(zoneId=1, revision=6)`. Check that fut2 is completed with [nodeA, nodeB].
7. Invoke `fut3=versionedDataNodes(zoneId=1, revision=7)`. Check that fut3 is completed with exception DistributionZoneNotFoundException.

Check this test case for a zone with default and custom zone.

*Test8* createThenDropZone
Prerequisite:
1. The last applied revision is 6.
2. The zone with zoneId=1 is not created.
3. Current topology: [nodeA, nodeB].

Test steps:
1. Invoke `fut1=versionedDataNodes(zoneId=1, revision=6)`
2. Check that fut1 is completed exceptionally with DistributionZoneNotFoundException.
3. Create zone with zoneId=1. A create zone revision is 7.
4. Invoke `fut2=versionedDataNodes(zoneId=1, revision=7)`
5. Check that fut2 is completed with current topology data nodes.
6. Drop zone with zoneId=1. A drop zone revision is 8.
7. Invoke `fut3=versionedDataNodes(zoneId=1, revision=8)`
8. Check that fut3 is completed exceptionally with DistributionZoneNotFoundException.

Check this test case for a zone with immediate and not immediate timers, default and custom zones.

*Test9* validationTest
Test steps:
1. Invoke `fut1=versionedDataNodes(zoneId=0, revision=0)`
2. Check that fut1 is completed exceptionally with IllegalArgumentException (or AssertionError).
3. Invoke `fut1=versionedDataNodes(zoneId=0, revision=-1)`
4. Check that fut1 is completed exceptionally with Exception (or AssertionError).

*Test10* simpleTopologyChanges
Test steps:
1. Do topology changes:
revision 1 - [nodeA],
revision 5 - [nodeA, nodeB]
2. Create zone1 with zoneId=1 and immediate timers. Create event revision is 7.
4. Get futures:
Invoke `versionedDataNodes(zoneId=1, revision=7)`,
Invoke `versionedDataNodes(zoneId=1, revision=10)`,
Invoke `versionedDataNodes(zoneId=1, revision=15)`.
5. Check that futures are not completed.
3. Do topology changes:
revision 10 - [nodeA, nodeB, nodeC],
revision 15 - [nodeA, nodeC].
5. Check that futures are completed with corresponds values:
revision 7 - [nodeA, nodeB],
revision 10 - [nodeA, nodeB, nodeC],
revision 15 - [nodeA, nodeC].",,Sergey Uttsel,,,,,"sergeyuttsel opened a new pull request, #2170:
URL: https://github.com/apache/ignite-3/pull/2170

   https://issues.apache.org/jira/browse/IGNITE-19602


;08/Jun/23 13:13;githubbot;600","sk0x50 merged PR #2170:
URL: https://github.com/apache/ignite-3/pull/2170


;19/Jun/23 07:42;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-19743,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-05-31 07:38:37.0,,,,,,,,,,"0|z1i8io:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
Partition creation fails with NSFE,IGNITE-19596,13538089,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ibessonov,ibessonov,30/May/23 09:10,02/Jun/23 11:22,13/Jul/23 09:11,02/Jun/23 11:22,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"You can reproduce it by creating tables in a loop. I did that with fsync disabled.
{noformat}
java.util.concurrent.CompletionException: java.io.UncheckedIOException: java.nio.file.NoSuchFileException: build/work/ItSqlLogicTest/static_2773294090214/sqllogic0/db/db/table-89/part-6-delta-0.bin.tmp
    at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:314)
    at java.base/java.util.concurrent.CompletableFuture.uniApplyNow(CompletableFuture.java:683)
    at java.base/java.util.concurrent.CompletableFuture.uniApplyStage(CompletableFuture.java:658)
    at java.base/java.util.concurrent.CompletableFuture.thenApply(CompletableFuture.java:2094)
    at org.apache.ignite.internal.storage.util.MvPartitionStorages.create(MvPartitionStorages.java:122)
    at org.apache.ignite.internal.storage.pagememory.AbstractPageMemoryTableStorage.lambda$createMvPartition$5(AbstractPageMemoryTableStorage.java:173)
    at org.apache.ignite.internal.util.IgniteUtils.inBusyLock(IgniteUtils.java:877)
    at org.apache.ignite.internal.storage.pagememory.AbstractPageMemoryTableStorage.busy(AbstractPageMemoryTableStorage.java:229)
    at org.apache.ignite.internal.storage.pagememory.AbstractPageMemoryTableStorage.createMvPartition(AbstractPageMemoryTableStorage.java:173)
    at org.apache.ignite.internal.table.distributed.TableManager.getOrCreatePartitionStorages(TableManager.java:2288)
    at org.apache.ignite.internal.table.distributed.TableManager.lambda$updateAssignmentInternal$21(TableManager.java:682)
    at org.apache.ignite.internal.util.IgniteUtils.inBusyLock(IgniteUtils.java:877)
    at org.apache.ignite.internal.table.distributed.TableManager.lambda$updateAssignmentInternal$22(TableManager.java:648)
    at java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:930)
    at java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:907)
    at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
    at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
    at org.apache.ignite.internal.causality.BaseVersionedValue.lambda$copyState$6(BaseVersionedValue.java:307)
    at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859)
    at java.base/java.util.concurrent.CompletableFuture.uniWhenCompleteStage(CompletableFuture.java:883)
    at java.base/java.util.concurrent.CompletableFuture.whenComplete(CompletableFuture.java:2251)
    at org.apache.ignite.internal.causality.BaseVersionedValue.copyState(BaseVersionedValue.java:303)
    at org.apache.ignite.internal.causality.BaseVersionedValue.complete(BaseVersionedValue.java:189)
    at org.apache.ignite.internal.causality.IncrementalVersionedValue.lambda$completeInternal$1(IncrementalVersionedValue.java:236)
    at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859)
    at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:837)
    at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
    at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
    at org.apache.ignite.internal.raft.RaftGroupServiceImpl.lambda$sendWithRetry$39(RaftGroupServiceImpl.java:540)
    at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859)
    at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:837)
    at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
    at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
    at org.apache.ignite.network.DefaultMessagingService.onInvokeResponse(DefaultMessagingService.java:371)
    at org.apache.ignite.network.DefaultMessagingService.send0(DefaultMessagingService.java:194)
    at org.apache.ignite.network.DefaultMessagingService.respond(DefaultMessagingService.java:137)
    at org.apache.ignite.network.MessagingService.respond(MessagingService.java:89)
    at org.apache.ignite.raft.jraft.rpc.impl.IgniteRpcServer$NetworkRpcContext.sendResponse(IgniteRpcServer.java:233)
    at org.apache.ignite.raft.jraft.rpc.impl.ActionRequestProcessor$1.result(ActionRequestProcessor.java:104)
    at org.apache.ignite.internal.raft.server.impl.JraftServerImpl$DelegatingStateMachine$1$1.result(JraftServerImpl.java:631)
    at org.apache.ignite.internal.metastorage.server.raft.MetaStorageWriteHandler.handleWriteWithTime(MetaStorageWriteHandler.java:171)
    at org.apache.ignite.internal.metastorage.server.raft.MetaStorageWriteHandler.handleWriteCommand(MetaStorageWriteHandler.java:90)
    at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)
    at org.apache.ignite.internal.metastorage.server.raft.MetaStorageListener.onWrite(MetaStorageListener.java:147)
    at org.apache.ignite.internal.raft.server.impl.JraftServerImpl$DelegatingStateMachine.onApply(JraftServerImpl.java:592)
    at org.apache.ignite.raft.jraft.core.FSMCallerImpl.doApplyTasks(FSMCallerImpl.java:561)
    at org.apache.ignite.raft.jraft.core.FSMCallerImpl.doCommitted(FSMCallerImpl.java:529)
    at org.apache.ignite.raft.jraft.core.FSMCallerImpl.runApplyTask(FSMCallerImpl.java:448)
    at org.apache.ignite.raft.jraft.core.FSMCallerImpl$ApplyTaskHandler.onEvent(FSMCallerImpl.java:136)
    at org.apache.ignite.raft.jraft.core.FSMCallerImpl$ApplyTaskHandler.onEvent(FSMCallerImpl.java:130)
    at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:217)
    at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:181)
    at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:137)
    at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: java.io.UncheckedIOException: java.nio.file.NoSuchFileException: build/work/ItSqlLogicTest/static_2773294090214/sqllogic0/db/db/table-89/part-6-delta-0.bin.tmp
    at java.base/java.nio.file.FileTreeIterator.fetchNextIfNeeded(FileTreeIterator.java:87)
    at java.base/java.nio.file.FileTreeIterator.hasNext(FileTreeIterator.java:103)
    at java.base/java.util.Iterator.forEachRemaining(Iterator.java:132)
    at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)
    at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
    at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
    at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:550)
    at java.base/java.util.stream.AbstractPipeline.evaluateToArrayNode(AbstractPipeline.java:260)
    at java.base/java.util.stream.ReferencePipeline.toArray(ReferencePipeline.java:517)
    at org.apache.ignite.internal.pagememory.persistence.store.FilePageStoreManager.findPartitionDeltaFiles(FilePageStoreManager.java:429)
    at org.apache.ignite.internal.pagememory.persistence.store.FilePageStoreManager.initialize(FilePageStoreManager.java:293)
    at org.apache.ignite.internal.storage.pagememory.PersistentPageMemoryTableStorage.ensurePartitionFilePageStoreExists(PersistentPageMemoryTableStorage.java:158)
    at org.apache.ignite.internal.storage.pagememory.PersistentPageMemoryTableStorage.getOrCreatePartitionMetaOnCreatePartition(PersistentPageMemoryTableStorage.java:550)
    at org.apache.ignite.internal.storage.pagememory.PersistentPageMemoryTableStorage.createMvPartitionStorage(PersistentPageMemoryTableStorage.java:116)
    at org.apache.ignite.internal.storage.pagememory.PersistentPageMemoryTableStorage.createMvPartitionStorage(PersistentPageMemoryTableStorage.java:56)
    at org.apache.ignite.internal.storage.pagememory.AbstractPageMemoryTableStorage.lambda$createMvPartition$4(AbstractPageMemoryTableStorage.java:174)
    at org.apache.ignite.internal.storage.util.MvPartitionStorages.lambda$create$1(MvPartitionStorages.java:123)
    at java.base/java.util.concurrent.CompletableFuture.uniApplyNow(CompletableFuture.java:680)
    ... 52 more
Caused by: java.nio.file.NoSuchFileException: build/work/ItSqlLogicTest/static_2773294090214/sqllogic0/db/db/table-89/part-6-delta-0.bin.tmp
    at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
    at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
    at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)
    at java.base/sun.nio.fs.UnixFileAttributeViews$Basic.readAttributes(UnixFileAttributeViews.java:55)
    at java.base/sun.nio.fs.UnixFileSystemProvider.readAttributes(UnixFileSystemProvider.java:149)
    at java.base/sun.nio.fs.LinuxFileSystemProvider.readAttributes(LinuxFileSystemProvider.java:99)
    at java.base/java.nio.file.Files.readAttributes(Files.java:1764)
    at java.base/java.nio.file.FileTreeWalker.getAttributes(FileTreeWalker.java:219)
    at java.base/java.nio.file.FileTreeWalker.visit(FileTreeWalker.java:276)
    at java.base/java.nio.file.FileTreeWalker.next(FileTreeWalker.java:373)
    at java.base/java.nio.file.FileTreeIterator.fetchNextIfNeeded(FileTreeIterator.java:83)
    ... 69 more
{noformat}",,ibessonov,rpuch,,,,"tkalkirill opened a new pull request, #2134:
URL: https://github.com/apache/ignite-3/pull/2134

   https://issues.apache.org/jira/browse/IGNITE-19596


;02/Jun/23 06:48;githubbot;600","rpuch commented on code in PR #2134:
URL: https://github.com/apache/ignite-3/pull/2134#discussion_r1214215024


##########
modules/page-memory/src/test/java/org/apache/ignite/internal/pagememory/persistence/store/FilePageStoreManagerTest.java:
##########
@@ -440,13 +449,68 @@ void testFullyRemovePartitionOnStart() throws Exception {
         );
     }
 
+    @ParameterizedTest
+    @ValueSource(ints = {1, 2, 4, 10, 25, 50})

Review Comment:
   Let's add a sane time out (like `@Timeout(value = 1, unit = MINUTE)`) just in case as racers use potentially infinite loops (if something gets broken in the future, they could hang forever)



;02/Jun/23 10:45;githubbot;600","tkalkirill commented on code in PR #2134:
URL: https://github.com/apache/ignite-3/pull/2134#discussion_r1214217015


##########
modules/page-memory/src/test/java/org/apache/ignite/internal/pagememory/persistence/store/FilePageStoreManagerTest.java:
##########
@@ -440,13 +449,68 @@ void testFullyRemovePartitionOnStart() throws Exception {
         );
     }
 
+    @ParameterizedTest
+    @ValueSource(ints = {1, 2, 4, 10, 25, 50})

Review Comment:
   Why not



;02/Jun/23 10:47;githubbot;600","tkalkirill merged PR #2134:
URL: https://github.com/apache/ignite-3/pull/2134


;02/Jun/23 11:21;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Jun 02 10:52:22 UTC 2023,,,,,,,,,,"0|z1i7rs:",9223372036854775807,,,rpuch,,,,,,,,,,,,,,,,,,"02/Jun/23 10:52;rpuch;The patch looks good to me, thanks!;;;",,,,,
ItClusterManagerTest#testClusterConfigurationIsRemovedFromClusterStateAfterUpdating increase timeout,IGNITE-19595,13538086,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ivan.gagarkin,ivan.gagarkin,ivan.gagarkin,30/May/23 08:51,30/May/23 12:43,13/Jul/23 09:11,30/May/23 12:17,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"{code:java}
assertThat(newLeaderNode.clusterManager().clusterConfigurationToUpdate(), willThrow(CancellationException.class)); {code}
1 second is not enough for the node to cancel the action. ",,ivan.gagarkin,,,,,"Flaugh24 opened a new pull request, #2118:
URL: https://github.com/apache/ignite-3/pull/2118

   …omClusterStateAfterUpdating increase timeout


;30/May/23 08:55;githubbot;600","Flaugh24 commented on PR #2118:
URL: https://github.com/apache/ignite-3/pull/2118#issuecomment-1568039361

   https://issues.apache.org/jira/browse/IGNITE-19595


;30/May/23 08:56;githubbot;600","ibessonov merged PR #2118:
URL: https://github.com/apache/ignite-3/pull/2118


;30/May/23 12:17;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,2023-05-30 08:51:44.0,,,,,,,,,,"0|z1i7r4:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
"Possible bottleneck with RocksDB on multiple table creation, with RocksDB as table storage",IGNITE-19591,13538006,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ibessonov,Denis Chudov,Denis Chudov,29/May/23 15:18,19/Jun/23 12:17,13/Jul/23 09:11,19/Jun/23 12:17,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Scenario:
 * 1 node cluster
 * rocksdb table storage ( created via SQL query {{create zone test_zone engine rocksdb with partitions=25}} )
 * sequential tables creation using this zone (queries like {{CREATE TABLE table_0(id INT PRIMARY KEY, column_1 VARCHAR, column_2 VARCHAR, column_3 VARCHAR, column_4 VARCHAR) with primary_zone='TEST_ZONE' }} ). Number of talbes: 1000, pause between query executions: 30 ms.

After creating a couple of hundreds of tables, queries start failing with timeout.

Threads are busy with RocksDB write operations:

  
{code:java}
""%sqllogic0%JRaft-FSMCaller-Disruptor-_stripe_0-0"" #28 daemon prio=5 os_prio=0 cpu=203.13ms elapsed=58.63s tid=0x000001e4966a0800 nid=0x37e0 runnable  [0x0000002e032ff000]
        java.lang.Thread.State: RUNNABLE
        at org.rocksdb.RocksDB.write1(Native Method)
        at org.rocksdb.RocksDB.write(RocksDB.java:1722)
        at org.apache.ignite.internal.storage.rocksdb.RocksDbMvPartitionStorage.lambda$runConsistently$1(RocksDbMvPartitionStorage.java:236)
        at org.apache.ignite.internal.storage.rocksdb.RocksDbMvPartitionStorage$$Lambda$2003/0x00000008014ecc40.get(Unknown Source)
        at org.apache.ignite.internal.storage.rocksdb.RocksDbMvPartitionStorage.busy(RocksDbMvPartitionStorage.java:1415)
        at org.apache.ignite.internal.storage.rocksdb.RocksDbMvPartitionStorage.runConsistently(RocksDbMvPartitionStorage.java:222)
        at org.apache.ignite.internal.table.distributed.raft.snapshot.outgoing.SnapshotAwarePartitionDataStorage.runConsistently(SnapshotAwarePartitionDataStorage.java:66)
        at org.apache.ignite.internal.table.distributed.raft.PartitionListener.handleBuildIndexCommand(PartitionListener.java:471)
        at org.apache.ignite.internal.table.distributed.raft.PartitionListener.lambda$onWrite$2(PartitionListener.java:187)
        at org.apache.ignite.internal.table.distributed.raft.PartitionListener$$Lambda$2187/0x0000000801536040.accept(Unknown Source)
        at java.util.Iterator.forEachRemaining(java.base@13.0.1/Iterator.java:133)
        at org.apache.ignite.internal.table.distributed.raft.PartitionListener.onWrite(PartitionListener.java:149)
        at org.apache.ignite.internal.raft.server.impl.JraftServerImpl$DelegatingStateMachine.onApply(JraftServerImpl.java:592)
        at org.apache.ignite.raft.jraft.core.FSMCallerImpl.doApplyTasks(FSMCallerImpl.java:561)
        at org.apache.ignite.raft.jraft.core.FSMCallerImpl.doCommitted(FSMCallerImpl.java:529)
        at org.apache.ignite.raft.jraft.core.FSMCallerImpl.runApplyTask(FSMCallerImpl.java:448)
        at org.apache.ignite.raft.jraft.core.FSMCallerImpl$ApplyTaskHandler.onEvent(FSMCallerImpl.java:136)
        at org.apache.ignite.raft.jraft.core.FSMCallerImpl$ApplyTaskHandler.onEvent(FSMCallerImpl.java:130)
        at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:217)
        at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:181)
        at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:137)
        at java.lang.Thread.run(java.base@13.0.1/Thread.java:830)

""%sqllogic0%vault-1"" #92 prio=5 os_prio=0 cpu=2687.50ms elapsed=58.52s tid=0x000001e49bdfc000 nid=0x6f24 runnable  [0x0000002e079fd000]
        java.lang.Thread.State: RUNNABLE
        at org.rocksdb.RocksDB.open(Native Method)
        at org.rocksdb.RocksDB.open(RocksDB.java:307)
        at org.apache.ignite.internal.storage.rocksdb.RocksDbTableStorage.lambda$start$1(RocksDbTableStorage.java:251)
        at org.apache.ignite.internal.storage.rocksdb.RocksDbTableStorage$$Lambda$1786/0x000000080148a040.run(Unknown Source)
        at org.apache.ignite.internal.util.IgniteUtils.inBusyLock(IgniteUtils.java:889)
        at org.apache.ignite.internal.storage.rocksdb.RocksDbTableStorage.start(RocksDbTableStorage.java:223)
        at org.apache.ignite.internal.table.distributed.TableManager.createTableStorage(TableManager.java:1159)
        at org.apache.ignite.internal.table.distributed.TableManager.createTableLocally(TableManager.java:1103)
        at org.apache.ignite.internal.table.distributed.TableManager.onTableCreate(TableManager.java:547)
        at org.apache.ignite.internal.table.distributed.TableManager$1.onCreate(TableManager.java:460)
        at org.apache.ignite.internal.configuration.notifications.ConfigurationNotifier$1$$Lambda$1711/0x0000000801460440.apply(Unknown Source)
        at org.apache.ignite.internal.configuration.notifications.ConfigurationNotifier.notifyPublicListeners(ConfigurationNotifier.java:488)
        at org.apache.ignite.internal.configuration.notifications.ConfigurationNotifier$1.visitNamedListNode(ConfigurationNotifier.java:206)
        at org.apache.ignite.internal.configuration.notifications.ConfigurationNotifier$1.visitNamedListNode(ConfigurationNotifier.java:129)
        at org.apache.ignite.internal.schema.configuration.TablesNode.traverseChildren(Unknown Source)
        at org.apache.ignite.internal.configuration.notifications.ConfigurationNotifier.notifyListeners(ConfigurationNotifier.java:129)
        at org.apache.ignite.internal.configuration.notifications.ConfigurationNotifier.notifyListeners(ConfigurationNotifier.java:91)
        at org.apache.ignite.internal.configuration.ConfigurationRegistry$3$1.visitInnerNode(ConfigurationRegistry.java:271)
        at org.apache.ignite.internal.configuration.ConfigurationRegistry$3$1.visitInnerNode(ConfigurationRegistry.java:254)
        at org.apache.ignite.internal.configuration.SuperRoot.traverseChildren(SuperRoot.java:105)
        at org.apache.ignite.internal.configuration.ConfigurationRegistry$3.onConfigurationUpdated(ConfigurationRegistry.java:254)
        at org.apache.ignite.internal.configuration.ConfigurationChanger$3.lambda$onEntriesChanged$1(ConfigurationChanger.java:658)
        at org.apache.ignite.internal.configuration.ConfigurationChanger$3$$Lambda$1702/0x000000080145d440.apply(Unknown Source)
        at java.util.concurrent.CompletableFuture$UniCompose.tryFire(java.base@13.0.1/CompletableFuture.java:1146)
        at java.util.concurrent.CompletableFuture.postComplete(java.base@13.0.1/CompletableFuture.java:506)
        at java.util.concurrent.CompletableFuture$AsyncRun.run(java.base@13.0.1/CompletableFuture.java:1813)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@13.0.1/ThreadPoolExecutor.java:1128)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@13.0.1/ThreadPoolExecutor.java:628)
        at java.lang.Thread.run(java.base@13.0.1/Thread.java:830)

""%sqllogic0%JRaft-FSMCaller-Disruptor-_stripe_1-0"" #29 daemon prio=5 os_prio=0 cpu=140.63ms elapsed=58.63s tid=0x000001e49669c800 nid=0x2214 runnable  [0x0000002e033fe000]
        java.lang.Thread.State: RUNNABLE
        at org.rocksdb.RocksDB.write1(Native Method)
        at org.rocksdb.RocksDB.write(RocksDB.java:1722)
        at org.apache.ignite.internal.storage.rocksdb.RocksDbMvPartitionStorage.lambda$runConsistently$1(RocksDbMvPartitionStorage.java:236)
        at org.apache.ignite.internal.storage.rocksdb.RocksDbMvPartitionStorage$$Lambda$2003/0x00000008014ecc40.get(Unknown Source)
        at org.apache.ignite.internal.storage.rocksdb.RocksDbMvPartitionStorage.busy(RocksDbMvPartitionStorage.java:1415)
        at org.apache.ignite.internal.storage.rocksdb.RocksDbMvPartitionStorage.runConsistently(RocksDbMvPartitionStorage.java:222)
        at org.apache.ignite.internal.table.distributed.raft.snapshot.outgoing.SnapshotAwarePartitionDataStorage.runConsistently(SnapshotAwarePartitionDataStorage.java:66)
        at org.apache.ignite.internal.table.distributed.raft.PartitionListener.handleSafeTimeSyncCommand(PartitionListener.java:378)
        at org.apache.ignite.internal.table.distributed.raft.PartitionListener.lambda$onWrite$2(PartitionListener.java:185)
        at org.apache.ignite.internal.table.distributed.raft.PartitionListener$$Lambda$2187/0x0000000801536040.accept(Unknown Source)
        at java.util.Iterator.forEachRemaining(java.base@13.0.1/Iterator.java:133)
        at org.apache.ignite.internal.table.distributed.raft.PartitionListener.onWrite(PartitionListener.java:149)
        at org.apache.ignite.internal.raft.server.impl.JraftServerImpl$DelegatingStateMachine.onApply(JraftServerImpl.java:592)
        at org.apache.ignite.raft.jraft.core.FSMCallerImpl.doApplyTasks(FSMCallerImpl.java:561)
        at org.apache.ignite.raft.jraft.core.FSMCallerImpl.doCommitted(FSMCallerImpl.java:529)
        at org.apache.ignite.raft.jraft.core.FSMCallerImpl.runApplyTask(FSMCallerImpl.java:448)
        at org.apache.ignite.raft.jraft.core.FSMCallerImpl$ApplyTaskHandler.onEvent(FSMCallerImpl.java:136)
        at org.apache.ignite.raft.jraft.core.FSMCallerImpl$ApplyTaskHandler.onEvent(FSMCallerImpl.java:130)
        at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:217)
        at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:181)
        at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:137)
        at java.lang.Thread.run(java.base@13.0.1/Thread.java:830)


""%sqllogic0%JRaft-FSMCaller-Disruptor-_stripe_2-0"" #30 daemon prio=5 os_prio=0 cpu=140.63ms elapsed=58.63s tid=0x000001e49669d000 nid=0x7770 runnable  [0x0000002e034fe000]
        java.lang.Thread.State: RUNNABLE
        at org.rocksdb.RocksDB.write1(Native Method)
        at org.rocksdb.RocksDB.write(RocksDB.java:1722)
        at org.apache.ignite.internal.storage.rocksdb.RocksDbMvPartitionStorage.lambda$runConsistently$1(RocksDbMvPartitionStorage.java:236)
        at org.apache.ignite.internal.storage.rocksdb.RocksDbMvPartitionStorage$$Lambda$2003/0x00000008014ecc40.get(Unknown Source)
        at org.apache.ignite.internal.storage.rocksdb.RocksDbMvPartitionStorage.busy(RocksDbMvPartitionStorage.java:1415)
        at org.apache.ignite.internal.storage.rocksdb.RocksDbMvPartitionStorage.runConsistently(RocksDbMvPartitionStorage.java:222)
        at org.apache.ignite.internal.table.distributed.raft.snapshot.outgoing.SnapshotAwarePartitionDataStorage.runConsistently(SnapshotAwarePartitionDataStorage.java:66)
        at org.apache.ignite.internal.table.distributed.raft.PartitionListener.onConfigurationCommitted(PartitionListener.java:398)
        at org.apache.ignite.internal.raft.server.impl.JraftServerImpl$DelegatingStateMachine.onRawConfigurationCommitted(JraftServerImpl.java:669)
        at org.apache.ignite.raft.jraft.core.FSMCallerImpl.doCommitted(FSMCallerImpl.java:511)
        at org.apache.ignite.raft.jraft.core.FSMCallerImpl.runApplyTask(FSMCallerImpl.java:448)
        at org.apache.ignite.raft.jraft.core.FSMCallerImpl$ApplyTaskHandler.onEvent(FSMCallerImpl.java:136)
        at org.apache.ignite.raft.jraft.core.FSMCallerImpl$ApplyTaskHandler.onEvent(FSMCallerImpl.java:130)
        at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:217)
        at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:181)
        at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:137)
        at java.lang.Thread.run(java.base@13.0.1/Thread.java:830){code}",,Denis Chudov,,,,,"ibessonov opened a new pull request, #2200:
URL: https://github.com/apache/ignite-3/pull/2200

   https://issues.apache.org/jira/browse/IGNITE-19591


;15/Jun/23 12:50;githubbot;600","tkalkirill commented on code in PR #2200:
URL: https://github.com/apache/ignite-3/pull/2200#discussion_r1231976667


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/AbstractMvPartitionStorageTest.java:
##########
@@ -803,30 +802,25 @@ void readByTimestampWorksCorrectlyIfNoUncommittedValueExists() {
     }
 
     /**
-     * Tests that changed {@link MvPartitionStorage#lastAppliedIndex()} can be successfully read and that it's returned from
-     * {@link MvPartitionStorage#persistedIndex()} after the {@link MvPartitionStorage#flush()}.
+     * Tests that changed {@link MvPartitionStorage#lastAppliedIndex()} can be successfully read back.
      */
     @Test
     void testAppliedIndex() {
         storage.runConsistently(locker -> {
             assertEquals(0, storage.lastAppliedIndex());
             assertEquals(0, storage.lastAppliedTerm());
-            assertEquals(0, storage.persistedIndex());

Review Comment:
   Are you sure that you need to remove these checks, you have deprecated this method for now, let it be tested for now.



##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/AbstractMvPartitionStorageTest.java:
##########
@@ -803,30 +802,25 @@ void readByTimestampWorksCorrectlyIfNoUncommittedValueExists() {
     }
 
     /**
-     * Tests that changed {@link MvPartitionStorage#lastAppliedIndex()} can be successfully read and that it's returned from
-     * {@link MvPartitionStorage#persistedIndex()} after the {@link MvPartitionStorage#flush()}.
+     * Tests that changed {@link MvPartitionStorage#lastAppliedIndex()} can be successfully read back.
      */
     @Test
     void testAppliedIndex() {
         storage.runConsistently(locker -> {
             assertEquals(0, storage.lastAppliedIndex());
             assertEquals(0, storage.lastAppliedTerm());
-            assertEquals(0, storage.persistedIndex());
 
             storage.lastApplied(1, 1);
 
             assertEquals(1, storage.lastAppliedIndex());
             assertEquals(1, storage.lastAppliedTerm());
-            assertThat(storage.persistedIndex(), is(lessThanOrEqualTo(1L)));
 
             return null;
         });
 
         CompletableFuture<Void> flushFuture = storage.flush();
 
         assertThat(flushFuture, willCompleteSuccessfully());
-
-        assertEquals(1, storage.persistedIndex());

Review Comment:
   Same



##########
modules/transactions/src/testFixtures/java/org/apache/ignite/internal/tx/storage/state/AbstractTxStateStorageTest.java:
##########
@@ -521,7 +521,6 @@ protected static void checkLastApplied(
             long expLastAppliedTerm
     ) {
         assertEquals(expLastAppliedIndex, storage.lastAppliedIndex());
-        assertEquals(expPersistentIndex, storage.persistedIndex());

Review Comment:
   same



##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/AbstractMvTableStorageTest.java:
##########
@@ -1054,7 +1053,6 @@ private static void checkLastApplied(
             long expLastAppliedTerm
     ) {
         assertEquals(expLastAppliedIndex, storage.lastAppliedIndex());
-        assertEquals(expPersistentIndex, storage.persistedIndex());

Review Comment:
   Same



##########
modules/storage-rocksdb/src/test/java/org/apache/ignite/internal/storage/rocksdb/RocksDbMvTableStorageTest.java:
##########
@@ -151,7 +150,9 @@ void testRestart() {
 
         tableStorage.start();
 
-        assertThat(tableStorage.getMvPartition(PARTITION_ID), is(notNullValue()));
+        assertThat(tableStorage.getMvPartition(PARTITION_ID), is(nullValue()));
+
+        tableStorage.createMvPartition(PARTITION_ID);

Review Comment:
   The method returns the future, please check if it succeeds.



##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/raft/snapshot/PartitionSnapshotStorageFactory.java:
##########
@@ -34,7 +34,7 @@
  * Snapshot storage factory for {@link MvPartitionStorage}. Utilizes the fact that every partition already stores its latest applied index
  * and thus can itself be used as its own snapshot.
  *
- * <p>Uses {@link MvPartitionStorage#persistedIndex()} and configuration, passed into constructor, to create a {@link SnapshotMeta} object

Review Comment:
   Same



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/RocksDbStorageEngine.java:
##########
@@ -70,6 +69,8 @@ public class RocksDbStorageEngine implements StorageEngine {
 
     private final Map<String, RocksDbDataRegion> regions = new ConcurrentHashMap<>();
 
+    private final Map<String, SharedRocksDbInstance> sharedInstances = new ConcurrentHashMap<>();

Review Comment:
   What is the key? name or something else? it would be more convenient to reflect in the variable name or documentation.



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/RocksDbStorageEngine.java:
##########
@@ -170,14 +173,18 @@ public RocksDbTableStorage createMvTable(
 
         assert dataRegion != null : ""tableId="" + tableId + "", dataRegion="" + tableDescriptor.getDataRegion();
 
-        Path tablePath = storagePath.resolve(TABLE_DIR_PREFIX + tableId);
-
-        try {
-            Files.createDirectories(tablePath);
-        } catch (IOException e) {
-            throw new StorageException(""Failed to create table store directory for table: "" + tableId, e);
-        }
+        SharedRocksDbInstance sharedInstance = sharedInstances.computeIfAbsent(tableDescriptor.getDataRegion(), name -> {

Review Comment:
   Do I understand correctly that now for tables with a rocsDB it will not be so easy to change the data region, maybe you need to tell about it somewhere in the documentation?



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/instance/SharedRocksDbInstance.java:
##########
@@ -0,0 +1,264 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.rocksdb.instance;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.stream.Collectors.toList;
+import static org.apache.ignite.internal.rocksdb.RocksUtils.incrementPrefix;
+import static org.apache.ignite.internal.storage.rocksdb.instance.SharedRocksDbInstanceCreator.sortedIndexCfOptions;
+import static org.apache.ignite.lang.IgniteStringFormatter.format;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.apache.ignite.internal.rocksdb.ColumnFamily;
+import org.apache.ignite.internal.rocksdb.flush.RocksDbFlusher;
+import org.apache.ignite.internal.storage.StorageClosedException;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.internal.storage.rocksdb.RocksDbMetaStorage;
+import org.apache.ignite.internal.storage.rocksdb.RocksDbStorageEngine;
+import org.apache.ignite.internal.util.IgniteSpinBusyLock;
+import org.apache.ignite.internal.util.IgniteUtils;
+import org.apache.ignite.lang.ByteArray;
+import org.rocksdb.ColumnFamilyDescriptor;
+import org.rocksdb.ColumnFamilyHandle;
+import org.rocksdb.RocksDB;
+import org.rocksdb.RocksDBException;
+import org.rocksdb.WriteBatch;
+import org.rocksdb.WriteOptions;
+
+/**
+ * Shared RocksDB instance for multiple tables. Managed directly by the engine.
+ */
+public final class SharedRocksDbInstance {
+

Review Comment:
   ```suggestion
   ```



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/instance/SharedRocksDbInstance.java:
##########
@@ -0,0 +1,264 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.rocksdb.instance;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.stream.Collectors.toList;
+import static org.apache.ignite.internal.rocksdb.RocksUtils.incrementPrefix;
+import static org.apache.ignite.internal.storage.rocksdb.instance.SharedRocksDbInstanceCreator.sortedIndexCfOptions;
+import static org.apache.ignite.lang.IgniteStringFormatter.format;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.apache.ignite.internal.rocksdb.ColumnFamily;
+import org.apache.ignite.internal.rocksdb.flush.RocksDbFlusher;
+import org.apache.ignite.internal.storage.StorageClosedException;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.internal.storage.rocksdb.RocksDbMetaStorage;
+import org.apache.ignite.internal.storage.rocksdb.RocksDbStorageEngine;
+import org.apache.ignite.internal.util.IgniteSpinBusyLock;
+import org.apache.ignite.internal.util.IgniteUtils;
+import org.apache.ignite.lang.ByteArray;
+import org.rocksdb.ColumnFamilyDescriptor;
+import org.rocksdb.ColumnFamilyHandle;
+import org.rocksdb.RocksDB;
+import org.rocksdb.RocksDBException;
+import org.rocksdb.WriteBatch;
+import org.rocksdb.WriteOptions;
+
+/**
+ * Shared RocksDB instance for multiple tables. Managed directly by the engine.
+ */
+public final class SharedRocksDbInstance {
+
+    /** Write options. */
+    public static final WriteOptions DFLT_WRITE_OPTS = new WriteOptions().setDisableWAL(true);
+
+    /** RocksDB storage engine instance. */
+    public final RocksDbStorageEngine engine;
+
+    /** Path for the directory that stores the data. */
+    public final Path path;
+
+    /** RocksDB flusher instance. */
+    public final RocksDbFlusher flusher;
+
+    /** Rocks DB instance. */
+    public final RocksDB db;
+
+    /** Meta information instance that wraps {@link ColumnFamily} instance for meta column family.. */
+    public final RocksDbMetaStorage meta;
+
+    /** Column Family for partition data. */
+    public final ColumnFamily partitionCf;
+
+    /** Column Family for GC queue. */
+    public final ColumnFamily gcQueueCf;
+
+    /** Column Family for Hash Index data. */
+    public final ColumnFamily hashIndexCf;
+
+    /** Column Family instances for different types of sorted indexes, identified by the column family name. */
+    private final ConcurrentMap<ByteArray, ColumnFamily> sortedIndexCfs;
+
+    /** Column family names mapped to sets of index IDs, that use that CF. */
+    private final ConcurrentMap<ByteArray, Set<Integer>> sortedIndexIdsByCfName = new ConcurrentHashMap<>();
+
+    /** Busy lock to stop synchronously. */
+    private final IgniteSpinBusyLock busyLock;
+
+    /** Prevents double stopping of the component. */
+    private final AtomicBoolean stopGuard = new AtomicBoolean();
+
+    SharedRocksDbInstance(
+            RocksDbStorageEngine engine,
+            Path path,
+            IgniteSpinBusyLock busyLock,
+            RocksDbFlusher flusher,
+            RocksDB db,
+            RocksDbMetaStorage meta,
+            ColumnFamily partitionCf,
+            ColumnFamily gcQueueCf,
+            ColumnFamily hashIndexCf,
+            ConcurrentMap<ByteArray, ColumnFamily> sortedIndexCfs
+    ) {
+        this.engine = engine;
+        this.path = path;
+        this.busyLock = busyLock;
+
+        this.flusher = flusher;
+        this.db = db;
+
+        this.meta = meta;
+        this.partitionCf = partitionCf;
+        this.gcQueueCf = gcQueueCf;
+        this.hashIndexCf = hashIndexCf;
+        this.sortedIndexCfs = sortedIndexCfs;
+    }
+
+    /**
+     * Utility method that performs range-deletion in the column family.
+     */
+    public static void deleteByPrefix(WriteBatch writeBatch, ColumnFamily columnFamily, byte[] prefix) throws RocksDBException {
+        byte[] upperBound = incrementPrefix(prefix);
+
+        writeBatch.deleteRange(columnFamily.handle(), prefix, upperBound);
+    }
+
+    /**
+     * Stops the instance, freeing all allocated resources.
+     */
+    public void stop() {
+        if (!stopGuard.compareAndSet(false, true)) {
+            return;
+        }
+
+        busyLock.block();
+
+        List<AutoCloseable> resources = new ArrayList<>();
+
+        resources.add(meta.columnFamily().handle());
+        resources.add(partitionCf.handle());
+        resources.add(gcQueueCf.handle());
+        resources.add(hashIndexCf.handle());
+        resources.addAll(sortedIndexCfs.values().stream()
+                .map(ColumnFamily::handle)
+                .collect(toList())
+        );
+
+        resources.add(db);
+        resources.add(flusher::stop);
+
+        try {
+            Collections.reverse(resources);
+
+            IgniteUtils.closeAll(resources);
+        } catch (Exception e) {
+            throw new StorageException(""Failed to stop RocksDB storage: "" + path, e);
+        }
+    }
+
+    /**
+     * Returns Column Family instance with the desired name. Creates it it it doesn't exist.
+     * Tracks every created index by its {@code indexId}.
+     */
+    public ColumnFamily getSortedIndexCfOnIndexCreate(byte[] cfName, int indexId) {
+        if (!busyLock.enterBusy()) {
+            throw new StorageClosedException();
+        }
+
+        try {
+            ColumnFamily[] result = {null};
+
+            sortedIndexIdsByCfName.compute(new ByteArray(cfName), (name, indexIds) -> {
+                ColumnFamily columnFamily = getOrCreateColumnFamily(cfName, name);
+
+                result[0] = columnFamily;
+
+                if (indexIds == null) {
+                    indexIds = new HashSet<>();
+                }
+
+                indexIds.add(indexId);

Review Comment:
   Perhaps we need to create a new set to avoid data races.



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/RocksDbStorageUtils.java:
##########
@@ -38,6 +38,9 @@ public class RocksDbStorageUtils {
     /** Index ID size in bytes. */
     public static final int INDEX_ID_SIZE = Integer.SIZE;
 
+    /** Table ID size. */

Review Comment:
   ```suggestion
       /** Table ID size in bytes. */
   ```



##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/MvPartitionStorage.java:
##########
@@ -127,7 +126,11 @@ interface Locker {
 
     /**
      * {@link #lastAppliedIndex()} value consistent with the data, already persisted on the storage.
+     *
+     * @deprecated No one needs it, and it slows down the storage.
      */
+    //TODO IGNITE-19750 Delete this method.

Review Comment:
   ```suggestion
       // TODO: IGNITE-19750 Delete this method.
   ```



##########
modules/transactions/src/main/java/org/apache/ignite/internal/tx/storage/state/TxStateStorage.java:
##########
@@ -145,7 +146,6 @@ public interface TxStateStorage extends ManuallyCloseable {
      *         <li>{@link TxStateStorage#put(UUID, TxMeta)};</li>
      *         <li>{@link TxStateStorage#lastAppliedIndex()};</li>
      *         <li>{@link TxStateStorage#lastAppliedTerm()}} ()};</li>
-     *         <li>{@link TxStateStorage#persistedIndex()}};</li>

Review Comment:
   same



##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/AbstractMvPartitionStorageTest.java:
##########
@@ -803,30 +802,25 @@ void readByTimestampWorksCorrectlyIfNoUncommittedValueExists() {
     }
 
     /**
-     * Tests that changed {@link MvPartitionStorage#lastAppliedIndex()} can be successfully read and that it's returned from
-     * {@link MvPartitionStorage#persistedIndex()} after the {@link MvPartitionStorage#flush()}.
+     * Tests that changed {@link MvPartitionStorage#lastAppliedIndex()} can be successfully read back.
      */
     @Test
     void testAppliedIndex() {
         storage.runConsistently(locker -> {
             assertEquals(0, storage.lastAppliedIndex());
             assertEquals(0, storage.lastAppliedTerm());
-            assertEquals(0, storage.persistedIndex());
 
             storage.lastApplied(1, 1);
 
             assertEquals(1, storage.lastAppliedIndex());
             assertEquals(1, storage.lastAppliedTerm());
-            assertThat(storage.persistedIndex(), is(lessThanOrEqualTo(1L)));

Review Comment:
   Same



##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -2372,8 +2372,8 @@ private CompletableFuture<PartitionStorages> getOrCreatePartitionStorages(TableI
                 .thenComposeAsync(mvPartitionStorage -> {
                     TxStateStorage txStateStorage = internalTable.txStateStorage().getOrCreateTxStateStorage(partitionId);
 
-                    if (mvPartitionStorage.persistedIndex() == MvPartitionStorage.REBALANCE_IN_PROGRESS

Review Comment:
   same



##########
modules/table/src/test/java/org/apache/ignite/internal/table/distributed/TableManagerTest.java:
##########
@@ -673,10 +673,10 @@ private void testStoragesGetClearedInMiddleOfFailedRebalance(boolean isTxStorage
 
         if (isTxStorageUnderRebalance) {
             // Emulate a situation when TX state storage was stopped in a middle of rebalance.
-            when(txStateStorage.persistedIndex()).thenReturn(TxStateStorage.REBALANCE_IN_PROGRESS);

Review Comment:
   same



##########
modules/transactions/src/main/java/org/apache/ignite/internal/tx/storage/state/TxStateStorage.java:
##########
@@ -201,7 +201,7 @@ public interface TxStateStorage extends ManuallyCloseable {
      *     <li>Cancels all current operations (including cursors) with storage and waits for their completion;</li>
      *     <li>Does not allow operations to be performed (exceptions will be thrown) with the storage until the cleaning is completed;</li>
      *     <li>Clears storage;</li>
-     *     <li>Sets the {@link #lastAppliedIndex()}, {@link #lastAppliedTerm()} and {@link #persistedIndex()} to {@code 0};</li>

Review Comment:
   same



##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -2372,8 +2372,8 @@ private CompletableFuture<PartitionStorages> getOrCreatePartitionStorages(TableI
                 .thenComposeAsync(mvPartitionStorage -> {
                     TxStateStorage txStateStorage = internalTable.txStateStorage().getOrCreateTxStateStorage(partitionId);
 
-                    if (mvPartitionStorage.persistedIndex() == MvPartitionStorage.REBALANCE_IN_PROGRESS
-                            || txStateStorage.persistedIndex() == TxStateStorage.REBALANCE_IN_PROGRESS) {

Review Comment:
   same



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/ColumnFamilyUtils.java:
##########
@@ -67,24 +93,135 @@ static ColumnFamilyType fromCfName(String cfName) {
     }
 
     /**
-     * Creates a column family name by index ID.
-     *
-     * @param indexId Index ID.
+     * Generates a sorted index column family name by its columns descriptions.
+     * The resulting array has a {@link #SORTED_INDEX_CF_PREFIX} prefix as a UTF8 array, followed by a number of pairs
+     * {@code {type, flags}}, where type represents ordinal of the corresponding {@link NativeTypeSpec}, and
+     * flags store information about column's nullability and comparison order.
      *
-     * @see #sortedIndexId
+     * @see #comparatorFromCfName(byte[])
      */
-    static String sortedIndexCfName(int indexId) {
-        return SORTED_INDEX_CF_PREFIX + indexId;
+    static byte[] sortedIndexCfName(List<StorageSortedIndexColumnDescriptor> columns) {

Review Comment:
   Please add unit tests for this



##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/index/StorageSortedIndexDescriptor.java:
##########
@@ -64,6 +64,7 @@ public StorageSortedIndexColumnDescriptor(String name, NativeType type, boolean
         }
 
         @Override
+        @Deprecated

Review Comment:
   Maybe add TODO or something like that?



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/ColumnFamilyUtils.java:
##########
@@ -67,24 +93,135 @@ static ColumnFamilyType fromCfName(String cfName) {
     }
 
     /**
-     * Creates a column family name by index ID.
-     *
-     * @param indexId Index ID.
+     * Generates a sorted index column family name by its columns descriptions.
+     * The resulting array has a {@link #SORTED_INDEX_CF_PREFIX} prefix as a UTF8 array, followed by a number of pairs
+     * {@code {type, flags}}, where type represents ordinal of the corresponding {@link NativeTypeSpec}, and
+     * flags store information about column's nullability and comparison order.
      *
-     * @see #sortedIndexId
+     * @see #comparatorFromCfName(byte[])
      */
-    static String sortedIndexCfName(int indexId) {
-        return SORTED_INDEX_CF_PREFIX + indexId;
+    static byte[] sortedIndexCfName(List<StorageSortedIndexColumnDescriptor> columns) {
+        ByteBuffer buf = ByteBuffer.allocate(SORTED_INDEX_CF_PREFIX.length() + columns.size() * 2);
+
+        buf.put(SORTED_INDEX_CF_PREFIX.getBytes(UTF_8));
+
+        for (StorageSortedIndexColumnDescriptor column : columns) {
+            NativeType nativeType = column.type();
+            NativeTypeSpec nativeTypeSpec = nativeType.spec();
+
+            buf.put((byte) nativeTypeSpec.ordinal());
+
+            int flags = 0;
+
+            if (column.nullable()) {
+                flags |= NULLABILITY_FLAG;
+            }
+
+            if (column.asc()) {
+                flags |= ASC_ORDER_FLAG;
+            }
+
+            buf.put((byte) flags);
+        }
+
+        return buf.array();
     }
 
     /**
-     * Extracts a Sorted Index ID from the given Column Family name.
-     *
-     * @param cfName Column Family name.
-     *
-     * @see #sortedIndexCfName
+     * Creates an {@link org.rocksdb.AbstractComparator} instance to compare keys in column family with name {@code cfName}.
+     * Please refer to {@link #sortedIndexCfName(List)} for the details of the CF name encoding.
      */
-    static int sortedIndexId(String cfName) {
-        return Integer.parseInt(cfName.substring(SORTED_INDEX_CF_PREFIX.length()));
+    public static RocksDbBinaryTupleComparator comparatorFromCfName(byte[] cfName) {

Review Comment:
   It would be nice to do unit tests for this method.



##########
modules/table/src/test/java/org/apache/ignite/internal/table/distributed/TableManagerTest.java:
##########
@@ -673,10 +673,10 @@ private void testStoragesGetClearedInMiddleOfFailedRebalance(boolean isTxStorage
 
         if (isTxStorageUnderRebalance) {
             // Emulate a situation when TX state storage was stopped in a middle of rebalance.
-            when(txStateStorage.persistedIndex()).thenReturn(TxStateStorage.REBALANCE_IN_PROGRESS);
+            when(txStateStorage.lastAppliedIndex()).thenReturn(TxStateStorage.REBALANCE_IN_PROGRESS);
         } else {
             // Emulate a situation when partition storage was stopped in a middle of rebalance.
-            when(mvPartitionStorage.persistedIndex()).thenReturn(MvPartitionStorage.REBALANCE_IN_PROGRESS);

Review Comment:
   same



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/instance/SharedRocksDbInstance.java:
##########
@@ -0,0 +1,264 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.rocksdb.instance;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.stream.Collectors.toList;
+import static org.apache.ignite.internal.rocksdb.RocksUtils.incrementPrefix;
+import static org.apache.ignite.internal.storage.rocksdb.instance.SharedRocksDbInstanceCreator.sortedIndexCfOptions;
+import static org.apache.ignite.lang.IgniteStringFormatter.format;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.apache.ignite.internal.rocksdb.ColumnFamily;
+import org.apache.ignite.internal.rocksdb.flush.RocksDbFlusher;
+import org.apache.ignite.internal.storage.StorageClosedException;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.internal.storage.rocksdb.RocksDbMetaStorage;
+import org.apache.ignite.internal.storage.rocksdb.RocksDbStorageEngine;
+import org.apache.ignite.internal.util.IgniteSpinBusyLock;
+import org.apache.ignite.internal.util.IgniteUtils;
+import org.apache.ignite.lang.ByteArray;
+import org.rocksdb.ColumnFamilyDescriptor;
+import org.rocksdb.ColumnFamilyHandle;
+import org.rocksdb.RocksDB;
+import org.rocksdb.RocksDBException;
+import org.rocksdb.WriteBatch;
+import org.rocksdb.WriteOptions;
+
+/**
+ * Shared RocksDB instance for multiple tables. Managed directly by the engine.
+ */
+public final class SharedRocksDbInstance {
+
+    /** Write options. */
+    public static final WriteOptions DFLT_WRITE_OPTS = new WriteOptions().setDisableWAL(true);
+
+    /** RocksDB storage engine instance. */
+    public final RocksDbStorageEngine engine;
+
+    /** Path for the directory that stores the data. */
+    public final Path path;
+
+    /** RocksDB flusher instance. */
+    public final RocksDbFlusher flusher;
+
+    /** Rocks DB instance. */
+    public final RocksDB db;
+
+    /** Meta information instance that wraps {@link ColumnFamily} instance for meta column family.. */

Review Comment:
   ```suggestion
       /** Meta information instance that wraps {@link ColumnFamily} instance for meta column family. */
   ```



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/RocksDbMetaStorage.java:
##########
@@ -17,110 +17,57 @@
 
 package org.apache.ignite.internal.storage.rocksdb;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.nio.ByteOrder.BIG_ENDIAN;
 import static org.apache.ignite.internal.storage.rocksdb.RocksDbStorageUtils.KEY_BYTE_ORDER;
-import static org.apache.ignite.internal.storage.rocksdb.RocksDbStorageUtils.PARTITION_ID_SIZE;
 import static org.apache.ignite.internal.storage.rocksdb.RocksDbStorageUtils.ROW_ID_SIZE;
 import static org.apache.ignite.internal.storage.rocksdb.RocksDbStorageUtils.getRowIdUuid;
-import static org.apache.ignite.internal.storage.rocksdb.RocksDbStorageUtils.putIndexId;
 import static org.apache.ignite.internal.storage.rocksdb.RocksDbStorageUtils.putRowIdUuid;
 import static org.apache.ignite.internal.util.ArrayUtils.BYTE_EMPTY_ARRAY;
 
 import java.nio.ByteBuffer;
-import java.util.stream.Stream;
 import org.apache.ignite.internal.rocksdb.ColumnFamily;
-import org.apache.ignite.internal.rocksdb.RocksUtils;
 import org.apache.ignite.internal.storage.RowId;
 import org.apache.ignite.internal.storage.StorageException;
 import org.jetbrains.annotations.Nullable;
 import org.rocksdb.AbstractWriteBatch;
-import org.rocksdb.ReadOptions;
 import org.rocksdb.RocksDBException;
-import org.rocksdb.RocksIterator;
-import org.rocksdb.Slice;
 
 /**
  * Wrapper around the ""meta"" Column Family inside a RocksDB-based storage, which stores some auxiliary information needed for internal
  * storage logic.
  */
 public class RocksDbMetaStorage {
-    /** Name of the key that corresponds to a list of existing partition IDs of a storage. */
-    private static final byte[] PARTITION_ID_PREFIX = ""part"".getBytes(UTF_8);
-
-    /** Index meta key prefix. */
-    private static final byte[] INDEX_META_KEY_PREFIX = ""index-meta"".getBytes(UTF_8);
-
-    /** Index meta key size in bytes. */
-    private static final int INDEX_META_KEY_SIZE = INDEX_META_KEY_PREFIX.length + PARTITION_ID_SIZE + ROW_ID_SIZE;
-
-    /** Name of the key that is out of range of the partition ID key prefix, used as an exclusive bound. */
-    private static final byte[] PARTITION_ID_PREFIX_END = RocksUtils.incrementPrefix(PARTITION_ID_PREFIX);
+    public static final byte[] PARTITION_META_PREFIX = {0};

Review Comment:
   Missing javadoc for constants



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/instance/SharedRocksDbInstance.java:
##########
@@ -0,0 +1,264 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.rocksdb.instance;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.stream.Collectors.toList;
+import static org.apache.ignite.internal.rocksdb.RocksUtils.incrementPrefix;
+import static org.apache.ignite.internal.storage.rocksdb.instance.SharedRocksDbInstanceCreator.sortedIndexCfOptions;
+import static org.apache.ignite.lang.IgniteStringFormatter.format;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.apache.ignite.internal.rocksdb.ColumnFamily;
+import org.apache.ignite.internal.rocksdb.flush.RocksDbFlusher;
+import org.apache.ignite.internal.storage.StorageClosedException;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.internal.storage.rocksdb.RocksDbMetaStorage;
+import org.apache.ignite.internal.storage.rocksdb.RocksDbStorageEngine;
+import org.apache.ignite.internal.util.IgniteSpinBusyLock;
+import org.apache.ignite.internal.util.IgniteUtils;
+import org.apache.ignite.lang.ByteArray;
+import org.rocksdb.ColumnFamilyDescriptor;
+import org.rocksdb.ColumnFamilyHandle;
+import org.rocksdb.RocksDB;
+import org.rocksdb.RocksDBException;
+import org.rocksdb.WriteBatch;
+import org.rocksdb.WriteOptions;
+
+/**
+ * Shared RocksDB instance for multiple tables. Managed directly by the engine.
+ */
+public final class SharedRocksDbInstance {
+
+    /** Write options. */
+    public static final WriteOptions DFLT_WRITE_OPTS = new WriteOptions().setDisableWAL(true);
+
+    /** RocksDB storage engine instance. */
+    public final RocksDbStorageEngine engine;
+
+    /** Path for the directory that stores the data. */
+    public final Path path;
+
+    /** RocksDB flusher instance. */
+    public final RocksDbFlusher flusher;
+
+    /** Rocks DB instance. */
+    public final RocksDB db;
+
+    /** Meta information instance that wraps {@link ColumnFamily} instance for meta column family.. */
+    public final RocksDbMetaStorage meta;
+
+    /** Column Family for partition data. */
+    public final ColumnFamily partitionCf;
+
+    /** Column Family for GC queue. */
+    public final ColumnFamily gcQueueCf;
+
+    /** Column Family for Hash Index data. */
+    public final ColumnFamily hashIndexCf;
+
+    /** Column Family instances for different types of sorted indexes, identified by the column family name. */
+    private final ConcurrentMap<ByteArray, ColumnFamily> sortedIndexCfs;
+
+    /** Column family names mapped to sets of index IDs, that use that CF. */
+    private final ConcurrentMap<ByteArray, Set<Integer>> sortedIndexIdsByCfName = new ConcurrentHashMap<>();
+
+    /** Busy lock to stop synchronously. */
+    private final IgniteSpinBusyLock busyLock;
+
+    /** Prevents double stopping of the component. */
+    private final AtomicBoolean stopGuard = new AtomicBoolean();
+
+    SharedRocksDbInstance(
+            RocksDbStorageEngine engine,
+            Path path,
+            IgniteSpinBusyLock busyLock,
+            RocksDbFlusher flusher,
+            RocksDB db,
+            RocksDbMetaStorage meta,
+            ColumnFamily partitionCf,
+            ColumnFamily gcQueueCf,
+            ColumnFamily hashIndexCf,
+            ConcurrentMap<ByteArray, ColumnFamily> sortedIndexCfs
+    ) {
+        this.engine = engine;
+        this.path = path;
+        this.busyLock = busyLock;
+
+        this.flusher = flusher;
+        this.db = db;
+
+        this.meta = meta;
+        this.partitionCf = partitionCf;
+        this.gcQueueCf = gcQueueCf;
+        this.hashIndexCf = hashIndexCf;
+        this.sortedIndexCfs = sortedIndexCfs;
+    }
+
+    /**
+     * Utility method that performs range-deletion in the column family.
+     */
+    public static void deleteByPrefix(WriteBatch writeBatch, ColumnFamily columnFamily, byte[] prefix) throws RocksDBException {
+        byte[] upperBound = incrementPrefix(prefix);
+
+        writeBatch.deleteRange(columnFamily.handle(), prefix, upperBound);
+    }
+
+    /**
+     * Stops the instance, freeing all allocated resources.
+     */
+    public void stop() {
+        if (!stopGuard.compareAndSet(false, true)) {
+            return;
+        }
+
+        busyLock.block();
+
+        List<AutoCloseable> resources = new ArrayList<>();
+
+        resources.add(meta.columnFamily().handle());
+        resources.add(partitionCf.handle());
+        resources.add(gcQueueCf.handle());
+        resources.add(hashIndexCf.handle());
+        resources.addAll(sortedIndexCfs.values().stream()
+                .map(ColumnFamily::handle)
+                .collect(toList())
+        );
+
+        resources.add(db);
+        resources.add(flusher::stop);
+
+        try {
+            Collections.reverse(resources);
+
+            IgniteUtils.closeAll(resources);
+        } catch (Exception e) {
+            throw new StorageException(""Failed to stop RocksDB storage: "" + path, e);
+        }
+    }
+
+    /**
+     * Returns Column Family instance with the desired name. Creates it it it doesn't exist.
+     * Tracks every created index by its {@code indexId}.
+     */
+    public ColumnFamily getSortedIndexCfOnIndexCreate(byte[] cfName, int indexId) {
+        if (!busyLock.enterBusy()) {
+            throw new StorageClosedException();
+        }
+
+        try {
+            ColumnFamily[] result = {null};
+
+            sortedIndexIdsByCfName.compute(new ByteArray(cfName), (name, indexIds) -> {
+                ColumnFamily columnFamily = getOrCreateColumnFamily(cfName, name);
+
+                result[0] = columnFamily;
+
+                if (indexIds == null) {
+                    indexIds = new HashSet<>();
+                }
+
+                indexIds.add(indexId);
+
+                return indexIds;
+            });
+
+            return result[0];
+        } finally {
+            busyLock.leaveBusy();
+        }
+    }
+
+    /**
+     * Possibly drops the column family after destroying the index.
+     */
+    public void dropCfOnIndexDestroy(byte[] cfName, int indexId) {
+        if (!busyLock.enterBusy()) {
+            throw new StorageClosedException();
+        }
+
+        try {
+            sortedIndexIdsByCfName.compute(new ByteArray(cfName), (name, indexIds) -> {
+                if (indexIds == null) {
+                    return null;
+                }
+
+                indexIds.remove(indexId);
+
+                if (indexIds.isEmpty()) {

Review Comment:
   Perhaps we need to create a new set to avoid data races.
   
   



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/instance/SharedRocksDbInstance.java:
##########
@@ -0,0 +1,264 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.rocksdb.instance;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.stream.Collectors.toList;
+import static org.apache.ignite.internal.rocksdb.RocksUtils.incrementPrefix;
+import static org.apache.ignite.internal.storage.rocksdb.instance.SharedRocksDbInstanceCreator.sortedIndexCfOptions;
+import static org.apache.ignite.lang.IgniteStringFormatter.format;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.apache.ignite.internal.rocksdb.ColumnFamily;
+import org.apache.ignite.internal.rocksdb.flush.RocksDbFlusher;
+import org.apache.ignite.internal.storage.StorageClosedException;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.internal.storage.rocksdb.RocksDbMetaStorage;
+import org.apache.ignite.internal.storage.rocksdb.RocksDbStorageEngine;
+import org.apache.ignite.internal.util.IgniteSpinBusyLock;
+import org.apache.ignite.internal.util.IgniteUtils;
+import org.apache.ignite.lang.ByteArray;
+import org.rocksdb.ColumnFamilyDescriptor;
+import org.rocksdb.ColumnFamilyHandle;
+import org.rocksdb.RocksDB;
+import org.rocksdb.RocksDBException;
+import org.rocksdb.WriteBatch;
+import org.rocksdb.WriteOptions;
+
+/**
+ * Shared RocksDB instance for multiple tables. Managed directly by the engine.
+ */
+public final class SharedRocksDbInstance {
+
+    /** Write options. */
+    public static final WriteOptions DFLT_WRITE_OPTS = new WriteOptions().setDisableWAL(true);
+
+    /** RocksDB storage engine instance. */
+    public final RocksDbStorageEngine engine;
+
+    /** Path for the directory that stores the data. */
+    public final Path path;
+
+    /** RocksDB flusher instance. */
+    public final RocksDbFlusher flusher;
+
+    /** Rocks DB instance. */
+    public final RocksDB db;
+
+    /** Meta information instance that wraps {@link ColumnFamily} instance for meta column family.. */
+    public final RocksDbMetaStorage meta;
+
+    /** Column Family for partition data. */
+    public final ColumnFamily partitionCf;
+
+    /** Column Family for GC queue. */
+    public final ColumnFamily gcQueueCf;
+
+    /** Column Family for Hash Index data. */
+    public final ColumnFamily hashIndexCf;
+
+    /** Column Family instances for different types of sorted indexes, identified by the column family name. */
+    private final ConcurrentMap<ByteArray, ColumnFamily> sortedIndexCfs;
+
+    /** Column family names mapped to sets of index IDs, that use that CF. */
+    private final ConcurrentMap<ByteArray, Set<Integer>> sortedIndexIdsByCfName = new ConcurrentHashMap<>();
+
+    /** Busy lock to stop synchronously. */
+    private final IgniteSpinBusyLock busyLock;
+
+    /** Prevents double stopping of the component. */
+    private final AtomicBoolean stopGuard = new AtomicBoolean();
+
+    SharedRocksDbInstance(
+            RocksDbStorageEngine engine,
+            Path path,
+            IgniteSpinBusyLock busyLock,
+            RocksDbFlusher flusher,
+            RocksDB db,
+            RocksDbMetaStorage meta,
+            ColumnFamily partitionCf,
+            ColumnFamily gcQueueCf,
+            ColumnFamily hashIndexCf,
+            ConcurrentMap<ByteArray, ColumnFamily> sortedIndexCfs
+    ) {
+        this.engine = engine;
+        this.path = path;
+        this.busyLock = busyLock;
+
+        this.flusher = flusher;
+        this.db = db;
+
+        this.meta = meta;
+        this.partitionCf = partitionCf;
+        this.gcQueueCf = gcQueueCf;
+        this.hashIndexCf = hashIndexCf;
+        this.sortedIndexCfs = sortedIndexCfs;
+    }
+
+    /**
+     * Utility method that performs range-deletion in the column family.
+     */
+    public static void deleteByPrefix(WriteBatch writeBatch, ColumnFamily columnFamily, byte[] prefix) throws RocksDBException {
+        byte[] upperBound = incrementPrefix(prefix);
+
+        writeBatch.deleteRange(columnFamily.handle(), prefix, upperBound);
+    }
+
+    /**
+     * Stops the instance, freeing all allocated resources.
+     */
+    public void stop() {
+        if (!stopGuard.compareAndSet(false, true)) {
+            return;
+        }
+
+        busyLock.block();
+
+        List<AutoCloseable> resources = new ArrayList<>();
+
+        resources.add(meta.columnFamily().handle());
+        resources.add(partitionCf.handle());
+        resources.add(gcQueueCf.handle());
+        resources.add(hashIndexCf.handle());
+        resources.addAll(sortedIndexCfs.values().stream()
+                .map(ColumnFamily::handle)
+                .collect(toList())
+        );
+
+        resources.add(db);
+        resources.add(flusher::stop);
+
+        try {
+            Collections.reverse(resources);
+
+            IgniteUtils.closeAll(resources);
+        } catch (Exception e) {
+            throw new StorageException(""Failed to stop RocksDB storage: "" + path, e);
+        }
+    }
+
+    /**
+     * Returns Column Family instance with the desired name. Creates it it it doesn't exist.
+     * Tracks every created index by its {@code indexId}.
+     */
+    public ColumnFamily getSortedIndexCfOnIndexCreate(byte[] cfName, int indexId) {
+        if (!busyLock.enterBusy()) {
+            throw new StorageClosedException();
+        }
+
+        try {
+            ColumnFamily[] result = {null};
+
+            sortedIndexIdsByCfName.compute(new ByteArray(cfName), (name, indexIds) -> {
+                ColumnFamily columnFamily = getOrCreateColumnFamily(cfName, name);
+
+                result[0] = columnFamily;
+
+                if (indexIds == null) {
+                    indexIds = new HashSet<>();
+                }
+
+                indexIds.add(indexId);
+
+                return indexIds;
+            });
+
+            return result[0];
+        } finally {
+            busyLock.leaveBusy();
+        }
+    }
+
+    /**
+     * Possibly drops the column family after destroying the index.
+     */
+    public void dropCfOnIndexDestroy(byte[] cfName, int indexId) {
+        if (!busyLock.enterBusy()) {
+            throw new StorageClosedException();
+        }
+
+        try {
+            sortedIndexIdsByCfName.compute(new ByteArray(cfName), (name, indexIds) -> {
+                if (indexIds == null) {
+                    return null;
+                }
+
+                indexIds.remove(indexId);
+
+                if (indexIds.isEmpty()) {
+                    indexIds = null;
+
+                    destroyColumnFamily(name);
+                }
+
+                return indexIds;
+            });
+        } finally {
+            busyLock.leaveBusy();
+        }
+    }
+
+    private ColumnFamily getOrCreateColumnFamily(byte[] cfName, ByteArray name) {
+        return sortedIndexCfs.computeIfAbsent(name, unused -> {
+            ColumnFamilyDescriptor cfDescriptor = new ColumnFamilyDescriptor(cfName, sortedIndexCfOptions(cfName));
+
+            ColumnFamily columnFamily;
+            try {
+                columnFamily = ColumnFamily.create(db, cfDescriptor);
+            } catch (RocksDBException e) {
+                throw new StorageException(""Failed to create new RocksDB column family: "" + new String(cfDescriptor.getName(), UTF_8), e);

Review Comment:
   Maybe create a helper common method to get the name from **ColumnFamilyDescriptor**?



;16/Jun/23 11:01;githubbot;600","tkalkirill commented on code in PR #2200:
URL: https://github.com/apache/ignite-3/pull/2200#discussion_r1232103992


##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/RocksDbTableStorage.java:
##########
@@ -239,7 +240,9 @@ private void destroyTableData() {
 
             rocksDb.db.write(DFLT_WRITE_OPTS, writeBatch);
         } catch (RocksDBException e) {
-            //TODO Handle.
+            String message = format(""Failed to destroy table data. [tableId={}]"", getTableId());

Review Comment:
   U can use `org.apache.ignite.internal.storage.StorageException#StorageException(int, java.lang.String, java.lang.Throwable, java.lang.Object...)`



;16/Jun/23 11:03;githubbot;600","ibessonov commented on code in PR #2200:
URL: https://github.com/apache/ignite-3/pull/2200#discussion_r1232105159


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/AbstractMvPartitionStorageTest.java:
##########
@@ -803,30 +802,25 @@ void readByTimestampWorksCorrectlyIfNoUncommittedValueExists() {
     }
 
     /**
-     * Tests that changed {@link MvPartitionStorage#lastAppliedIndex()} can be successfully read and that it's returned from
-     * {@link MvPartitionStorage#persistedIndex()} after the {@link MvPartitionStorage#flush()}.
+     * Tests that changed {@link MvPartitionStorage#lastAppliedIndex()} can be successfully read back.
      */
     @Test
     void testAppliedIndex() {
         storage.runConsistently(locker -> {
             assertEquals(0, storage.lastAppliedIndex());
             assertEquals(0, storage.lastAppliedTerm());
-            assertEquals(0, storage.persistedIndex());

Review Comment:
   I removed the method



;16/Jun/23 11:04;githubbot;600","ibessonov commented on code in PR #2200:
URL: https://github.com/apache/ignite-3/pull/2200#discussion_r1232109927


##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/ColumnFamilyUtils.java:
##########
@@ -67,24 +93,135 @@ static ColumnFamilyType fromCfName(String cfName) {
     }
 
     /**
-     * Creates a column family name by index ID.
-     *
-     * @param indexId Index ID.
+     * Generates a sorted index column family name by its columns descriptions.
+     * The resulting array has a {@link #SORTED_INDEX_CF_PREFIX} prefix as a UTF8 array, followed by a number of pairs
+     * {@code {type, flags}}, where type represents ordinal of the corresponding {@link NativeTypeSpec}, and
+     * flags store information about column's nullability and comparison order.
      *
-     * @see #sortedIndexId
+     * @see #comparatorFromCfName(byte[])
      */
-    static String sortedIndexCfName(int indexId) {
-        return SORTED_INDEX_CF_PREFIX + indexId;
+    static byte[] sortedIndexCfName(List<StorageSortedIndexColumnDescriptor> columns) {

Review Comment:
   Ok



;16/Jun/23 11:10;githubbot;600","ibessonov commented on code in PR #2200:
URL: https://github.com/apache/ignite-3/pull/2200#discussion_r1232132258


##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/ColumnFamilyUtils.java:
##########
@@ -67,24 +93,135 @@ static ColumnFamilyType fromCfName(String cfName) {
     }
 
     /**
-     * Creates a column family name by index ID.
-     *
-     * @param indexId Index ID.
+     * Generates a sorted index column family name by its columns descriptions.
+     * The resulting array has a {@link #SORTED_INDEX_CF_PREFIX} prefix as a UTF8 array, followed by a number of pairs
+     * {@code {type, flags}}, where type represents ordinal of the corresponding {@link NativeTypeSpec}, and
+     * flags store information about column's nullability and comparison order.
      *
-     * @see #sortedIndexId
+     * @see #comparatorFromCfName(byte[])
      */
-    static String sortedIndexCfName(int indexId) {
-        return SORTED_INDEX_CF_PREFIX + indexId;
+    static byte[] sortedIndexCfName(List<StorageSortedIndexColumnDescriptor> columns) {
+        ByteBuffer buf = ByteBuffer.allocate(SORTED_INDEX_CF_PREFIX.length() + columns.size() * 2);
+
+        buf.put(SORTED_INDEX_CF_PREFIX.getBytes(UTF_8));
+
+        for (StorageSortedIndexColumnDescriptor column : columns) {
+            NativeType nativeType = column.type();
+            NativeTypeSpec nativeTypeSpec = nativeType.spec();
+
+            buf.put((byte) nativeTypeSpec.ordinal());
+
+            int flags = 0;
+
+            if (column.nullable()) {
+                flags |= NULLABILITY_FLAG;
+            }
+
+            if (column.asc()) {
+                flags |= ASC_ORDER_FLAG;
+            }
+
+            buf.put((byte) flags);
+        }
+
+        return buf.array();
     }
 
     /**
-     * Extracts a Sorted Index ID from the given Column Family name.
-     *
-     * @param cfName Column Family name.
-     *
-     * @see #sortedIndexCfName
+     * Creates an {@link org.rocksdb.AbstractComparator} instance to compare keys in column family with name {@code cfName}.
+     * Please refer to {@link #sortedIndexCfName(List)} for the details of the CF name encoding.
      */
-    static int sortedIndexId(String cfName) {
-        return Integer.parseInt(cfName.substring(SORTED_INDEX_CF_PREFIX.length()));
+    public static RocksDbBinaryTupleComparator comparatorFromCfName(byte[] cfName) {

Review Comment:
   Sure



;16/Jun/23 11:36;githubbot;600","ibessonov commented on code in PR #2200:
URL: https://github.com/apache/ignite-3/pull/2200#discussion_r1232166136


##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/RocksDbStorageEngine.java:
##########
@@ -170,14 +173,18 @@ public RocksDbTableStorage createMvTable(
 
         assert dataRegion != null : ""tableId="" + tableId + "", dataRegion="" + tableDescriptor.getDataRegion();
 
-        Path tablePath = storagePath.resolve(TABLE_DIR_PREFIX + tableId);
-
-        try {
-            Files.createDirectories(tablePath);
-        } catch (IOException e) {
-            throw new StorageException(""Failed to create table store directory for table: "" + tableId, e);
-        }
+        SharedRocksDbInstance sharedInstance = sharedInstances.computeIfAbsent(tableDescriptor.getDataRegion(), name -> {

Review Comment:
   We should revisit this whole data region thing in rocksdb anyway, I think I'll create a JIRA for it



;16/Jun/23 12:09;githubbot;600","ibessonov commented on code in PR #2200:
URL: https://github.com/apache/ignite-3/pull/2200#discussion_r1232166136


##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/RocksDbStorageEngine.java:
##########
@@ -170,14 +173,18 @@ public RocksDbTableStorage createMvTable(
 
         assert dataRegion != null : ""tableId="" + tableId + "", dataRegion="" + tableDescriptor.getDataRegion();
 
-        Path tablePath = storagePath.resolve(TABLE_DIR_PREFIX + tableId);
-
-        try {
-            Files.createDirectories(tablePath);
-        } catch (IOException e) {
-            throw new StorageException(""Failed to create table store directory for table: "" + tableId, e);
-        }
+        SharedRocksDbInstance sharedInstance = sharedInstances.computeIfAbsent(tableDescriptor.getDataRegion(), name -> {

Review Comment:
   We should revisit this whole data region thing in rocksdb anyway, I think I'll create a JIRA for it
   EDIT: https://issues.apache.org/jira/browse/IGNITE-19762
   We'll figure it out later



;16/Jun/23 12:13;githubbot;600","ibessonov commented on code in PR #2200:
URL: https://github.com/apache/ignite-3/pull/2200#discussion_r1232171093


##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/instance/SharedRocksDbInstance.java:
##########
@@ -0,0 +1,264 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.rocksdb.instance;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.stream.Collectors.toList;
+import static org.apache.ignite.internal.rocksdb.RocksUtils.incrementPrefix;
+import static org.apache.ignite.internal.storage.rocksdb.instance.SharedRocksDbInstanceCreator.sortedIndexCfOptions;
+import static org.apache.ignite.lang.IgniteStringFormatter.format;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.apache.ignite.internal.rocksdb.ColumnFamily;
+import org.apache.ignite.internal.rocksdb.flush.RocksDbFlusher;
+import org.apache.ignite.internal.storage.StorageClosedException;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.internal.storage.rocksdb.RocksDbMetaStorage;
+import org.apache.ignite.internal.storage.rocksdb.RocksDbStorageEngine;
+import org.apache.ignite.internal.util.IgniteSpinBusyLock;
+import org.apache.ignite.internal.util.IgniteUtils;
+import org.apache.ignite.lang.ByteArray;
+import org.rocksdb.ColumnFamilyDescriptor;
+import org.rocksdb.ColumnFamilyHandle;
+import org.rocksdb.RocksDB;
+import org.rocksdb.RocksDBException;
+import org.rocksdb.WriteBatch;
+import org.rocksdb.WriteOptions;
+
+/**
+ * Shared RocksDB instance for multiple tables. Managed directly by the engine.
+ */
+public final class SharedRocksDbInstance {
+
+    /** Write options. */
+    public static final WriteOptions DFLT_WRITE_OPTS = new WriteOptions().setDisableWAL(true);
+
+    /** RocksDB storage engine instance. */
+    public final RocksDbStorageEngine engine;
+
+    /** Path for the directory that stores the data. */
+    public final Path path;
+
+    /** RocksDB flusher instance. */
+    public final RocksDbFlusher flusher;
+
+    /** Rocks DB instance. */
+    public final RocksDB db;
+
+    /** Meta information instance that wraps {@link ColumnFamily} instance for meta column family.. */
+    public final RocksDbMetaStorage meta;
+
+    /** Column Family for partition data. */
+    public final ColumnFamily partitionCf;
+
+    /** Column Family for GC queue. */
+    public final ColumnFamily gcQueueCf;
+
+    /** Column Family for Hash Index data. */
+    public final ColumnFamily hashIndexCf;
+
+    /** Column Family instances for different types of sorted indexes, identified by the column family name. */
+    private final ConcurrentMap<ByteArray, ColumnFamily> sortedIndexCfs;
+
+    /** Column family names mapped to sets of index IDs, that use that CF. */
+    private final ConcurrentMap<ByteArray, Set<Integer>> sortedIndexIdsByCfName = new ConcurrentHashMap<>();
+
+    /** Busy lock to stop synchronously. */
+    private final IgniteSpinBusyLock busyLock;
+
+    /** Prevents double stopping of the component. */
+    private final AtomicBoolean stopGuard = new AtomicBoolean();
+
+    SharedRocksDbInstance(
+            RocksDbStorageEngine engine,
+            Path path,
+            IgniteSpinBusyLock busyLock,
+            RocksDbFlusher flusher,
+            RocksDB db,
+            RocksDbMetaStorage meta,
+            ColumnFamily partitionCf,
+            ColumnFamily gcQueueCf,
+            ColumnFamily hashIndexCf,
+            ConcurrentMap<ByteArray, ColumnFamily> sortedIndexCfs
+    ) {
+        this.engine = engine;
+        this.path = path;
+        this.busyLock = busyLock;
+
+        this.flusher = flusher;
+        this.db = db;
+
+        this.meta = meta;
+        this.partitionCf = partitionCf;
+        this.gcQueueCf = gcQueueCf;
+        this.hashIndexCf = hashIndexCf;
+        this.sortedIndexCfs = sortedIndexCfs;
+    }
+
+    /**
+     * Utility method that performs range-deletion in the column family.
+     */
+    public static void deleteByPrefix(WriteBatch writeBatch, ColumnFamily columnFamily, byte[] prefix) throws RocksDBException {
+        byte[] upperBound = incrementPrefix(prefix);
+
+        writeBatch.deleteRange(columnFamily.handle(), prefix, upperBound);
+    }
+
+    /**
+     * Stops the instance, freeing all allocated resources.
+     */
+    public void stop() {
+        if (!stopGuard.compareAndSet(false, true)) {
+            return;
+        }
+
+        busyLock.block();
+
+        List<AutoCloseable> resources = new ArrayList<>();
+
+        resources.add(meta.columnFamily().handle());
+        resources.add(partitionCf.handle());
+        resources.add(gcQueueCf.handle());
+        resources.add(hashIndexCf.handle());
+        resources.addAll(sortedIndexCfs.values().stream()
+                .map(ColumnFamily::handle)
+                .collect(toList())
+        );
+
+        resources.add(db);
+        resources.add(flusher::stop);
+
+        try {
+            Collections.reverse(resources);
+
+            IgniteUtils.closeAll(resources);
+        } catch (Exception e) {
+            throw new StorageException(""Failed to stop RocksDB storage: "" + path, e);
+        }
+    }
+
+    /**
+     * Returns Column Family instance with the desired name. Creates it it it doesn't exist.
+     * Tracks every created index by its {@code indexId}.
+     */
+    public ColumnFamily getSortedIndexCfOnIndexCreate(byte[] cfName, int indexId) {
+        if (!busyLock.enterBusy()) {
+            throw new StorageClosedException();
+        }
+
+        try {
+            ColumnFamily[] result = {null};
+
+            sortedIndexIdsByCfName.compute(new ByteArray(cfName), (name, indexIds) -> {
+                ColumnFamily columnFamily = getOrCreateColumnFamily(cfName, name);
+
+                result[0] = columnFamily;
+
+                if (indexIds == null) {
+                    indexIds = new HashSet<>();
+                }
+
+                indexIds.add(indexId);
+
+                return indexIds;
+            });
+
+            return result[0];
+        } finally {
+            busyLock.leaveBusy();
+        }
+    }
+
+    /**
+     * Possibly drops the column family after destroying the index.
+     */
+    public void dropCfOnIndexDestroy(byte[] cfName, int indexId) {
+        if (!busyLock.enterBusy()) {
+            throw new StorageClosedException();
+        }
+
+        try {
+            sortedIndexIdsByCfName.compute(new ByteArray(cfName), (name, indexIds) -> {
+                if (indexIds == null) {
+                    return null;
+                }
+
+                indexIds.remove(indexId);
+
+                if (indexIds.isEmpty()) {

Review Comment:
   But we are protected by the lock in ""compute"" from ""sortedIndexIdsByCfName"", there are no races already



;16/Jun/23 12:15;githubbot;600","ibessonov commented on code in PR #2200:
URL: https://github.com/apache/ignite-3/pull/2200#discussion_r1232175078


##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/instance/SharedRocksDbInstance.java:
##########
@@ -0,0 +1,264 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.rocksdb.instance;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.stream.Collectors.toList;
+import static org.apache.ignite.internal.rocksdb.RocksUtils.incrementPrefix;
+import static org.apache.ignite.internal.storage.rocksdb.instance.SharedRocksDbInstanceCreator.sortedIndexCfOptions;
+import static org.apache.ignite.lang.IgniteStringFormatter.format;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.apache.ignite.internal.rocksdb.ColumnFamily;
+import org.apache.ignite.internal.rocksdb.flush.RocksDbFlusher;
+import org.apache.ignite.internal.storage.StorageClosedException;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.internal.storage.rocksdb.RocksDbMetaStorage;
+import org.apache.ignite.internal.storage.rocksdb.RocksDbStorageEngine;
+import org.apache.ignite.internal.util.IgniteSpinBusyLock;
+import org.apache.ignite.internal.util.IgniteUtils;
+import org.apache.ignite.lang.ByteArray;
+import org.rocksdb.ColumnFamilyDescriptor;
+import org.rocksdb.ColumnFamilyHandle;
+import org.rocksdb.RocksDB;
+import org.rocksdb.RocksDBException;
+import org.rocksdb.WriteBatch;
+import org.rocksdb.WriteOptions;
+
+/**
+ * Shared RocksDB instance for multiple tables. Managed directly by the engine.
+ */
+public final class SharedRocksDbInstance {
+
+    /** Write options. */
+    public static final WriteOptions DFLT_WRITE_OPTS = new WriteOptions().setDisableWAL(true);
+
+    /** RocksDB storage engine instance. */
+    public final RocksDbStorageEngine engine;
+
+    /** Path for the directory that stores the data. */
+    public final Path path;
+
+    /** RocksDB flusher instance. */
+    public final RocksDbFlusher flusher;
+
+    /** Rocks DB instance. */
+    public final RocksDB db;
+
+    /** Meta information instance that wraps {@link ColumnFamily} instance for meta column family.. */
+    public final RocksDbMetaStorage meta;
+
+    /** Column Family for partition data. */
+    public final ColumnFamily partitionCf;
+
+    /** Column Family for GC queue. */
+    public final ColumnFamily gcQueueCf;
+
+    /** Column Family for Hash Index data. */
+    public final ColumnFamily hashIndexCf;
+
+    /** Column Family instances for different types of sorted indexes, identified by the column family name. */
+    private final ConcurrentMap<ByteArray, ColumnFamily> sortedIndexCfs;
+
+    /** Column family names mapped to sets of index IDs, that use that CF. */
+    private final ConcurrentMap<ByteArray, Set<Integer>> sortedIndexIdsByCfName = new ConcurrentHashMap<>();
+
+    /** Busy lock to stop synchronously. */
+    private final IgniteSpinBusyLock busyLock;
+
+    /** Prevents double stopping of the component. */
+    private final AtomicBoolean stopGuard = new AtomicBoolean();
+
+    SharedRocksDbInstance(
+            RocksDbStorageEngine engine,
+            Path path,
+            IgniteSpinBusyLock busyLock,
+            RocksDbFlusher flusher,
+            RocksDB db,
+            RocksDbMetaStorage meta,
+            ColumnFamily partitionCf,
+            ColumnFamily gcQueueCf,
+            ColumnFamily hashIndexCf,
+            ConcurrentMap<ByteArray, ColumnFamily> sortedIndexCfs
+    ) {
+        this.engine = engine;
+        this.path = path;
+        this.busyLock = busyLock;
+
+        this.flusher = flusher;
+        this.db = db;
+
+        this.meta = meta;
+        this.partitionCf = partitionCf;
+        this.gcQueueCf = gcQueueCf;
+        this.hashIndexCf = hashIndexCf;
+        this.sortedIndexCfs = sortedIndexCfs;
+    }
+
+    /**
+     * Utility method that performs range-deletion in the column family.
+     */
+    public static void deleteByPrefix(WriteBatch writeBatch, ColumnFamily columnFamily, byte[] prefix) throws RocksDBException {
+        byte[] upperBound = incrementPrefix(prefix);
+
+        writeBatch.deleteRange(columnFamily.handle(), prefix, upperBound);
+    }
+
+    /**
+     * Stops the instance, freeing all allocated resources.
+     */
+    public void stop() {
+        if (!stopGuard.compareAndSet(false, true)) {
+            return;
+        }
+
+        busyLock.block();
+
+        List<AutoCloseable> resources = new ArrayList<>();
+
+        resources.add(meta.columnFamily().handle());
+        resources.add(partitionCf.handle());
+        resources.add(gcQueueCf.handle());
+        resources.add(hashIndexCf.handle());
+        resources.addAll(sortedIndexCfs.values().stream()
+                .map(ColumnFamily::handle)
+                .collect(toList())
+        );
+
+        resources.add(db);
+        resources.add(flusher::stop);
+
+        try {
+            Collections.reverse(resources);
+
+            IgniteUtils.closeAll(resources);
+        } catch (Exception e) {
+            throw new StorageException(""Failed to stop RocksDB storage: "" + path, e);
+        }
+    }
+
+    /**
+     * Returns Column Family instance with the desired name. Creates it it it doesn't exist.
+     * Tracks every created index by its {@code indexId}.
+     */
+    public ColumnFamily getSortedIndexCfOnIndexCreate(byte[] cfName, int indexId) {
+        if (!busyLock.enterBusy()) {
+            throw new StorageClosedException();
+        }
+
+        try {
+            ColumnFamily[] result = {null};
+
+            sortedIndexIdsByCfName.compute(new ByteArray(cfName), (name, indexIds) -> {
+                ColumnFamily columnFamily = getOrCreateColumnFamily(cfName, name);
+
+                result[0] = columnFamily;
+
+                if (indexIds == null) {
+                    indexIds = new HashSet<>();
+                }
+
+                indexIds.add(indexId);
+
+                return indexIds;
+            });
+
+            return result[0];
+        } finally {
+            busyLock.leaveBusy();
+        }
+    }
+
+    /**
+     * Possibly drops the column family after destroying the index.
+     */
+    public void dropCfOnIndexDestroy(byte[] cfName, int indexId) {
+        if (!busyLock.enterBusy()) {
+            throw new StorageClosedException();
+        }
+
+        try {
+            sortedIndexIdsByCfName.compute(new ByteArray(cfName), (name, indexIds) -> {
+                if (indexIds == null) {
+                    return null;
+                }
+
+                indexIds.remove(indexId);
+
+                if (indexIds.isEmpty()) {
+                    indexIds = null;
+
+                    destroyColumnFamily(name);
+                }
+
+                return indexIds;
+            });
+        } finally {
+            busyLock.leaveBusy();
+        }
+    }
+
+    private ColumnFamily getOrCreateColumnFamily(byte[] cfName, ByteArray name) {
+        return sortedIndexCfs.computeIfAbsent(name, unused -> {
+            ColumnFamilyDescriptor cfDescriptor = new ColumnFamilyDescriptor(cfName, sortedIndexCfOptions(cfName));
+
+            ColumnFamily columnFamily;
+            try {
+                columnFamily = ColumnFamily.create(db, cfDescriptor);
+            } catch (RocksDBException e) {
+                throw new StorageException(""Failed to create new RocksDB column family: "" + new String(cfDescriptor.getName(), UTF_8), e);

Review Comment:
   I'll do it



;16/Jun/23 12:19;githubbot;600","ibessonov commented on code in PR #2200:
URL: https://github.com/apache/ignite-3/pull/2200#discussion_r1232175439


##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/RocksDbTableStorage.java:
##########
@@ -239,7 +240,9 @@ private void destroyTableData() {
 
             rocksDb.db.write(DFLT_WRITE_OPTS, writeBatch);
         } catch (RocksDBException e) {
-            //TODO Handle.
+            String message = format(""Failed to destroy table data. [tableId={}]"", getTableId());

Review Comment:
   Ok



;16/Jun/23 12:19;githubbot;600","tkalkirill commented on code in PR #2200:
URL: https://github.com/apache/ignite-3/pull/2200#discussion_r1232189383


##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/ColumnFamilyUtils.java:
##########
@@ -92,6 +90,10 @@ public static ColumnFamilyType fromCfName(String cfName) {
         }
     }
 
+    public static String stringName(byte[] cfName) {

Review Comment:
   Missing javadoc, I think a more appropriate name `toStingName`



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/instance/SharedRocksDbInstanceCreator.java:
##########
@@ -189,7 +188,7 @@ private List<ColumnFamilyDescriptor> getExistingCfDescriptors(Path path) throws
 
     @SuppressWarnings(""resource"")
     private ColumnFamilyOptions createCfOptions(byte[] cfName, Path path) {
-        var utf8cfName = new String(cfName, UTF_8);
+        String utf8cfName = ColumnFamilyUtils.stringName(cfName);

Review Comment:
   Use static import



;16/Jun/23 12:40;githubbot;600","ibessonov merged PR #2200:
URL: https://github.com/apache/ignite-3/pull/2200


;19/Jun/23 12:16;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,7800,,,0,7800,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19275,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-05-29 15:18:31.0,,,,,,,,,,"0|z1i79k:",9223372036854775807,,,ktkalenko@gridgain.com,,,,,,,,,,,,,,,,,,,,,,,
Implement restoring of immediate scale up intent after restart when a filter was changed,IGNITE-19581,13537808,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,maliev,maliev,maliev,26/May/23 13:59,06/Jul/23 07:33,13/Jul/23 09:11,06/Jul/23 07:33,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"In https://issues.apache.org/jira/browse/IGNITE-19061 we have provided design for a correct restart of a node and recovering all Distributed Zones states.

In this ticket we want to take into account immediate scale up when filter was changed, so this intent must be restored after restart. In the ticket https://issues.apache.org/jira/browse/IGNITE-19580 we restored all zones' states, including all scheduled before restart timers, but node could be restarted when immediate scale up was running, so data nodes weren't updated before restart. This immediate propagation must be done while node is restarting.

The overall idea is to save synchronously revision of the event of filter change to Vault (let’s name it filterChangeRevision). On a restart, for every zone, when we will recover scheduled timers using topologyAugmentationMap, we will check value of zoneScaleUpChangeTriggerKey from Vault and compare it with the maxScUpFromMap and filterChangeRevision. 

Details could be found in the design document",,alapin,maliev,,,,"alievmirza opened a new pull request, #2288:
URL: https://github.com/apache/ignite-3/pull/2288

   https://issues.apache.org/jira/browse/IGNITE-19581


;04/Jul/23 20:49;githubbot;600","sanpwc merged PR #2288:
URL: https://github.com/apache/ignite-3/pull/2288


;06/Jul/23 07:33;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-19741,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jul 06 07:33:49 UTC 2023,,,,,,,,,,"0|z1i61s:",9223372036854775807,,,alapin,,,,,,,,,,,,,,,,,,"06/Jul/23 07:33;alapin;[~maliev] LGTM, merged.;;;",,,,,
Implement restoring of zones states of DistributionZoneManager after restart,IGNITE-19580,13537806,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,maliev,maliev,maliev,26/May/23 13:54,28/Jun/23 12:54,13/Jul/23 09:11,28/Jun/23 12:54,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"In https://issues.apache.org/jira/browse/IGNITE-19061 we have provided design for a correct restart of a node and recovering all Distributed Zones states.

In this ticket we want to restore {{DistributionZoneManager.ZoneState}} per every zone. Note that in this ticket we don't want to take into account immediate scale up when filter was changed, this will be done in a separate ticket (https://issues.apache.org/jira/browse/IGNITE-19581). 


h4. The overall flow is the following: 
We need to save topologyAugmentationMap to Vault synchronously on metastorage watch listener for zonesLogicalTopologyPrefix. This is the only place where {{topologyAugmentationMap}} are changed. So, when restart, for every zone from configuration, when {{onCreate}} for every zone is called, restore topologyAugmentationMap from Vault. After that restoring the values for these local fields will be as they were before restart. After that schedule scale Up timer with {{maxScUpFromMap}} and schedule a scale down timer with {{maxScDownFromMap}}. 

Details could be found in the design document.

As a result, zones' states must be restored to the state that they had before restart. It includes data nodes field, topologyAugmentationMap, and all scheduled before restart timers. Tests scenarios could be found in the document as well",,alapin,maliev,,,,"alievmirza opened a new pull request, #2253:
URL: https://github.com/apache/ignite-3/pull/2253

   https://issues.apache.org/jira/browse/IGNITE-19580


;26/Jun/23 03:20;githubbot;600","sanpwc commented on code in PR #2253:
URL: https://github.com/apache/ignite-3/pull/2253#discussion_r1243957628


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -798,15 +787,81 @@ public CompletableFuture<?> onDelete(ConfigurationNotificationEvent<Distribution
     }
 
     /**
-     * Method updates data nodes value for the specified zone, also sets {@code revision} to the
-     * {@link DistributionZonesUtil#zoneScaleUpChangeTriggerKey(int)}, {@link DistributionZonesUtil#zoneScaleDownChangeTriggerKey(int)}
-     * and {@link DistributionZonesUtil#zonesChangeTriggerKey(int)} if it passes the condition.
+     * Creates or restores zone's state depending of the {@link ZoneState#topologyAugmentationMap()} existence in the Vault.
+     * We save {@link ZoneState#topologyAugmentationMap()} in the Vault every time we receive logical topology changes from the metastore.
+     *
+     * @param zone Zone's view.
+     * @param revision Revision for which we restore zone's state.
+     */
+    private void createOrRestoreZoneState(DistributionZoneView zone, long revision) {
+        int zoneId = zone.zoneId();
+
+        VaultEntry topologyAugmentationMapFromVault = vaultMgr.get(zoneTopologyAugmentationVault(zoneId)).join();
+
+        // First creation of a zone, or first call on the manager start for the default zone.
+        if (topologyAugmentationMapFromVault == null) {
+            ZoneState zoneState = new ZoneState(executor);
+
+            zonesState.putIfAbsent(zoneId, zoneState);

Review Comment:
   If it's first creation, why it's possible to have non absent zoneId. Should we assert the putIfAbsent result?



;27/Jun/23 15:36;githubbot;600","sanpwc commented on code in PR #2253:
URL: https://github.com/apache/ignite-3/pull/2253#discussion_r1243972544


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -798,15 +787,81 @@ public CompletableFuture<?> onDelete(ConfigurationNotificationEvent<Distribution
     }
 
     /**
-     * Method updates data nodes value for the specified zone, also sets {@code revision} to the
-     * {@link DistributionZonesUtil#zoneScaleUpChangeTriggerKey(int)}, {@link DistributionZonesUtil#zoneScaleDownChangeTriggerKey(int)}
-     * and {@link DistributionZonesUtil#zonesChangeTriggerKey(int)} if it passes the condition.
+     * Creates or restores zone's state depending of the {@link ZoneState#topologyAugmentationMap()} existence in the Vault.
+     * We save {@link ZoneState#topologyAugmentationMap()} in the Vault every time we receive logical topology changes from the metastore.
+     *
+     * @param zone Zone's view.
+     * @param revision Revision for which we restore zone's state.
+     */
+    private void createOrRestoreZoneState(DistributionZoneView zone, long revision) {
+        int zoneId = zone.zoneId();
+
+        VaultEntry topologyAugmentationMapFromVault = vaultMgr.get(zoneTopologyAugmentationVault(zoneId)).join();
+
+        // First creation of a zone, or first call on the manager start for the default zone.
+        if (topologyAugmentationMapFromVault == null) {
+            ZoneState zoneState = new ZoneState(executor);
+
+            zonesState.putIfAbsent(zoneId, zoneState);
+
+            Set<Node> dataNodes = logicalTopology.stream().map(NodeWithAttributes::node).collect(toSet());
+
+            initDataNodesAndTriggerKeysInMetaStorage(zoneId, revision, dataNodes);
+        } else {
+            // Restart case, when topologyAugmentationMap has already been saved during a cluster work.
+            ConcurrentSkipListMap<Long, Augmentation> topologyAugmentationMap = fromBytes(topologyAugmentationMapFromVault.value());
+
+            ZoneState zoneState = new ZoneState(executor, topologyAugmentationMap);
+
+            VaultEntry dataNodes = vaultMgr.get(zoneDataNodesKey(zoneId)).join();

Review Comment:
   Why do we need to explicitly store dataNodes?



;27/Jun/23 15:45;githubbot;600","sanpwc commented on code in PR #2253:
URL: https://github.com/apache/ignite-3/pull/2253#discussion_r1243972544


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -798,15 +787,81 @@ public CompletableFuture<?> onDelete(ConfigurationNotificationEvent<Distribution
     }
 
     /**
-     * Method updates data nodes value for the specified zone, also sets {@code revision} to the
-     * {@link DistributionZonesUtil#zoneScaleUpChangeTriggerKey(int)}, {@link DistributionZonesUtil#zoneScaleDownChangeTriggerKey(int)}
-     * and {@link DistributionZonesUtil#zonesChangeTriggerKey(int)} if it passes the condition.
+     * Creates or restores zone's state depending of the {@link ZoneState#topologyAugmentationMap()} existence in the Vault.
+     * We save {@link ZoneState#topologyAugmentationMap()} in the Vault every time we receive logical topology changes from the metastore.
+     *
+     * @param zone Zone's view.
+     * @param revision Revision for which we restore zone's state.
+     */
+    private void createOrRestoreZoneState(DistributionZoneView zone, long revision) {
+        int zoneId = zone.zoneId();
+
+        VaultEntry topologyAugmentationMapFromVault = vaultMgr.get(zoneTopologyAugmentationVault(zoneId)).join();
+
+        // First creation of a zone, or first call on the manager start for the default zone.
+        if (topologyAugmentationMapFromVault == null) {
+            ZoneState zoneState = new ZoneState(executor);
+
+            zonesState.putIfAbsent(zoneId, zoneState);
+
+            Set<Node> dataNodes = logicalTopology.stream().map(NodeWithAttributes::node).collect(toSet());
+
+            initDataNodesAndTriggerKeysInMetaStorage(zoneId, revision, dataNodes);
+        } else {
+            // Restart case, when topologyAugmentationMap has already been saved during a cluster work.
+            ConcurrentSkipListMap<Long, Augmentation> topologyAugmentationMap = fromBytes(topologyAugmentationMapFromVault.value());
+
+            ZoneState zoneState = new ZoneState(executor, topologyAugmentationMap);
+
+            VaultEntry dataNodes = vaultMgr.get(zoneDataNodesKey(zoneId)).join();

Review Comment:
   Why do we need to explicitly store dataNodes?



;27/Jun/23 15:55;githubbot;600","sanpwc commented on code in PR #2253:
URL: https://github.com/apache/ignite-3/pull/2253#discussion_r1244005904


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -854,7 +920,7 @@ private void removeTriggerKeysAndDataNodes(int zoneId, long revision) {
 
             metaStorageManager.invoke(iif).thenAccept(res -> {

Review Comment:
   invoke exception handling



;27/Jun/23 16:09;githubbot;600","sanpwc commented on code in PR #2253:
URL: https://github.com/apache/ignite-3/pull/2253#discussion_r1244012838


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZonesUtil.java:
##########
@@ -250,24 +260,11 @@ static CompoundCondition triggerKeyConditionForZonesChanges(long revision, int z
      * @param zoneId Zone id.
      * @return Update condition.
      */
-    static CompoundCondition triggerScaleUpScaleDownKeysCondition(long scaleUpTriggerRevision, long scaleDownTriggerRevision,  int zoneId) {
-        SimpleCondition scaleUpCondition;
-
-        if (scaleUpTriggerRevision != INITIAL_TRIGGER_REVISION_VALUE) {

Review Comment:
   // todo sanpc: recall



;27/Jun/23 16:14;githubbot;600","sanpwc commented on code in PR #2253:
URL: https://github.com/apache/ignite-3/pull/2253#discussion_r1244012838


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZonesUtil.java:
##########
@@ -250,24 +260,11 @@ static CompoundCondition triggerKeyConditionForZonesChanges(long revision, int z
      * @param zoneId Zone id.
      * @return Update condition.
      */
-    static CompoundCondition triggerScaleUpScaleDownKeysCondition(long scaleUpTriggerRevision, long scaleDownTriggerRevision,  int zoneId) {
-        SimpleCondition scaleUpCondition;
-
-        if (scaleUpTriggerRevision != INITIAL_TRIGGER_REVISION_VALUE) {

Review Comment:
   restore, it's still possible to have empty scaleUp/DownTrigger keys because of race between initial zone cratetion with async initZone... and scaleUp that will be triggered on node restart.



;27/Jun/23 16:20;githubbot;600","sanpwc commented on code in PR #2253:
URL: https://github.com/apache/ignite-3/pull/2253#discussion_r1244781559


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -798,15 +787,81 @@ public CompletableFuture<?> onDelete(ConfigurationNotificationEvent<Distribution
     }
 
     /**
-     * Method updates data nodes value for the specified zone, also sets {@code revision} to the
-     * {@link DistributionZonesUtil#zoneScaleUpChangeTriggerKey(int)}, {@link DistributionZonesUtil#zoneScaleDownChangeTriggerKey(int)}
-     * and {@link DistributionZonesUtil#zonesChangeTriggerKey(int)} if it passes the condition.
+     * Creates or restores zone's state depending of the {@link ZoneState#topologyAugmentationMap()} existence in the Vault.

Review Comment:
   depending **on** i believe.



;28/Jun/23 07:08;githubbot;600","sanpwc commented on code in PR #2253:
URL: https://github.com/apache/ignite-3/pull/2253#discussion_r1244814330


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -798,15 +787,85 @@ public CompletableFuture<?> onDelete(ConfigurationNotificationEvent<Distribution
     }
 
     /**
-     * Method updates data nodes value for the specified zone, also sets {@code revision} to the
-     * {@link DistributionZonesUtil#zoneScaleUpChangeTriggerKey(int)}, {@link DistributionZonesUtil#zoneScaleDownChangeTriggerKey(int)}
-     * and {@link DistributionZonesUtil#zonesChangeTriggerKey(int)} if it passes the condition.
+     * Creates or restores zone's state depending of the {@link ZoneState#topologyAugmentationMap()} existence in the Vault.
+     * We save {@link ZoneState#topologyAugmentationMap()} in the Vault every time we receive logical topology changes from the metastore.
+     *
+     * @param zone Zone's view.
+     * @param revision Revision for which we restore zone's state.
+     */
+    private void createOrRestoreZoneState(DistributionZoneView zone, long revision) {
+        int zoneId = zone.zoneId();
+
+        VaultEntry topologyAugmentationMapFromVault = vaultMgr.get(zoneTopologyAugmentationVault(zoneId)).join();
+
+        // First creation of a zone, or first call on the manager start for the default zone.
+        if (topologyAugmentationMapFromVault == null) {
+            ZoneState zoneState = new ZoneState(executor);
+
+            ZoneState prevZoneState = zonesState.putIfAbsent(zoneId, zoneState);
+
+            assert prevZoneState == null : ""Zone's state was created twice [zoneId = "" + zoneId + ""]"";

Review Comment:
   ""]"" -> ']'      ;)



;28/Jun/23 07:39;githubbot;600","alievmirza commented on code in PR #2253:
URL: https://github.com/apache/ignite-3/pull/2253#discussion_r1244830911


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -798,15 +787,85 @@ public CompletableFuture<?> onDelete(ConfigurationNotificationEvent<Distribution
     }
 
     /**
-     * Method updates data nodes value for the specified zone, also sets {@code revision} to the
-     * {@link DistributionZonesUtil#zoneScaleUpChangeTriggerKey(int)}, {@link DistributionZonesUtil#zoneScaleDownChangeTriggerKey(int)}
-     * and {@link DistributionZonesUtil#zonesChangeTriggerKey(int)} if it passes the condition.
+     * Creates or restores zone's state depending of the {@link ZoneState#topologyAugmentationMap()} existence in the Vault.
+     * We save {@link ZoneState#topologyAugmentationMap()} in the Vault every time we receive logical topology changes from the metastore.
+     *
+     * @param zone Zone's view.
+     * @param revision Revision for which we restore zone's state.
+     */
+    private void createOrRestoreZoneState(DistributionZoneView zone, long revision) {
+        int zoneId = zone.zoneId();
+
+        VaultEntry topologyAugmentationMapFromVault = vaultMgr.get(zoneTopologyAugmentationVault(zoneId)).join();
+
+        // First creation of a zone, or first call on the manager start for the default zone.
+        if (topologyAugmentationMapFromVault == null) {
+            ZoneState zoneState = new ZoneState(executor);
+
+            ZoneState prevZoneState = zonesState.putIfAbsent(zoneId, zoneState);
+
+            assert prevZoneState == null : ""Zone's state was created twice [zoneId = "" + zoneId + ""]"";

Review Comment:
   fixed



##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -798,15 +787,81 @@ public CompletableFuture<?> onDelete(ConfigurationNotificationEvent<Distribution
     }
 
     /**
-     * Method updates data nodes value for the specified zone, also sets {@code revision} to the
-     * {@link DistributionZonesUtil#zoneScaleUpChangeTriggerKey(int)}, {@link DistributionZonesUtil#zoneScaleDownChangeTriggerKey(int)}
-     * and {@link DistributionZonesUtil#zonesChangeTriggerKey(int)} if it passes the condition.
+     * Creates or restores zone's state depending of the {@link ZoneState#topologyAugmentationMap()} existence in the Vault.

Review Comment:
   fixed



##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZonesUtil.java:
##########
@@ -250,24 +260,11 @@ static CompoundCondition triggerKeyConditionForZonesChanges(long revision, int z
      * @param zoneId Zone id.
      * @return Update condition.
      */
-    static CompoundCondition triggerScaleUpScaleDownKeysCondition(long scaleUpTriggerRevision, long scaleDownTriggerRevision,  int zoneId) {
-        SimpleCondition scaleUpCondition;
-
-        if (scaleUpTriggerRevision != INITIAL_TRIGGER_REVISION_VALUE) {

Review Comment:
   reverted



;28/Jun/23 07:53;githubbot;600","alievmirza commented on code in PR #2253:
URL: https://github.com/apache/ignite-3/pull/2253#discussion_r1244831217


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -854,7 +920,7 @@ private void removeTriggerKeysAndDataNodes(int zoneId, long revision) {
 
             metaStorageManager.invoke(iif).thenAccept(res -> {

Review Comment:
   added



##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -798,15 +787,81 @@ public CompletableFuture<?> onDelete(ConfigurationNotificationEvent<Distribution
     }
 
     /**
-     * Method updates data nodes value for the specified zone, also sets {@code revision} to the
-     * {@link DistributionZonesUtil#zoneScaleUpChangeTriggerKey(int)}, {@link DistributionZonesUtil#zoneScaleDownChangeTriggerKey(int)}
-     * and {@link DistributionZonesUtil#zonesChangeTriggerKey(int)} if it passes the condition.
+     * Creates or restores zone's state depending of the {@link ZoneState#topologyAugmentationMap()} existence in the Vault.
+     * We save {@link ZoneState#topologyAugmentationMap()} in the Vault every time we receive logical topology changes from the metastore.
+     *
+     * @param zone Zone's view.
+     * @param revision Revision for which we restore zone's state.
+     */
+    private void createOrRestoreZoneState(DistributionZoneView zone, long revision) {
+        int zoneId = zone.zoneId();
+
+        VaultEntry topologyAugmentationMapFromVault = vaultMgr.get(zoneTopologyAugmentationVault(zoneId)).join();
+
+        // First creation of a zone, or first call on the manager start for the default zone.
+        if (topologyAugmentationMapFromVault == null) {
+            ZoneState zoneState = new ZoneState(executor);
+
+            zonesState.putIfAbsent(zoneId, zoneState);

Review Comment:
   added



;28/Jun/23 07:54;githubbot;600","sanpwc merged PR #2253:
URL: https://github.com/apache/ignite-3/pull/2253


;28/Jun/23 12:53;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,7200,,,0,7200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-19741,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jun 28 12:54:05 UTC 2023,,,,,,,,,,"0|z1i61c:",9223372036854775807,,,alapin,,,,,,,,,,,,,,,,,,"28/Jun/23 12:54;alapin;[~maliev] LGTM and merged. Thanks!;;;",,,,,
org.apache.ignite.internal.cluster.management.ItClusterManagerTest#testClusterConfigurationIsRemovedFromClusterStateAfterUpdating is flaky,IGNITE-19576,13537801,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,ivan.gagarkin,ivan.gagarkin,ivan.gagarkin,26/May/23 13:06,29/May/23 14:45,13/Jul/23 09:11,29/May/23 14:45,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"The problem is the test tries to find the cluster leader twice.
{code:java}
// Wait for a new leader to be elected.
Awaitility.await().until(() -> findLeaderNode(cluster).isPresent());
// Find the new CMG leader.
MockNode newLeaderNode = findLeaderNode(cluster).orElseThrow(); {code}
 # Awaits for appearing of the new leader
 # Gets the leader

From time to time the test can't find the leader the second time. 

We should investigate it and fix it. ",,aleksandr.pakhomov,ivan.gagarkin,,,,"Flaugh24 opened a new pull request, #2110:
URL: https://github.com/apache/ignite-3/pull/2110

   https://issues.apache.org/jira/browse/IGNITE-19576


;26/May/23 13:14;githubbot;600","PakhomovAlexander merged PR #2110:
URL: https://github.com/apache/ignite-3/pull/2110


;29/May/23 14:43;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Mon May 29 14:45:07 UTC 2023,,,,,,,,,,"0|z1i608:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"29/May/23 14:45;aleksandr.pakhomov;Thank you for the patch, merged into main: bcbe8280aab3aaea1926900ec00cd70871f85b63;;;",,,,,
Implement restoring of global states of DistributionZoneManager after restart,IGNITE-19574,13537781,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,maliev,maliev,maliev,26/May/23 08:58,20/Jun/23 11:18,13/Jul/23 09:11,20/Jun/23 11:18,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"In https://issues.apache.org/jira/browse/IGNITE-19061 we have provided design for a correct restart of a node and recovering all Distributed Zones states. 

In this ticket we want to restore {{DistributionZoneManager#nodesAttributes}}, check that {{DistributionZoneManager#logicalTopology}} is restored correctly. To achieve restoring {{DistributionZoneManager#nodesAttributes}}, we need to save it synchronously to Vault when we handle {{DistributionZoneManager#createMetastorageTopologyListener}}, and read this value on a restart in {{DistributionZoneManager#start}}
Details could be found in the design document.

As a result, this global states must be restored to the state that they had before restart. Test for restart scenarios must be provided, so we want to test, that any restart of a node leads to correct global states restoring, meaning that their state before restart are restored.",,alapin,maliev,,,,"alievmirza opened a new pull request, #2172:
URL: https://github.com/apache/ignite-3/pull/2172

   (no comment)


;08/Jun/23 22:25;githubbot;600","sergeyuttsel commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1224198380


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZonesUtil.java:
##########
@@ -73,6 +73,12 @@ public class DistributionZonesUtil {
     /** Key prefix for zones' logical topology nodes and logical topology version. */
     private static final String DISTRIBUTION_ZONES_LOGICAL_TOPOLOGY_PREFIX = ""distributionZones.logicalTopology."";
 
+    /** Key value for zones' nodes' attributes in vault. */
+    private static final String DISTRIBUTION_ZONES_NODES_ATTRIBUTES_VAULT = ""vault.distributionZones.nodesAttributes"";
+
+    /** Key prefix for zones' logical topology nodes in vault. */
+    private static final String DISTRIBUTION_ZONES_LOGICAL_TOPOLOGY_VAULT = ""vault.distributionZones.logicalTopology.nodes"";

Review Comment:
   Maybe it will be better to use `""vault."" + DISTRIBUTION_ZONES_LOGICAL_TOPOLOGY`



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/distribution/zones/ItIgniteDistributionZoneManagerNodeRestartTest.java:
##########
@@ -0,0 +1,313 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.distribution.zones;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.apache.ignite.internal.distributionzones.DistributionZoneManager.IMMEDIATE_TIMER_VALUE;
+import static org.apache.ignite.internal.recovery.ConfigurationCatchUpListener.CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY;
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.testNodeName;
+import static org.apache.ignite.utils.ClusterServiceTestUtils.defaultSerializationRegistry;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+import org.apache.ignite.internal.BaseIgniteRestartTest;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.raft.TestClusterStateStorage;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyImpl;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyServiceImpl;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalNode;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.ConfigurationModules;
+import org.apache.ignite.internal.configuration.ConfigurationTreeGenerator;
+import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.storage.DistributedConfigurationStorage;
+import org.apache.ignite.internal.configuration.storage.LocalFileConfigurationStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.configuration.validation.ConfigurationValidatorImpl;
+import org.apache.ignite.internal.distributionzones.DistributionZoneConfigurationParameters;
+import org.apache.ignite.internal.distributionzones.DistributionZoneManager;
+import org.apache.ignite.internal.distributionzones.NodeWithAttributes;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZonesConfiguration;
+import org.apache.ignite.internal.manager.IgniteComponent;
+import org.apache.ignite.internal.metastorage.impl.StandaloneMetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.TestRocksDbKeyValueStorage;
+import org.apache.ignite.internal.network.configuration.NetworkConfiguration;
+import org.apache.ignite.internal.network.recovery.VaultStateIds;
+import org.apache.ignite.internal.schema.configuration.TablesConfiguration;
+import org.apache.ignite.internal.testframework.TestIgnitionManager;
+import org.apache.ignite.internal.testframework.WithSystemProperty;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.network.ClusterNode;
+import org.apache.ignite.network.NettyBootstrapFactory;
+import org.apache.ignite.network.NetworkAddress;
+import org.apache.ignite.network.scalecube.TestScaleCubeClusterServiceFactory;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+/**
+ * Tests for checking {@link DistributionZoneManager} behavior after node's restart.
+ */
+@WithSystemProperty(key = CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY, value = ""0"")
+@ExtendWith(ConfigurationExtension.class)
+public class ItIgniteDistributionZoneManagerNodeRestartTest extends BaseIgniteRestartTest {
+    private static final LogicalNode A = new LogicalNode(
+            new ClusterNode(""1"", ""A"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""US"", ""storage"", ""SSD"", ""dataRegionSize"", ""10"")
+    );
+
+    private static final LogicalNode B = new LogicalNode(
+            new ClusterNode(""2"", ""B"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""EU"", ""storage"", ""HHD"", ""dataRegionSize"", ""30"")
+    );
+
+    private static final LogicalNode C = new LogicalNode(
+            new ClusterNode(""3"", ""C"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""CN"", ""storage"", ""SSD"", ""dataRegionSize"", ""20"")
+    );
+
+    private static final String ZONE_NAME = ""zone1"";
+
+    /**
+     * Start some of Ignite components that are able to serve as Ignite node for test purposes.
+     *
+     * @param idx Node index.
+     * @return Partial node.
+     */
+    private PartialNode startPartialNode(int idx) {
+        String name = testNodeName(testInfo, idx);
+
+        Path dir = workDir.resolve(name);
+
+        List<IgniteComponent> components = new ArrayList<>();
+
+        VaultManager vault = createVault(name, dir);
+
+        ConfigurationModules modules = loadConfigurationModules(log, Thread.currentThread().getContextClassLoader());
+
+        Path configFile = workDir.resolve(TestIgnitionManager.DEFAULT_CONFIG_NAME);
+        String configString = configurationString(idx);
+        try {
+            Files.writeString(configFile, configString);
+        } catch (IOException e) {
+            throw new NodeConfigWriteException(""Failed to write config content to file."", e);
+        }
+
+        var localConfigurationGenerator = new ConfigurationTreeGenerator(
+                modules.local().rootKeys(),
+                modules.local().internalSchemaExtensions(),
+                modules.local().polymorphicSchemaExtensions()
+        );
+
+        var nodeCfgMgr = new ConfigurationManager(
+                modules.local().rootKeys(),
+                new LocalFileConfigurationStorage(configFile, localConfigurationGenerator),
+                localConfigurationGenerator,
+                ConfigurationValidatorImpl.withDefaultValidators(localConfigurationGenerator, modules.local().validators())
+        );
+
+        NetworkConfiguration networkConfiguration = nodeCfgMgr.configurationRegistry().getConfiguration(NetworkConfiguration.KEY);
+
+        var nettyBootstrapFactory = new NettyBootstrapFactory(networkConfiguration, name);
+
+        var clusterSvc = new TestScaleCubeClusterServiceFactory().createClusterService(
+                name,
+                networkConfiguration,
+                nettyBootstrapFactory,
+                defaultSerializationRegistry(),
+                new VaultStateIds(vault)
+        );
+
+        var clusterStateStorage = new TestClusterStateStorage();
+
+        var logicalTopology = new LogicalTopologyImpl(clusterStateStorage);
+
+        var cmgManager = mock(ClusterManagementGroupManager.class);
+
+        when(cmgManager.logicalTopology()).thenAnswer(invocation -> completedFuture(logicalTopology.getLogicalTopology()));
+
+        var metaStorageMgr = StandaloneMetaStorageManager.create(
+                vault,
+                new TestRocksDbKeyValueStorage(""test"", workDir.resolve(""metastorage""))
+        );
+
+        var cfgStorage = new DistributedConfigurationStorage(metaStorageMgr, vault);
+
+        ConfigurationTreeGenerator distributedConfigurationGenerator = new ConfigurationTreeGenerator(
+                modules.distributed().rootKeys(),
+                modules.distributed().internalSchemaExtensions(),
+                modules.distributed().polymorphicSchemaExtensions()
+        );
+
+        var clusterCfgMgr = new ConfigurationManager(
+                modules.distributed().rootKeys(),
+                cfgStorage,
+                distributedConfigurationGenerator,
+                ConfigurationValidatorImpl.withDefaultValidators(distributedConfigurationGenerator, modules.distributed().validators())
+        );
+
+        DistributionZonesConfiguration zonesConfiguration = clusterCfgMgr.configurationRegistry()
+                .getConfiguration(DistributionZonesConfiguration.KEY);
+
+        TablesConfiguration tablesConfiguration = clusterCfgMgr.configurationRegistry().getConfiguration(TablesConfiguration.KEY);
+
+        LogicalTopologyServiceImpl logicalTopologyService = new LogicalTopologyServiceImpl(logicalTopology, cmgManager);
+
+        DistributionZoneManager distributionZoneManager = new DistributionZoneManager(
+                zonesConfiguration,
+                tablesConfiguration,
+                metaStorageMgr,
+                logicalTopologyService,
+                vault,
+                name
+        );
+
+        // Preparing the result map.
+
+        components.add(vault);
+        components.add(nodeCfgMgr);
+
+        // Start.
+
+        vault.start();
+        vault.putName(name).join();
+
+        nodeCfgMgr.start();
+
+        // Start the remaining components.
+        List<IgniteComponent> otherComponents = List.of(
+                nettyBootstrapFactory,
+                clusterSvc,
+                clusterStateStorage,
+                cmgManager,
+                metaStorageMgr,
+                clusterCfgMgr,
+                distributionZoneManager
+        );
+
+        for (IgniteComponent component : otherComponents) {
+            component.start();
+
+            components.add(component);
+        }
+
+        PartialNode partialNode = partialNode(
+                nodeCfgMgr,
+                clusterCfgMgr,
+                null,
+                components,
+                localConfigurationGenerator,
+                logicalTopology,
+                cfgStorage,
+                distributedConfigurationGenerator
+        );
+
+        partialNodes.add(partialNode);
+
+        return partialNode;
+    }
+
+    @Test
+    public void testNodeAttributesRestoredAfterRestart() throws Exception {
+        PartialNode partialNode = startPartialNode(0);
+
+        DistributionZoneManager distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        partialNode.logicalTopology().putNode(A);
+        partialNode.logicalTopology().putNode(B);
+        partialNode.logicalTopology().putNode(C);
+
+        distributionZoneManager.createZone(
+                new DistributionZoneConfigurationParameters.Builder(ZONE_NAME)
+                        .dataNodesAutoAdjustScaleUp(IMMEDIATE_TIMER_VALUE)
+                        .dataNodesAutoAdjustScaleDown(IMMEDIATE_TIMER_VALUE)
+                        .build()
+        ).get(10_000, TimeUnit.MILLISECONDS);
+
+        Set<String> nodes = distributionZoneManager.topologyVersionedDataNodes(
+                1,
+                partialNode.logicalTopology().getLogicalTopology().version()
+        ).get(10_000, TimeUnit.MILLISECONDS);
+
+        assertEquals(Set.of(A, B, C).stream().map(ClusterNode::name).collect(Collectors.toSet()), nodes);
+
+        Map<String, Map<String, String>> nodeAttributesBeforeRestart = distributionZoneManager.nodesAttributes();
+
+        partialNode.stop();
+
+        partialNode = startPartialNode(0);
+
+        distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        Map<String, Map<String, String>> nodeAttributesAfterRestart = distributionZoneManager.nodesAttributes();
+
+        assertEquals(3, nodeAttributesAfterRestart.size());
+
+        assertEquals(nodeAttributesBeforeRestart, nodeAttributesAfterRestart);
+    }
+
+    @Test
+    public void testLogicalTopologyRestoredAfterRestart() throws Exception {
+        PartialNode partialNode = startPartialNode(0);
+
+        DistributionZoneManager distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        partialNode.logicalTopology().putNode(A);
+        partialNode.logicalTopology().putNode(B);
+        partialNode.logicalTopology().putNode(C);
+
+        distributionZoneManager.createZone(
+                new DistributionZoneConfigurationParameters.Builder(ZONE_NAME)
+                        .dataNodesAutoAdjustScaleUp(IMMEDIATE_TIMER_VALUE)
+                        .dataNodesAutoAdjustScaleDown(IMMEDIATE_TIMER_VALUE)
+                        .build()
+        ).get(10_000, TimeUnit.MILLISECONDS);
+
+        Set<String> nodes = distributionZoneManager.topologyVersionedDataNodes(
+                1,
+                partialNode.logicalTopology().getLogicalTopology().version()
+        ).get(10_000, TimeUnit.MILLISECONDS);
+
+        assertEquals(Set.of(A, B, C).stream().map(ClusterNode::name).collect(Collectors.toSet()), nodes);

Review Comment:
   `Set.of(A, B, C).stream().map(ClusterNode::name).collect(Collectors.toSet())`
   Need to save it in the variable.



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/distribution/zones/ItIgniteDistributionZoneManagerNodeRestartTest.java:
##########
@@ -0,0 +1,313 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.distribution.zones;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.apache.ignite.internal.distributionzones.DistributionZoneManager.IMMEDIATE_TIMER_VALUE;
+import static org.apache.ignite.internal.recovery.ConfigurationCatchUpListener.CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY;
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.testNodeName;
+import static org.apache.ignite.utils.ClusterServiceTestUtils.defaultSerializationRegistry;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+import org.apache.ignite.internal.BaseIgniteRestartTest;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.raft.TestClusterStateStorage;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyImpl;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyServiceImpl;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalNode;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.ConfigurationModules;
+import org.apache.ignite.internal.configuration.ConfigurationTreeGenerator;
+import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.storage.DistributedConfigurationStorage;
+import org.apache.ignite.internal.configuration.storage.LocalFileConfigurationStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.configuration.validation.ConfigurationValidatorImpl;
+import org.apache.ignite.internal.distributionzones.DistributionZoneConfigurationParameters;
+import org.apache.ignite.internal.distributionzones.DistributionZoneManager;
+import org.apache.ignite.internal.distributionzones.NodeWithAttributes;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZonesConfiguration;
+import org.apache.ignite.internal.manager.IgniteComponent;
+import org.apache.ignite.internal.metastorage.impl.StandaloneMetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.TestRocksDbKeyValueStorage;
+import org.apache.ignite.internal.network.configuration.NetworkConfiguration;
+import org.apache.ignite.internal.network.recovery.VaultStateIds;
+import org.apache.ignite.internal.schema.configuration.TablesConfiguration;
+import org.apache.ignite.internal.testframework.TestIgnitionManager;
+import org.apache.ignite.internal.testframework.WithSystemProperty;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.network.ClusterNode;
+import org.apache.ignite.network.NettyBootstrapFactory;
+import org.apache.ignite.network.NetworkAddress;
+import org.apache.ignite.network.scalecube.TestScaleCubeClusterServiceFactory;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+/**
+ * Tests for checking {@link DistributionZoneManager} behavior after node's restart.
+ */
+@WithSystemProperty(key = CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY, value = ""0"")
+@ExtendWith(ConfigurationExtension.class)
+public class ItIgniteDistributionZoneManagerNodeRestartTest extends BaseIgniteRestartTest {
+    private static final LogicalNode A = new LogicalNode(
+            new ClusterNode(""1"", ""A"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""US"", ""storage"", ""SSD"", ""dataRegionSize"", ""10"")
+    );
+
+    private static final LogicalNode B = new LogicalNode(
+            new ClusterNode(""2"", ""B"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""EU"", ""storage"", ""HHD"", ""dataRegionSize"", ""30"")
+    );
+
+    private static final LogicalNode C = new LogicalNode(
+            new ClusterNode(""3"", ""C"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""CN"", ""storage"", ""SSD"", ""dataRegionSize"", ""20"")
+    );
+
+    private static final String ZONE_NAME = ""zone1"";
+
+    /**
+     * Start some of Ignite components that are able to serve as Ignite node for test purposes.
+     *
+     * @param idx Node index.
+     * @return Partial node.
+     */
+    private PartialNode startPartialNode(int idx) {
+        String name = testNodeName(testInfo, idx);
+
+        Path dir = workDir.resolve(name);
+
+        List<IgniteComponent> components = new ArrayList<>();
+
+        VaultManager vault = createVault(name, dir);
+
+        ConfigurationModules modules = loadConfigurationModules(log, Thread.currentThread().getContextClassLoader());
+
+        Path configFile = workDir.resolve(TestIgnitionManager.DEFAULT_CONFIG_NAME);
+        String configString = configurationString(idx);
+        try {
+            Files.writeString(configFile, configString);
+        } catch (IOException e) {
+            throw new NodeConfigWriteException(""Failed to write config content to file."", e);
+        }
+
+        var localConfigurationGenerator = new ConfigurationTreeGenerator(
+                modules.local().rootKeys(),
+                modules.local().internalSchemaExtensions(),
+                modules.local().polymorphicSchemaExtensions()
+        );
+
+        var nodeCfgMgr = new ConfigurationManager(
+                modules.local().rootKeys(),
+                new LocalFileConfigurationStorage(configFile, localConfigurationGenerator),
+                localConfigurationGenerator,
+                ConfigurationValidatorImpl.withDefaultValidators(localConfigurationGenerator, modules.local().validators())
+        );
+
+        NetworkConfiguration networkConfiguration = nodeCfgMgr.configurationRegistry().getConfiguration(NetworkConfiguration.KEY);
+
+        var nettyBootstrapFactory = new NettyBootstrapFactory(networkConfiguration, name);
+
+        var clusterSvc = new TestScaleCubeClusterServiceFactory().createClusterService(
+                name,
+                networkConfiguration,
+                nettyBootstrapFactory,
+                defaultSerializationRegistry(),
+                new VaultStateIds(vault)
+        );
+
+        var clusterStateStorage = new TestClusterStateStorage();
+
+        var logicalTopology = new LogicalTopologyImpl(clusterStateStorage);
+
+        var cmgManager = mock(ClusterManagementGroupManager.class);
+
+        when(cmgManager.logicalTopology()).thenAnswer(invocation -> completedFuture(logicalTopology.getLogicalTopology()));
+
+        var metaStorageMgr = StandaloneMetaStorageManager.create(
+                vault,
+                new TestRocksDbKeyValueStorage(""test"", workDir.resolve(""metastorage""))
+        );
+
+        var cfgStorage = new DistributedConfigurationStorage(metaStorageMgr, vault);
+
+        ConfigurationTreeGenerator distributedConfigurationGenerator = new ConfigurationTreeGenerator(
+                modules.distributed().rootKeys(),
+                modules.distributed().internalSchemaExtensions(),
+                modules.distributed().polymorphicSchemaExtensions()
+        );
+
+        var clusterCfgMgr = new ConfigurationManager(
+                modules.distributed().rootKeys(),
+                cfgStorage,
+                distributedConfigurationGenerator,
+                ConfigurationValidatorImpl.withDefaultValidators(distributedConfigurationGenerator, modules.distributed().validators())
+        );
+
+        DistributionZonesConfiguration zonesConfiguration = clusterCfgMgr.configurationRegistry()
+                .getConfiguration(DistributionZonesConfiguration.KEY);
+
+        TablesConfiguration tablesConfiguration = clusterCfgMgr.configurationRegistry().getConfiguration(TablesConfiguration.KEY);
+
+        LogicalTopologyServiceImpl logicalTopologyService = new LogicalTopologyServiceImpl(logicalTopology, cmgManager);
+
+        DistributionZoneManager distributionZoneManager = new DistributionZoneManager(
+                zonesConfiguration,
+                tablesConfiguration,
+                metaStorageMgr,
+                logicalTopologyService,
+                vault,
+                name
+        );
+
+        // Preparing the result map.
+
+        components.add(vault);
+        components.add(nodeCfgMgr);
+
+        // Start.
+
+        vault.start();
+        vault.putName(name).join();
+
+        nodeCfgMgr.start();
+
+        // Start the remaining components.
+        List<IgniteComponent> otherComponents = List.of(
+                nettyBootstrapFactory,
+                clusterSvc,
+                clusterStateStorage,
+                cmgManager,
+                metaStorageMgr,
+                clusterCfgMgr,
+                distributionZoneManager
+        );
+
+        for (IgniteComponent component : otherComponents) {
+            component.start();
+
+            components.add(component);
+        }
+
+        PartialNode partialNode = partialNode(
+                nodeCfgMgr,
+                clusterCfgMgr,
+                null,
+                components,
+                localConfigurationGenerator,
+                logicalTopology,
+                cfgStorage,
+                distributedConfigurationGenerator
+        );
+
+        partialNodes.add(partialNode);
+
+        return partialNode;
+    }
+
+    @Test
+    public void testNodeAttributesRestoredAfterRestart() throws Exception {
+        PartialNode partialNode = startPartialNode(0);
+
+        DistributionZoneManager distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        partialNode.logicalTopology().putNode(A);
+        partialNode.logicalTopology().putNode(B);
+        partialNode.logicalTopology().putNode(C);
+
+        distributionZoneManager.createZone(
+                new DistributionZoneConfigurationParameters.Builder(ZONE_NAME)
+                        .dataNodesAutoAdjustScaleUp(IMMEDIATE_TIMER_VALUE)
+                        .dataNodesAutoAdjustScaleDown(IMMEDIATE_TIMER_VALUE)
+                        .build()
+        ).get(10_000, TimeUnit.MILLISECONDS);
+
+        Set<String> nodes = distributionZoneManager.topologyVersionedDataNodes(
+                1,
+                partialNode.logicalTopology().getLogicalTopology().version()
+        ).get(10_000, TimeUnit.MILLISECONDS);
+
+        assertEquals(Set.of(A, B, C).stream().map(ClusterNode::name).collect(Collectors.toSet()), nodes);
+
+        Map<String, Map<String, String>> nodeAttributesBeforeRestart = distributionZoneManager.nodesAttributes();
+
+        partialNode.stop();
+
+        partialNode = startPartialNode(0);
+
+        distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        Map<String, Map<String, String>> nodeAttributesAfterRestart = distributionZoneManager.nodesAttributes();
+
+        assertEquals(3, nodeAttributesAfterRestart.size());
+
+        assertEquals(nodeAttributesBeforeRestart, nodeAttributesAfterRestart);
+    }
+
+    @Test
+    public void testLogicalTopologyRestoredAfterRestart() throws Exception {

Review Comment:
   Do we need two separate tests? They have many of the same lines of code. Perhaps need to move them to a separate method.



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/distribution/zones/ItIgniteDistributionZoneManagerNodeRestartTest.java:
##########
@@ -0,0 +1,313 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.distribution.zones;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.apache.ignite.internal.distributionzones.DistributionZoneManager.IMMEDIATE_TIMER_VALUE;
+import static org.apache.ignite.internal.recovery.ConfigurationCatchUpListener.CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY;
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.testNodeName;
+import static org.apache.ignite.utils.ClusterServiceTestUtils.defaultSerializationRegistry;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+import org.apache.ignite.internal.BaseIgniteRestartTest;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.raft.TestClusterStateStorage;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyImpl;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyServiceImpl;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalNode;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.ConfigurationModules;
+import org.apache.ignite.internal.configuration.ConfigurationTreeGenerator;
+import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.storage.DistributedConfigurationStorage;
+import org.apache.ignite.internal.configuration.storage.LocalFileConfigurationStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.configuration.validation.ConfigurationValidatorImpl;
+import org.apache.ignite.internal.distributionzones.DistributionZoneConfigurationParameters;
+import org.apache.ignite.internal.distributionzones.DistributionZoneManager;
+import org.apache.ignite.internal.distributionzones.NodeWithAttributes;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZonesConfiguration;
+import org.apache.ignite.internal.manager.IgniteComponent;
+import org.apache.ignite.internal.metastorage.impl.StandaloneMetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.TestRocksDbKeyValueStorage;
+import org.apache.ignite.internal.network.configuration.NetworkConfiguration;
+import org.apache.ignite.internal.network.recovery.VaultStateIds;
+import org.apache.ignite.internal.schema.configuration.TablesConfiguration;
+import org.apache.ignite.internal.testframework.TestIgnitionManager;
+import org.apache.ignite.internal.testframework.WithSystemProperty;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.network.ClusterNode;
+import org.apache.ignite.network.NettyBootstrapFactory;
+import org.apache.ignite.network.NetworkAddress;
+import org.apache.ignite.network.scalecube.TestScaleCubeClusterServiceFactory;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+/**
+ * Tests for checking {@link DistributionZoneManager} behavior after node's restart.
+ */
+@WithSystemProperty(key = CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY, value = ""0"")
+@ExtendWith(ConfigurationExtension.class)
+public class ItIgniteDistributionZoneManagerNodeRestartTest extends BaseIgniteRestartTest {
+    private static final LogicalNode A = new LogicalNode(
+            new ClusterNode(""1"", ""A"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""US"", ""storage"", ""SSD"", ""dataRegionSize"", ""10"")
+    );
+
+    private static final LogicalNode B = new LogicalNode(
+            new ClusterNode(""2"", ""B"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""EU"", ""storage"", ""HHD"", ""dataRegionSize"", ""30"")
+    );
+
+    private static final LogicalNode C = new LogicalNode(
+            new ClusterNode(""3"", ""C"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""CN"", ""storage"", ""SSD"", ""dataRegionSize"", ""20"")
+    );
+
+    private static final String ZONE_NAME = ""zone1"";
+
+    /**
+     * Start some of Ignite components that are able to serve as Ignite node for test purposes.
+     *
+     * @param idx Node index.
+     * @return Partial node.
+     */
+    private PartialNode startPartialNode(int idx) {
+        String name = testNodeName(testInfo, idx);
+
+        Path dir = workDir.resolve(name);
+
+        List<IgniteComponent> components = new ArrayList<>();
+
+        VaultManager vault = createVault(name, dir);
+
+        ConfigurationModules modules = loadConfigurationModules(log, Thread.currentThread().getContextClassLoader());
+
+        Path configFile = workDir.resolve(TestIgnitionManager.DEFAULT_CONFIG_NAME);
+        String configString = configurationString(idx);
+        try {
+            Files.writeString(configFile, configString);
+        } catch (IOException e) {
+            throw new NodeConfigWriteException(""Failed to write config content to file."", e);
+        }
+
+        var localConfigurationGenerator = new ConfigurationTreeGenerator(
+                modules.local().rootKeys(),
+                modules.local().internalSchemaExtensions(),
+                modules.local().polymorphicSchemaExtensions()
+        );
+
+        var nodeCfgMgr = new ConfigurationManager(
+                modules.local().rootKeys(),
+                new LocalFileConfigurationStorage(configFile, localConfigurationGenerator),
+                localConfigurationGenerator,
+                ConfigurationValidatorImpl.withDefaultValidators(localConfigurationGenerator, modules.local().validators())
+        );
+
+        NetworkConfiguration networkConfiguration = nodeCfgMgr.configurationRegistry().getConfiguration(NetworkConfiguration.KEY);
+
+        var nettyBootstrapFactory = new NettyBootstrapFactory(networkConfiguration, name);
+
+        var clusterSvc = new TestScaleCubeClusterServiceFactory().createClusterService(
+                name,
+                networkConfiguration,
+                nettyBootstrapFactory,
+                defaultSerializationRegistry(),
+                new VaultStateIds(vault)
+        );
+
+        var clusterStateStorage = new TestClusterStateStorage();
+
+        var logicalTopology = new LogicalTopologyImpl(clusterStateStorage);
+
+        var cmgManager = mock(ClusterManagementGroupManager.class);
+
+        when(cmgManager.logicalTopology()).thenAnswer(invocation -> completedFuture(logicalTopology.getLogicalTopology()));
+
+        var metaStorageMgr = StandaloneMetaStorageManager.create(
+                vault,
+                new TestRocksDbKeyValueStorage(""test"", workDir.resolve(""metastorage""))
+        );
+
+        var cfgStorage = new DistributedConfigurationStorage(metaStorageMgr, vault);
+
+        ConfigurationTreeGenerator distributedConfigurationGenerator = new ConfigurationTreeGenerator(
+                modules.distributed().rootKeys(),
+                modules.distributed().internalSchemaExtensions(),
+                modules.distributed().polymorphicSchemaExtensions()
+        );
+
+        var clusterCfgMgr = new ConfigurationManager(
+                modules.distributed().rootKeys(),
+                cfgStorage,
+                distributedConfigurationGenerator,
+                ConfigurationValidatorImpl.withDefaultValidators(distributedConfigurationGenerator, modules.distributed().validators())
+        );
+
+        DistributionZonesConfiguration zonesConfiguration = clusterCfgMgr.configurationRegistry()
+                .getConfiguration(DistributionZonesConfiguration.KEY);
+
+        TablesConfiguration tablesConfiguration = clusterCfgMgr.configurationRegistry().getConfiguration(TablesConfiguration.KEY);
+
+        LogicalTopologyServiceImpl logicalTopologyService = new LogicalTopologyServiceImpl(logicalTopology, cmgManager);
+
+        DistributionZoneManager distributionZoneManager = new DistributionZoneManager(
+                zonesConfiguration,
+                tablesConfiguration,
+                metaStorageMgr,
+                logicalTopologyService,
+                vault,
+                name
+        );
+
+        // Preparing the result map.
+
+        components.add(vault);
+        components.add(nodeCfgMgr);
+
+        // Start.
+
+        vault.start();
+        vault.putName(name).join();
+
+        nodeCfgMgr.start();
+
+        // Start the remaining components.
+        List<IgniteComponent> otherComponents = List.of(
+                nettyBootstrapFactory,
+                clusterSvc,
+                clusterStateStorage,
+                cmgManager,
+                metaStorageMgr,
+                clusterCfgMgr,
+                distributionZoneManager
+        );
+
+        for (IgniteComponent component : otherComponents) {
+            component.start();
+
+            components.add(component);
+        }
+
+        PartialNode partialNode = partialNode(
+                nodeCfgMgr,
+                clusterCfgMgr,
+                null,
+                components,
+                localConfigurationGenerator,
+                logicalTopology,
+                cfgStorage,
+                distributedConfigurationGenerator
+        );
+
+        partialNodes.add(partialNode);
+
+        return partialNode;
+    }
+
+    @Test
+    public void testNodeAttributesRestoredAfterRestart() throws Exception {
+        PartialNode partialNode = startPartialNode(0);
+
+        DistributionZoneManager distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        partialNode.logicalTopology().putNode(A);
+        partialNode.logicalTopology().putNode(B);
+        partialNode.logicalTopology().putNode(C);
+
+        distributionZoneManager.createZone(
+                new DistributionZoneConfigurationParameters.Builder(ZONE_NAME)
+                        .dataNodesAutoAdjustScaleUp(IMMEDIATE_TIMER_VALUE)
+                        .dataNodesAutoAdjustScaleDown(IMMEDIATE_TIMER_VALUE)
+                        .build()
+        ).get(10_000, TimeUnit.MILLISECONDS);
+
+        Set<String> nodes = distributionZoneManager.topologyVersionedDataNodes(
+                1,
+                partialNode.logicalTopology().getLogicalTopology().version()
+        ).get(10_000, TimeUnit.MILLISECONDS);
+
+        assertEquals(Set.of(A, B, C).stream().map(ClusterNode::name).collect(Collectors.toSet()), nodes);
+
+        Map<String, Map<String, String>> nodeAttributesBeforeRestart = distributionZoneManager.nodesAttributes();
+
+        partialNode.stop();
+
+        partialNode = startPartialNode(0);
+
+        distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        Map<String, Map<String, String>> nodeAttributesAfterRestart = distributionZoneManager.nodesAttributes();
+
+        assertEquals(3, nodeAttributesAfterRestart.size());
+
+        assertEquals(nodeAttributesBeforeRestart, nodeAttributesAfterRestart);
+    }
+
+    @Test
+    public void testLogicalTopologyRestoredAfterRestart() throws Exception {
+        PartialNode partialNode = startPartialNode(0);
+
+        DistributionZoneManager distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        partialNode.logicalTopology().putNode(A);
+        partialNode.logicalTopology().putNode(B);
+        partialNode.logicalTopology().putNode(C);
+
+        distributionZoneManager.createZone(

Review Comment:
   Why do you need to create a zone in this test?



##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1340,6 +1349,26 @@ public void onError(Throwable e) {
         };
     }
 
+    /**
+     * Saves logical topology and nodes' attributes map to vault atomically in one batch.
+     * After restart it could be used to restore these fields.
+     *
+     * @param newLogicalTopology Logical topology.
+     */
+    private void saveLogicalTopologyNodeAttributesToVault(Set<NodeWithAttributes> newLogicalTopology) {

Review Comment:
   It's not only save to vault but also update local state of `logicalTopology` and `nodesAttributes`. Maybe need to rename it or update these fields outside from this method.



;09/Jun/23 13:23;githubbot;600","alievmirza commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1224461556


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/distribution/zones/ItIgniteDistributionZoneManagerNodeRestartTest.java:
##########
@@ -0,0 +1,313 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.distribution.zones;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.apache.ignite.internal.distributionzones.DistributionZoneManager.IMMEDIATE_TIMER_VALUE;
+import static org.apache.ignite.internal.recovery.ConfigurationCatchUpListener.CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY;
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.testNodeName;
+import static org.apache.ignite.utils.ClusterServiceTestUtils.defaultSerializationRegistry;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+import org.apache.ignite.internal.BaseIgniteRestartTest;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.raft.TestClusterStateStorage;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyImpl;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyServiceImpl;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalNode;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.ConfigurationModules;
+import org.apache.ignite.internal.configuration.ConfigurationTreeGenerator;
+import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.storage.DistributedConfigurationStorage;
+import org.apache.ignite.internal.configuration.storage.LocalFileConfigurationStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.configuration.validation.ConfigurationValidatorImpl;
+import org.apache.ignite.internal.distributionzones.DistributionZoneConfigurationParameters;
+import org.apache.ignite.internal.distributionzones.DistributionZoneManager;
+import org.apache.ignite.internal.distributionzones.NodeWithAttributes;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZonesConfiguration;
+import org.apache.ignite.internal.manager.IgniteComponent;
+import org.apache.ignite.internal.metastorage.impl.StandaloneMetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.TestRocksDbKeyValueStorage;
+import org.apache.ignite.internal.network.configuration.NetworkConfiguration;
+import org.apache.ignite.internal.network.recovery.VaultStateIds;
+import org.apache.ignite.internal.schema.configuration.TablesConfiguration;
+import org.apache.ignite.internal.testframework.TestIgnitionManager;
+import org.apache.ignite.internal.testframework.WithSystemProperty;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.network.ClusterNode;
+import org.apache.ignite.network.NettyBootstrapFactory;
+import org.apache.ignite.network.NetworkAddress;
+import org.apache.ignite.network.scalecube.TestScaleCubeClusterServiceFactory;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+/**
+ * Tests for checking {@link DistributionZoneManager} behavior after node's restart.
+ */
+@WithSystemProperty(key = CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY, value = ""0"")
+@ExtendWith(ConfigurationExtension.class)
+public class ItIgniteDistributionZoneManagerNodeRestartTest extends BaseIgniteRestartTest {
+    private static final LogicalNode A = new LogicalNode(
+            new ClusterNode(""1"", ""A"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""US"", ""storage"", ""SSD"", ""dataRegionSize"", ""10"")
+    );
+
+    private static final LogicalNode B = new LogicalNode(
+            new ClusterNode(""2"", ""B"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""EU"", ""storage"", ""HHD"", ""dataRegionSize"", ""30"")
+    );
+
+    private static final LogicalNode C = new LogicalNode(
+            new ClusterNode(""3"", ""C"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""CN"", ""storage"", ""SSD"", ""dataRegionSize"", ""20"")
+    );
+
+    private static final String ZONE_NAME = ""zone1"";
+
+    /**
+     * Start some of Ignite components that are able to serve as Ignite node for test purposes.
+     *
+     * @param idx Node index.
+     * @return Partial node.
+     */
+    private PartialNode startPartialNode(int idx) {
+        String name = testNodeName(testInfo, idx);
+
+        Path dir = workDir.resolve(name);
+
+        List<IgniteComponent> components = new ArrayList<>();
+
+        VaultManager vault = createVault(name, dir);
+
+        ConfigurationModules modules = loadConfigurationModules(log, Thread.currentThread().getContextClassLoader());
+
+        Path configFile = workDir.resolve(TestIgnitionManager.DEFAULT_CONFIG_NAME);
+        String configString = configurationString(idx);
+        try {
+            Files.writeString(configFile, configString);
+        } catch (IOException e) {
+            throw new NodeConfigWriteException(""Failed to write config content to file."", e);
+        }
+
+        var localConfigurationGenerator = new ConfigurationTreeGenerator(
+                modules.local().rootKeys(),
+                modules.local().internalSchemaExtensions(),
+                modules.local().polymorphicSchemaExtensions()
+        );
+
+        var nodeCfgMgr = new ConfigurationManager(
+                modules.local().rootKeys(),
+                new LocalFileConfigurationStorage(configFile, localConfigurationGenerator),
+                localConfigurationGenerator,
+                ConfigurationValidatorImpl.withDefaultValidators(localConfigurationGenerator, modules.local().validators())
+        );
+
+        NetworkConfiguration networkConfiguration = nodeCfgMgr.configurationRegistry().getConfiguration(NetworkConfiguration.KEY);
+
+        var nettyBootstrapFactory = new NettyBootstrapFactory(networkConfiguration, name);
+
+        var clusterSvc = new TestScaleCubeClusterServiceFactory().createClusterService(
+                name,
+                networkConfiguration,
+                nettyBootstrapFactory,
+                defaultSerializationRegistry(),
+                new VaultStateIds(vault)
+        );
+
+        var clusterStateStorage = new TestClusterStateStorage();
+
+        var logicalTopology = new LogicalTopologyImpl(clusterStateStorage);
+
+        var cmgManager = mock(ClusterManagementGroupManager.class);
+
+        when(cmgManager.logicalTopology()).thenAnswer(invocation -> completedFuture(logicalTopology.getLogicalTopology()));
+
+        var metaStorageMgr = StandaloneMetaStorageManager.create(
+                vault,
+                new TestRocksDbKeyValueStorage(""test"", workDir.resolve(""metastorage""))
+        );
+
+        var cfgStorage = new DistributedConfigurationStorage(metaStorageMgr, vault);
+
+        ConfigurationTreeGenerator distributedConfigurationGenerator = new ConfigurationTreeGenerator(
+                modules.distributed().rootKeys(),
+                modules.distributed().internalSchemaExtensions(),
+                modules.distributed().polymorphicSchemaExtensions()
+        );
+
+        var clusterCfgMgr = new ConfigurationManager(
+                modules.distributed().rootKeys(),
+                cfgStorage,
+                distributedConfigurationGenerator,
+                ConfigurationValidatorImpl.withDefaultValidators(distributedConfigurationGenerator, modules.distributed().validators())
+        );
+
+        DistributionZonesConfiguration zonesConfiguration = clusterCfgMgr.configurationRegistry()
+                .getConfiguration(DistributionZonesConfiguration.KEY);
+
+        TablesConfiguration tablesConfiguration = clusterCfgMgr.configurationRegistry().getConfiguration(TablesConfiguration.KEY);
+
+        LogicalTopologyServiceImpl logicalTopologyService = new LogicalTopologyServiceImpl(logicalTopology, cmgManager);
+
+        DistributionZoneManager distributionZoneManager = new DistributionZoneManager(
+                zonesConfiguration,
+                tablesConfiguration,
+                metaStorageMgr,
+                logicalTopologyService,
+                vault,
+                name
+        );
+
+        // Preparing the result map.
+
+        components.add(vault);
+        components.add(nodeCfgMgr);
+
+        // Start.
+
+        vault.start();
+        vault.putName(name).join();
+
+        nodeCfgMgr.start();
+
+        // Start the remaining components.
+        List<IgniteComponent> otherComponents = List.of(
+                nettyBootstrapFactory,
+                clusterSvc,
+                clusterStateStorage,
+                cmgManager,
+                metaStorageMgr,
+                clusterCfgMgr,
+                distributionZoneManager
+        );
+
+        for (IgniteComponent component : otherComponents) {
+            component.start();
+
+            components.add(component);
+        }
+
+        PartialNode partialNode = partialNode(
+                nodeCfgMgr,
+                clusterCfgMgr,
+                null,
+                components,
+                localConfigurationGenerator,
+                logicalTopology,
+                cfgStorage,
+                distributedConfigurationGenerator
+        );
+
+        partialNodes.add(partialNode);
+
+        return partialNode;
+    }
+
+    @Test
+    public void testNodeAttributesRestoredAfterRestart() throws Exception {
+        PartialNode partialNode = startPartialNode(0);
+
+        DistributionZoneManager distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        partialNode.logicalTopology().putNode(A);
+        partialNode.logicalTopology().putNode(B);
+        partialNode.logicalTopology().putNode(C);
+
+        distributionZoneManager.createZone(
+                new DistributionZoneConfigurationParameters.Builder(ZONE_NAME)
+                        .dataNodesAutoAdjustScaleUp(IMMEDIATE_TIMER_VALUE)
+                        .dataNodesAutoAdjustScaleDown(IMMEDIATE_TIMER_VALUE)
+                        .build()
+        ).get(10_000, TimeUnit.MILLISECONDS);
+
+        Set<String> nodes = distributionZoneManager.topologyVersionedDataNodes(
+                1,
+                partialNode.logicalTopology().getLogicalTopology().version()
+        ).get(10_000, TimeUnit.MILLISECONDS);
+
+        assertEquals(Set.of(A, B, C).stream().map(ClusterNode::name).collect(Collectors.toSet()), nodes);
+
+        Map<String, Map<String, String>> nodeAttributesBeforeRestart = distributionZoneManager.nodesAttributes();
+
+        partialNode.stop();
+
+        partialNode = startPartialNode(0);
+
+        distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        Map<String, Map<String, String>> nodeAttributesAfterRestart = distributionZoneManager.nodesAttributes();
+
+        assertEquals(3, nodeAttributesAfterRestart.size());
+
+        assertEquals(nodeAttributesBeforeRestart, nodeAttributesAfterRestart);
+    }
+
+    @Test
+    public void testLogicalTopologyRestoredAfterRestart() throws Exception {
+        PartialNode partialNode = startPartialNode(0);
+
+        DistributionZoneManager distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        partialNode.logicalTopology().putNode(A);
+        partialNode.logicalTopology().putNode(B);
+        partialNode.logicalTopology().putNode(C);
+
+        distributionZoneManager.createZone(

Review Comment:
   good catch, fixed! 



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/distribution/zones/ItIgniteDistributionZoneManagerNodeRestartTest.java:
##########
@@ -0,0 +1,313 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.distribution.zones;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.apache.ignite.internal.distributionzones.DistributionZoneManager.IMMEDIATE_TIMER_VALUE;
+import static org.apache.ignite.internal.recovery.ConfigurationCatchUpListener.CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY;
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.testNodeName;
+import static org.apache.ignite.utils.ClusterServiceTestUtils.defaultSerializationRegistry;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+import org.apache.ignite.internal.BaseIgniteRestartTest;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.raft.TestClusterStateStorage;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyImpl;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyServiceImpl;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalNode;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.ConfigurationModules;
+import org.apache.ignite.internal.configuration.ConfigurationTreeGenerator;
+import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.storage.DistributedConfigurationStorage;
+import org.apache.ignite.internal.configuration.storage.LocalFileConfigurationStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.configuration.validation.ConfigurationValidatorImpl;
+import org.apache.ignite.internal.distributionzones.DistributionZoneConfigurationParameters;
+import org.apache.ignite.internal.distributionzones.DistributionZoneManager;
+import org.apache.ignite.internal.distributionzones.NodeWithAttributes;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZonesConfiguration;
+import org.apache.ignite.internal.manager.IgniteComponent;
+import org.apache.ignite.internal.metastorage.impl.StandaloneMetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.TestRocksDbKeyValueStorage;
+import org.apache.ignite.internal.network.configuration.NetworkConfiguration;
+import org.apache.ignite.internal.network.recovery.VaultStateIds;
+import org.apache.ignite.internal.schema.configuration.TablesConfiguration;
+import org.apache.ignite.internal.testframework.TestIgnitionManager;
+import org.apache.ignite.internal.testframework.WithSystemProperty;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.network.ClusterNode;
+import org.apache.ignite.network.NettyBootstrapFactory;
+import org.apache.ignite.network.NetworkAddress;
+import org.apache.ignite.network.scalecube.TestScaleCubeClusterServiceFactory;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+/**
+ * Tests for checking {@link DistributionZoneManager} behavior after node's restart.
+ */
+@WithSystemProperty(key = CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY, value = ""0"")
+@ExtendWith(ConfigurationExtension.class)
+public class ItIgniteDistributionZoneManagerNodeRestartTest extends BaseIgniteRestartTest {
+    private static final LogicalNode A = new LogicalNode(
+            new ClusterNode(""1"", ""A"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""US"", ""storage"", ""SSD"", ""dataRegionSize"", ""10"")
+    );
+
+    private static final LogicalNode B = new LogicalNode(
+            new ClusterNode(""2"", ""B"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""EU"", ""storage"", ""HHD"", ""dataRegionSize"", ""30"")
+    );
+
+    private static final LogicalNode C = new LogicalNode(
+            new ClusterNode(""3"", ""C"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""CN"", ""storage"", ""SSD"", ""dataRegionSize"", ""20"")
+    );
+
+    private static final String ZONE_NAME = ""zone1"";
+
+    /**
+     * Start some of Ignite components that are able to serve as Ignite node for test purposes.
+     *
+     * @param idx Node index.
+     * @return Partial node.
+     */
+    private PartialNode startPartialNode(int idx) {
+        String name = testNodeName(testInfo, idx);
+
+        Path dir = workDir.resolve(name);
+
+        List<IgniteComponent> components = new ArrayList<>();
+
+        VaultManager vault = createVault(name, dir);
+
+        ConfigurationModules modules = loadConfigurationModules(log, Thread.currentThread().getContextClassLoader());
+
+        Path configFile = workDir.resolve(TestIgnitionManager.DEFAULT_CONFIG_NAME);
+        String configString = configurationString(idx);
+        try {
+            Files.writeString(configFile, configString);
+        } catch (IOException e) {
+            throw new NodeConfigWriteException(""Failed to write config content to file."", e);
+        }
+
+        var localConfigurationGenerator = new ConfigurationTreeGenerator(
+                modules.local().rootKeys(),
+                modules.local().internalSchemaExtensions(),
+                modules.local().polymorphicSchemaExtensions()
+        );
+
+        var nodeCfgMgr = new ConfigurationManager(
+                modules.local().rootKeys(),
+                new LocalFileConfigurationStorage(configFile, localConfigurationGenerator),
+                localConfigurationGenerator,
+                ConfigurationValidatorImpl.withDefaultValidators(localConfigurationGenerator, modules.local().validators())
+        );
+
+        NetworkConfiguration networkConfiguration = nodeCfgMgr.configurationRegistry().getConfiguration(NetworkConfiguration.KEY);
+
+        var nettyBootstrapFactory = new NettyBootstrapFactory(networkConfiguration, name);
+
+        var clusterSvc = new TestScaleCubeClusterServiceFactory().createClusterService(
+                name,
+                networkConfiguration,
+                nettyBootstrapFactory,
+                defaultSerializationRegistry(),
+                new VaultStateIds(vault)
+        );
+
+        var clusterStateStorage = new TestClusterStateStorage();
+
+        var logicalTopology = new LogicalTopologyImpl(clusterStateStorage);
+
+        var cmgManager = mock(ClusterManagementGroupManager.class);
+
+        when(cmgManager.logicalTopology()).thenAnswer(invocation -> completedFuture(logicalTopology.getLogicalTopology()));
+
+        var metaStorageMgr = StandaloneMetaStorageManager.create(
+                vault,
+                new TestRocksDbKeyValueStorage(""test"", workDir.resolve(""metastorage""))
+        );
+
+        var cfgStorage = new DistributedConfigurationStorage(metaStorageMgr, vault);
+
+        ConfigurationTreeGenerator distributedConfigurationGenerator = new ConfigurationTreeGenerator(
+                modules.distributed().rootKeys(),
+                modules.distributed().internalSchemaExtensions(),
+                modules.distributed().polymorphicSchemaExtensions()
+        );
+
+        var clusterCfgMgr = new ConfigurationManager(
+                modules.distributed().rootKeys(),
+                cfgStorage,
+                distributedConfigurationGenerator,
+                ConfigurationValidatorImpl.withDefaultValidators(distributedConfigurationGenerator, modules.distributed().validators())
+        );
+
+        DistributionZonesConfiguration zonesConfiguration = clusterCfgMgr.configurationRegistry()
+                .getConfiguration(DistributionZonesConfiguration.KEY);
+
+        TablesConfiguration tablesConfiguration = clusterCfgMgr.configurationRegistry().getConfiguration(TablesConfiguration.KEY);
+
+        LogicalTopologyServiceImpl logicalTopologyService = new LogicalTopologyServiceImpl(logicalTopology, cmgManager);
+
+        DistributionZoneManager distributionZoneManager = new DistributionZoneManager(
+                zonesConfiguration,
+                tablesConfiguration,
+                metaStorageMgr,
+                logicalTopologyService,
+                vault,
+                name
+        );
+
+        // Preparing the result map.
+
+        components.add(vault);
+        components.add(nodeCfgMgr);
+
+        // Start.
+
+        vault.start();
+        vault.putName(name).join();
+
+        nodeCfgMgr.start();
+
+        // Start the remaining components.
+        List<IgniteComponent> otherComponents = List.of(
+                nettyBootstrapFactory,
+                clusterSvc,
+                clusterStateStorage,
+                cmgManager,
+                metaStorageMgr,
+                clusterCfgMgr,
+                distributionZoneManager
+        );
+
+        for (IgniteComponent component : otherComponents) {
+            component.start();
+
+            components.add(component);
+        }
+
+        PartialNode partialNode = partialNode(
+                nodeCfgMgr,
+                clusterCfgMgr,
+                null,
+                components,
+                localConfigurationGenerator,
+                logicalTopology,
+                cfgStorage,
+                distributedConfigurationGenerator
+        );
+
+        partialNodes.add(partialNode);
+
+        return partialNode;
+    }
+
+    @Test
+    public void testNodeAttributesRestoredAfterRestart() throws Exception {
+        PartialNode partialNode = startPartialNode(0);
+
+        DistributionZoneManager distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        partialNode.logicalTopology().putNode(A);
+        partialNode.logicalTopology().putNode(B);
+        partialNode.logicalTopology().putNode(C);
+
+        distributionZoneManager.createZone(
+                new DistributionZoneConfigurationParameters.Builder(ZONE_NAME)
+                        .dataNodesAutoAdjustScaleUp(IMMEDIATE_TIMER_VALUE)
+                        .dataNodesAutoAdjustScaleDown(IMMEDIATE_TIMER_VALUE)
+                        .build()
+        ).get(10_000, TimeUnit.MILLISECONDS);
+
+        Set<String> nodes = distributionZoneManager.topologyVersionedDataNodes(
+                1,
+                partialNode.logicalTopology().getLogicalTopology().version()
+        ).get(10_000, TimeUnit.MILLISECONDS);
+
+        assertEquals(Set.of(A, B, C).stream().map(ClusterNode::name).collect(Collectors.toSet()), nodes);
+
+        Map<String, Map<String, String>> nodeAttributesBeforeRestart = distributionZoneManager.nodesAttributes();
+
+        partialNode.stop();
+
+        partialNode = startPartialNode(0);
+
+        distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        Map<String, Map<String, String>> nodeAttributesAfterRestart = distributionZoneManager.nodesAttributes();
+
+        assertEquals(3, nodeAttributesAfterRestart.size());
+
+        assertEquals(nodeAttributesBeforeRestart, nodeAttributesAfterRestart);
+    }
+
+    @Test
+    public void testLogicalTopologyRestoredAfterRestart() throws Exception {
+        PartialNode partialNode = startPartialNode(0);
+
+        DistributionZoneManager distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        partialNode.logicalTopology().putNode(A);
+        partialNode.logicalTopology().putNode(B);
+        partialNode.logicalTopology().putNode(C);
+
+        distributionZoneManager.createZone(

Review Comment:
   good catch, fixed, thanks! 



;09/Jun/23 15:34;githubbot;600","alievmirza commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1224462574


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/distribution/zones/ItIgniteDistributionZoneManagerNodeRestartTest.java:
##########
@@ -0,0 +1,313 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.distribution.zones;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.apache.ignite.internal.distributionzones.DistributionZoneManager.IMMEDIATE_TIMER_VALUE;
+import static org.apache.ignite.internal.recovery.ConfigurationCatchUpListener.CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY;
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.testNodeName;
+import static org.apache.ignite.utils.ClusterServiceTestUtils.defaultSerializationRegistry;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+import org.apache.ignite.internal.BaseIgniteRestartTest;
+import org.apache.ignite.internal.cluster.management.ClusterManagementGroupManager;
+import org.apache.ignite.internal.cluster.management.raft.TestClusterStateStorage;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyImpl;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyServiceImpl;
+import org.apache.ignite.internal.cluster.management.topology.api.LogicalNode;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.ConfigurationModules;
+import org.apache.ignite.internal.configuration.ConfigurationTreeGenerator;
+import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.storage.DistributedConfigurationStorage;
+import org.apache.ignite.internal.configuration.storage.LocalFileConfigurationStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.configuration.validation.ConfigurationValidatorImpl;
+import org.apache.ignite.internal.distributionzones.DistributionZoneConfigurationParameters;
+import org.apache.ignite.internal.distributionzones.DistributionZoneManager;
+import org.apache.ignite.internal.distributionzones.NodeWithAttributes;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZonesConfiguration;
+import org.apache.ignite.internal.manager.IgniteComponent;
+import org.apache.ignite.internal.metastorage.impl.StandaloneMetaStorageManager;
+import org.apache.ignite.internal.metastorage.server.TestRocksDbKeyValueStorage;
+import org.apache.ignite.internal.network.configuration.NetworkConfiguration;
+import org.apache.ignite.internal.network.recovery.VaultStateIds;
+import org.apache.ignite.internal.schema.configuration.TablesConfiguration;
+import org.apache.ignite.internal.testframework.TestIgnitionManager;
+import org.apache.ignite.internal.testframework.WithSystemProperty;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.network.ClusterNode;
+import org.apache.ignite.network.NettyBootstrapFactory;
+import org.apache.ignite.network.NetworkAddress;
+import org.apache.ignite.network.scalecube.TestScaleCubeClusterServiceFactory;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+/**
+ * Tests for checking {@link DistributionZoneManager} behavior after node's restart.
+ */
+@WithSystemProperty(key = CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY, value = ""0"")
+@ExtendWith(ConfigurationExtension.class)
+public class ItIgniteDistributionZoneManagerNodeRestartTest extends BaseIgniteRestartTest {
+    private static final LogicalNode A = new LogicalNode(
+            new ClusterNode(""1"", ""A"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""US"", ""storage"", ""SSD"", ""dataRegionSize"", ""10"")
+    );
+
+    private static final LogicalNode B = new LogicalNode(
+            new ClusterNode(""2"", ""B"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""EU"", ""storage"", ""HHD"", ""dataRegionSize"", ""30"")
+    );
+
+    private static final LogicalNode C = new LogicalNode(
+            new ClusterNode(""3"", ""C"", new NetworkAddress(""localhost"", 123)),
+            Map.of(""region"", ""CN"", ""storage"", ""SSD"", ""dataRegionSize"", ""20"")
+    );
+
+    private static final String ZONE_NAME = ""zone1"";
+
+    /**
+     * Start some of Ignite components that are able to serve as Ignite node for test purposes.
+     *
+     * @param idx Node index.
+     * @return Partial node.
+     */
+    private PartialNode startPartialNode(int idx) {
+        String name = testNodeName(testInfo, idx);
+
+        Path dir = workDir.resolve(name);
+
+        List<IgniteComponent> components = new ArrayList<>();
+
+        VaultManager vault = createVault(name, dir);
+
+        ConfigurationModules modules = loadConfigurationModules(log, Thread.currentThread().getContextClassLoader());
+
+        Path configFile = workDir.resolve(TestIgnitionManager.DEFAULT_CONFIG_NAME);
+        String configString = configurationString(idx);
+        try {
+            Files.writeString(configFile, configString);
+        } catch (IOException e) {
+            throw new NodeConfigWriteException(""Failed to write config content to file."", e);
+        }
+
+        var localConfigurationGenerator = new ConfigurationTreeGenerator(
+                modules.local().rootKeys(),
+                modules.local().internalSchemaExtensions(),
+                modules.local().polymorphicSchemaExtensions()
+        );
+
+        var nodeCfgMgr = new ConfigurationManager(
+                modules.local().rootKeys(),
+                new LocalFileConfigurationStorage(configFile, localConfigurationGenerator),
+                localConfigurationGenerator,
+                ConfigurationValidatorImpl.withDefaultValidators(localConfigurationGenerator, modules.local().validators())
+        );
+
+        NetworkConfiguration networkConfiguration = nodeCfgMgr.configurationRegistry().getConfiguration(NetworkConfiguration.KEY);
+
+        var nettyBootstrapFactory = new NettyBootstrapFactory(networkConfiguration, name);
+
+        var clusterSvc = new TestScaleCubeClusterServiceFactory().createClusterService(
+                name,
+                networkConfiguration,
+                nettyBootstrapFactory,
+                defaultSerializationRegistry(),
+                new VaultStateIds(vault)
+        );
+
+        var clusterStateStorage = new TestClusterStateStorage();
+
+        var logicalTopology = new LogicalTopologyImpl(clusterStateStorage);
+
+        var cmgManager = mock(ClusterManagementGroupManager.class);
+
+        when(cmgManager.logicalTopology()).thenAnswer(invocation -> completedFuture(logicalTopology.getLogicalTopology()));
+
+        var metaStorageMgr = StandaloneMetaStorageManager.create(
+                vault,
+                new TestRocksDbKeyValueStorage(""test"", workDir.resolve(""metastorage""))
+        );
+
+        var cfgStorage = new DistributedConfigurationStorage(metaStorageMgr, vault);
+
+        ConfigurationTreeGenerator distributedConfigurationGenerator = new ConfigurationTreeGenerator(
+                modules.distributed().rootKeys(),
+                modules.distributed().internalSchemaExtensions(),
+                modules.distributed().polymorphicSchemaExtensions()
+        );
+
+        var clusterCfgMgr = new ConfigurationManager(
+                modules.distributed().rootKeys(),
+                cfgStorage,
+                distributedConfigurationGenerator,
+                ConfigurationValidatorImpl.withDefaultValidators(distributedConfigurationGenerator, modules.distributed().validators())
+        );
+
+        DistributionZonesConfiguration zonesConfiguration = clusterCfgMgr.configurationRegistry()
+                .getConfiguration(DistributionZonesConfiguration.KEY);
+
+        TablesConfiguration tablesConfiguration = clusterCfgMgr.configurationRegistry().getConfiguration(TablesConfiguration.KEY);
+
+        LogicalTopologyServiceImpl logicalTopologyService = new LogicalTopologyServiceImpl(logicalTopology, cmgManager);
+
+        DistributionZoneManager distributionZoneManager = new DistributionZoneManager(
+                zonesConfiguration,
+                tablesConfiguration,
+                metaStorageMgr,
+                logicalTopologyService,
+                vault,
+                name
+        );
+
+        // Preparing the result map.
+
+        components.add(vault);
+        components.add(nodeCfgMgr);
+
+        // Start.
+
+        vault.start();
+        vault.putName(name).join();
+
+        nodeCfgMgr.start();
+
+        // Start the remaining components.
+        List<IgniteComponent> otherComponents = List.of(
+                nettyBootstrapFactory,
+                clusterSvc,
+                clusterStateStorage,
+                cmgManager,
+                metaStorageMgr,
+                clusterCfgMgr,
+                distributionZoneManager
+        );
+
+        for (IgniteComponent component : otherComponents) {
+            component.start();
+
+            components.add(component);
+        }
+
+        PartialNode partialNode = partialNode(
+                nodeCfgMgr,
+                clusterCfgMgr,
+                null,
+                components,
+                localConfigurationGenerator,
+                logicalTopology,
+                cfgStorage,
+                distributedConfigurationGenerator
+        );
+
+        partialNodes.add(partialNode);
+
+        return partialNode;
+    }
+
+    @Test
+    public void testNodeAttributesRestoredAfterRestart() throws Exception {
+        PartialNode partialNode = startPartialNode(0);
+
+        DistributionZoneManager distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        partialNode.logicalTopology().putNode(A);
+        partialNode.logicalTopology().putNode(B);
+        partialNode.logicalTopology().putNode(C);
+
+        distributionZoneManager.createZone(
+                new DistributionZoneConfigurationParameters.Builder(ZONE_NAME)
+                        .dataNodesAutoAdjustScaleUp(IMMEDIATE_TIMER_VALUE)
+                        .dataNodesAutoAdjustScaleDown(IMMEDIATE_TIMER_VALUE)
+                        .build()
+        ).get(10_000, TimeUnit.MILLISECONDS);
+
+        Set<String> nodes = distributionZoneManager.topologyVersionedDataNodes(
+                1,
+                partialNode.logicalTopology().getLogicalTopology().version()
+        ).get(10_000, TimeUnit.MILLISECONDS);
+
+        assertEquals(Set.of(A, B, C).stream().map(ClusterNode::name).collect(Collectors.toSet()), nodes);
+
+        Map<String, Map<String, String>> nodeAttributesBeforeRestart = distributionZoneManager.nodesAttributes();
+
+        partialNode.stop();
+
+        partialNode = startPartialNode(0);
+
+        distributionZoneManager = findComponent(partialNode.startedComponents(), DistributionZoneManager.class);
+
+        Map<String, Map<String, String>> nodeAttributesAfterRestart = distributionZoneManager.nodesAttributes();
+
+        assertEquals(3, nodeAttributesAfterRestart.size());
+
+        assertEquals(nodeAttributesBeforeRestart, nodeAttributesAfterRestart);
+    }
+
+    @Test
+    public void testLogicalTopologyRestoredAfterRestart() throws Exception {

Review Comment:
   Test was simplified, please check 



;09/Jun/23 15:35;githubbot;600","alievmirza commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1224462828


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZonesUtil.java:
##########
@@ -73,6 +73,12 @@ public class DistributionZonesUtil {
     /** Key prefix for zones' logical topology nodes and logical topology version. */
     private static final String DISTRIBUTION_ZONES_LOGICAL_TOPOLOGY_PREFIX = ""distributionZones.logicalTopology."";
 
+    /** Key value for zones' nodes' attributes in vault. */
+    private static final String DISTRIBUTION_ZONES_NODES_ATTRIBUTES_VAULT = ""vault.distributionZones.nodesAttributes"";
+
+    /** Key prefix for zones' logical topology nodes in vault. */
+    private static final String DISTRIBUTION_ZONES_LOGICAL_TOPOLOGY_VAULT = ""vault.distributionZones.logicalTopology.nodes"";

Review Comment:
   Thanks, changed 



##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1340,6 +1349,26 @@ public void onError(Throwable e) {
         };
     }
 
+    /**
+     * Saves logical topology and nodes' attributes map to vault atomically in one batch.
+     * After restart it could be used to restore these fields.
+     *
+     * @param newLogicalTopology Logical topology.
+     */
+    private void saveLogicalTopologyNodeAttributesToVault(Set<NodeWithAttributes> newLogicalTopology) {

Review Comment:
   renamed 



;09/Jun/23 15:36;githubbot;600","sanpwc commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1229162592


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1027,44 +1030,52 @@ private void initDataNodesFromVaultManager() {
         try {
             long appliedRevision = metaStorageManager.appliedRevision();
 
-            VaultEntry topologyEntry = vaultMgr.get(zonesLogicalTopologyKey()).join();
-
-            if (topologyEntry != null && topologyEntry.value() != null) {
-                assert  appliedRevision > 0 : ""The meta storage last applied revision is 0 but the logical topology is not null."";
-
-                logicalTopology = fromBytes(topologyEntry.value());
-
-                logicalTopology.forEach(n -> nodesAttributes.put(n.nodeId(), n.nodeAttributes()));
+            restoreGlobalStateFromVault();

Review Comment:
   It seems a little bit messy now. 
   In start() we have
   ```
               initDataNodesFromVaultManager();
   
               initLogicalTopologyAndVersionInMetaStorageOnStart();
   ```
   where `initDataNodesFromVaultManager` restores logicalTopology despite the fact that according to the method names it's the `initLogicalTopologyAndVersionInMetaStorageOnStart` to do this.
   So, please refactor this a bit, at lease by adjusting method names.



;14/Jun/23 07:44;githubbot;600","sanpwc commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1229168979


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1027,44 +1030,52 @@ private void initDataNodesFromVaultManager() {
         try {
             long appliedRevision = metaStorageManager.appliedRevision();
 
-            VaultEntry topologyEntry = vaultMgr.get(zonesLogicalTopologyKey()).join();
-
-            if (topologyEntry != null && topologyEntry.value() != null) {
-                assert  appliedRevision > 0 : ""The meta storage last applied revision is 0 but the logical topology is not null."";
-
-                logicalTopology = fromBytes(topologyEntry.value());
-
-                logicalTopology.forEach(n -> nodesAttributes.put(n.nodeId(), n.nodeAttributes()));
+            restoreGlobalStateFromVault();

Review Comment:
   I've tried to understand what `initLogicalTopologyAndVersionInMetaStorageOnStart` should do though it's javadoc and failed with this.
   ```
       /**
        * Initialises {@link DistributionZonesUtil#zonesLogicalTopologyKey()} and
        * {@link DistributionZonesUtil#zonesLogicalTopologyVersionKey()} from meta storage on the start of {@link DistributionZoneManager}.
        */
   ```
   What do you mean by `Initialises {@link DistributionZonesUtil#zonesLogicalTopologyKey()}` for example?



;14/Jun/23 07:49;githubbot;600","sanpwc commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1229395040


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1027,44 +1030,52 @@ private void initDataNodesFromVaultManager() {
         try {
             long appliedRevision = metaStorageManager.appliedRevision();
 
-            VaultEntry topologyEntry = vaultMgr.get(zonesLogicalTopologyKey()).join();
-
-            if (topologyEntry != null && topologyEntry.value() != null) {
-                assert  appliedRevision > 0 : ""The meta storage last applied revision is 0 but the logical topology is not null."";
-
-                logicalTopology = fromBytes(topologyEntry.value());
-
-                logicalTopology.forEach(n -> nodesAttributes.put(n.nodeId(), n.nodeAttributes()));
+            restoreGlobalStateFromVault();
 
+            if (!logicalTopology.isEmpty()) {
                 // init keys and data nodes for default zone
                 saveDataNodesAndUpdateTriggerKeysInMetaStorage(
                         DEFAULT_ZONE_ID,
                         appliedRevision,
                         logicalTopology.stream().map(NodeWithAttributes::node).collect(toSet())
                 );
-
-                zonesConfiguration.distributionZones().value().forEach(zone -> {
-                    int zoneId = zone.zoneId();
-
-                    saveDataNodesAndUpdateTriggerKeysInMetaStorage(
-                            zoneId,
-                            appliedRevision,
-                            logicalTopology.stream().map(NodeWithAttributes::node).collect(toSet())
-                    );
-                });
             }
 
             zonesState.values().forEach(zoneState -> {
                 zoneState.nodes(logicalTopology.stream().map(NodeWithAttributes::nodeName).collect(toSet()));
             });
 
-            assert topologyEntry == null || topologyEntry.value() == null || logicalTopology.equals(fromBytes(topologyEntry.value()))
-                    : ""Initial value of logical topology was changed after initialization from the vault manager."";
         } finally {
             busyLock.leaveBusy();
         }
     }
 
+    /**
+     * Restores from vault logical topology and nodes' attributes fields in {@link DistributionZoneManager} after restart.
+     */
+    private void restoreGlobalStateFromVault() {
+        VaultEntry topologyEntry = vaultMgr.get(zonesLogicalTopologyVault()).join();
+
+        VaultEntry nodeAttributesEntry = vaultMgr.get(zonesNodesAttributesVault()).join();
+
+        if (topologyEntry != null && topologyEntry.value() != null) {
+            assert nodeAttributesEntry != null : ""Nodes' attributes cannot be null when logical topology is not null."";
+            assert nodeAttributesEntry.value() != null : ""Nodes' attributes cannot be null when logical topology is not null."";
+
+            logicalTopology = fromBytes(topologyEntry.value());
+
+            nodesAttributes = fromBytes(nodeAttributesEntry.value());

Review Comment:
   What kind of Map class will be resolved from fromBytes()?



;14/Jun/23 10:42;githubbot;600","sanpwc commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1229398452


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1119,9 +1130,8 @@ public CompletableFuture<Void> onUpdate(WatchEvent evt) {
                                     .map(NodeWithAttributes::node)
                                     .collect(toSet());
 
-                    newLogicalTopology.forEach(n -> nodesAttributes.put(n.nodeId(), n.nodeAttributes()));
+                    updateLogicalTopologyNodeAttributesAndSaveToVault(newLogicalTopology);

Review Comment:
   So, as a result we may finish with an inconsistent vault state, if we will fail right after `updateLogicalTopologyNodeAttributesAndSaveToVault` when applied revision will be x but logicalTopology and node attributes will match x + 1. It's not a problem right?



;14/Jun/23 10:45;githubbot;600","alievmirza commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1229400809


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1027,44 +1030,52 @@ private void initDataNodesFromVaultManager() {
         try {
             long appliedRevision = metaStorageManager.appliedRevision();
 
-            VaultEntry topologyEntry = vaultMgr.get(zonesLogicalTopologyKey()).join();
-
-            if (topologyEntry != null && topologyEntry.value() != null) {
-                assert  appliedRevision > 0 : ""The meta storage last applied revision is 0 but the logical topology is not null."";
-
-                logicalTopology = fromBytes(topologyEntry.value());
-
-                logicalTopology.forEach(n -> nodesAttributes.put(n.nodeId(), n.nodeAttributes()));
+            restoreGlobalStateFromVault();
 
+            if (!logicalTopology.isEmpty()) {
                 // init keys and data nodes for default zone
                 saveDataNodesAndUpdateTriggerKeysInMetaStorage(
                         DEFAULT_ZONE_ID,
                         appliedRevision,
                         logicalTopology.stream().map(NodeWithAttributes::node).collect(toSet())
                 );
-
-                zonesConfiguration.distributionZones().value().forEach(zone -> {
-                    int zoneId = zone.zoneId();
-
-                    saveDataNodesAndUpdateTriggerKeysInMetaStorage(
-                            zoneId,
-                            appliedRevision,
-                            logicalTopology.stream().map(NodeWithAttributes::node).collect(toSet())
-                    );
-                });
             }
 
             zonesState.values().forEach(zoneState -> {
                 zoneState.nodes(logicalTopology.stream().map(NodeWithAttributes::nodeName).collect(toSet()));
             });
 
-            assert topologyEntry == null || topologyEntry.value() == null || logicalTopology.equals(fromBytes(topologyEntry.value()))
-                    : ""Initial value of logical topology was changed after initialization from the vault manager."";
         } finally {
             busyLock.leaveBusy();
         }
     }
 
+    /**
+     * Restores from vault logical topology and nodes' attributes fields in {@link DistributionZoneManager} after restart.
+     */
+    private void restoreGlobalStateFromVault() {
+        VaultEntry topologyEntry = vaultMgr.get(zonesLogicalTopologyVault()).join();
+
+        VaultEntry nodeAttributesEntry = vaultMgr.get(zonesNodesAttributesVault()).join();
+
+        if (topologyEntry != null && topologyEntry.value() != null) {
+            assert nodeAttributesEntry != null : ""Nodes' attributes cannot be null when logical topology is not null."";
+            assert nodeAttributesEntry.value() != null : ""Nodes' attributes cannot be null when logical topology is not null."";
+
+            logicalTopology = fromBytes(topologyEntry.value());
+
+            nodesAttributes = fromBytes(nodeAttributesEntry.value());

Review Comment:
   `ConcurrentHashMap`



;14/Jun/23 10:47;githubbot;600","sanpwc commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1229409136


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneManagerConfigurationChangesTest.java:
##########
@@ -113,7 +116,12 @@ public void setUp() throws Exception {
 
         // Mock logical topology for distribution zone.
         vaultMgr = new VaultManager(new InMemoryVaultService());
-        assertThat(vaultMgr.put(zonesLogicalTopologyKey(), toBytes(nodes)), willCompleteSuccessfully());
+        assertThat(vaultMgr.put(zonesLogicalTopologyVault(), toBytes(nodes)), willCompleteSuccessfully());
+
+        Map<String, Map<String, String>> nodesAttributes = new HashMap<>();

Review Comment:
   Is it safe to use non-thread-safe map?



;14/Jun/23 10:55;githubbot;600","sanpwc commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1229409136


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneManagerConfigurationChangesTest.java:
##########
@@ -113,7 +116,12 @@ public void setUp() throws Exception {
 
         // Mock logical topology for distribution zone.
         vaultMgr = new VaultManager(new InMemoryVaultService());
-        assertThat(vaultMgr.put(zonesLogicalTopologyKey(), toBytes(nodes)), willCompleteSuccessfully());
+        assertThat(vaultMgr.put(zonesLogicalTopologyVault(), toBytes(nodes)), willCompleteSuccessfully());
+
+        Map<String, Map<String, String>> nodesAttributes = new HashMap<>();

Review Comment:
   Here and in other tests. Is it safe to use non-thread-safe map?



;14/Jun/23 10:57;githubbot;600","sanpwc commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1229416702


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/BaseIgniteRestartTest.java:
##########
@@ -0,0 +1,369 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal;
+
+import static org.apache.ignite.internal.recovery.ConfigurationCatchUpListener.CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Consumer;
+import org.apache.ignite.IgnitionManager;
+import org.apache.ignite.configuration.ConfigurationModule;
+import org.apache.ignite.internal.close.ManuallyCloseable;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopology;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyImpl;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.ConfigurationModules;
+import org.apache.ignite.internal.configuration.ConfigurationTreeGenerator;
+import org.apache.ignite.internal.configuration.ServiceLoaderModulesProvider;
+import org.apache.ignite.internal.configuration.storage.ConfigurationStorage;
+import org.apache.ignite.internal.configuration.storage.DistributedConfigurationStorage;
+import org.apache.ignite.internal.logger.IgniteLogger;
+import org.apache.ignite.internal.manager.IgniteComponent;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.recovery.ConfigurationCatchUpListener;
+import org.apache.ignite.internal.recovery.RecoveryCompletionFutureFactory;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.util.IgniteUtils;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.persistence.PersistentVaultService;
+import org.apache.ignite.lang.IgniteInternalException;
+import org.apache.ignite.lang.IgniteStringFormatter;
+import org.apache.ignite.lang.IgniteSystemProperties;
+import org.apache.ignite.lang.NodeStoppingException;
+import org.intellij.lang.annotations.Language;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.TestInfo;
+
+/**
+ * Base class for node's restart tests.
+ */
+public abstract class BaseIgniteRestartTest extends IgniteAbstractTest {

Review Comment:
   So, you are going to extend given class by all node restart tests, is that correct? What about `ItIgniteInMemoryNodeRestartTest`?



;14/Jun/23 11:01;githubbot;600","sanpwc commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1229417932


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/BaseIgniteRestartTest.java:
##########
@@ -0,0 +1,369 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal;
+
+import static org.apache.ignite.internal.recovery.ConfigurationCatchUpListener.CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Consumer;
+import org.apache.ignite.IgnitionManager;
+import org.apache.ignite.configuration.ConfigurationModule;
+import org.apache.ignite.internal.close.ManuallyCloseable;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopology;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyImpl;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.ConfigurationModules;
+import org.apache.ignite.internal.configuration.ConfigurationTreeGenerator;
+import org.apache.ignite.internal.configuration.ServiceLoaderModulesProvider;
+import org.apache.ignite.internal.configuration.storage.ConfigurationStorage;
+import org.apache.ignite.internal.configuration.storage.DistributedConfigurationStorage;
+import org.apache.ignite.internal.logger.IgniteLogger;
+import org.apache.ignite.internal.manager.IgniteComponent;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.recovery.ConfigurationCatchUpListener;
+import org.apache.ignite.internal.recovery.RecoveryCompletionFutureFactory;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.util.IgniteUtils;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.persistence.PersistentVaultService;
+import org.apache.ignite.lang.IgniteInternalException;
+import org.apache.ignite.lang.IgniteStringFormatter;
+import org.apache.ignite.lang.IgniteSystemProperties;
+import org.apache.ignite.lang.NodeStoppingException;
+import org.intellij.lang.annotations.Language;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.TestInfo;
+
+/**
+ * Base class for node's restart tests.
+ */
+public abstract class BaseIgniteRestartTest extends IgniteAbstractTest {
+    /** Default node port. */
+    protected static final int DEFAULT_NODE_PORT = 3344;
+
+    @Language(""HOCON"")
+    protected static final String RAFT_CFG = ""{\n""
+            + ""  fsync: false,\n""

Review Comment:
   Why? AFAIK default is true.



;14/Jun/23 11:03;githubbot;600","alievmirza commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1229602840


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/BaseIgniteRestartTest.java:
##########
@@ -0,0 +1,369 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal;
+
+import static org.apache.ignite.internal.recovery.ConfigurationCatchUpListener.CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Consumer;
+import org.apache.ignite.IgnitionManager;
+import org.apache.ignite.configuration.ConfigurationModule;
+import org.apache.ignite.internal.close.ManuallyCloseable;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopology;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyImpl;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.ConfigurationModules;
+import org.apache.ignite.internal.configuration.ConfigurationTreeGenerator;
+import org.apache.ignite.internal.configuration.ServiceLoaderModulesProvider;
+import org.apache.ignite.internal.configuration.storage.ConfigurationStorage;
+import org.apache.ignite.internal.configuration.storage.DistributedConfigurationStorage;
+import org.apache.ignite.internal.logger.IgniteLogger;
+import org.apache.ignite.internal.manager.IgniteComponent;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.recovery.ConfigurationCatchUpListener;
+import org.apache.ignite.internal.recovery.RecoveryCompletionFutureFactory;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.util.IgniteUtils;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.persistence.PersistentVaultService;
+import org.apache.ignite.lang.IgniteInternalException;
+import org.apache.ignite.lang.IgniteStringFormatter;
+import org.apache.ignite.lang.IgniteSystemProperties;
+import org.apache.ignite.lang.NodeStoppingException;
+import org.intellij.lang.annotations.Language;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.TestInfo;
+
+/**
+ * Base class for node's restart tests.
+ */
+public abstract class BaseIgniteRestartTest extends IgniteAbstractTest {
+    /** Default node port. */
+    protected static final int DEFAULT_NODE_PORT = 3344;
+
+    @Language(""HOCON"")
+    protected static final String RAFT_CFG = ""{\n""
+            + ""  fsync: false,\n""

Review Comment:
   I haven't changed the defaults from the original `ItIgniteNodeRestartTest`, just moved to abstract class



;14/Jun/23 13:15;githubbot;600","alievmirza commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1229643997


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1119,9 +1130,8 @@ public CompletableFuture<Void> onUpdate(WatchEvent evt) {
                                     .map(NodeWithAttributes::node)
                                     .collect(toSet());
 
-                    newLogicalTopology.forEach(n -> nodesAttributes.put(n.nodeId(), n.nodeAttributes()));
+                    updateLogicalTopologyNodeAttributesAndSaveToVault(newLogicalTopology);

Review Comment:
   Thanks for noticing! IMHO right behaviour here is to call `updateLogicalTopologyNodeAttributesAndSaveToVault` right after the WatchListener was successfully handled. In that case, your case won't occur, so data in vault will be consistent with `WatchListener`. 



;14/Jun/23 13:43;githubbot;600","alievmirza commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1234200651


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/BaseIgniteRestartTest.java:
##########
@@ -0,0 +1,369 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal;
+
+import static org.apache.ignite.internal.recovery.ConfigurationCatchUpListener.CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Consumer;
+import org.apache.ignite.IgnitionManager;
+import org.apache.ignite.configuration.ConfigurationModule;
+import org.apache.ignite.internal.close.ManuallyCloseable;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopology;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyImpl;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.ConfigurationModules;
+import org.apache.ignite.internal.configuration.ConfigurationTreeGenerator;
+import org.apache.ignite.internal.configuration.ServiceLoaderModulesProvider;
+import org.apache.ignite.internal.configuration.storage.ConfigurationStorage;
+import org.apache.ignite.internal.configuration.storage.DistributedConfigurationStorage;
+import org.apache.ignite.internal.logger.IgniteLogger;
+import org.apache.ignite.internal.manager.IgniteComponent;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.recovery.ConfigurationCatchUpListener;
+import org.apache.ignite.internal.recovery.RecoveryCompletionFutureFactory;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.util.IgniteUtils;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.persistence.PersistentVaultService;
+import org.apache.ignite.lang.IgniteInternalException;
+import org.apache.ignite.lang.IgniteStringFormatter;
+import org.apache.ignite.lang.IgniteSystemProperties;
+import org.apache.ignite.lang.NodeStoppingException;
+import org.intellij.lang.annotations.Language;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.TestInfo;
+
+/**
+ * Base class for node's restart tests.
+ */
+public abstract class BaseIgniteRestartTest extends IgniteAbstractTest {

Review Comment:
   Extended



##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneManagerConfigurationChangesTest.java:
##########
@@ -113,7 +116,12 @@ public void setUp() throws Exception {
 
         // Mock logical topology for distribution zone.
         vaultMgr = new VaultManager(new InMemoryVaultService());
-        assertThat(vaultMgr.put(zonesLogicalTopologyKey(), toBytes(nodes)), willCompleteSuccessfully());
+        assertThat(vaultMgr.put(zonesLogicalTopologyVault(), toBytes(nodes)), willCompleteSuccessfully());
+
+        Map<String, Map<String, String>> nodesAttributes = new HashMap<>();

Review Comment:
   changed to CHM



;19/Jun/23 15:20;githubbot;600","alievmirza commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1234201063


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1027,44 +1030,52 @@ private void initDataNodesFromVaultManager() {
         try {
             long appliedRevision = metaStorageManager.appliedRevision();
 
-            VaultEntry topologyEntry = vaultMgr.get(zonesLogicalTopologyKey()).join();
-
-            if (topologyEntry != null && topologyEntry.value() != null) {
-                assert  appliedRevision > 0 : ""The meta storage last applied revision is 0 but the logical topology is not null."";
-
-                logicalTopology = fromBytes(topologyEntry.value());
-
-                logicalTopology.forEach(n -> nodesAttributes.put(n.nodeId(), n.nodeAttributes()));
+            restoreGlobalStateFromVault();

Review Comment:
   `initLogicalTopologyAndVersionInMetaStorageOnStart` was removed



;19/Jun/23 15:21;githubbot;600","sanpwc commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1234813293


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/BaseIgniteRestartTest.java:
##########
@@ -0,0 +1,369 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal;
+
+import static org.apache.ignite.internal.recovery.ConfigurationCatchUpListener.CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Consumer;
+import org.apache.ignite.IgnitionManager;
+import org.apache.ignite.configuration.ConfigurationModule;
+import org.apache.ignite.internal.close.ManuallyCloseable;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopology;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyImpl;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.ConfigurationModules;
+import org.apache.ignite.internal.configuration.ConfigurationTreeGenerator;
+import org.apache.ignite.internal.configuration.ServiceLoaderModulesProvider;
+import org.apache.ignite.internal.configuration.storage.ConfigurationStorage;
+import org.apache.ignite.internal.configuration.storage.DistributedConfigurationStorage;
+import org.apache.ignite.internal.logger.IgniteLogger;
+import org.apache.ignite.internal.manager.IgniteComponent;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.recovery.ConfigurationCatchUpListener;
+import org.apache.ignite.internal.recovery.RecoveryCompletionFutureFactory;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.util.IgniteUtils;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.persistence.PersistentVaultService;
+import org.apache.ignite.lang.IgniteInternalException;
+import org.apache.ignite.lang.IgniteStringFormatter;
+import org.apache.ignite.lang.IgniteSystemProperties;
+import org.apache.ignite.lang.NodeStoppingException;
+import org.intellij.lang.annotations.Language;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.TestInfo;
+
+/**
+ * Base class for node's restart tests.
+ */
+public abstract class BaseIgniteRestartTest extends IgniteAbstractTest {
+    /** Default node port. */
+    protected static final int DEFAULT_NODE_PORT = 3344;
+
+    @Language(""HOCON"")
+    protected static final String RAFT_CFG = ""{\n""
+            + ""  fsync: false,\n""

Review Comment:
   Ok, I've forwarded given message to @ibessonov. My point here, is that you may need fsync in restart tests.



;20/Jun/23 06:50;githubbot;600","sanpwc commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1234836916


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -946,81 +955,11 @@ private void updateLogicalTopologyInMetaStorage(LogicalTopologySnapshot newTopol
         }
     }
 
-    /**
-     * Initialises {@link DistributionZonesUtil#zonesLogicalTopologyKey()} and
-     * {@link DistributionZonesUtil#zonesLogicalTopologyVersionKey()} from meta storage on the start of {@link DistributionZoneManager}.
-     */
-    private void initLogicalTopologyAndVersionInMetaStorageOnStart() {

Review Comment:
   So, in order to remove given method and still preserve all guarantees you've added
   ```
               if (newTopology.version() == 1) {
                   // Very first start of the cluster, so we just initialize zonesLogicalTopologyVersionKey
                   updateCondition = notExists(zonesLogicalTopologyVersionKey());
               }
   ```
   Is that correct?
   Did you add anything else besides aforementioned code?



;20/Jun/23 07:15;githubbot;600","sanpwc commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1234850732


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneManagerConfigurationChangesTest.java:
##########
@@ -113,7 +116,12 @@ public void setUp() throws Exception {
 
         // Mock logical topology for distribution zone.
         vaultMgr = new VaultManager(new InMemoryVaultService());
-        assertThat(vaultMgr.put(zonesLogicalTopologyKey(), toBytes(nodes)), willCompleteSuccessfully());
+        assertThat(vaultMgr.put(zonesLogicalTopologyVault(), toBytes(nodes)), willCompleteSuccessfully());

Review Comment:
   Here and in other tests, what about `zonesGlobalStateRevision`, should we also mock it?



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/BaseIgniteRestartTest.java:
##########
@@ -0,0 +1,369 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal;
+
+import static org.apache.ignite.internal.recovery.ConfigurationCatchUpListener.CONFIGURATION_CATCH_UP_DIFFERENCE_PROPERTY;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Consumer;
+import org.apache.ignite.IgnitionManager;
+import org.apache.ignite.configuration.ConfigurationModule;
+import org.apache.ignite.internal.close.ManuallyCloseable;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopology;
+import org.apache.ignite.internal.cluster.management.topology.LogicalTopologyImpl;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.ConfigurationModules;
+import org.apache.ignite.internal.configuration.ConfigurationTreeGenerator;
+import org.apache.ignite.internal.configuration.ServiceLoaderModulesProvider;
+import org.apache.ignite.internal.configuration.storage.ConfigurationStorage;
+import org.apache.ignite.internal.configuration.storage.DistributedConfigurationStorage;
+import org.apache.ignite.internal.logger.IgniteLogger;
+import org.apache.ignite.internal.manager.IgniteComponent;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.recovery.ConfigurationCatchUpListener;
+import org.apache.ignite.internal.recovery.RecoveryCompletionFutureFactory;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.util.IgniteUtils;
+import org.apache.ignite.internal.vault.VaultManager;
+import org.apache.ignite.internal.vault.persistence.PersistentVaultService;
+import org.apache.ignite.lang.IgniteInternalException;
+import org.apache.ignite.lang.IgniteStringFormatter;
+import org.apache.ignite.lang.IgniteSystemProperties;
+import org.apache.ignite.lang.NodeStoppingException;
+import org.intellij.lang.annotations.Language;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.TestInfo;
+
+/**
+ * Base class for node's restart tests.
+ */
+public abstract class BaseIgniteRestartTest extends IgniteAbstractTest {
+    /** Default node port. */
+    protected static final int DEFAULT_NODE_PORT = 3344;
+
+    @Language(""HOCON"")
+    protected static final String RAFT_CFG = ""{\n""
+            + ""  fsync: false,\n""

Review Comment:
   My fault, fsync: false is fine here as in all other tests actually.



;20/Jun/23 07:27;githubbot;600","alievmirza commented on code in PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172#discussion_r1234868769


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -946,81 +955,11 @@ private void updateLogicalTopologyInMetaStorage(LogicalTopologySnapshot newTopol
         }
     }
 
-    /**
-     * Initialises {@link DistributionZonesUtil#zonesLogicalTopologyKey()} and
-     * {@link DistributionZonesUtil#zonesLogicalTopologyVersionKey()} from meta storage on the start of {@link DistributionZoneManager}.
-     */
-    private void initLogicalTopologyAndVersionInMetaStorageOnStart() {

Review Comment:
   Yes, it seems correct to me, previous method was deleted 



;20/Jun/23 07:43;githubbot;600","sanpwc merged PR #2172:
URL: https://github.com/apache/ignite-3/pull/2172


;20/Jun/23 11:18;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,0,13800,,,0,13800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-19741,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Jun 20 11:18:31 UTC 2023,,,,,,,,,,"0|z1i5vs:",9223372036854775807,,,alapin,,,,,,,,,,,,,,,,,,"20/Jun/23 11:18;alapin;[~maliev] LGTM, thanks!;;;",,,,,
Non-REPL node commands show node name option,IGNITE-19572,13537773,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,vpakhnushev,vpakhnushev,26/May/23 08:35,26/May/23 14:53,13/Jul/23 09:11,26/May/23 14:53,,,,,,,,3.0.0-beta2,cli,,,0,ignite-3,,,"{{node config show --help}} shows that it's possible to use {{-n, --node-name=<nodeName>}} option but it can only be used in the REPL mode while connected.",,aleksandr.pakhomov,vpakhnushev,,,,"valepakh opened a new pull request, #2111:
URL: https://github.com/apache/ignite-3/pull/2111

   https://issues.apache.org/jira/browse/IGNITE-19572


;26/May/23 13:36;githubbot;600","PakhomovAlexander merged PR #2111:
URL: https://github.com/apache/ignite-3/pull/2111


;26/May/23 14:52;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Fri May 26 14:53:29 UTC 2023,,,,,,,,,,"0|z1i5u0:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"26/May/23 14:53;aleksandr.pakhomov;Thanks, merged into main: c6ee1d2bd0c7f9c3d19cebab1dc0984c7d914ee3;;;",,,,,
Thin 3.0: Can't connect to cluster with default configuration,IGNITE-19571,13537772,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,26/May/23 08:33,15/Jun/23 14:05,13/Jul/23 09:11,15/Jun/23 14:05,3.0.0-beta1,,,,,,,3.0.0-beta2,thin client,,,0,ignite-3,,,"We have a server running on local machine on the default port (10800). We try to connect the client like this:
{code:java}
var client = IgniteClient.builder().addresses(""localhost"").build();
{code}

It fails with an exception:
{code}
[WARNING][nioEventLoopGroup-12-1][ReliableChannel] Failed to establish connection to localhost:10896: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:1ebe1f74-892c-471a-a520-b8bccecc246c Client failed to connect: Connection refused: localhost/127.0.0.1:10896
java.util.concurrent.CompletionException: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:1ebe1f74-892c-471a-a520-b8bccecc246c Client failed to connect: Connection refused: localhost/127.0.0.1:10896
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1063)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
	at org.apache.ignite.internal.client.io.netty.NettyClientConnectionMultiplexer.lambda$openAsync$1(NettyClientConnectionMultiplexer.java:197)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:590)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:583)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:559)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:492)
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:636)
	at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:629)
	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:118)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:321)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:337)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:776)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:1ebe1f74-892c-471a-a520-b8bccecc246c Client failed to connect: Connection refused: localhost/127.0.0.1:10896
	at org.apache.ignite.internal.client.io.netty.NettyClientConnectionMultiplexer.lambda$openAsync$1(NettyClientConnectionMultiplexer.java:194)
	... 17 more
Caused by: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: localhost/127.0.0.1:10896
Caused by: java.net.ConnectException: Connection refused
	at java.base/sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)
	at java.base/sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:777)
	at io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:337)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:776)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)
2023-05-26 11:42:11:269 +0300 [WARNING][nioEventLoopGroup-12-2][ReliableChannel] Failed to establish connection to localhost:10895: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:13d626f5-4a92-48d2-bbc7-cdf98b63104f Client failed to connect: Connection refused: localhost/127.0.0.1:10895
java.util.concurrent.CompletionException: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:13d626f5-4a92-48d2-bbc7-cdf98b63104f Client failed to connect: Connection refused: localhost/127.0.0.1:10895
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1063)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
	at org.apache.ignite.internal.client.io.netty.NettyClientConnectionMultiplexer.lambda$openAsync$1(NettyClientConnectionMultiplexer.java:197)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:590)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:583)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:559)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:492)
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:636)
	at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:629)
	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:118)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:321)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:337)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:776)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:13d626f5-4a92-48d2-bbc7-cdf98b63104f Client failed to connect: Connection refused: localhost/127.0.0.1:10895
	at org.apache.ignite.internal.client.io.netty.NettyClientConnectionMultiplexer.lambda$openAsync$1(NettyClientConnectionMultiplexer.java:194)
	... 17 more
Caused by: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: localhost/127.0.0.1:10895
Caused by: java.net.ConnectException: Connection refused
	at java.base/sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)
	at java.base/sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:777)
	at io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:337)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:776)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)
2023-05-26 11:42:11:273 +0300 [WARNING][nioEventLoopGroup-12-3][ReliableChannel] Failed to establish connection to localhost:10894: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:679f5a1d-6f0f-4acc-ad97-cdaf425951e2 Client failed to connect: Connection refused: localhost/127.0.0.1:10894
java.util.concurrent.CompletionException: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:679f5a1d-6f0f-4acc-ad97-cdaf425951e2 Client failed to connect: Connection refused: localhost/127.0.0.1:10894
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1063)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
	at org.apache.ignite.internal.client.io.netty.NettyClientConnectionMultiplexer.lambda$openAsync$1(NettyClientConnectionMultiplexer.java:197)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:590)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:583)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:559)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:492)
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:636)
	at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:629)
	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:118)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:321)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:337)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:776)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:679f5a1d-6f0f-4acc-ad97-cdaf425951e2 Client failed to connect: Connection refused: localhost/127.0.0.1:10894
	at org.apache.ignite.internal.client.io.netty.NettyClientConnectionMultiplexer.lambda$openAsync$1(NettyClientConnectionMultiplexer.java:194)
	... 17 more
Caused by: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: localhost/127.0.0.1:10894
Caused by: java.net.ConnectException: Connection refused
	at java.base/sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)
	at java.base/sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:777)
	at io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:337)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:776)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)
2023-05-26 11:42:11:280 +0300 [WARNING][nioEventLoopGroup-12-4][ReliableChannel] Failed to establish connection to localhost:10893: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:b5cd2028-f3bc-4c7d-9ade-5b209b539086 Client failed to connect: Connection refused: localhost/127.0.0.1:10893
java.util.concurrent.CompletionException: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:b5cd2028-f3bc-4c7d-9ade-5b209b539086 Client failed to connect: Connection refused: localhost/127.0.0.1:10893
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1063)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
	at org.apache.ignite.internal.client.io.netty.NettyClientConnectionMultiplexer.lambda$openAsync$1(NettyClientConnectionMultiplexer.java:197)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:590)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:583)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:559)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:492)
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:636)
	at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:629)
	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:118)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:321)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:337)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:776)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:b5cd2028-f3bc-4c7d-9ade-5b209b539086 Client failed to connect: Connection refused: localhost/127.0.0.1:10893
	at org.apache.ignite.internal.client.io.netty.NettyClientConnectionMultiplexer.lambda$openAsync$1(NettyClientConnectionMultiplexer.java:194)
	... 17 more
Caused by: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: localhost/127.0.0.1:10893
Caused by: java.net.ConnectException: Connection refused
	at java.base/sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)
	at java.base/sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:777)
	at io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:337)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:776)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)
2023-05-26 11:42:11:284 +0300 [WARNING][nioEventLoopGroup-12-5][ReliableChannel] Failed to establish connection to localhost:10900: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:ac355982-ce70-43f4-bdb1-c4168f024d3e Client failed to connect: Connection refused: localhost/127.0.0.1:10900
java.util.concurrent.CompletionException: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:ac355982-ce70-43f4-bdb1-c4168f024d3e Client failed to connect: Connection refused: localhost/127.0.0.1:10900
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1063)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
	at org.apache.ignite.internal.client.io.netty.NettyClientConnectionMultiplexer.lambda$openAsync$1(NettyClientConnectionMultiplexer.java:197)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:590)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:583)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:559)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:492)
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:636)
	at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:629)
	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:118)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:321)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:337)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:776)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:ac355982-ce70-43f4-bdb1-c4168f024d3e Client failed to connect: Connection refused: localhost/127.0.0.1:10900
	at org.apache.ignite.internal.client.io.netty.NettyClientConnectionMultiplexer.lambda$openAsync$1(NettyClientConnectionMultiplexer.java:194)
	... 17 more
Caused by: io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: localhost/127.0.0.1:10900
Caused by: java.net.ConnectException: Connection refused
	at java.base/sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)
	at java.base/sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:777)
	at io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:337)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:776)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)
2023-05-26 11:42:11:287 +0300 [WARNING][nioEventLoopGroup-12-6][ReliableChannel] Failed to establish connection to localhost:10899: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:ca5aaea9-e03d-4aec-8de3-554685d29894 Client failed to connect: Connection refused: localhost/127.0.0.1:10899
java.util.concurrent.CompletionException: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:ca5aaea9-e03d-4aec-8de3-554685d29894 Client failed to connect: Connection refused: localhost/127.0.0.1:10899
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1063)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
	at org.apache.ignite.internal.client.io.netty.NettyClientConnectionMultiplexer.lambda$openAsync$1(NettyClientConnectionMultiplexer.java:197)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:590)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:583)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:559)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:492)
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:636)
	at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:629)
	at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:118)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:321)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:337)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:776)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: org.apache.ignite.client.IgniteClientConnectionException: IGN-CLIENT-1 TraceId:ca5aaea9-e03d-4aec-8de3-554685d29894 Client failed to connect: Connection refused: localhost/127.0.0.1:10899
	at org.apache.ignite.internal.client.io.netty.NettyClientConnectionMultiplexer.lambda$openAsync$1(NettyClientConnectionMultiplexer.java:194)
	... 17 more
{code}


*Explanation*
* {{IgniteClientConfiguration.DFLT_PORT_RANGE}} is 100.
* We try all endpoints in random order (because they go into a Map - see initChannelHolders).
* Default RetryPolicy has retryLimit = 16

We fail after 16 tries, never checking port 10800.

*Potential fixes*
* Reduce default port range (both on client and server)
* Remove port range from the client completely (controversial feature - other db drivers do not have that)
* Fix connection logic to try ports in order
* Increase default retry limit",,ptupitsyn,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19601,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,Java,Thu Jun 15 14:05:01 UTC 2023,,,,,,,,,,"0|z1i5ts:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"31/May/23 05:38;ptupitsyn;Probably will be fixed by IGNITE-19601;;;","15/Jun/23 14:05;ptupitsyn;Fixed as part of IGNITE-19601, test for default config added too: [ConnectionTest#testDefaultClientConfig|https://github.com/apache/ignite-3/blob/9d3f085606dbbf3676ce6c0393048afb43a3a24b/modules/client/src/test/java/org/apache/ignite/client/ConnectionTest.java#L57];;;",,,,
Snapshot restoration metric is not always assigned when an error occurs.,IGNITE-19564,13537649,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,vladsz83,vladsz83,vladsz83,25/May/23 11:41,31/May/23 10:56,13/Jul/23 09:11,31/May/23 10:48,,,,,,,,2.16,,,,0,ise,,,"The metric of last snapshot process might not be assigned in case of failed snapshot restoration. Happens when an error occurs on the process preparation, before launching. The cause is that we assign the holder of last process context after some checks which can raise an exception.",,ignitetcbot,NSAmelchev,vladsz83,,,"sonarcloud[bot] commented on PR #10735:
URL: https://github.com/apache/ignite/pull/10735#issuecomment-1564105925

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10735)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10735&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10735&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10735&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_duplicated_lines_density&view=list)
   
   


;26/May/23 09:36;githubbot;600","sonarcloud[bot] commented on PR #10735:
URL: https://github.com/apache/ignite/pull/10735#issuecomment-1565659880

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10735)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10735&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10735&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10735&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_duplicated_lines_density&view=list)
   
   


;27/May/23 19:41;githubbot;600","sonarcloud[bot] commented on PR #10735:
URL: https://github.com/apache/ignite/pull/10735#issuecomment-1566244876

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10735)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10735&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10735&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10735&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=CODE_SMELL) [4 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_duplicated_lines_density&view=list)
   
   


;28/May/23 19:56;githubbot;600","sonarcloud[bot] commented on PR #10735:
URL: https://github.com/apache/ignite/pull/10735#issuecomment-1568327190

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10735)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10735&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10735&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10735&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_duplicated_lines_density&view=list)
   
   


;30/May/23 12:12;githubbot;600","sonarcloud[bot] commented on PR #10735:
URL: https://github.com/apache/ignite/pull/10735#issuecomment-1568530875

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10735)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10735&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10735&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10735&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10735&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10735&metric=new_duplicated_lines_density&view=list)
   
   


;30/May/23 14:25;githubbot;600","NSAmelchev merged PR #10735:
URL: https://github.com/apache/ignite/pull/10735


;31/May/23 10:47;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3600,,,0,3600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"25/May/23 11:45;vladsz83;IgniteClusterSnapshotMetricsTest.java;https://issues.apache.org/jira/secure/attachment/13058532/IgniteClusterSnapshotMetricsTest.java",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Wed May 31 10:48:41 UTC 2023,,,,,,,,,,"0|z1i52g:",9223372036854775807,Fixed snapshot restore metrics is case of an error on prepare.,,,,,,,,,,,,,,,,,,,,"31/May/23 10:15;ignitetcbot;{panel:title=Branch: [pull/10735/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10735/head] Base: [master] : New Tests (6)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Disk Page Compressions 1{color} [[tests 2|https://ci2.ignite.apache.org/viewLog.html?buildId=7196128]]
* {color:#013220}IgnitePdsCompressionTestSuite: IgniteClusterSnapshotMetricsTest.testUnableToRestoreSnapshotError[encryption=false, onlyPrimay=true] - PASSED{color}
* {color:#013220}IgnitePdsCompressionTestSuite: IgniteClusterSnapshotMetricsTest.testUnableToRestoreSnapshotError[encryption=false, onlyPrimay=false] - PASSED{color}

{color:#00008b}Snapshots With Indexes{color} [[tests 4|https://ci2.ignite.apache.org/viewLog.html?buildId=7196086]]
* {color:#013220}IgniteSnapshotWithIndexingTestSuite: IgniteClusterSnapshotMetricsTest.testUnableToRestoreSnapshotError[encryption=false, onlyPrimay=true] - PASSED{color}
* {color:#013220}IgniteSnapshotWithIndexingTestSuite: IgniteClusterSnapshotMetricsTest.testUnableToRestoreSnapshotError[encryption=false, onlyPrimay=false] - PASSED{color}
* {color:#013220}IgniteSnapshotWithIndexingTestSuite: IgniteClusterSnapshotMetricsTest.testUnableToRestoreSnapshotError[encryption=true, onlyPrimay=true] - PASSED{color}
* {color:#013220}IgniteSnapshotWithIndexingTestSuite: IgniteClusterSnapshotMetricsTest.testUnableToRestoreSnapshotError[encryption=true, onlyPrimay=false] - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7196106&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","31/May/23 10:48;NSAmelchev;Merged into the master.

[~vladsz83], Thank you for the contribution.;;;",,,,
Deadlock on indexes creation with multiple tables creation ,IGNITE-19563,13537643,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ibessonov,Denis Chudov,Denis Chudov,25/May/23 11:15,30/May/23 09:33,13/Jul/23 09:11,30/May/23 09:33,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"* Disruptor stripe took CP read lock and waits for index future (PK) to be completed. This future should be completed in configuration registry thread (see IndexManager#createIndexLocally);
 * Checkpoint thread is trying to take CP write lock;
 * Configuration registry thread is stuck on waiting for CP read lock as well, so it never will complete index future.

  
{code:java}
""%sqllogic0%JRaft-FSMCaller-Disruptor-_stripe_6-0"" #34 daemon prio=5 os_prio=0 cpu=46.88ms elapsed=26.72s tid=0x000002befd805000 nid=0x42e8 waiting on condition  [0x000000c8b92fe000]    java.lang.Thread.State: WAITING (parking) at jdk.internal.misc.Unsafe.park(java.base@13.0.1/Native Method) - parking to wait for  <0x000000060f6d08a0> (a java.util.concurrent.CompletableFuture$Signaller) at java.util.concurrent.locks.LockSupport.park(java.base@13.0.1/LockSupport.java:194) at java.util.concurrent.CompletableFuture$Signaller.block(java.base@13.0.1/CompletableFuture.java:1867) at java.util.concurrent.ForkJoinPool.managedBlock(java.base@13.0.1/ForkJoinPool.java:3137) at java.util.concurrent.CompletableFuture.waitingGet(java.base@13.0.1/CompletableFuture.java:1894) at java.util.concurrent.CompletableFuture.join(java.base@13.0.1/CompletableFuture.java:2114) at org.apache.ignite.internal.table.TableImpl.awaitIndexes(TableImpl.java:374) at org.apache.ignite.internal.table.TableImpl$1.get(TableImpl.java:232) at org.apache.ignite.internal.table.distributed.index.IndexUpdateHandler.buildIndex(IndexUpdateHandler.java:136) at org.apache.ignite.internal.table.distributed.raft.PartitionListener.lambda$handleBuildIndexCommand$14(PartitionListener.java:481) at org.apache.ignite.internal.table.distributed.raft.PartitionListener$$Lambda$2041/0x000000080151ac40.execute(Unknown Source) at org.apache.ignite.internal.storage.pagememory.mv.PersistentPageMemoryMvPartitionStorage.lambda$runConsistently$0(PersistentPageMemoryMvPartitionStorage.java:157) at org.apache.ignite.internal.storage.pagememory.mv.PersistentPageMemoryMvPartitionStorage$$Lambda$1875/0x00000008014cf840.get(Unknown Source) at org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.busy(AbstractPageMemoryMvPartitionStorage.java:784) at org.apache.ignite.internal.storage.pagememory.mv.PersistentPageMemoryMvPartitionStorage.runConsistently(PersistentPageMemoryMvPartitionStorage.java:147) at org.apache.ignite.internal.table.distributed.raft.snapshot.outgoing.SnapshotAwarePartitionDataStorage.runConsistently(SnapshotAwarePartitionDataStorage.java:66) at org.apache.ignite.internal.table.distributed.raft.PartitionListener.handleBuildIndexCommand(PartitionListener.java:471) at org.apache.ignite.internal.table.distributed.raft.PartitionListener.lambda$onWrite$2(PartitionListener.java:187) at org.apache.ignite.internal.table.distributed.raft.PartitionListener$$Lambda$2037/0x0000000801518440.accept(Unknown Source) at java.util.Iterator.forEachRemaining(java.base@13.0.1/Iterator.java:133) at org.apache.ignite.internal.table.distributed.raft.PartitionListener.onWrite(PartitionListener.java:149) at org.apache.ignite.internal.raft.server.impl.JraftServerImpl$DelegatingStateMachine.onApply(JraftServerImpl.java:592) at org.apache.ignite.raft.jraft.core.FSMCallerImpl.doApplyTasks(FSMCallerImpl.java:561) at org.apache.ignite.raft.jraft.core.FSMCallerImpl.doCommitted(FSMCallerImpl.java:529) at org.apache.ignite.raft.jraft.core.FSMCallerImpl.runApplyTask(FSMCallerImpl.java:448) at org.apache.ignite.raft.jraft.core.FSMCallerImpl$ApplyTaskHandler.onEvent(FSMCallerImpl.java:136) at org.apache.ignite.raft.jraft.core.FSMCallerImpl$ApplyTaskHandler.onEvent(FSMCallerImpl.java:130) at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:217) at org.apache.ignite.raft.jraft.disruptor.StripedDisruptor$StripeEntryHandler.onEvent(StripedDisruptor.java:181) at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:137) at java.lang.Thread.run(java.base@13.0.1/Thread.java:830)   

""%sqllogic0%vault-3"" #107 prio=5 os_prio=0 cpu=171.88ms elapsed=26.34s tid=0x000002befec1f000 nid=0x6f74 waiting on condition  [0x000000c8be8fd000]    java.lang.Thread.State: WAITING (parking) at jdk.internal.misc.Unsafe.park(java.base@13.0.1/Native Method) - parking to wait for  <0x000000060f4689b0> (a java.util.concurrent.CompletableFuture$Signaller) at java.util.concurrent.locks.LockSupport.park(java.base@13.0.1/LockSupport.java:194) at java.util.concurrent.CompletableFuture$Signaller.block(java.base@13.0.1/CompletableFuture.java:1867) at java.util.concurrent.ForkJoinPool.managedBlock(java.base@13.0.1/ForkJoinPool.java:3137) at java.util.concurrent.CompletableFuture.waitingGet(java.base@13.0.1/CompletableFuture.java:1894) at java.util.concurrent.CompletableFuture.get(java.base@13.0.1/CompletableFuture.java:2069) at org.apache.ignite.internal.util.IgniteUtils.getUninterruptibly(IgniteUtils.java:824) at org.apache.ignite.internal.pagememory.persistence.checkpoint.CheckpointTimeoutLock.checkpointReadLock(CheckpointTimeoutLock.java:163) at org.apache.ignite.internal.storage.pagememory.mv.PersistentPageMemoryMvPartitionStorage.lambda$runConsistently$0(PersistentPageMemoryMvPartitionStorage.java:152) at org.apache.ignite.internal.storage.pagememory.mv.PersistentPageMemoryMvPartitionStorage$$Lambda$1875/0x00000008014cf840.get(Unknown Source) at org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.busy(AbstractPageMemoryMvPartitionStorage.java:784) at org.apache.ignite.internal.storage.pagememory.mv.PersistentPageMemoryMvPartitionStorage.runConsistently(PersistentPageMemoryMvPartitionStorage.java:147) at org.apache.ignite.internal.storage.pagememory.mv.PersistentPageMemoryMvPartitionStorage.getOrCreateHashIndex(PersistentPageMemoryMvPartitionStorage.java:303) at org.apache.ignite.internal.storage.pagememory.AbstractPageMemoryTableStorage.lambda$getOrCreateHashIndex$9(AbstractPageMemoryTableStorage.java:214) at org.apache.ignite.internal.storage.pagememory.AbstractPageMemoryTableStorage$$Lambda$2007/0x0000000801508840.get(Unknown Source) at org.apache.ignite.internal.util.IgniteUtils.inBusyLock(IgniteUtils.java:872) at org.apache.ignite.internal.storage.pagememory.AbstractPageMemoryTableStorage.busy(AbstractPageMemoryTableStorage.java:229) at org.apache.ignite.internal.storage.pagememory.AbstractPageMemoryTableStorage.getOrCreateHashIndex(AbstractPageMemoryTableStorage.java:207) at org.apache.ignite.internal.storage.engine.MvTableStorage.getOrCreateIndex(MvTableStorage.java:91) at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.startBuildIndex(PartitionReplicaListener.java:2476) at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener$1.lambda$onCreate$0(PartitionReplicaListener.java:2436) at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener$1$$Lambda$2006/0x0000000801508440.run(Unknown Source) at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.inBusyLock(PartitionReplicaListener.java:2506) at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener$1.onCreate(PartitionReplicaListener.java:2432) at org.apache.ignite.internal.configuration.notifications.ConfigurationNotifier$1$$Lambda$1755/0x000000080147bc40.apply(Unknown Source) at org.apache.ignite.internal.configuration.notifications.ConfigurationNotifier.notifyPublicListeners(ConfigurationNotifier.java:488) at org.apache.ignite.internal.configuration.notifications.ConfigurationNotifier$1.visitNamedListNode(ConfigurationNotifier.java:206) at org.apache.ignite.internal.configuration.notifications.ConfigurationNotifier$1.visitNamedListNode(ConfigurationNotifier.java:129) at org.apache.ignite.internal.schema.configuration.TablesNode.traverseChildren(Unknown Source) at org.apache.ignite.internal.configuration.notifications.ConfigurationNotifier.notifyListeners(ConfigurationNotifier.java:129) at org.apache.ignite.internal.configuration.notifications.ConfigurationNotifier.notifyListeners(ConfigurationNotifier.java:91) at org.apache.ignite.internal.configuration.ConfigurationRegistry$3$1.visitInnerNode(ConfigurationRegistry.java:271) at org.apache.ignite.internal.configuration.ConfigurationRegistry$3$1.visitInnerNode(ConfigurationRegistry.java:254) at org.apache.ignite.internal.configuration.SuperRoot.traverseChildren(SuperRoot.java:105) at org.apache.ignite.internal.configuration.ConfigurationRegistry$3.onConfigurationUpdated(ConfigurationRegistry.java:254) at org.apache.ignite.internal.configuration.ConfigurationChanger$3.lambda$onEntriesChanged$1(ConfigurationChanger.java:658) at org.apache.ignite.internal.configuration.ConfigurationChanger$3$$Lambda$1747/0x0000000801479040.apply(Unknown Source) at java.util.concurrent.CompletableFuture$UniCompose.tryFire(java.base@13.0.1/CompletableFuture.java:1146) at java.util.concurrent.CompletableFuture.postComplete(java.base@13.0.1/CompletableFuture.java:506) at java.util.concurrent.CompletableFuture$AsyncRun.run(java.base@13.0.1/CompletableFuture.java:1813) at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@13.0.1/ThreadPoolExecutor.java:1128) at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@13.0.1/ThreadPoolExecutor.java:628) at java.lang.Thread.run(java.base@13.0.1/Thread.java:830)   

""%sqllogic0%checkpoint-thread-1"" #133 prio=5 os_prio=0 cpu=31.25ms elapsed=26.26s tid=0x000002befec3a800 nid=0x214c waiting on condition  [0x000000c8c03fe000]    java.lang.Thread.State: WAITING (parking) at jdk.internal.misc.Unsafe.park(java.base@13.0.1/Native Method) - parking to wait for  <0x00000006050084b0> (a java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync) at java.util.concurrent.locks.LockSupport.park(java.base@13.0.1/LockSupport.java:194) at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(java.base@13.0.1/AbstractQueuedSynchronizer.java:885) at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(java.base@13.0.1/AbstractQueuedSynchronizer.java:917) at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(java.base@13.0.1/AbstractQueuedSynchronizer.java:1240) at java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock.lock(java.base@13.0.1/ReentrantReadWriteLock.java:959) at org.apache.ignite.internal.pagememory.persistence.checkpoint.CheckpointReadWriteLock.writeLock(CheckpointReadWriteLock.java:129) at org.apache.ignite.internal.pagememory.persistence.checkpoint.CheckpointWorkflow.markCheckpointBegin(CheckpointWorkflow.java:209) at org.apache.ignite.internal.pagememory.persistence.checkpoint.Checkpointer.doCheckpoint(Checkpointer.java:280) at org.apache.ignite.internal.pagememory.persistence.checkpoint.Checkpointer.body(Checkpointer.java:205) at org.apache.ignite.internal.util.worker.IgniteWorker.run(IgniteWorker.java:108) at java.lang.Thread.run(java.base@13.0.1/Thread.java:830){code}
 

Could be reproduced very fast on creation of multiple tables like it is described in IGNITE-19275 and with raft fsync turned off.",,Denis Chudov,,,,,"ibessonov opened a new pull request, #2117:
URL: https://github.com/apache/ignite-3/pull/2117

   https://issues.apache.org/jira/browse/IGNITE-19563


;30/May/23 08:21;githubbot;600","ibessonov merged PR #2117:
URL: https://github.com/apache/ignite-3/pull/2117


;30/May/23 09:33;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19275,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-05-25 11:15:11.0,,,,,,,,,,"0|z1i514:",9223372036854775807,,,ktkalenko@gridgain.com,,,,,,,,,,,,,,,,,,,,,,,
Thin 3.0: Netty buffer leak in ConfigurationTest,IGNITE-19560,13537470,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,24/May/23 11:31,21/Jun/23 14:18,13/Jul/23 09:11,21/Jun/23 14:18,3.0.0-beta1,,,,,,,3.0.0-beta2,thin client,,,0,ignite-3,,,"{code}
ClientTupleTest > testTypedGetters() PASSED
  org.apache.ignite.client.ClientTupleTest.testTypedGettersWithIncorrectType()
  ClientTupleTest > testTypedGettersWithIncorrectType() PASSED
org.apache.ignite.client.ConfigurationTest
  ConfigurationTest STANDARD_ERROR
      2023-05-24 13:53:59:238 +0300 [INFO][Test worker][ClientHandlerModule] Thin client protocol started successfully [port=10800]
      2023-05-24 13:53:59:249 +0300 [ERROR][nioEventLoopGroup-168-1][ResourceLeakDetector] LEAK: ByteBuf.release() was not called before it's garbage-collected. See https://netty.io/wiki/reference-counted-objects.html for more information.
      Recent access records:
      #1:
        io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:300)
        io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
        io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
        io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
        io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
        io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
        io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
{code}

https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunUnitTests/7247037?hideProblemsFromDependencies=false&hideTestsFromDependencies=false



",,isapego,ptupitsyn,,,,"ptupitsyn opened a new pull request, #2229:
URL: https://github.com/apache/ignite-3/pull/2229

   (no comment)


;21/Jun/23 08:47;githubbot;600","ptupitsyn merged PR #2229:
URL: https://github.com/apache/ignite-3/pull/2229


;21/Jun/23 14:18;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/May/23 11:35;ptupitsyn;_Test_Run_Unit_Tests_14560.log;https://issues.apache.org/jira/secure/attachment/13058476/_Test_Run_Unit_Tests_14560.log",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jun 21 14:18:32 UTC 2023,,,,,,,,,,"0|z1i3yw:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"30/May/23 09:09;ptupitsyn;https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunUnitTests/7258625?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandBuildProblemsSection=true&expandBuildChangesSection=true;;;","06/Jun/23 04:56;ptupitsyn;https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunUnitTests/7273172?hideProblemsFromDependencies=false&hideTestsFromDependencies=false;;;","21/Jun/23 11:26;ptupitsyn;[~isapego] please review.

50+ builds without leaks: https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunUnitTests?branch=pull%2F2229&buildTypeTab=overview&mode=builds#all-projects;;;","21/Jun/23 12:10;isapego;Looks good to me.;;;","21/Jun/23 14:18;ptupitsyn;Merged to main: 027dcea777f3cd9dbb03ceeb95a384e55fb523ad;;;",
NPE in deploy/undeploy calls in non-REPL mode,IGNITE-19559,13537464,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,vpakhnushev,vpakhnushev,24/May/23 10:22,05/Jun/23 14:44,13/Jul/23 09:11,05/Jun/23 14:44,,,,,,,,3.0.0-beta2,cli,,,0,ignite-3,,,"When running ItDeployUndeployCallsTest the following exception is printed:
{code:java}
java.lang.NullPointerException
	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1690)
	at org.apache.ignite.internal.cli.logger.CliLoggers.addApiClient(CliLoggers.java:65)
	at org.apache.ignite.internal.cli.core.rest.ApiClientFactory.getClient(ApiClientFactory.java:83)
	at org.apache.ignite.internal.cli.call.unit.ListUnitCall.execute(ListUnitCall.java:46)
	at org.apache.ignite.internal.cli.core.repl.registry.impl.UnitsRegistryImpl.lambda$updateState$1(UnitsRegistryImpl.java:57)
{code}
This happens due to the {{UnitsRegistryImpl}} being called from the {{DeployUnitCall}} even if we are not in the REPL mode.",,aleksandr.pakhomov,vpakhnushev,,,,"valepakh opened a new pull request, #2131:
URL: https://github.com/apache/ignite-3/pull/2131

   https://issues.apache.org/jira/browse/IGNITE-19559


;01/Jun/23 10:46;githubbot;600","PakhomovAlexander commented on code in PR #2131:
URL: https://github.com/apache/ignite-3/pull/2131#discussion_r1214557477


##########
modules/cli/src/main/java/org/apache/ignite/internal/cli/call/cluster/unit/UndeployUnitReplCallFactory.java:
##########
@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.cli.call.cluster.unit;
+
+import io.micronaut.context.annotation.Bean;
+import io.micronaut.context.annotation.Factory;
+import jakarta.inject.Singleton;
+import org.apache.ignite.internal.cli.core.repl.registry.UnitsRegistry;
+import org.apache.ignite.internal.cli.core.rest.ApiClientFactory;
+
+/** Factory for {@link UndeployUnitReplCall} in REPL mode. */
+@Factory
+public class UndeployUnitReplCallFactory {
+
+    private final ApiClientFactory factory;
+
+    private final UnitsRegistry registry;
+
+    public UndeployUnitReplCallFactory(ApiClientFactory factory, UnitsRegistry registry) {
+        this.factory = factory;
+        this.registry = registry;
+    }
+
+    @Bean
+    @Singleton
+    public UndeployUnitReplCall create() {

Review Comment:
   same for naming



##########
modules/cli/src/main/java/org/apache/ignite/internal/cli/call/cluster/unit/UndeployUnitCallFactory.java:
##########
@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.cli.call.cluster.unit;
+
+import io.micronaut.context.annotation.Bean;
+import io.micronaut.context.annotation.Factory;
+import jakarta.inject.Singleton;
+import org.apache.ignite.internal.cli.core.rest.ApiClientFactory;
+
+/** Factory for {@link UndeployUnitCall}. */
+@Factory
+public class UndeployUnitCallFactory {
+
+    private final ApiClientFactory factory;
+
+    public UndeployUnitCallFactory(ApiClientFactory factory) {
+        this.factory = factory;
+    }
+
+    @Bean
+    @Singleton
+    public UndeployUnitCall create() {

Review Comment:
   its better to call factory methods the same name you would like to name a bean. Here `undeployUnitCall() ` is ok.



##########
modules/cli/src/main/java/org/apache/ignite/internal/cli/call/cluster/unit/DeployUnitReplCall.java:
##########
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.cli.call.cluster.unit;
+
+import java.util.concurrent.CompletableFuture;
+import org.apache.ignite.internal.cli.core.call.CallOutput;
+import org.apache.ignite.internal.cli.core.call.ProgressTracker;
+import org.apache.ignite.internal.cli.core.repl.registry.UnitsRegistry;
+import org.apache.ignite.internal.cli.core.rest.ApiClientFactory;
+
+/** Call to deploy a unit and refresh units registry. */
+public class DeployUnitReplCall extends DeployUnitCall {

Review Comment:
   Why don't use an aggregation? You can pass `DeployUnitCall` to the constructor. And if you want to use polymorphism, it's better to declare an interface `DeployUnitCall ` and have two separate implementations like  `DeployUnitReplCall` and `DeployUnitNonReplCall`.



;02/Jun/23 16:00;githubbot;600","valepakh commented on code in PR #2131:
URL: https://github.com/apache/ignite-3/pull/2131#discussion_r1217672545


##########
modules/cli/src/main/java/org/apache/ignite/internal/cli/call/cluster/unit/DeployUnitReplCall.java:
##########
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.cli.call.cluster.unit;
+
+import java.util.concurrent.CompletableFuture;
+import org.apache.ignite.internal.cli.core.call.CallOutput;
+import org.apache.ignite.internal.cli.core.call.ProgressTracker;
+import org.apache.ignite.internal.cli.core.repl.registry.UnitsRegistry;
+import org.apache.ignite.internal.cli.core.rest.ApiClientFactory;
+
+/** Call to deploy a unit and refresh units registry. */
+public class DeployUnitReplCall extends DeployUnitCall {

Review Comment:
   Why do you think it's better than inheritance in this case?
   Not sure how do you propose to use these implementations here, still extend the repl from non-repl call?
   What's the point of the interface then?



;05/Jun/23 07:54;githubbot;600","PakhomovAlexander merged PR #2131:
URL: https://github.com/apache/ignite-3/pull/2131


;05/Jun/23 14:43;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Jun 05 14:44:49 UTC 2023,,,,,,,,,,"0|z1i3xk:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"05/Jun/23 14:44;aleksandr.pakhomov;Thanks, merged into main: a2254434c403bc54685f05e0d6f51bef56abea2a;;;",,,,,
ArrayStoreException on connect to remote server node,IGNITE-19552,13537337,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Mikhail Pochatkin,Berkov,Berkov,23/May/23 13:19,13/Jun/23 10:10,13/Jul/23 09:11,13/Jun/23 10:10,3.0,,,,,,,3.0.0-beta2,jdbc,,,0,ignite-3,,,"The problem consistently reproduces with the remote server node, sometimes - with the local one on AI3 after {color:#d1d2d3}a4912c63 IGNITE-19318 Unable to build stand alone/fat jar with JDBC driver (#2048){color}.

1) Start single server node

2) Active cluster

3) Connect to the cluster via JDBC driver.

Expected result: connection established

Actual result:
{code:java}
[16:08:46][INFO ][Thread-2] Create table request: CREATE TABLE IF NOT EXISTS usertable (yscb_key VARCHAR PRIMARY KEY, field0 VARCHAR, field1 VARCHAR, field2 VARCHAR, field3 VARCHAR, field4 VARCHAR, field5 VARCHAR, field6 VARCHAR, field7 VARCHAR, field8 VARCHAR, field9 VARCHAR);May 23, 2023 4:08:46 PM io.netty.channel.ChannelInitializer exceptionCaughtWARNING: Failed to initialize a channel. Closing: [id: 0x0392f8b4, L:/127.0.0.1:10800 - R:/127.0.0.1:53528]java.lang.ArrayStoreException: org.apache.ignite.internal.client.proto.ClientMessageDecoder    at org.apache.ignite.client.handler.ClientHandlerModule$1.initChannel(ClientHandlerModule.java:250)    at io.netty.channel.ChannelInitializer.initChannel(ChannelInitializer.java:129)    at io.netty.channel.ChannelInitializer.handlerAdded(ChannelInitializer.java:112)    at io.netty.channel.AbstractChannelHandlerContext.callHandlerAdded(AbstractChannelHandlerContext.java:1114)    at io.netty.channel.DefaultChannelPipeline.callHandlerAdded0(DefaultChannelPipeline.java:609)    at io.netty.channel.DefaultChannelPipeline.access$100(DefaultChannelPipeline.java:46)    at io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask.execute(DefaultChannelPipeline.java:1463)    at io.netty.channel.DefaultChannelPipeline.callHandlerAddedForAllHandlers(DefaultChannelPipeline.java:1115)    at io.netty.channel.DefaultChannelPipeline.invokeHandlerAddedIfNeeded(DefaultChannelPipeline.java:650)    at io.netty.channel.AbstractChannel$AbstractUnsafe.register0(AbstractChannel.java:514)    at io.netty.channel.AbstractChannel$AbstractUnsafe.access$200(AbstractChannel.java:429)    at io.netty.channel.AbstractChannel$AbstractUnsafe$1.run(AbstractChannel.java:486)    at io.netty.util.concurrent.AbstractEventExecutor.runTask(AbstractEventExecutor.java:174)    at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:167)    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:470)    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:569)    at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)    at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)    at java.base/java.lang.Thread.run(Thread.java:829) {code}
 ",,aleksandr.pakhomov,Berkov,korlov,,,"Pochatkin opened a new pull request, #2127:
URL: https://github.com/apache/ignite-3/pull/2127

   https://issues.apache.org/jira/browse/IGNITE-19552


;01/Jun/23 07:10;githubbot;600","PakhomovAlexander merged PR #2127:
URL: https://github.com/apache/ignite-3/pull/2127


;13/Jun/23 10:09;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,Important,,,,,,,,9223372036854775807,,,,,,Tue Jun 13 10:10:03 UTC 2023,,,,,,,,,,"0|z1i35c:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"24/May/23 13:32;Berkov;Problem was related to IGNITE-19318, due to installing fat JDBC jar into the local maven repo on my host.;;;","25/May/23 09:22;korlov;The problem is caused by dependency conflict.

Both {{ignite-jdbc}} and {{ignite-client-handler}} modules have (transitive in case of jdbc) dependency on {{ignite-client-common}} module. The {{ClientMessageDecoder}} class from exception in description resides in the {{ignite-client-common}} and extends {{{}io.netty.handler.codec.LengthFieldBasedFrameDecoder{}}}. The jdbc is published as fatJar shadowing and relocating all its external dependencies ({{{}io.netty{}}} is among them).

Having both {{ignite-jdbc}} and ignite-runner (including all transitive deps) in the project result in having two version of {{{}ClientMessageDecoder{}}}: the first one extends {{io.netty.handler.codec.LengthFieldBasedFrameDecoder}} and another extends {{{}{*}org.apache.ignite.shaded{*}.io.netty.handler.codec.LengthFieldBasedFrameDecoder{}}}.;;;","13/Jun/23 10:10;aleksandr.pakhomov;Thanks, merged into main: 575ce79edbd6d07976693e9465bf35a15ac24082;;;",,,
Introduce exception handler to prevent leaking internal exceptions to the end user,IGNITE-19539,13537181,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,slava.koptilin,slava.koptilin,slava.koptilin,22/May/23 14:48,28/Jun/23 13:36,13/Jul/23 09:11,28/Jun/23 13:36,,,,,,,,3.0.0-beta2,,,,0,iep-84,ignite-3,,"It seems reasonable to introduce some kind of mapper/handler of internal exceptions in order to prevent leaking internal exceptions to the end user.
All public methods/interfaces should only throw IgniteException/IgniteCheckedException instances and their subclasses.
All internal exceptions should be mapped to IgniteException with the INTERNAL_ERR error code and be considered as a bug.",,jooger,slava.koptilin,,,,"sk0x50 opened a new pull request, #2225:
URL: https://github.com/apache/ignite-3/pull/2225

   https://issues.apache.org/jira/browse/IGNITE-19539


;20/Jun/23 11:47;githubbot;600","ibessonov commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1236693712


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperFuture.java:
##########
@@ -0,0 +1,436 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static org.apache.ignite.internal.util.ExceptionUtils.unwrapCause;
+import static org.apache.ignite.lang.IgniteExceptionMapperUtil.mapToPublicException;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.CompletionStage;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.function.BiConsumer;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+/**
+ * This class represents a {@link CompletableFuture}, the main purpose of this future is to automatically map
+ * internal exceptions to public ones on completion.
+ *
+ * @param <T> The result type.
+ */
+public class IgniteExceptionMapperFuture<T> extends CompletableFuture<T> {
+    /** Internal future, whose result will be used to map to a public exception if this delegate completed exceptionally. */
+    private final CompletableFuture<T> delegate;
+
+    /**
+     * Creates a new instance {@link IgniteExceptionMapperFuture} with the given {@code delegate}
+     * as an underlying future that serves all requests.
+     *
+     * @param delegate Future to be wrapped.
+     * @param <U> The result Type.
+     * @return New instance {@link IgniteExceptionMapperFuture}.
+     */
+    public static <U> IgniteExceptionMapperFuture<U> of(CompletableFuture<U> delegate) {

Review Comment:
   Why not returning `delegate.handle(...)`? This entire subclass does nothing useful as far as I see.
   If it does, it must be documented. Please consider removing the inheritance and making this class utilitarian.



##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>>
+            EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<? extends Exception, ? extends Exception> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());
+        if (m != null) {
+            Exception mapped = map(m, origin);
+
+            assert mapped instanceof IgniteException || mapped instanceof IgniteCheckedException :
+                    ""Unexpected mapping of internal exception to a public one [origin="" + origin + "", mapped="" + mapped + ']';
+
+            return mapped;
+        }
+
+        // There are no exception mappings for the given exception. This case should be considered as internal error.
+        return new IgniteException(INTERNAL_ERR, origin);

Review Comment:
   Shouldn't we have a specific exception class for each error code?



##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>>
+            EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<? extends Exception, ? extends Exception> mapper,

Review Comment:
   Given that `Exception` is already an upped bound for type parameters, this could be safely replaced with `IgniteExceptionMapper<?, ?>`.



##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMappersProvider.java:
##########
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import java.util.Collection;
+
+/**
+ * This interface provides the ability to register specific mappers from Ignite internal exceptions a public ones.
+ *
+ * <p>
+ *     Each module can provide such a mapping for its own internal exceptions.
+ *     Designed for integration with {@link java.util.ServiceLoader} mechanism, so IgniteExceptionMapper instances
+ *     provided by a library are to be defined as services either
+ *     in {@code META-INF/services/org.apache.ignite.lang.IgniteExceptionMapper}, or in a {@code module-info.java}.
+ * </p>
+ *
+ * <p>There are the following constraints that should be taken into account by a particular implementation of this interface:</p>
+ * <ul>
+ *     <li>it is prohibited to register more than one mapper for the same internal exception.</li>
+ *     <li>mapper should only provide mappings either to {@link IgniteException}, or {@link IgniteCheckedException}.</li>
+ *     <li>mapper should not provide mapping for Java standard exception like {@link NullPointerException},
+ *     {@link IllegalArgumentException}, etc.</li>
+ *     <li>mapper should not provide any mappings for errors {@link Error}.</li>
+ * </ul>
+ */
+public interface IgniteExceptionMappersProvider {
+    /**
+     * Returns a collection of mappers to be used to map internal exceptions to public ones.
+     *
+     * @return Collection of mappers.
+     */
+    Collection<IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers();

Review Comment:
   Same not about the signature. I get that explicit is better than implicit, but this name is too long to justify the argument



##########
modules/api/src/test/java/org/apache/ignite/lang/IgniteExceptionMapperUtilTest.java:
##########
@@ -0,0 +1,238 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static org.apache.ignite.lang.ErrorGroups.Common.COMMON_ERR_GROUP;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+import static org.apache.ignite.lang.ErrorGroups.Common.NODE_STOPPING_ERR;
+import static org.apache.ignite.lang.IgniteExceptionMapper.checked;
+import static org.apache.ignite.lang.IgniteExceptionMapper.unchecked;
+import static org.apache.ignite.lang.IgniteExceptionMapperUtil.mapToPublicException;
+import static org.apache.ignite.lang.IgniteExceptionMapperUtil.registerMapping;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.isA;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+import java.util.stream.Stream;
+import org.junit.jupiter.api.Named;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests mapping internal exceptions to public ones.
+ */
+public class IgniteExceptionMapperUtilTest {
+    /** Internal collection of mappers for tests. */
+    private Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers = new HashMap<>();

Review Comment:
   I get my point, please make types shorter



##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>>
+            EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<? extends Exception, ? extends Exception> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());
+        if (m != null) {
+            Exception mapped = map(m, origin);
+
+            assert mapped instanceof IgniteException || mapped instanceof IgniteCheckedException :
+                    ""Unexpected mapping of internal exception to a public one [origin="" + origin + "", mapped="" + mapped + ']';
+
+            return mapped;
+        }
+
+        // There are no exception mappings for the given exception. This case should be considered as internal error.
+        return new IgniteException(INTERNAL_ERR, origin);
+    }
+
+    /**
+     * Returns a new instance of public exception provided by the {@code mapper}.
+     *
+     * @param mapper Mapper function to produce a public exception.
+     * @param t Internal exception.
+     * @param <T> Type of an internal exception.
+     * @param <R> Type of a public exception.
+     * @return New public exception.
+     */
+    private static <T extends Exception, R extends Exception> Exception map(IgniteExceptionMapper<T, R> mapper, Throwable t) {
+        return mapper.map(mapper.mappingFrom().cast(t));
+    }
+
+    /**
+     * Returns {@code true} if the given exception {@code t} is instance of {@link NullPointerException}, {@link IllegalArgumentException}.
+     *
+     * @return {@code true} if the given exception is Java standard exception.
+     */
+    private static boolean isJavaStandardException(Throwable t) {
+        return t instanceof NullPointerException || t instanceof IllegalArgumentException;

Review Comment:
   Interesting. Is this all that we support?



##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>>
+            EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<? extends Exception, ? extends Exception> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>

Review Comment:
   ""...that _will_ always be mapped...""? I think that some word is missing here



##########
modules/api/src/test/java/org/apache/ignite/lang/IgniteExceptionMapperUtilTest.java:
##########
@@ -0,0 +1,238 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static org.apache.ignite.lang.ErrorGroups.Common.COMMON_ERR_GROUP;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+import static org.apache.ignite.lang.ErrorGroups.Common.NODE_STOPPING_ERR;
+import static org.apache.ignite.lang.IgniteExceptionMapper.checked;
+import static org.apache.ignite.lang.IgniteExceptionMapper.unchecked;
+import static org.apache.ignite.lang.IgniteExceptionMapperUtil.mapToPublicException;
+import static org.apache.ignite.lang.IgniteExceptionMapperUtil.registerMapping;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.isA;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+import java.util.stream.Stream;
+import org.junit.jupiter.api.Named;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests mapping internal exceptions to public ones.
+ */
+public class IgniteExceptionMapperUtilTest {
+    /** Internal collection of mappers for tests. */
+    private Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers = new HashMap<>();
+
+    /**
+     * Tests a simple scenario od registering mapper for internal exceptions.

Review Comment:
   ```suggestion
        * Tests a simple scenario of registering mapper for internal exceptions.
   ```



##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMappersProvider.java:
##########
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import java.util.Collection;
+
+/**
+ * This interface provides the ability to register specific mappers from Ignite internal exceptions a public ones.

Review Comment:
   ''...exceptions _to_ a public ones"", I guess. I think a word is missing here as well



##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>>
+            EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<? extends Exception, ? extends Exception> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> registeredMappings) {

Review Comment:
   Same here, shorter types are easier to read



;21/Jun/23 09:46;githubbot;600","ibessonov commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1236708527


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMappersProvider.java:
##########
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import java.util.Collection;
+
+/**
+ * This interface provides the ability to register specific mappers from Ignite internal exceptions a public ones.
+ *
+ * <p>
+ *     Each module can provide such a mapping for its own internal exceptions.
+ *     Designed for integration with {@link java.util.ServiceLoader} mechanism, so IgniteExceptionMapper instances
+ *     provided by a library are to be defined as services either
+ *     in {@code META-INF/services/org.apache.ignite.lang.IgniteExceptionMapper}, or in a {@code module-info.java}.
+ * </p>
+ *
+ * <p>There are the following constraints that should be taken into account by a particular implementation of this interface:</p>
+ * <ul>
+ *     <li>it is prohibited to register more than one mapper for the same internal exception.</li>
+ *     <li>mapper should only provide mappings either to {@link IgniteException}, or {@link IgniteCheckedException}.</li>
+ *     <li>mapper should not provide mapping for Java standard exception like {@link NullPointerException},
+ *     {@link IllegalArgumentException}, etc.</li>
+ *     <li>mapper should not provide any mappings for errors {@link Error}.</li>
+ * </ul>
+ */
+public interface IgniteExceptionMappersProvider {
+    /**
+     * Returns a collection of mappers to be used to map internal exceptions to public ones.
+     *
+     * @return Collection of mappers.
+     */
+    Collection<IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers();

Review Comment:
   Same one about the signature. I get that explicit is better than implicit, but this name is too long to justify the argument



;21/Jun/23 09:47;githubbot;600","ibessonov commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1236712924


##########
modules/api/src/test/java/org/apache/ignite/lang/IgniteExceptionMapperUtilTest.java:
##########
@@ -0,0 +1,238 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static org.apache.ignite.lang.ErrorGroups.Common.COMMON_ERR_GROUP;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+import static org.apache.ignite.lang.ErrorGroups.Common.NODE_STOPPING_ERR;
+import static org.apache.ignite.lang.IgniteExceptionMapper.checked;
+import static org.apache.ignite.lang.IgniteExceptionMapper.unchecked;
+import static org.apache.ignite.lang.IgniteExceptionMapperUtil.mapToPublicException;
+import static org.apache.ignite.lang.IgniteExceptionMapperUtil.registerMapping;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.isA;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+import java.util.stream.Stream;
+import org.junit.jupiter.api.Named;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests mapping internal exceptions to public ones.
+ */
+public class IgniteExceptionMapperUtilTest {
+    /** Internal collection of mappers for tests. */
+    private Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers = new HashMap<>();

Review Comment:
   You get my point, please make types shorter



;21/Jun/23 09:47;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1236832620


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperFuture.java:
##########
@@ -0,0 +1,436 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static org.apache.ignite.internal.util.ExceptionUtils.unwrapCause;
+import static org.apache.ignite.lang.IgniteExceptionMapperUtil.mapToPublicException;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.CompletionStage;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.function.BiConsumer;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+/**
+ * This class represents a {@link CompletableFuture}, the main purpose of this future is to automatically map
+ * internal exceptions to public ones on completion.
+ *
+ * @param <T> The result type.
+ */
+public class IgniteExceptionMapperFuture<T> extends CompletableFuture<T> {
+    /** Internal future, whose result will be used to map to a public exception if this delegate completed exceptionally. */
+    private final CompletableFuture<T> delegate;
+
+    /**
+     * Creates a new instance {@link IgniteExceptionMapperFuture} with the given {@code delegate}
+     * as an underlying future that serves all requests.
+     *
+     * @param delegate Future to be wrapped.
+     * @param <U> The result Type.
+     * @return New instance {@link IgniteExceptionMapperFuture}.
+     */
+    public static <U> IgniteExceptionMapperFuture<U> of(CompletableFuture<U> delegate) {

Review Comment:
   This makes sense to me. I will provide a utility method instead of this future.



;21/Jun/23 11:28;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1236963103


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>>
+            EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<? extends Exception, ? extends Exception> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());
+        if (m != null) {
+            Exception mapped = map(m, origin);
+
+            assert mapped instanceof IgniteException || mapped instanceof IgniteCheckedException :
+                    ""Unexpected mapping of internal exception to a public one [origin="" + origin + "", mapped="" + mapped + ']';
+
+            return mapped;
+        }
+
+        // There are no exception mappings for the given exception. This case should be considered as internal error.
+        return new IgniteException(INTERNAL_ERR, origin);
+    }
+
+    /**
+     * Returns a new instance of public exception provided by the {@code mapper}.
+     *
+     * @param mapper Mapper function to produce a public exception.
+     * @param t Internal exception.
+     * @param <T> Type of an internal exception.
+     * @param <R> Type of a public exception.
+     * @return New public exception.
+     */
+    private static <T extends Exception, R extends Exception> Exception map(IgniteExceptionMapper<T, R> mapper, Throwable t) {
+        return mapper.map(mapper.mappingFrom().cast(t));
+    }
+
+    /**
+     * Returns {@code true} if the given exception {@code t} is instance of {@link NullPointerException}, {@link IllegalArgumentException}.
+     *
+     * @return {@code true} if the given exception is Java standard exception.
+     */
+    private static boolean isJavaStandardException(Throwable t) {
+        return t instanceof NullPointerException || t instanceof IllegalArgumentException;

Review Comment:
   Well, I think that should not support any of them, but for now, there are interfaces that use the following approach (just an example):
   ```
       /**
        * Creates a new distribution zone with the given {@code name} asynchronously.
        *
        * @param distributionZoneCfg Distribution zone configuration.
        * @return Future with the id of the zone. Future can be completed with:
        *      {@link DistributionZoneAlreadyExistsException} if a zone with the given name already exists,
        *      {@link ConfigurationValidationException} if {@code distributionZoneCfg} is broken,
        *      {@link IllegalArgumentException} if distribution zone configuration is null
        *      or distribution zone name is {@code DEFAULT_ZONE_NAME},
        *      {@link NodeStoppingException} if the node is stopping.
        */
       public CompletableFuture<Integer> createZone(DistributionZoneConfigurationParameters distributionZoneCfg) {
   ```
   
   In that particular case, `IllegalArgumentException` should not be wrapped into `IgniteException` with the `INTERNAL_ERR` code. I don't think that this approach is good enough. IMHO, we should check incoming parameters (and throw an exception if it is needed) before creating an internal future. On the other hand, we can introduce special mapping rules to handle such cases.



;21/Jun/23 13:00;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1236972592


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>>
+            EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<? extends Exception, ? extends Exception> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());
+        if (m != null) {
+            Exception mapped = map(m, origin);
+
+            assert mapped instanceof IgniteException || mapped instanceof IgniteCheckedException :
+                    ""Unexpected mapping of internal exception to a public one [origin="" + origin + "", mapped="" + mapped + ']';
+
+            return mapped;
+        }
+
+        // There are no exception mappings for the given exception. This case should be considered as internal error.
+        return new IgniteException(INTERNAL_ERR, origin);

Review Comment:
   I don't think so. Let's assume that we have hundreds of codes (it is an absolutely possible case). Should we create hundreds of exception classes? IMHO, it is OK to map several error codes to one exception class, assuming that these error codes relate to the one error group of course.
   
   In this particular case, we can introduce a new type with a proper name, I think.



;21/Jun/23 13:07;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1236972592


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>>
+            EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<? extends Exception, ? extends Exception> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());
+        if (m != null) {
+            Exception mapped = map(m, origin);
+
+            assert mapped instanceof IgniteException || mapped instanceof IgniteCheckedException :
+                    ""Unexpected mapping of internal exception to a public one [origin="" + origin + "", mapped="" + mapped + ']';
+
+            return mapped;
+        }
+
+        // There are no exception mappings for the given exception. This case should be considered as internal error.
+        return new IgniteException(INTERNAL_ERR, origin);

Review Comment:
   I don't think so. Let's assume that we have hundreds of codes (it is an absolutely possible case). Should we create hundreds of exception classes? IMHO, it is OK to map several error codes to one exception class, assuming that these error codes relate to the same error group of course.
   
   In this particular case, we can introduce a new type with a proper name, I think.



;21/Jun/23 14:23;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1236963103


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>>
+            EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<? extends Exception, ? extends Exception> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());
+        if (m != null) {
+            Exception mapped = map(m, origin);
+
+            assert mapped instanceof IgniteException || mapped instanceof IgniteCheckedException :
+                    ""Unexpected mapping of internal exception to a public one [origin="" + origin + "", mapped="" + mapped + ']';
+
+            return mapped;
+        }
+
+        // There are no exception mappings for the given exception. This case should be considered as internal error.
+        return new IgniteException(INTERNAL_ERR, origin);
+    }
+
+    /**
+     * Returns a new instance of public exception provided by the {@code mapper}.
+     *
+     * @param mapper Mapper function to produce a public exception.
+     * @param t Internal exception.
+     * @param <T> Type of an internal exception.
+     * @param <R> Type of a public exception.
+     * @return New public exception.
+     */
+    private static <T extends Exception, R extends Exception> Exception map(IgniteExceptionMapper<T, R> mapper, Throwable t) {
+        return mapper.map(mapper.mappingFrom().cast(t));
+    }
+
+    /**
+     * Returns {@code true} if the given exception {@code t} is instance of {@link NullPointerException}, {@link IllegalArgumentException}.
+     *
+     * @return {@code true} if the given exception is Java standard exception.
+     */
+    private static boolean isJavaStandardException(Throwable t) {
+        return t instanceof NullPointerException || t instanceof IllegalArgumentException;

Review Comment:
   Well, I think that we should not support any of them, but for now, there are interfaces that use the following approach (just an example):
   ```
       /**
        * Creates a new distribution zone with the given {@code name} asynchronously.
        *
        * @param distributionZoneCfg Distribution zone configuration.
        * @return Future with the id of the zone. Future can be completed with:
        *      {@link DistributionZoneAlreadyExistsException} if a zone with the given name already exists,
        *      {@link ConfigurationValidationException} if {@code distributionZoneCfg} is broken,
        *      {@link IllegalArgumentException} if distribution zone configuration is null
        *      or distribution zone name is {@code DEFAULT_ZONE_NAME},
        *      {@link NodeStoppingException} if the node is stopping.
        */
       public CompletableFuture<Integer> createZone(DistributionZoneConfigurationParameters distributionZoneCfg) {
   ```
   
   In that particular case, `IllegalArgumentException` should not be wrapped into `IgniteException` with the `INTERNAL_ERR` code. I don't think that this approach is good enough. IMHO, we should check incoming parameters (and throw an exception if it is needed) before creating an internal future. On the other hand, we can introduce special mapping rules to handle such cases.



;21/Jun/23 14:24;githubbot;600","sanpwc commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1241987943


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapper.java:
##########
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import java.util.function.Function;
+
+/**
+ * Represents a mapper from an internal exception {@code T} to a public one {@code R}.
+ */
+public class IgniteExceptionMapper<T extends Exception, R extends Exception> {
+    /** Class that represents an internal exception for mapping. */
+    private final Class<T> from;
+
+    /** Mapping function. */
+    private final Function<T, R> mapper;
+
+    /**
+     * Creates a new instance of mapper.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     */
+    private IgniteExceptionMapper(Class<T> from, Function<T, R> mapper) {
+        this.from = from;
+        this.mapper = mapper;
+    }
+
+    /**
+     * Returns a class instance that represents an internal exception to be used for mapping.
+     *
+     * @return Class instance that represents an internal exception to be used for mapping.
+     */
+    public Class<T> mappingFrom() {
+        return from;
+    }
+
+    /**
+     * Maps the provided internal exception to a public one.
+     *
+     * @param error Exception instance to be mapped.
+     * @return Public exception instance.
+     */
+    public R map(T error) {
+        return mapper.apply(error);
+    }
+
+    /**
+     * Creates a new exception mapper from an internal exception {@code T} to a public runtime exception {@code R}.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     * @param <T> Internal exception type.
+     * @param <R> Public runtime exception type.
+     *
+     * @return New instance of {@link IgniteExceptionMapper}.
+     */
+    public static <T extends Exception, R extends IgniteException> IgniteExceptionMapper<T, R> unchecked(

Review Comment:
   This method seems strange. It's either mapper to be returned or converted exception. In first case we need only Function<T, R> mapper in second we may have both from and mapper params but should return R. What's the point of given method?



##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapper.java:
##########
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import java.util.function.Function;
+
+/**
+ * Represents a mapper from an internal exception {@code T} to a public one {@code R}.
+ */
+public class IgniteExceptionMapper<T extends Exception, R extends Exception> {
+    /** Class that represents an internal exception for mapping. */
+    private final Class<T> from;
+
+    /** Mapping function. */
+    private final Function<T, R> mapper;
+
+    /**
+     * Creates a new instance of mapper.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     */
+    private IgniteExceptionMapper(Class<T> from, Function<T, R> mapper) {
+        this.from = from;
+        this.mapper = mapper;
+    }
+
+    /**
+     * Returns a class instance that represents an internal exception to be used for mapping.
+     *
+     * @return Class instance that represents an internal exception to be used for mapping.
+     */
+    public Class<T> mappingFrom() {
+        return from;
+    }
+
+    /**
+     * Maps the provided internal exception to a public one.
+     *
+     * @param error Exception instance to be mapped.
+     * @return Public exception instance.
+     */
+    public R map(T error) {

Review Comment:
   Why it's an error? Meaning that there's an [Error](https://docs.oracle.com/javase/8/docs/api/?java/lang/Error.html) in java Throwable hierarchy, thus it might be a bit confusing.



##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>>
+            EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<? extends Exception, ? extends Exception> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());
+        if (m != null) {
+            Exception mapped = map(m, origin);
+
+            assert mapped instanceof IgniteException || mapped instanceof IgniteCheckedException :
+                    ""Unexpected mapping of internal exception to a public one [origin="" + origin + "", mapped="" + mapped + ']';
+
+            return mapped;
+        }
+
+        // There are no exception mappings for the given exception. This case should be considered as internal error.
+        return new IgniteException(INTERNAL_ERR, origin);
+    }
+
+    /**
+     * Returns a new instance of public exception provided by the {@code mapper}.
+     *
+     * @param mapper Mapper function to produce a public exception.
+     * @param t Internal exception.
+     * @param <T> Type of an internal exception.
+     * @param <R> Type of a public exception.
+     * @return New public exception.
+     */
+    private static <T extends Exception, R extends Exception> Exception map(IgniteExceptionMapper<T, R> mapper, Throwable t) {
+        return mapper.map(mapper.mappingFrom().cast(t));
+    }
+
+    /**
+     * Returns {@code true} if the given exception {@code t} is instance of {@link NullPointerException}, {@link IllegalArgumentException}.
+     *
+     * @return {@code true} if the given exception is Java standard exception.
+     */
+    private static boolean isJavaStandardException(Throwable t) {
+        return t instanceof NullPointerException || t instanceof IllegalArgumentException;

Review Comment:
   Not sure that I got an idea. What about all that common IllegalStateException, IllegalArgumentException etc? You've mentioned that 
   
   > I think that we should not support any of them
   
   But still we consider NPE as valid internalException to throw in public.



##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapper.java:
##########
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import java.util.function.Function;
+
+/**
+ * Represents a mapper from an internal exception {@code T} to a public one {@code R}.
+ */
+public class IgniteExceptionMapper<T extends Exception, R extends Exception> {
+    /** Class that represents an internal exception for mapping. */
+    private final Class<T> from;
+
+    /** Mapping function. */
+    private final Function<T, R> mapper;
+
+    /**
+     * Creates a new instance of mapper.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     */
+    private IgniteExceptionMapper(Class<T> from, Function<T, R> mapper) {
+        this.from = from;
+        this.mapper = mapper;
+    }
+
+    /**
+     * Returns a class instance that represents an internal exception to be used for mapping.
+     *
+     * @return Class instance that represents an internal exception to be used for mapping.
+     */
+    public Class<T> mappingFrom() {
+        return from;
+    }
+
+    /**
+     * Maps the provided internal exception to a public one.
+     *
+     * @param error Exception instance to be mapped.
+     * @return Public exception instance.
+     */
+    public R map(T error) {
+        return mapper.apply(error);
+    }
+
+    /**
+     * Creates a new exception mapper from an internal exception {@code T} to a public runtime exception {@code R}.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     * @param <T> Internal exception type.
+     * @param <R> Public runtime exception type.
+     *
+     * @return New instance of {@link IgniteExceptionMapper}.
+     */
+    public static <T extends Exception, R extends IgniteException> IgniteExceptionMapper<T, R> unchecked(
+            Class<T> from,
+            Function<T, R> mapper
+    ) {
+        return new IgniteExceptionMapper<T, R>(from, mapper);
+    }
+
+    /**
+     * Creates a new exception mapper from an internal exception {@code T} to a public checked exception {@code R}.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     * @param <T> Internal exception type.
+     * @param <R> Public checked exception type.
+     *
+     * @return New instance of {@link IgniteExceptionMapper}.
+     */
+    public static <T extends Exception, R extends IgniteCheckedException> IgniteExceptionMapper<T, R> checked(

Review Comment:
   Same as above.



##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.internal.util.ExceptionUtils.unwrapCause;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<?, ?> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that will always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());

Review Comment:
   Why do we check only exact matching? Let's say InternalTransactionException -> PublicTransactionException mapper was registered. And we have SomeSpecficInternalTransactionException extends InternalTransactionException. Do we expect this SomeSpecficInternalTransactionException to be converted to PublicTransactionException? I believe we should, because from the hierarchy point of view SomeSpecficInternalTransactionException is an InternalTransactionException. 
   Thus I believe we should find the most specific mapper with a top level IgniteException(INTERNAL_ERR, origin);



##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.internal.util.ExceptionUtils.unwrapCause;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<?, ?> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that will always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());
+        if (m != null) {
+            Exception mapped = map(m, origin);
+
+            assert mapped instanceof IgniteException || mapped instanceof IgniteCheckedException :
+                    ""Unexpected mapping of internal exception to a public one [origin="" + origin + "", mapped="" + mapped + ']';
+
+            return mapped;
+        }
+
+        // There are no exception mappings for the given exception. This case should be considered as internal error.
+        return new IgniteException(INTERNAL_ERR, origin);
+    }
+
+    /**
+     * Returns a new CompletableFuture that, when the given {@code origin} future completes exceptionally,
+     * maps the origin's exception to a public Ignite exception if it is needed.
+     *
+     * @param origin The future to use to create a new stage.
+     * @param <T> Type os result.
+     * @return New CompletableFuture.
+     */
+    public static <T> CompletableFuture<T> convertToPublicFuture(CompletableFuture<T> origin) {
+        return origin
+                .handle((res, err) -> {
+                    if (err != null) {
+                        throw new CompletionException(mapToPublicException(unwrapCause(err)));

Review Comment:
   There's still a gap here. In case of Future of future we may have CompletionException of similar with InternalException inside. So I believe we should flat all top level futures here.



##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionUtils.java:
##########
@@ -177,14 +177,15 @@ public static int extractCodeFrom(Throwable t) {
         return INTERNAL_ERR;
     }
 
-    // TODO: https://issues.apache.org/jira/browse/IGNITE-19539 this method should be removed or re-worked.
+    // TODO: This method should be removed or re-worked and usages should be changed to IgniteExceptionMapperUtil.mapToPublicException.

Review Comment:
   I don't think that it's valid to have todo without ignite link.



;26/Jun/23 11:41;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1242072073


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapper.java:
##########
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import java.util.function.Function;
+
+/**
+ * Represents a mapper from an internal exception {@code T} to a public one {@code R}.
+ */
+public class IgniteExceptionMapper<T extends Exception, R extends Exception> {
+    /** Class that represents an internal exception for mapping. */
+    private final Class<T> from;
+
+    /** Mapping function. */
+    private final Function<T, R> mapper;
+
+    /**
+     * Creates a new instance of mapper.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     */
+    private IgniteExceptionMapper(Class<T> from, Function<T, R> mapper) {
+        this.from = from;
+        this.mapper = mapper;
+    }
+
+    /**
+     * Returns a class instance that represents an internal exception to be used for mapping.
+     *
+     * @return Class instance that represents an internal exception to be used for mapping.
+     */
+    public Class<T> mappingFrom() {
+        return from;
+    }
+
+    /**
+     * Maps the provided internal exception to a public one.
+     *
+     * @param error Exception instance to be mapped.
+     * @return Public exception instance.
+     */
+    public R map(T error) {

Review Comment:
   Ok, will change.



;26/Jun/23 11:49;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1242080574


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapper.java:
##########
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import java.util.function.Function;
+
+/**
+ * Represents a mapper from an internal exception {@code T} to a public one {@code R}.
+ */
+public class IgniteExceptionMapper<T extends Exception, R extends Exception> {
+    /** Class that represents an internal exception for mapping. */
+    private final Class<T> from;
+
+    /** Mapping function. */
+    private final Function<T, R> mapper;
+
+    /**
+     * Creates a new instance of mapper.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     */
+    private IgniteExceptionMapper(Class<T> from, Function<T, R> mapper) {
+        this.from = from;
+        this.mapper = mapper;
+    }
+
+    /**
+     * Returns a class instance that represents an internal exception to be used for mapping.
+     *
+     * @return Class instance that represents an internal exception to be used for mapping.
+     */
+    public Class<T> mappingFrom() {
+        return from;
+    }
+
+    /**
+     * Maps the provided internal exception to a public one.
+     *
+     * @param error Exception instance to be mapped.
+     * @return Public exception instance.
+     */
+    public R map(T error) {
+        return mapper.apply(error);
+    }
+
+    /**
+     * Creates a new exception mapper from an internal exception {@code T} to a public runtime exception {@code R}.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     * @param <T> Internal exception type.
+     * @param <R> Public runtime exception type.
+     *
+     * @return New instance of {@link IgniteExceptionMapper}.
+     */
+    public static <T extends Exception, R extends IgniteException> IgniteExceptionMapper<T, R> unchecked(

Review Comment:
   The main goal is to restrict the type of mapper. The exception mapper should provide either a mapping Exception -> IgniteException (unchecked) or Exception -> IgniteCheckedException (checked). The mapper should not try to provide a mapping Exception -> IgniteInternalException, for instance.
   Java generics do not allow using something as follows:
   ```
       <T, R extends IgniteException> Function<T, R> mapper();
       <T, R extends IgniteCheckedException> Function<T, R> mapper();
   ```
   just because these methods have exactly the same `erasure`



;26/Jun/23 11:57;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1242080574


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapper.java:
##########
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import java.util.function.Function;
+
+/**
+ * Represents a mapper from an internal exception {@code T} to a public one {@code R}.
+ */
+public class IgniteExceptionMapper<T extends Exception, R extends Exception> {
+    /** Class that represents an internal exception for mapping. */
+    private final Class<T> from;
+
+    /** Mapping function. */
+    private final Function<T, R> mapper;
+
+    /**
+     * Creates a new instance of mapper.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     */
+    private IgniteExceptionMapper(Class<T> from, Function<T, R> mapper) {
+        this.from = from;
+        this.mapper = mapper;
+    }
+
+    /**
+     * Returns a class instance that represents an internal exception to be used for mapping.
+     *
+     * @return Class instance that represents an internal exception to be used for mapping.
+     */
+    public Class<T> mappingFrom() {
+        return from;
+    }
+
+    /**
+     * Maps the provided internal exception to a public one.
+     *
+     * @param error Exception instance to be mapped.
+     * @return Public exception instance.
+     */
+    public R map(T error) {
+        return mapper.apply(error);
+    }
+
+    /**
+     * Creates a new exception mapper from an internal exception {@code T} to a public runtime exception {@code R}.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     * @param <T> Internal exception type.
+     * @param <R> Public runtime exception type.
+     *
+     * @return New instance of {@link IgniteExceptionMapper}.
+     */
+    public static <T extends Exception, R extends IgniteException> IgniteExceptionMapper<T, R> unchecked(

Review Comment:
   The main goal is to restrict the type of mapper. The exception mapper should provide either a mapping Exception -> IgniteException (unchecked) or Exception -> IgniteCheckedException (checked). The mapper should not try to provide a mapping Exception -> IgniteInternalException, for instance.
   Java generics do not allow using something as follows:
   ```
       <T, R extends IgniteException> Function<T, R> mapper();
       <T, R extends IgniteCheckedException> Function<T, R> mapper();
   ```
   just because these methods have exactly the same `erasure`
   
   The method `IgniteExceptionMapper.mappingFrom` allows us to avoid incorrect registration of the mapper:
   ```
       Function<CustomExceptionB, IgniteException> mapper = err -> ...;
       mappers.put(CustomExceptionA.class, mapper);
   ```



;26/Jun/23 12:08;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1242093277


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapper.java:
##########
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import java.util.function.Function;
+
+/**
+ * Represents a mapper from an internal exception {@code T} to a public one {@code R}.
+ */
+public class IgniteExceptionMapper<T extends Exception, R extends Exception> {
+    /** Class that represents an internal exception for mapping. */
+    private final Class<T> from;
+
+    /** Mapping function. */
+    private final Function<T, R> mapper;
+
+    /**
+     * Creates a new instance of mapper.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     */
+    private IgniteExceptionMapper(Class<T> from, Function<T, R> mapper) {
+        this.from = from;
+        this.mapper = mapper;
+    }
+
+    /**
+     * Returns a class instance that represents an internal exception to be used for mapping.
+     *
+     * @return Class instance that represents an internal exception to be used for mapping.
+     */
+    public Class<T> mappingFrom() {
+        return from;
+    }
+
+    /**
+     * Maps the provided internal exception to a public one.
+     *
+     * @param error Exception instance to be mapped.
+     * @return Public exception instance.
+     */
+    public R map(T error) {
+        return mapper.apply(error);
+    }
+
+    /**
+     * Creates a new exception mapper from an internal exception {@code T} to a public runtime exception {@code R}.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     * @param <T> Internal exception type.
+     * @param <R> Public runtime exception type.
+     *
+     * @return New instance of {@link IgniteExceptionMapper}.
+     */
+    public static <T extends Exception, R extends IgniteException> IgniteExceptionMapper<T, R> unchecked(
+            Class<T> from,
+            Function<T, R> mapper
+    ) {
+        return new IgniteExceptionMapper<T, R>(from, mapper);
+    }
+
+    /**
+     * Creates a new exception mapper from an internal exception {@code T} to a public checked exception {@code R}.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     * @param <T> Internal exception type.
+     * @param <R> Public checked exception type.
+     *
+     * @return New instance of {@link IgniteExceptionMapper}.
+     */
+    public static <T extends Exception, R extends IgniteCheckedException> IgniteExceptionMapper<T, R> checked(

Review Comment:
   Please take a look at the comment above.



;26/Jun/23 12:09;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1242109276


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.internal.util.ExceptionUtils.unwrapCause;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<?, ?> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that will always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());

Review Comment:
   Well, It is arguable. IMHO, a particular component should provide a comprehensive list of mappers. Let's consider the following case:
   ```
       public class ComponentException {};
       public class SpecificExceptionA extends ComponentException {};
   
       // @throws SpecificExceptionA If ...
       publicApiCall() throws SpecificExceptionA
   ```
   and after that, we decided to introduce a new type of exception to clarify the behavior in some particular case:
   ```
       public class SpecificExceptionB extends ComponentException {};
       or
       public class SpecificExceptionB extends SpecificExceptionA{};
   
       // @throws SpecificExceptionA If ...
       // @throws SpecificExceptionB If ...
       publicApiCall() throws SpecificExceptionA
   ```
   and our component does not provide a mapping from InternalSpecificExceptionB to SpecificExceptionB.
   
   In this case, the user will observe SpecificExceptionA or  ComponentException instead of SpecificExceptionB.
   IMHO, this behavior would not be correct.



;26/Jun/23 12:22;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1242111422


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.internal.util.ExceptionUtils.unwrapCause;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<?, ?> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that will always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());
+        if (m != null) {
+            Exception mapped = map(m, origin);
+
+            assert mapped instanceof IgniteException || mapped instanceof IgniteCheckedException :
+                    ""Unexpected mapping of internal exception to a public one [origin="" + origin + "", mapped="" + mapped + ']';
+
+            return mapped;
+        }
+
+        // There are no exception mappings for the given exception. This case should be considered as internal error.
+        return new IgniteException(INTERNAL_ERR, origin);
+    }
+
+    /**
+     * Returns a new CompletableFuture that, when the given {@code origin} future completes exceptionally,
+     * maps the origin's exception to a public Ignite exception if it is needed.
+     *
+     * @param origin The future to use to create a new stage.
+     * @param <T> Type os result.
+     * @return New CompletableFuture.
+     */
+    public static <T> CompletableFuture<T> convertToPublicFuture(CompletableFuture<T> origin) {
+        return origin
+                .handle((res, err) -> {
+                    if (err != null) {
+                        throw new CompletionException(mapToPublicException(unwrapCause(err)));

Review Comment:
   Could you please provide an example? I didn't get the idea.



;26/Jun/23 12:23;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1242112542


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionUtils.java:
##########
@@ -177,14 +177,15 @@ public static int extractCodeFrom(Throwable t) {
         return INTERNAL_ERR;
     }
 
-    // TODO: https://issues.apache.org/jira/browse/IGNITE-19539 this method should be removed or re-worked.
+    // TODO: This method should be removed or re-worked and usages should be changed to IgniteExceptionMapperUtil.mapToPublicException.

Review Comment:
   Yep, you are right. Will create a ticket.



;26/Jun/23 12:24;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1242149763


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>>
+            EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<? extends Exception, ? extends Exception> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());
+        if (m != null) {
+            Exception mapped = map(m, origin);
+
+            assert mapped instanceof IgniteException || mapped instanceof IgniteCheckedException :
+                    ""Unexpected mapping of internal exception to a public one [origin="" + origin + "", mapped="" + mapped + ']';
+
+            return mapped;
+        }
+
+        // There are no exception mappings for the given exception. This case should be considered as internal error.
+        return new IgniteException(INTERNAL_ERR, origin);
+    }
+
+    /**
+     * Returns a new instance of public exception provided by the {@code mapper}.
+     *
+     * @param mapper Mapper function to produce a public exception.
+     * @param t Internal exception.
+     * @param <T> Type of an internal exception.
+     * @param <R> Type of a public exception.
+     * @return New public exception.
+     */
+    private static <T extends Exception, R extends Exception> Exception map(IgniteExceptionMapper<T, R> mapper, Throwable t) {
+        return mapper.map(mapper.mappingFrom().cast(t));
+    }
+
+    /**
+     * Returns {@code true} if the given exception {@code t} is instance of {@link NullPointerException}, {@link IllegalArgumentException}.
+     *
+     * @return {@code true} if the given exception is Java standard exception.
+     */
+    private static boolean isJavaStandardException(Throwable t) {
+        return t instanceof NullPointerException || t instanceof IllegalArgumentException;

Review Comment:
   Well, after some thought, I think that NPE should not be considered a valid case.
   ```
       /**
        * @throws NullPointerException If the provided name is {@code null}.
        */
       public CompletableFuture<Res> asycnOp(String name) throws NullPointerException {
           Object.requireNonNull(name);
   
           // This future should not be completed with NPE
           CompletableFuture<Res> r = internalApiCall();
           ...
           return res;
       }
   ```



;26/Jun/23 12:55;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1242150615


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>>
+            EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<? extends Exception, ? extends Exception> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<? extends Exception, ? extends Exception>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());
+        if (m != null) {
+            Exception mapped = map(m, origin);
+
+            assert mapped instanceof IgniteException || mapped instanceof IgniteCheckedException :
+                    ""Unexpected mapping of internal exception to a public one [origin="" + origin + "", mapped="" + mapped + ']';
+
+            return mapped;
+        }
+
+        // There are no exception mappings for the given exception. This case should be considered as internal error.
+        return new IgniteException(INTERNAL_ERR, origin);
+    }
+
+    /**
+     * Returns a new instance of public exception provided by the {@code mapper}.
+     *
+     * @param mapper Mapper function to produce a public exception.
+     * @param t Internal exception.
+     * @param <T> Type of an internal exception.
+     * @param <R> Type of a public exception.
+     * @return New public exception.
+     */
+    private static <T extends Exception, R extends Exception> Exception map(IgniteExceptionMapper<T, R> mapper, Throwable t) {
+        return mapper.map(mapper.mappingFrom().cast(t));
+    }
+
+    /**
+     * Returns {@code true} if the given exception {@code t} is instance of {@link NullPointerException}, {@link IllegalArgumentException}.
+     *
+     * @return {@code true} if the given exception is Java standard exception.
+     */
+    private static boolean isJavaStandardException(Throwable t) {
+        return t instanceof NullPointerException || t instanceof IllegalArgumentException;

Review Comment:
   All in all, this particular step of mapping should be removed from the PR.



;26/Jun/23 12:56;githubbot;600","sanpwc commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1242434599


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapper.java:
##########
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import java.util.function.Function;
+
+/**
+ * Represents a mapper from an internal exception {@code T} to a public one {@code R}.
+ */
+public class IgniteExceptionMapper<T extends Exception, R extends Exception> {
+    /** Class that represents an internal exception for mapping. */
+    private final Class<T> from;
+
+    /** Mapping function. */
+    private final Function<T, R> mapper;
+
+    /**
+     * Creates a new instance of mapper.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     */
+    private IgniteExceptionMapper(Class<T> from, Function<T, R> mapper) {
+        this.from = from;
+        this.mapper = mapper;
+    }
+
+    /**
+     * Returns a class instance that represents an internal exception to be used for mapping.
+     *
+     * @return Class instance that represents an internal exception to be used for mapping.
+     */
+    public Class<T> mappingFrom() {
+        return from;
+    }
+
+    /**
+     * Maps the provided internal exception to a public one.
+     *
+     * @param error Exception instance to be mapped.
+     * @return Public exception instance.
+     */
+    public R map(T error) {
+        return mapper.apply(error);
+    }
+
+    /**
+     * Creates a new exception mapper from an internal exception {@code T} to a public runtime exception {@code R}.
+     *
+     * @param from Class instance that represents a class of internal exception.
+     * @param mapper Mapping function to map an internal exception to a public one.
+     * @param <T> Internal exception type.
+     * @param <R> Public runtime exception type.
+     *
+     * @return New instance of {@link IgniteExceptionMapper}.
+     */
+    public static <T extends Exception, R extends IgniteException> IgniteExceptionMapper<T, R> unchecked(

Review Comment:
   Yep, ok.



;26/Jun/23 16:09;githubbot;600","sanpwc commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1242448068


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.internal.util.ExceptionUtils.unwrapCause;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<?, ?> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that will always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());

Review Comment:
   It's correct from the substitution principle. Alternative here, the one you've implemented, is converting SpecificExceptionB to root IgniteException, that should be considered incorrect according to aforementioned logic, meaning we have A extends B extends C, and B to B_public mapper along with anything to C_public. You claim that it's incorrect to consider A as B and thus convert it to B_public however it's correct to consider A as C and thus convert it to C_public, where C_public is IgniteException in this particular case.That seems confusing.
   In real life that would actually mean that in case of TransactionInternalCheckedException->TransactionException mapper we will convert LockException extends TransactionInternalCheckedException to IgniteException instead of TransactionException, that is more specific and thus better.



;26/Jun/23 16:21;githubbot;600","sanpwc commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1243209920


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.internal.util.ExceptionUtils.unwrapCause;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<?, ?> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that will always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());
+        if (m != null) {
+            Exception mapped = map(m, origin);
+
+            assert mapped instanceof IgniteException || mapped instanceof IgniteCheckedException :
+                    ""Unexpected mapping of internal exception to a public one [origin="" + origin + "", mapped="" + mapped + ']';
+
+            return mapped;
+        }
+
+        // There are no exception mappings for the given exception. This case should be considered as internal error.
+        return new IgniteException(INTERNAL_ERR, origin);
+    }
+
+    /**
+     * Returns a new CompletableFuture that, when the given {@code origin} future completes exceptionally,
+     * maps the origin's exception to a public Ignite exception if it is needed.
+     *
+     * @param origin The future to use to create a new stage.
+     * @param <T> Type os result.
+     * @return New CompletableFuture.
+     */
+    public static <T> CompletableFuture<T> convertToPublicFuture(CompletableFuture<T> origin) {
+        return origin
+                .handle((res, err) -> {
+                    if (err != null) {
+                        throw new CompletionException(mapToPublicException(unwrapCause(err)));

Review Comment:
   I mean that it's possible to have CompletionException(ExecutionException(NPE)) or similar. However unwrapCause actually flattens stack on it's own:
   ```
       public static Throwable unwrapCause(Throwable e) {
           while ((e instanceof CompletionException || e instanceof ExecutionException) && e.getCause() != null) {
               e = e.getCause();
           }
   
           return e;
       }
   ```



;27/Jun/23 06:37;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1243236656


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.internal.util.ExceptionUtils.unwrapCause;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<?, ?> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that will always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());

Review Comment:
   Well, I don't think so, just because the logic you proposed breaks handling exceptions on the user's side, and even cannot be compiled in case of checked exceptions.
   
   Let's consider the following examples:
   (1)
   ```
   Public hierarchy:
       ComponentException extends IgniteException;
       SpecificExceptionA extends ComponentException
       SpecificExceptionB extends ComponentException
   
   Internal hierarchy:
       InternalComponentException extends IgniteInternalException;
       InternalSpecificExceptionA extends InternalComponentException
       InternalSpecificExceptionB extends InternalComponentException
   
   Mappings:
       InternalComponentException -> ComponentException
       InternalSpecificExceptionA -> SpecificExceptionA
       mapping for InternalSpecificExceptionB is absent due to a bug
   ```
   ```
   Public api:
       public void apiCall() throws SpecificExceptionA, SpecificExceptionB;
   
       try {
           apiCall();
       catch (SpecificExceptionB e) {
           // handle specific case (B)
       } catch (SpecificExceptionA e) {
           // handle specific case (A)
       } catch (ComponentException e) {
           // optional catch block, just to illustrate the issue (C)
       }
   ```
   
   If I understand your proposal correctly, the mapper should convert InternalSpecificExceptionB to ComponentException, because the most specific mapping is InternalComponentException -> ComponentException and InternalSpecificExceptionB extends InternalComponentException.
   
   In this case, exception handler (B) will be skipped at all, only (C) will be executed. I would say, this is a bug caused by the absence of the required mapping and we should clearly state that it is incorrect behavior via throwing `IgniteException(INTERNAL_ERR)` I think.
   
   When ComponentException is a checked exception, the situation is even worse - the code should not be compiled:
   ```
       public static void apiCall() throws SpecificExceptionA, SpecificExceptionB {
           ...
           throw new ComponentException();
       }
   ```
   
   (2) 
   ```
   Public hierarchy:
       ComponentException extends IgniteException;
       SpecificExceptionA extends ComponentException
       SpecificExceptionB extends SpecificExceptionA
   ```
   
   The fact, that the right handler is skipped, is still in play.



;27/Jun/23 07:05;githubbot;600","sanpwc commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1243283024


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.internal.util.ExceptionUtils.unwrapCause;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<?, ?> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that will always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());

Review Comment:
   > I would say, this is a bug caused by the absence of the required mapping and we should clearly state that it is incorrect behavior via throwing IgniteException(INTERNAL_ERR) I think.
   
   Why it's a bug? Is it mandatory to have explicit internal to public mappers for all internal exceptions? Why?
   
   > When ComponentException is a checked exception, the situation is even worse - the code should not be compiled:
   
   What do you mean? You either expect ComponentException to be thrown and thus add it to throws clause, or provide required mapping.



;27/Jun/23 07:44;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1245139714


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionMapperUtil.java:
##########
@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.lang;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apache.ignite.internal.util.ExceptionUtils.unwrapCause;
+import static org.apache.ignite.lang.ErrorGroups.Common.INTERNAL_ERR;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.ServiceLoader;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+
+/**
+ * This utility class provides an ability to map Ignite internal exceptions to Ignite public ones.
+ */
+public class IgniteExceptionMapperUtil {
+    /** All exception mappers to be used to map internal exceptions to public ones. */
+    private static final Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> EXCEPTION_CONVERTERS;
+
+    static {
+        Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> mappers = new HashMap<>();
+
+        ServiceLoader
+                .load(IgniteExceptionMappersProvider.class)
+                .forEach(provider -> provider.mappers().forEach(m -> registerMapping(m, mappers)));
+
+        EXCEPTION_CONVERTERS = unmodifiableMap(mappers);
+    }
+
+    /**
+     * Add a new mapping to already registered ones.
+     *
+     * @param mapper Exception mapper from internal exception to a public one.
+     * @param registeredMappings Already registered mappings.
+     * @throws IgniteException If a mapper for the given {@code clazz} already registered,
+     *      or {@code clazz} represents Java standard exception like {@link NullPointerException}, {@link IllegalArgumentException}.
+     */
+    static void registerMapping(
+            IgniteExceptionMapper<?, ?> mapper,
+            Map<Class<? extends Exception>, IgniteExceptionMapper<?, ?>> registeredMappings) {
+        if (registeredMappings.containsKey(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper, duplicate found [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        if (isJavaStandardException(mapper.mappingFrom())) {
+            throw new IgniteException(
+                    INTERNAL_ERR,
+                    ""Failed to register exception mapper. ""
+                            + ""Mapping for this class is prohibited [class="" + mapper.mappingFrom().getCanonicalName() + ']');
+        }
+
+        registeredMappings.put(mapper.mappingFrom(), mapper);
+    }
+
+    /**
+     * This method provides a mapping from internal exception to Ignite public ones.
+     *
+     * <p>The rules of mapping are the following:</p>
+     * <ul>
+     *     <li>any instance of {@link Error} is returned as is, except {@link AssertionError}
+     *     that will always be mapped to {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code.</li>
+     *     <li>any instance of Java standard exception like {@link NullPointerException} is returned as is.</li>
+     *     <li>any instance of {@link IgniteException} or {@link IgniteCheckedException} is returned as is.</li>
+     *     <li>if there are no any mappers that can do a mapping from the given error to a public exception,
+     *     then {@link IgniteException} with the {@link ErrorGroups.Common#INTERNAL_ERR} error code is returned.</li>
+     * </ul>
+     *
+     * @param origin Exception to be mapped.
+     * @return Public exception.
+     */
+    public static Throwable mapToPublicException(Throwable origin) {
+        if (origin instanceof Error) {
+            if (origin instanceof AssertionError) {
+                return new IgniteException(INTERNAL_ERR, origin);
+            }
+
+            return origin;
+        }
+
+        if (origin instanceof IgniteException || origin instanceof IgniteCheckedException) {
+            return origin;
+        }
+
+        if (isJavaStandardException(origin)) {
+            return origin;
+        }
+
+        IgniteExceptionMapper<? extends Exception, ? extends Exception> m = EXCEPTION_CONVERTERS.get(origin.getClass());

Review Comment:
   As was disccussed with @ibessonov and @sanpwc the improvement of the mapping rules will be partially addressed by https://issues.apache.org/jira/browse/IGNITE-19871. All other questions mentioned in this topic will be postponed until the real use cases shows the need.



;28/Jun/23 12:32;githubbot;600","sk0x50 commented on code in PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225#discussion_r1242112542


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteExceptionUtils.java:
##########
@@ -177,14 +177,15 @@ public static int extractCodeFrom(Throwable t) {
         return INTERNAL_ERR;
     }
 
-    // TODO: https://issues.apache.org/jira/browse/IGNITE-19539 this method should be removed or re-worked.
+    // TODO: This method should be removed or re-worked and usages should be changed to IgniteExceptionMapperUtil.mapToPublicException.

Review Comment:
   Yep, you are right. Will create a ticket. https://issues.apache.org/jira/browse/IGNITE-19870



;28/Jun/23 12:44;githubbot;600","sk0x50 merged PR #2225:
URL: https://github.com/apache/ignite-3/pull/2225


;28/Jun/23 13:36;githubbot;600",,,,,,,,,,,,,,,,,,,,0,16200,,,0,16200,,,,,,,,,,,,,,,,IGNITE-14865,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-14611,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-05-22 14:48:35.0,,,,,,,,,,"0|z1i26o:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
Duplicating error code in the message.,IGNITE-19534,13537173,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,slava.koptilin,slava.koptilin,slava.koptilin,22/May/23 14:10,01/Jun/23 09:33,13/Jul/23 09:11,01/Jun/23 09:33,,,,,,,,3.0.0-beta2,,,,0,iep-84,ignite-3,,"Error code can be duplicated in the message as follows:
{code:java}
org.apache.ignite.sql.SqlException: IGN-SQL-20 TraceId:8c53228d-6463-4dec-8ef6-7f7a19baab49 IGN-SQL-20 TraceId:8c53228d-6463-4dec-8ef6-7f7a19baab49 IGN-SQL-20 TraceId:8c53228d-6463-4dec-8ef6-7f7a19baab49
  at java.base@11.0.17/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
  at java.base@11.0.17/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
  at java.base@11.0.17/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
  at java.base@11.0.17/java.lang.reflect.Constructor.newInstance(Constructor.java:490)
  at app//org.apache.ignite.lang.IgniteException.wrap(IgniteException.java:276)
  at app//org.apache.ignite.sql.Session.execute(Session.java:60)
  at app//org.apache.ignite.internal.sqllogic.ScriptContext.executeQuery(ScriptContext.java:89)
  at app//org.apache.ignite.internal.sqllogic.Statement.execute(Statement.java:108)
  ... 7 more
Caused by: org.apache.ignite.sql.SqlException: IGN-SQL-20 TraceId:8c53228d-6463-4dec-8ef6-7f7a19baab49 IGN-SQL-20 TraceId:8c53228d-6463-4dec-8ef6-7f7a19baab49
  ...
  ... 3 more
Caused by: org.apache.ignite.sql.SqlException: IGN-SQL-20 TraceId:8c53228d-6463-4dec-8ef6-7f7a19baab49
  at app//org.apache.ignite.internal.sql.engine.exec.ExecutionServiceImpl.convertDdlException(ExecutionServiceImpl.java:311)
  at app//org.apache.ignite.internal.sql.engine.exec.ExecutionServiceImpl.lambda$executeDdl$8(ExecutionServiceImpl.java:289)
  ... 12 more
Caused by: java.util.concurrent.TimeoutException
  ... 8 more
{code}
-It seems to me, this behavior is caused by `IgniteException.wrap`.-
-By the way, this method is a good candidate to be moved to `ExceptionUtils` along with `IgniteException.getIgniteErrorCode()`.-

It seems to me, that the real cause of the issue is that `IgniteException` extends the user-provided message with an error code and trace id, but this behavior contradicts the implementation of Throwable:
 - the user-defined message should not be changed in any way, and `getMessage()` should return exactly the same message.
 - any additional information is included by `toString()` implementation (such as adding FQCN, error code, and traceId)",,ptupitsyn,slava.koptilin,,,,"sk0x50 opened a new pull request, #2107:
URL: https://github.com/apache/ignite-3/pull/2107

   (no comment)


;25/May/23 17:33;githubbot;600","sk0x50 closed pull request #2104: IGNITE-19534 Fixed error code duplicating in error message
URL: https://github.com/apache/ignite-3/pull/2104


;31/May/23 15:00;githubbot;600","sanpwc commented on code in PR #2107:
URL: https://github.com/apache/ignite-3/pull/2107#discussion_r1212059946


##########
modules/api/src/test/java/org/apache/ignite/lang/IgniteExceptionTest.java:
##########
@@ -32,34 +32,89 @@
  */
 public class IgniteExceptionTest {
     @Test
-    public void testWrapUncheckedException() {
-        var originalEx = new CustomTestException(UUID.randomUUID(), Table.TABLE_NOT_FOUND_ERR, ""Error foo bar"", null);
+    public void testWrapPublicUncheckedException() {
+        var originalMessage = ""Error foo bar"";
+        var originalTraceId = UUID.randomUUID();
+        var expectedFullMessage = CustomTestException.class.getName() + "": ""
+                + errorMessage(originalTraceId, Table.TABLE_NOT_FOUND_ERR, originalMessage);
+
+        var originalEx = new CustomTestException(originalTraceId, Table.TABLE_NOT_FOUND_ERR, originalMessage, null);
         var wrappedEx = new CompletionException(originalEx);
         var res = IgniteException.wrap(wrappedEx);
 
-        assertThat(res.getMessage(), containsString(""Error foo bar""));
         assertEquals(originalEx.traceId(), res.traceId());
         assertEquals(originalEx.code(), res.code());
         assertEquals(originalEx.getClass(), res.getClass());
         assertSame(originalEx, res.getCause());
+        assertEquals(originalMessage, res.getMessage());
+        assertEquals(expectedFullMessage, res.toString());
     }
 
     @Test
-    public void testWrapCheckedException() {
-        var originalEx = new IgniteCheckedException(Table.COLUMN_ALREADY_EXISTS_ERR, ""Msg."");
+    public void testWrapPublicCheckedException() {
+        var originalMessage = ""Msg"";
+        var originalTraceId = UUID.randomUUID();
+        var expectedFullMessage = IgniteException.class.getName() + "": ""
+                + errorMessage(originalTraceId, Table.COLUMN_ALREADY_EXISTS_ERR, originalMessage);
+
+        var originalEx = new IgniteCheckedException(originalTraceId, Table.COLUMN_ALREADY_EXISTS_ERR, originalMessage);
         var wrappedEx = new CompletionException(originalEx);
         var res = IgniteException.wrap(wrappedEx);
 
-        assertThat(res.getMessage(), containsString(""Msg.""));
         assertEquals(originalEx.traceId(), res.traceId());
         assertEquals(originalEx.code(), res.code());
         assertSame(originalEx, res.getCause());
+        assertEquals(originalMessage, res.getMessage());
+        assertEquals(expectedFullMessage, res.toString());
+    }
+
+    @Test
+    public void testWrapInternalException() {
+        var originalMessage = ""Unexpected error."";
+        var originalTraceId = UUID.randomUUID();
+
+        var originalEx = new IgniteInternalException(originalTraceId, Common.INTERNAL_ERR, originalMessage);
+        var wrappedEx = new CompletionException(originalEx);
+        var res = IgniteException.wrap(wrappedEx);

Review Comment:
   Not sure, but formally speaking I believe it's not valid to use var in such cases. However, from my point of view it's still fine in given case.



;31/May/23 17:27;githubbot;600","sanpwc commented on code in PR #2107:
URL: https://github.com/apache/ignite-3/pull/2107#discussion_r1212060474


##########
modules/client-handler/src/integrationTest/java/org/apache/ignite/client/handler/ItClientHandlerMetricsTest.java:
##########
@@ -147,7 +147,7 @@ void testBytesSentReceived(TestInfo testInfo) throws Exception {
         ItClientHandlerTestUtils.connectAndHandshake(serverModule, false, true);
 
         assertTrue(
-                IgniteTestUtils.waitForCondition(() -> testServer.metrics().bytesSent() == 216, 1000),
+                IgniteTestUtils.waitForCondition(() -> testServer.metrics().bytesSent() == 158, 1000),

Review Comment:
   What's that?



;31/May/23 17:28;githubbot;600","sanpwc commented on code in PR #2107:
URL: https://github.com/apache/ignite-3/pull/2107#discussion_r1212075525


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteException.java:
##########
@@ -255,6 +252,14 @@ public UUID traceId() {
         return traceId;
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public String toString() {

Review Comment:
   It looks a bit weird that we had to duplicate exact the same code in all our ignite specific root exceptions toString() and similar, however I don't have better solution here.   



;31/May/23 17:40;githubbot;600","sk0x50 commented on code in PR #2107:
URL: https://github.com/apache/ignite-3/pull/2107#discussion_r1212710214


##########
modules/api/src/test/java/org/apache/ignite/lang/IgniteExceptionTest.java:
##########
@@ -32,34 +32,89 @@
  */
 public class IgniteExceptionTest {
     @Test
-    public void testWrapUncheckedException() {
-        var originalEx = new CustomTestException(UUID.randomUUID(), Table.TABLE_NOT_FOUND_ERR, ""Error foo bar"", null);
+    public void testWrapPublicUncheckedException() {
+        var originalMessage = ""Error foo bar"";
+        var originalTraceId = UUID.randomUUID();
+        var expectedFullMessage = CustomTestException.class.getName() + "": ""
+                + errorMessage(originalTraceId, Table.TABLE_NOT_FOUND_ERR, originalMessage);
+
+        var originalEx = new CustomTestException(originalTraceId, Table.TABLE_NOT_FOUND_ERR, originalMessage, null);
         var wrappedEx = new CompletionException(originalEx);
         var res = IgniteException.wrap(wrappedEx);
 
-        assertThat(res.getMessage(), containsString(""Error foo bar""));
         assertEquals(originalEx.traceId(), res.traceId());
         assertEquals(originalEx.code(), res.code());
         assertEquals(originalEx.getClass(), res.getClass());
         assertSame(originalEx, res.getCause());
+        assertEquals(originalMessage, res.getMessage());
+        assertEquals(expectedFullMessage, res.toString());
     }
 
     @Test
-    public void testWrapCheckedException() {
-        var originalEx = new IgniteCheckedException(Table.COLUMN_ALREADY_EXISTS_ERR, ""Msg."");
+    public void testWrapPublicCheckedException() {
+        var originalMessage = ""Msg"";
+        var originalTraceId = UUID.randomUUID();
+        var expectedFullMessage = IgniteException.class.getName() + "": ""
+                + errorMessage(originalTraceId, Table.COLUMN_ALREADY_EXISTS_ERR, originalMessage);
+
+        var originalEx = new IgniteCheckedException(originalTraceId, Table.COLUMN_ALREADY_EXISTS_ERR, originalMessage);
         var wrappedEx = new CompletionException(originalEx);
         var res = IgniteException.wrap(wrappedEx);
 
-        assertThat(res.getMessage(), containsString(""Msg.""));
         assertEquals(originalEx.traceId(), res.traceId());
         assertEquals(originalEx.code(), res.code());
         assertSame(originalEx, res.getCause());
+        assertEquals(originalMessage, res.getMessage());
+        assertEquals(expectedFullMessage, res.toString());
+    }
+
+    @Test
+    public void testWrapInternalException() {
+        var originalMessage = ""Unexpected error."";
+        var originalTraceId = UUID.randomUUID();
+
+        var originalEx = new IgniteInternalException(originalTraceId, Common.INTERNAL_ERR, originalMessage);
+        var wrappedEx = new CompletionException(originalEx);
+        var res = IgniteException.wrap(wrappedEx);

Review Comment:
   Ok. this makes sense to me. I will change



;01/Jun/23 07:28;githubbot;600","sk0x50 commented on code in PR #2107:
URL: https://github.com/apache/ignite-3/pull/2107#discussion_r1212720169


##########
modules/client-handler/src/integrationTest/java/org/apache/ignite/client/handler/ItClientHandlerMetricsTest.java:
##########
@@ -147,7 +147,7 @@ void testBytesSentReceived(TestInfo testInfo) throws Exception {
         ItClientHandlerTestUtils.connectAndHandshake(serverModule, false, true);
 
         assertTrue(
-                IgniteTestUtils.waitForCondition(() -> testServer.metrics().bytesSent() == 216, 1000),
+                IgniteTestUtils.waitForCondition(() -> testServer.metrics().bytesSent() == 158, 1000),

Review Comment:
   This particular line of code checks the size of an exception transferred from the server node. After the changes proposed in this PR, the size (in bytes) was reduced just because the exception message is not extended by the error code and trace identifier.



;01/Jun/23 07:36;githubbot;600","sk0x50 commented on code in PR #2107:
URL: https://github.com/apache/ignite-3/pull/2107#discussion_r1212724055


##########
modules/api/src/main/java/org/apache/ignite/lang/IgniteException.java:
##########
@@ -255,6 +252,14 @@ public UUID traceId() {
         return traceId;
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public String toString() {

Review Comment:
   we are on the same page. :)



;01/Jun/23 07:39;githubbot;600","sk0x50 commented on code in PR #2107:
URL: https://github.com/apache/ignite-3/pull/2107#discussion_r1212775945


##########
modules/api/src/test/java/org/apache/ignite/lang/IgniteExceptionTest.java:
##########
@@ -32,34 +32,89 @@
  */
 public class IgniteExceptionTest {
     @Test
-    public void testWrapUncheckedException() {
-        var originalEx = new CustomTestException(UUID.randomUUID(), Table.TABLE_NOT_FOUND_ERR, ""Error foo bar"", null);
+    public void testWrapPublicUncheckedException() {
+        var originalMessage = ""Error foo bar"";
+        var originalTraceId = UUID.randomUUID();
+        var expectedFullMessage = CustomTestException.class.getName() + "": ""
+                + errorMessage(originalTraceId, Table.TABLE_NOT_FOUND_ERR, originalMessage);
+
+        var originalEx = new CustomTestException(originalTraceId, Table.TABLE_NOT_FOUND_ERR, originalMessage, null);
         var wrappedEx = new CompletionException(originalEx);
         var res = IgniteException.wrap(wrappedEx);
 
-        assertThat(res.getMessage(), containsString(""Error foo bar""));
         assertEquals(originalEx.traceId(), res.traceId());
         assertEquals(originalEx.code(), res.code());
         assertEquals(originalEx.getClass(), res.getClass());
         assertSame(originalEx, res.getCause());
+        assertEquals(originalMessage, res.getMessage());
+        assertEquals(expectedFullMessage, res.toString());
     }
 
     @Test
-    public void testWrapCheckedException() {
-        var originalEx = new IgniteCheckedException(Table.COLUMN_ALREADY_EXISTS_ERR, ""Msg."");
+    public void testWrapPublicCheckedException() {
+        var originalMessage = ""Msg"";
+        var originalTraceId = UUID.randomUUID();
+        var expectedFullMessage = IgniteException.class.getName() + "": ""
+                + errorMessage(originalTraceId, Table.COLUMN_ALREADY_EXISTS_ERR, originalMessage);
+
+        var originalEx = new IgniteCheckedException(originalTraceId, Table.COLUMN_ALREADY_EXISTS_ERR, originalMessage);
         var wrappedEx = new CompletionException(originalEx);
         var res = IgniteException.wrap(wrappedEx);
 
-        assertThat(res.getMessage(), containsString(""Msg.""));
         assertEquals(originalEx.traceId(), res.traceId());
         assertEquals(originalEx.code(), res.code());
         assertSame(originalEx, res.getCause());
+        assertEquals(originalMessage, res.getMessage());
+        assertEquals(expectedFullMessage, res.toString());
+    }
+
+    @Test
+    public void testWrapInternalException() {
+        var originalMessage = ""Unexpected error."";
+        var originalTraceId = UUID.randomUUID();
+
+        var originalEx = new IgniteInternalException(originalTraceId, Common.INTERNAL_ERR, originalMessage);
+        var wrappedEx = new CompletionException(originalEx);
+        var res = IgniteException.wrap(wrappedEx);

Review Comment:
   As was discussed in private, we decided to stick with the current code without any changes for this particular case



;01/Jun/23 08:19;githubbot;600","sk0x50 merged PR #2107:
URL: https://github.com/apache/ignite-3/pull/2107


;01/Jun/23 09:32;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,6000,,,0,6000,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-14611,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jun 01 04:07:50 UTC 2023,,,,,,,,,,"0|z1i24w:",9223372036854775807,,,ptupitsyn,,,,,,,,,,,,,,,,,,"31/May/23 14:51;slava.koptilin;Hi [~ptupitsyn] , [~sanpwc] ,

Could you please take a look at this patch [https://github.com/apache/ignite-3/pull/2107] ?;;;","01/Jun/23 04:07;ptupitsyn;[~slava.koptilin] looks good to me.;;;",,,,
Rename UNKNOWN_ERR error code to INTERNAL_ERR,IGNITE-19533,13537171,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,slava.koptilin,slava.koptilin,slava.koptilin,22/May/23 14:00,24/May/23 15:35,13/Jul/23 09:11,24/May/23 15:35,,,,,,,,3.0.0-beta2,,,,0,iep-84,ignite-3,,"The UNKNOWN_ERR error code should be renamed to INTERNAL_ERR. The @Deprecated should be removed as well.

The INTRNAL_ERR error code should be considered as the product's internal error caused by faulty logic or coding in the product. In general, this error code represents a non-recoverable error that should be provided to code maintainers.

It seems to me the UNEXPECTED_ERR and Sql.INTERNAL_ERR  error codes just duplicate the `Common.INTERNAL_ERR` one, so, both of them should be removed.

[1] https://docs.oracle.com/en/database/oracle/oracle-database/19/errmg/using-messages.html#GUID-3D523C69-502E-4E8B-8E56-BEA97EBE50ED
{noformat}
ORA-00600: internal error code, arguments: [string], [string], [string], [string], [string], [string], [string], [string], [string], [string], [string], [string]
Cause: This is the generic internal error number for Oracle program exceptions. It indicates that a process has encountered a low-level, unexpected condition. The first argument is the internal message number. This argument and the database version number are critical in identifying the root cause and the potential impact to your system.

Action: Visit My Oracle Support to access the ORA-00600 Lookup tool (reference Note 600.1) for more information regarding the specific ORA-00600 error encountered. An Incident has been created for this error in the Automatic Diagnostic Repository (ADR). When logging a service request, use the Incident Packaging Service (IPS) from the Support Workbench or the ADR Command Interpreter (ADRCI) to automatically package the relevant trace information (reference My Oracle Support Note 411.1). The following information should also be gathered to help determine the root cause: - changes leading up to the error - events or unusual circumstances leading up to the error - operations attempted prior to the error - conditions of the operating system and databases at the time of the error Note: The cause of this message may manifest itself as different errors at different times. Be aware of the history of errors that occurred before this internal error.
{noformat}

[2] https://www.postgresql.org/docs/current/errcodes-appendix.html
{noformat}
Class XX — Internal Error
XX000	internal_error
XX001	data_corrupted
XX002	index_corrupted
{noformat}
",,alapin,slava.koptilin,,,,"sk0x50 opened a new pull request, #2097:
URL: https://github.com/apache/ignite-3/pull/2097

   https://issues.apache.org/jira/browse/IGNITE-19533


;23/May/23 10:26;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-14611,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed May 24 13:42:26 UTC 2023,,,,,,,,,,"0|z1i24g:",9223372036854775807,,,sanpwc,,,,,,,,,,,,,,,,,,"24/May/23 13:42;alapin;[~slava.koptilin] LGTM!;;;",,,,,
Unmute TxAbstractTest.testRollbackUpgradedLock,IGNITE-19523,13536721,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,slava.koptilin,slava.koptilin,slava.koptilin,18/May/23 09:21,23/May/23 07:17,13/Jul/23 09:11,23/May/23 07:17,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"The ticket IGNITE-15939 was resolved, so need to check and unmute the following test: testRollbackUpgradedLock
",,slava.koptilin,v.pyatkov,,,,"sk0x50 merged PR #2087:
URL: https://github.com/apache/ignite-3/pull/2087


;23/May/23 07:17;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon May 22 08:18:56 UTC 2023,,,,,,,,,,"0|z1hzco:",9223372036854775807,,,v.pyatkov,,,,,,,,,,,,,,,,,,"22/May/23 08:18;v.pyatkov;LGTM;;;",,,,,
"SQL onheap cache stores row on per-cache basis, but access these rows on per-index basis",IGNITE-19495,13536528,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,alex_pl,alex_pl,alex_pl,17/May/23 09:49,18/May/23 08:34,13/Jul/23 09:11,18/May/23 08:34,,,,,,,,2.16,,,,0,ise,,,"If there are two indexes on the same cache and sqlOnHeapCache property is enabled there can be node failures such as:
{noformat}
org.apache.ignite.internal.processors.cache.persistence.tree.CorruptedTreeException: B+Tree is corrupted [groupId=-917681634, pageIds=[844420635164678], cacheId=-917681634, cacheName=..., indexName=_key_PK, msg=Runtime failure on row: Row@71aeb1b9[ ... ][  ]]
...
Caused by: org.apache.ignite.IgniteException: Failed to store new index row.
...
Caused by: java.lang.UnsupportedOperationException: 13 cannot be used for inline type 19
{noformat}
Root cause: {{IndexRowCache}} is created per cache group (see {{IndexRowCacheRegistry#onCacheRegistered}}), but stores {{IndexRowImpl}} binded to particular index (see {{InlineIndexTree#createIndexRow}}). In case, when another index requires the same data row, it gets row from the onheap cache with the wrong index row handler.",,alex_pl,ignitetcbot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Thu May 18 08:34:15 UTC 2023,,,,,,,,,,"0|z1hy5s:",9223372036854775807,Fixed failure on sqlOnHeapCache=enabled and more than one index used,,,,,,,,,,,,,,,,,,,,"18/May/23 08:31;ignitetcbot;{panel:title=Branch: [pull/10722/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10722/head] Base: [master] : No new tests found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7178894&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","18/May/23 08:34;alex_pl;[~ivandasch], thanks for the review! Merged to master.;;;",,,,
Correctly stop a replica,IGNITE-19494,13536526,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,v.pyatkov,ktkalenko@gridgain.com,ktkalenko@gridgain.com,17/May/23 09:44,08/Jun/23 14:08,13/Jul/23 09:11,08/Jun/23 14:07,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"If we look at the implementation of stopping the replica in (*org.apache.ignite.internal.replicator.ReplicaManager#stopReplicaInternal*), then we simply delete the future.

I think that this is not right, and we should wait for it or something and only after that stop it.
Maybe I don't understand something and then we'll just close the ticket.


",,alapin,ktkalenko@gridgain.com,v.pyatkov,,,"vldpyatkov opened a new pull request, #2142:
URL: https://github.com/apache/ignite-3/pull/2142

   https://issues.apache.org/jira/browse/IGNITE-19494


;02/Jun/23 17:48;githubbot;600","sanpwc commented on code in PR #2142:
URL: https://github.com/apache/ignite-3/pull/2142#discussion_r1221656137


##########
modules/raft/src/main/java/org/apache/ignite/raft/jraft/disruptor/StripedDisruptor.java:
##########
@@ -214,7 +214,7 @@ void unsubscribe(NodeId nodeId) {
             assert handler != null : format(""Group of the event is unsupported [nodeId={}, event={}]"", event.nodeId(), event);
 
             //TODO: IGNITE-15568 endOfBatch should be set to true to prevent caching tasks until IGNITE-15568 has fixed.
-            handler.onEvent(event, sequence, true);
+            handler.onEvent(event, sequence, subscribers.size() > 1 ? true : endOfBatch);

Review Comment:
   Is it an intended change?



;07/Jun/23 14:02;githubbot;600","sanpwc commented on code in PR #2142:
URL: https://github.com/apache/ignite-3/pull/2142#discussion_r1221661458


##########
modules/replicator/src/main/java/org/apache/ignite/internal/replicator/ReplicaManager.java:
##########
@@ -387,11 +399,18 @@ private boolean stopReplicaInternal(ReplicationGroupId replicaGrpId) {
         CompletableFuture<Replica> removed = replicas.remove(replicaGrpId);
 
         if (removed != null) {
-            removed.whenComplete((replica, throwable) -> {
-                if (throwable != null) {
-                    replica.shutdown();
-                }
-            });
+            if (!removed.isDone()) {

Review Comment:
   ```
       // TODO: IGNITE-19494 We need to correctly stop the replica
       private boolean stopReplicaInternal(ReplicationGroupId replicaGrpId) 
   ```
   todo still present



;07/Jun/23 14:05;githubbot;600","sanpwc commented on code in PR #2142:
URL: https://github.com/apache/ignite-3/pull/2142#discussion_r1221682891


##########
modules/replicator/src/main/java/org/apache/ignite/internal/replicator/ReplicaManager.java:
##########
@@ -387,11 +399,18 @@ private boolean stopReplicaInternal(ReplicationGroupId replicaGrpId) {
         CompletableFuture<Replica> removed = replicas.remove(replicaGrpId);
 
         if (removed != null) {
-            removed.whenComplete((replica, throwable) -> {
-                if (throwable != null) {
-                    replica.shutdown();
-                }
-            });
+            if (!removed.isDone()) {
+                removed.completeExceptionally(new ReplicaStoppingException(

Review Comment:
   Is it guaranteed that `!removed.isDone()` and `removed.completeExceptionally` are atomic? In other words why we don't call replica.shutdown() in case of removed.completeExceptionally() branch?



;07/Jun/23 14:18;githubbot;600","sanpwc commented on code in PR #2142:
URL: https://github.com/apache/ignite-3/pull/2142#discussion_r1221695867


##########
modules/replicator/src/main/java/org/apache/ignite/internal/replicator/exception/ReplicaStoppingException.java:
##########
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.replicator.exception;
+
+import static org.apache.ignite.lang.ErrorGroups.Replicator.REPLICA_STOPPING_ERR;
+
+import java.util.UUID;
+import org.apache.ignite.internal.replicator.ReplicationGroupId;
+import org.apache.ignite.network.ClusterNode;
+
+/**
+ * The exception is thrown for unhandled requests that wait for the replica, but it is already stopping.
+ */
+public class ReplicaStoppingException extends ReplicationException {
+    /**
+     * The constructor.
+     *
+     * @param groupId Replication group id.
+     * @param node Node.
+     */
+    public ReplicaStoppingException(ReplicationGroupId groupId, ClusterNode node) {
+        super(REPLICA_STOPPING_ERR, ""Replica is stopping [replicationGroupId="" + groupId + "", nodeName="" + node.name() + ']');
+    }
+
+    /**
+     * The constructor is used for creating an exception instance that is thrown from a remote server.
+     *
+     * @param traceId Trace id.
+     * @param code Error code.
+     * @param message Error message.
+     * @param cause Cause exception.
+     */
+    public ReplicaStoppingException(UUID traceId, int code, String message, Throwable cause) {

Review Comment:
   Where do we use such constructor? Within deserialization process?



;07/Jun/23 14:24;githubbot;600","vldpyatkov commented on code in PR #2142:
URL: https://github.com/apache/ignite-3/pull/2142#discussion_r1222561847


##########
modules/raft/src/main/java/org/apache/ignite/raft/jraft/disruptor/StripedDisruptor.java:
##########
@@ -214,7 +214,7 @@ void unsubscribe(NodeId nodeId) {
             assert handler != null : format(""Group of the event is unsupported [nodeId={}, event={}]"", event.nodeId(), event);
 
             //TODO: IGNITE-15568 endOfBatch should be set to true to prevent caching tasks until IGNITE-15568 has fixed.
-            handler.onEvent(event, sequence, true);
+            handler.onEvent(event, sequence, subscribers.size() > 1 ? true : endOfBatch);

Review Comment:
   Not intended, but I decided to leave it after commit. Because this allows to do slightly better of disruptor for Meta storage and Cluster management group and I don't want to create dedicate ticket for this small change.



;08/Jun/23 07:18;githubbot;600","vldpyatkov commented on code in PR #2142:
URL: https://github.com/apache/ignite-3/pull/2142#discussion_r1222566102


##########
modules/replicator/src/main/java/org/apache/ignite/internal/replicator/ReplicaManager.java:
##########
@@ -387,11 +399,18 @@ private boolean stopReplicaInternal(ReplicationGroupId replicaGrpId) {
         CompletableFuture<Replica> removed = replicas.remove(replicaGrpId);
 
         if (removed != null) {
-            removed.whenComplete((replica, throwable) -> {
-                if (throwable != null) {
-                    replica.shutdown();
-                }
-            });
+            if (!removed.isDone()) {
+                removed.completeExceptionally(new ReplicaStoppingException(

Review Comment:
   We have the grantee, because the replica future is already deleted from the replicas, but successful complete possible only in a compute closure for the map.



;08/Jun/23 07:21;githubbot;600","vldpyatkov commented on code in PR #2142:
URL: https://github.com/apache/ignite-3/pull/2142#discussion_r1222568013


##########
modules/replicator/src/main/java/org/apache/ignite/internal/replicator/exception/ReplicaStoppingException.java:
##########
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.replicator.exception;
+
+import static org.apache.ignite.lang.ErrorGroups.Replicator.REPLICA_STOPPING_ERR;
+
+import java.util.UUID;
+import org.apache.ignite.internal.replicator.ReplicationGroupId;
+import org.apache.ignite.network.ClusterNode;
+
+/**
+ * The exception is thrown for unhandled requests that wait for the replica, but it is already stopping.
+ */
+public class ReplicaStoppingException extends ReplicationException {
+    /**
+     * The constructor.
+     *
+     * @param groupId Replication group id.
+     * @param node Node.
+     */
+    public ReplicaStoppingException(ReplicationGroupId groupId, ClusterNode node) {
+        super(REPLICA_STOPPING_ERR, ""Replica is stopping [replicationGroupId="" + groupId + "", nodeName="" + node.name() + ']');
+    }
+
+    /**
+     * The constructor is used for creating an exception instance that is thrown from a remote server.
+     *
+     * @param traceId Trace id.
+     * @param code Error code.
+     * @param message Error message.
+     * @param cause Cause exception.
+     */
+    public ReplicaStoppingException(UUID traceId, int code, String message, Throwable cause) {

Review Comment:
   I think, any exception should have constructor like this, even if it is not used in network just now.



;08/Jun/23 07:23;githubbot;600","vldpyatkov commented on code in PR #2142:
URL: https://github.com/apache/ignite-3/pull/2142#discussion_r1222572038


##########
modules/replicator/src/main/java/org/apache/ignite/internal/replicator/ReplicaManager.java:
##########
@@ -387,11 +399,18 @@ private boolean stopReplicaInternal(ReplicationGroupId replicaGrpId) {
         CompletableFuture<Replica> removed = replicas.remove(replicaGrpId);
 
         if (removed != null) {
-            removed.whenComplete((replica, throwable) -> {
-                if (throwable != null) {
-                    replica.shutdown();
-                }
-            });
+            if (!removed.isDone()) {

Review Comment:
   Removed this note.



;08/Jun/23 07:27;githubbot;600","sanpwc commented on code in PR #2142:
URL: https://github.com/apache/ignite-3/pull/2142#discussion_r1222619421


##########
modules/raft/src/main/java/org/apache/ignite/raft/jraft/disruptor/StripedDisruptor.java:
##########
@@ -214,7 +214,7 @@ void unsubscribe(NodeId nodeId) {
             assert handler != null : format(""Group of the event is unsupported [nodeId={}, event={}]"", event.nodeId(), event);
 
             //TODO: IGNITE-15568 endOfBatch should be set to true to prevent caching tasks until IGNITE-15568 has fixed.
-            handler.onEvent(event, sequence, true);
+            handler.onEvent(event, sequence, subscribers.size() > 1 ? true : endOfBatch);

Review Comment:
   Sounds reasonable, however I had to ask. How did you understand that it works better after given change?



;08/Jun/23 08:08;githubbot;600","sanpwc commented on code in PR #2142:
URL: https://github.com/apache/ignite-3/pull/2142#discussion_r1222629038


##########
modules/replicator/src/main/java/org/apache/ignite/internal/replicator/ReplicaManager.java:
##########
@@ -387,11 +399,18 @@ private boolean stopReplicaInternal(ReplicationGroupId replicaGrpId) {
         CompletableFuture<Replica> removed = replicas.remove(replicaGrpId);
 
         if (removed != null) {
-            removed.whenComplete((replica, throwable) -> {
-                if (throwable != null) {
-                    replica.shutdown();
-                }
-            });
+            if (!removed.isDone()) {
+                removed.completeExceptionally(new ReplicaStoppingException(

Review Comment:
   I'd still call shutdown just in case. Seems that it should be safe, what do you think?



;08/Jun/23 08:17;githubbot;600","vldpyatkov commented on code in PR #2142:
URL: https://github.com/apache/ignite-3/pull/2142#discussion_r1222907486


##########
modules/raft/src/main/java/org/apache/ignite/raft/jraft/disruptor/StripedDisruptor.java:
##########
@@ -214,7 +214,7 @@ void unsubscribe(NodeId nodeId) {
             assert handler != null : format(""Group of the event is unsupported [nodeId={}, event={}]"", event.nodeId(), event);
 
             //TODO: IGNITE-15568 endOfBatch should be set to true to prevent caching tasks until IGNITE-15568 has fixed.
-            handler.onEvent(event, sequence, true);
+            handler.onEvent(event, sequence, subscribers.size() > 1 ? true : endOfBatch);

Review Comment:
   We don't have a test that will be able to demonstrate that. I assume, that update is not doing worse at least.
   Theoretically, RAFT log may fsync less often in the circumstance when several RAFT commands are executing simultaniously.



;08/Jun/23 11:26;githubbot;600","alievmirza commented on code in PR #2142:
URL: https://github.com/apache/ignite-3/pull/2142#discussion_r1222947503


##########
modules/raft/src/main/java/org/apache/ignite/raft/jraft/disruptor/StripedDisruptor.java:
##########
@@ -214,7 +214,7 @@ void unsubscribe(NodeId nodeId) {
             assert handler != null : format(""Group of the event is unsupported [nodeId={}, event={}]"", event.nodeId(), event);
 
             //TODO: IGNITE-15568 endOfBatch should be set to true to prevent caching tasks until IGNITE-15568 has fixed.
-            handler.onEvent(event, sequence, true);
+            handler.onEvent(event, sequence, subscribers.size() > 1 ? true : endOfBatch);

Review Comment:
   I don't think that this change is reasonable, because we have a plan to port disruptor changes in a upcoming sprint, potentially this fix will live a few weeks 



;08/Jun/23 12:07;githubbot;600","vldpyatkov commented on code in PR #2142:
URL: https://github.com/apache/ignite-3/pull/2142#discussion_r1222963905


##########
modules/raft/src/main/java/org/apache/ignite/raft/jraft/disruptor/StripedDisruptor.java:
##########
@@ -214,7 +214,7 @@ void unsubscribe(NodeId nodeId) {
             assert handler != null : format(""Group of the event is unsupported [nodeId={}, event={}]"", event.nodeId(), event);
 
             //TODO: IGNITE-15568 endOfBatch should be set to true to prevent caching tasks until IGNITE-15568 has fixed.
-            handler.onEvent(event, sequence, true);
+            handler.onEvent(event, sequence, subscribers.size() > 1 ? true : endOfBatch);

Review Comment:
   We will work a little better just now. Today, the change worth nothing for us.



;08/Jun/23 12:22;githubbot;600","vldpyatkov commented on code in PR #2142:
URL: https://github.com/apache/ignite-3/pull/2142#discussion_r1222965710


##########
modules/replicator/src/main/java/org/apache/ignite/internal/replicator/ReplicaManager.java:
##########
@@ -387,11 +399,18 @@ private boolean stopReplicaInternal(ReplicationGroupId replicaGrpId) {
         CompletableFuture<Replica> removed = replicas.remove(replicaGrpId);
 
         if (removed != null) {
-            removed.whenComplete((replica, throwable) -> {
-                if (throwable != null) {
-                    replica.shutdown();
-                }
-            });
+            if (!removed.isDone()) {
+                removed.completeExceptionally(new ReplicaStoppingException(

Review Comment:
   I changed the behavior and add shutdown invocation in any case when the future is not completed with exception.



;08/Jun/23 12:24;githubbot;600","vldpyatkov merged PR #2142:
URL: https://github.com/apache/ignite-3/pull/2142


;08/Jun/23 14:06;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,9600,,,0,9600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jun 08 14:08:21 UTC 2023,,,,,,,,,,"0|z1hy5c:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"08/Jun/23 13:34;alapin;[~v.pyatkov] LGTM from my side.;;;","08/Jun/23 14:08;v.pyatkov;Merged b4bdceb72519710b7e635067569285a172a1b404;;;",,,,
RemoteFragmentExecutionException when inserting more than 30 000 rows into one table,IGNITE-19488,13536443,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,zstan,lunigorn,lunigorn,16/May/23 17:25,30/May/23 12:16,13/Jul/23 09:11,30/May/23 12:16,,,,,,,,,jdbc,sql,,0,ignite-3,,,"h1. Steps to reproduce

Ignite 3 main branch commit 45380a6c802203dab0d72bd1eb9fb202b2a345b0
 # Create table with 5 columns
 # Insert into table rows by batches 1000 rows each batch.
 # Repeat previous step untill exception is thrown.

h1. Expected behaviour

Created more than 30 000 rows.
h1. Actual behaviour

An exception after 29 000 rows are inserted:
{code:java}
Exception while executing query [query=SELECT COUNT(*) FROM rows_capacity_table]. Error message:IGN-CMN-1 TraceId:24c93463-f078-410a-8831-36b5c549a907 IGN-CMN-1 TraceId:24c93463-f078-410a-8831-36b5c549a907 Query remote fragment execution failed: nodeName=TablesAmountCapacityTest_cluster_0, queryId=ecd14026-5366-4ee2-b73a-f38757d3ba4f, fragmentId=1561, originalMessage=IGN-CMN-1 TraceId:24c93463-f078-410a-8831-36b5c549a907
java.sql.SQLException: Exception while executing query [query=SELECT COUNT(*) FROM rows_capacity_table]. Error message:IGN-CMN-1 TraceId:24c93463-f078-410a-8831-36b5c549a907 IGN-CMN-1 TraceId:24c93463-f078-410a-8831-36b5c549a907 Query remote fragment execution failed: nodeName=TablesAmountCapacityTest_cluster_0, queryId=ecd14026-5366-4ee2-b73a-f38757d3ba4f, fragmentId=1561, originalMessage=IGN-CMN-1 TraceId:24c93463-f078-410a-8831-36b5c549a907
	at org.apache.ignite.internal.jdbc.proto.IgniteQueryErrorCode.createJdbcSqlException(IgniteQueryErrorCode.java:57)
	at org.apache.ignite.internal.jdbc.JdbcStatement.execute0(JdbcStatement.java:149)
	at org.apache.ignite.internal.jdbc.JdbcStatement.executeQuery(JdbcStatement.java:108) {code}
Logs are in the attachment.

[^logs.zip]",,lunigorn,xtern,zstan,,,"xtern commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1205722535


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -617,21 +645,27 @@ private static <RowT> CompletableFuture<List<RowT>> handleInsertResults(
             RowHandler<RowT> handler,
             CompletableFuture<List<RowT>>[] futs
     ) {
+        updateStat.set(true);
+
         return CompletableFuture.allOf(futs)
                 .thenApply(response -> {
-                    List<String> conflictRows = new ArrayList<>();
+                    List<String> conflictRows = null;
 
                     for (CompletableFuture<List<RowT>> future : futs) {
                         List<RowT> values = future.join();
 
+                        if (conflictRows == null && values != null && !values.isEmpty()) {
+                            conflictRows = new ArrayList<>(values.size());
+                        }
+
                         if (values != null) {
                             for (RowT row : values) {
                                 conflictRows.add(handler.toString(row));
                             }
                         }
                     }
 
-                    if (!conflictRows.isEmpty()) {
+                    if (conflictRows != null && !conflictRows.isEmpty()) {

Review Comment:
   As I see it, if `conflictRows` is not `null`, it cannot be empty.



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -531,16 +536,17 @@ private ColocationGroup partitionedGroup() {
     }
 
     private class StatisticsImpl implements Statistic {
-        private static final int STATS_CLI_UPDATE_THRESHOLD = 200;
+        private static final int STATS_UPDATE_THRESHOLD = DistributionZoneManager.DEFAULT_PARTITION_COUNT;
 
-        AtomicInteger statReqCnt = new AtomicInteger();
+        private final AtomicLong lastUpd = new AtomicLong();
 
-        private volatile long localRowCnt;
+        private volatile long localRowCnt = 0L;
 
         /** {@inheritDoc} */
         @Override
+        // TODO: need to be refactored https://issues.apache.org/jira/browse/IGNITE-19558
         public Double getRowCount() {
-            if (statReqCnt.getAndIncrement() % STATS_CLI_UPDATE_THRESHOLD == 0) {
+            if (updateStat.get()) {

Review Comment:
   Will this work correctly if node is started with persisted data?



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -617,21 +645,27 @@ private static <RowT> CompletableFuture<List<RowT>> handleInsertResults(
             RowHandler<RowT> handler,
             CompletableFuture<List<RowT>>[] futs
     ) {
+        updateStat.set(true);
+
         return CompletableFuture.allOf(futs)
                 .thenApply(response -> {
-                    List<String> conflictRows = new ArrayList<>();
+                    List<String> conflictRows = null;
 
                     for (CompletableFuture<List<RowT>> future : futs) {
                         List<RowT> values = future.join();
 
+                        if (conflictRows == null && values != null && !values.isEmpty()) {
+                            conflictRows = new ArrayList<>(values.size());
+                        }
+
                         if (values != null) {
                             for (RowT row : values) {
                                 conflictRows.add(handler.toString(row));
                             }
                         }

Review Comment:
   I suggest not repeating the condition `values != null`.
   
   ```suggestion
                           if (values == null || values.isEmpty()) {
                               continue;
                           }
   
                           if (conflictRows == null) {
                               conflictRows = new ArrayList<>(values.size());
                           }
   
                           for (RowT row : values) {
                               conflictRows.add(handler.toString(row));
                           }
   ```



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/rel/IndexScanNode.java:
##########
@@ -173,7 +173,7 @@ private Publisher<RowT> partitionPublisher(PartitionWithTerm partWithTerm, @Null
             }
         } else {
             assert schemaIndex.type() == Type.HASH;
-            assert cond != null && cond.lower() != null : ""Invalid hash index condition."";
+            assert cond != null && (cond.lower() != null || cond.upper() != null) : ""Invalid hash index condition."";

Review Comment:
   Why we need such change?
   We don't use upper bound here and seems this will be equal to 
   ```
   assert cond != null  : ""Invalid hash index condition."";
   ```



;25/May/23 16:15;githubbot;600","zstan commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1205901915


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -617,21 +645,27 @@ private static <RowT> CompletableFuture<List<RowT>> handleInsertResults(
             RowHandler<RowT> handler,
             CompletableFuture<List<RowT>>[] futs
     ) {
+        updateStat.set(true);
+
         return CompletableFuture.allOf(futs)
                 .thenApply(response -> {
-                    List<String> conflictRows = new ArrayList<>();
+                    List<String> conflictRows = null;
 
                     for (CompletableFuture<List<RowT>> future : futs) {
                         List<RowT> values = future.join();
 
+                        if (conflictRows == null && values != null && !values.isEmpty()) {
+                            conflictRows = new ArrayList<>(values.size());
+                        }
+
                         if (values != null) {
                             for (RowT row : values) {
                                 conflictRows.add(handler.toString(row));
                             }
                         }
                     }
 
-                    if (!conflictRows.isEmpty()) {
+                    if (conflictRows != null && !conflictRows.isEmpty()) {

Review Comment:
   got it



;25/May/23 18:59;githubbot;600","zstan commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1205905300


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -531,16 +536,17 @@ private ColocationGroup partitionedGroup() {
     }
 
     private class StatisticsImpl implements Statistic {
-        private static final int STATS_CLI_UPDATE_THRESHOLD = 200;
+        private static final int STATS_UPDATE_THRESHOLD = DistributionZoneManager.DEFAULT_PARTITION_COUNT;
 
-        AtomicInteger statReqCnt = new AtomicInteger();
+        private final AtomicLong lastUpd = new AtomicLong();
 
-        private volatile long localRowCnt;
+        private volatile long localRowCnt = 0L;
 
         /** {@inheritDoc} */
         @Override
+        // TODO: need to be refactored https://issues.apache.org/jira/browse/IGNITE-19558
         public Double getRowCount() {
-            if (statReqCnt.getAndIncrement() % STATS_CLI_UPDATE_THRESHOLD == 0) {
+            if (updateStat.get()) {

Review Comment:
   this will work NOT WORSE than before ) correct fix mention in TODO a little bit upper 
   https://issues.apache.org/jira/browse/IGNITE-19558



;25/May/23 19:03;githubbot;600","korlov42 commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1206561794


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/rule/logical/ExposeIndexRule.java:
##########
@@ -31,6 +31,7 @@
 import org.apache.calcite.util.ImmutableBitSet;
 import org.apache.ignite.internal.sql.engine.rel.logical.IgniteLogicalIndexScan;
 import org.apache.ignite.internal.sql.engine.rel.logical.IgniteLogicalTableScan;
+import org.apache.ignite.internal.sql.engine.schema.IgniteIndex.Type;

Review Comment:
   why do you need this import? 



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/rel/AbstractIndexScan.java:
##########
@@ -111,33 +112,44 @@ public RelNode accept(RexShuttle shuttle) {
         return super.accept(shuttle);
     }
 
-    /**
-     * Get index name.
-     * TODO Documentation https://issues.apache.org/jira/browse/IGNITE-15859
-     */
+    /** Return index name. */
     public String indexName() {
         return idxName;
     }
 
+    /** Index type. */
+    public Type indexType() {
+        return type;
+    }
+
     /** {@inheritDoc} */
     @Override
     public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {
         double rows = table.getRowCount();
 
-        double cost;
+        double cost = 0;
+
+        if (type == Type.HASH) {
+            boolean notExact = (searchBounds() == null)
+                    || (searchBounds().stream().anyMatch(bound -> bound.type() != SearchBounds.Type.EXACT));

Review Comment:
   I think, `SearchBounds.Type.MULTI` type is legit as well



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/rel/AbstractIndexScan.java:
##########
@@ -111,33 +112,44 @@ public RelNode accept(RexShuttle shuttle) {
         return super.accept(shuttle);
     }
 
-    /**
-     * Get index name.
-     * TODO Documentation https://issues.apache.org/jira/browse/IGNITE-15859
-     */
+    /** Return index name. */
     public String indexName() {
         return idxName;
     }
 
+    /** Index type. */
+    public Type indexType() {

Review Comment:
   indexType is not used



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -552,14 +559,36 @@ public Double getRowCount() {
                         continue;
                     }
 
-                    try {
-                        size += part.rowsCount();
-                    } catch (StorageRebalanceException ignore) {
-                        // No-op.
-                    }
+                    long upd = part.lastAppliedIndex();
+
+                    size += upd;

Review Comment:
   I'm not sure what size you are counting here



##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/planner/HashIndexPlannerTest.java:
##########
@@ -88,6 +90,27 @@ public void hashIndexIsNotAppliedForRangeCondition() throws Exception {
         String invalidPlanMsg = ""Invalid plan:\n"" + RelOptUtil.toString(phys);
 
         assertThat(invalidPlanMsg, scan, notNullValue());
+
+        // Can`t use hash index scan with range.
+        String sqlGT = ""SELECT /*+ DISABLE_RULE('LogicalTableScanConverterRule')*/ id FROM test_tbl WHERE val >= 10"";
+
+        IgniteTestUtils.assertThrowsWithCause(() -> physicalPlan(sqlGT, schema), CannotPlanException.class,

Review Comment:
   let's split this test in order to have single test case per method



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -111,6 +114,9 @@ public class IgniteTableImpl extends AbstractTable implements IgniteTable, Updat
 
     private final PartitionExtractor partitionExtractor;
 
+    /** Triggers statistic update. */
+    private static AtomicBoolean updateStat = new AtomicBoolean();

Review Comment:
   don't quite understand why do we need this flag. It only prevents from updating stats before first insert, but why?



;26/May/23 14:10;githubbot;600","zstan commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1206884156


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/rule/logical/ExposeIndexRule.java:
##########
@@ -31,6 +31,7 @@
 import org.apache.calcite.util.ImmutableBitSet;
 import org.apache.ignite.internal.sql.engine.rel.logical.IgniteLogicalIndexScan;
 import org.apache.ignite.internal.sql.engine.rel.logical.IgniteLogicalTableScan;
+import org.apache.ignite.internal.sql.engine.schema.IgniteIndex.Type;

Review Comment:
   got it



;26/May/23 14:36;githubbot;600","zstan commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1206897245


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/rel/AbstractIndexScan.java:
##########
@@ -111,33 +112,44 @@ public RelNode accept(RexShuttle shuttle) {
         return super.accept(shuttle);
     }
 
-    /**
-     * Get index name.
-     * TODO Documentation https://issues.apache.org/jira/browse/IGNITE-15859
-     */
+    /** Return index name. */
     public String indexName() {
         return idxName;
     }
 
+    /** Index type. */
+    public Type indexType() {
+        return type;
+    }
+
     /** {@inheritDoc} */
     @Override
     public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {
         double rows = table.getRowCount();
 
-        double cost;
+        double cost = 0;
+
+        if (type == Type.HASH) {
+            boolean notExact = (searchBounds() == null)
+                    || (searchBounds().stream().anyMatch(bound -> bound.type() != SearchBounds.Type.EXACT));

Review Comment:
   as i can see from java doc : Multiple values or multiple ranges, thus seems this is not applicable at common.



;26/May/23 14:45;githubbot;600","zstan commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1206897245


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/rel/AbstractIndexScan.java:
##########
@@ -111,33 +112,44 @@ public RelNode accept(RexShuttle shuttle) {
         return super.accept(shuttle);
     }
 
-    /**
-     * Get index name.
-     * TODO Documentation https://issues.apache.org/jira/browse/IGNITE-15859
-     */
+    /** Return index name. */
     public String indexName() {
         return idxName;
     }
 
+    /** Index type. */
+    public Type indexType() {
+        return type;
+    }
+
     /** {@inheritDoc} */
     @Override
     public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {
         double rows = table.getRowCount();
 
-        double cost;
+        double cost = 0;
+
+        if (type == Type.HASH) {
+            boolean notExact = (searchBounds() == null)
+                    || (searchBounds().stream().anyMatch(bound -> bound.type() != SearchBounds.Type.EXACT));

Review Comment:
   as i can see from java doc : **Multiple values or multiple ranges**, thus seems this is not applicable at common.



;26/May/23 14:45;githubbot;600","zstan commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1206901654


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -111,6 +114,9 @@ public class IgniteTableImpl extends AbstractTable implements IgniteTable, Updat
 
     private final PartitionExtractor partitionExtractor;
 
+    /** Triggers statistic update. */
+    private static AtomicBoolean updateStat = new AtomicBoolean();

Review Comment:
   It updates in IgniteTableImpl#handleInsertResults



;26/May/23 14:48;githubbot;600","zstan commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1206918462


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -552,14 +559,36 @@ public Double getRowCount() {
                         continue;
                     }
 
-                    try {
-                        size += part.rowsCount();
-                    } catch (StorageRebalanceException ignore) {
-                        // No-op.
-                    }
+                    long upd = part.lastAppliedIndex();
+
+                    size += upd;

Review Comment:
   I use it like lightweight trigger, of course this update incremented not only on data mutation but also in raft machinery SE people shows me it.



;26/May/23 15:00;githubbot;600","korlov42 commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1208956201


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/rel/AbstractIndexScan.java:
##########
@@ -111,33 +112,44 @@ public RelNode accept(RexShuttle shuttle) {
         return super.accept(shuttle);
     }
 
-    /**
-     * Get index name.
-     * TODO Documentation https://issues.apache.org/jira/browse/IGNITE-15859
-     */
+    /** Return index name. */
     public String indexName() {
         return idxName;
     }
 
+    /** Index type. */
+    public Type indexType() {
+        return type;
+    }
+
     /** {@inheritDoc} */
     @Override
     public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {
         double rows = table.getRowCount();
 
-        double cost;
+        double cost = 0;
+
+        if (type == Type.HASH) {
+            boolean notExact = (searchBounds() == null)
+                    || (searchBounds().stream().anyMatch(bound -> bound.type() != SearchBounds.Type.EXACT));

Review Comment:
   what is wrong with multiple values?



;29/May/23 06:23;githubbot;600","korlov42 commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1208966656


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -111,6 +114,9 @@ public class IgniteTableImpl extends AbstractTable implements IgniteTable, Updat
 
     private final PartitionExtractor partitionExtractor;
 
+    /** Triggers statistic update. */
+    private static AtomicBoolean updateStat = new AtomicBoolean();

Review Comment:
   yes, I see this. But still... You have _static_ field that initialised to `false` (default value for AtomicBoolean). You change this field to `true` once the table has processed the very first insert from SQL (but not from KV). 
   
   After commit `e9b8fbf` this has even less sense, because you initialised this field to `true`, thus this field literally does nothing.



;29/May/23 06:32;githubbot;600","korlov42 commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1208966656


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -111,6 +114,9 @@ public class IgniteTableImpl extends AbstractTable implements IgniteTable, Updat
 
     private final PartitionExtractor partitionExtractor;
 
+    /** Triggers statistic update. */
+    private static AtomicBoolean updateStat = new AtomicBoolean();

Review Comment:
   yes, I see this. But still... You have _static_ field that initialised to `false` (default value for AtomicBoolean). You change this field to `true` once the table (not particular table, but random table since the field is static) has processed the very first insert from SQL (but not from KV). 
   
   After commit `e9b8fbf` this has even less sense, because you initialised this field to `true`, thus this field literally does nothing.



;29/May/23 06:33;githubbot;600","korlov42 commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1208968606


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -552,14 +559,36 @@ public Double getRowCount() {
                         continue;
                     }
 
-                    try {
-                        size += part.rowsCount();
-                    } catch (StorageRebalanceException ignore) {
-                        // No-op.
-                    }
+                    long upd = part.lastAppliedIndex();
+
+                    size += upd;

Review Comment:
   why do you use `size` as a trigger? 



;29/May/23 06:35;githubbot;600","zstan commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1208973712


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -552,14 +559,36 @@ public Double getRowCount() {
                         continue;
                     }
 
-                    try {
-                        size += part.rowsCount();
-                    } catch (StorageRebalanceException ignore) {
-                        // No-op.
-                    }
+                    long upd = part.lastAppliedIndex();
+
+                    size += upd;

Review Comment:
   lastAppliedIndex - means last update revision of raft group who service current partition.



;29/May/23 06:43;githubbot;600","korlov42 commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1208982712


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -552,14 +559,36 @@ public Double getRowCount() {
                         continue;
                     }
 
-                    try {
-                        size += part.rowsCount();
-                    } catch (StorageRebalanceException ignore) {
-                        // No-op.
-                    }
+                    long upd = part.lastAppliedIndex();
+
+                    size += upd;

Review Comment:
   I understand the idea behind summing up applied indexes, but I still don't understand why should we reuse `size` variable (which supposed to be size of the table) for this



;29/May/23 06:56;githubbot;600","zstan commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1209003957


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/planner/HashIndexPlannerTest.java:
##########
@@ -88,6 +90,27 @@ public void hashIndexIsNotAppliedForRangeCondition() throws Exception {
         String invalidPlanMsg = ""Invalid plan:\n"" + RelOptUtil.toString(phys);
 
         assertThat(invalidPlanMsg, scan, notNullValue());
+
+        // Can`t use hash index scan with range.
+        String sqlGT = ""SELECT /*+ DISABLE_RULE('LogicalTableScanConverterRule')*/ id FROM test_tbl WHERE val >= 10"";
+
+        IgniteTestUtils.assertThrowsWithCause(() -> physicalPlan(sqlGT, schema), CannotPlanException.class,

Review Comment:
   done



;29/May/23 07:23;githubbot;600","zstan commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1209141169


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -111,6 +114,9 @@ public class IgniteTableImpl extends AbstractTable implements IgniteTable, Updat
 
     private final PartitionExtractor partitionExtractor;
 
+    /** Triggers statistic update. */
+    private static AtomicBoolean updateStat = new AtomicBoolean();

Review Comment:
   got it, fixed



;29/May/23 09:51;githubbot;600","zstan commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1209203432


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/rel/AbstractIndexScan.java:
##########
@@ -111,33 +112,44 @@ public RelNode accept(RexShuttle shuttle) {
         return super.accept(shuttle);
     }
 
-    /**
-     * Get index name.
-     * TODO Documentation https://issues.apache.org/jira/browse/IGNITE-15859
-     */
+    /** Return index name. */
     public String indexName() {
         return idxName;
     }
 
+    /** Index type. */
+    public Type indexType() {
+        return type;
+    }
+
     /** {@inheritDoc} */
     @Override
     public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {
         double rows = table.getRowCount();
 
-        double cost;
+        double cost = 0;
+
+        if (type == Type.HASH) {
+            boolean notExact = (searchBounds() == null)
+                    || (searchBounds().stream().anyMatch(bound -> bound.type() != SearchBounds.Type.EXACT));

Review Comment:
   i fear: **multiple ranges**



;29/May/23 11:08;githubbot;600","zstan commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1209204686


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/rel/AbstractIndexScan.java:
##########
@@ -111,33 +112,44 @@ public RelNode accept(RexShuttle shuttle) {
         return super.accept(shuttle);
     }
 
-    /**
-     * Get index name.
-     * TODO Documentation https://issues.apache.org/jira/browse/IGNITE-15859
-     */
+    /** Return index name. */
     public String indexName() {
         return idxName;
     }
 
+    /** Index type. */
+    public Type indexType() {
+        return type;
+    }
+
     /** {@inheritDoc} */
     @Override
     public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {
         double rows = table.getRowCount();
 
-        double cost;
+        double cost = 0;
+
+        if (type == Type.HASH) {
+            boolean notExact = (searchBounds() == null)
+                    || (searchBounds().stream().anyMatch(bound -> bound.type() != SearchBounds.Type.EXACT));

Review Comment:
   seems we need somehow discern multiple values from multiple ranges



;29/May/23 11:10;githubbot;600","korlov42 commented on code in PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#discussion_r1209939749


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -524,35 +526,56 @@ private ColocationGroup partitionedGroup() {
     }
 
     private class StatisticsImpl implements Statistic {
-        private static final int STATS_CLI_UPDATE_THRESHOLD = 200;
+        private final int updateThreshold = DistributionZoneManager.DEFAULT_PARTITION_COUNT;
 
-        AtomicInteger statReqCnt = new AtomicInteger();
+        private final AtomicLong lastUpd = new AtomicLong();
 
-        private volatile long localRowCnt;
+        private volatile long localRowCnt = 0L;
 
         /** {@inheritDoc} */
         @Override
+        // TODO: need to be refactored https://issues.apache.org/jira/browse/IGNITE-19558
         public Double getRowCount() {
-            if (statReqCnt.getAndIncrement() % STATS_CLI_UPDATE_THRESHOLD == 0) {
-                int parts = table.storage().distributionZoneConfiguration().partitions().value();
+            int parts = table.storage().distributionZoneConfiguration().partitions().value();
 
-                long size = 0L;
+            long partitionsRevisionCounter = 0L;
 
-                for (int p = 0; p < parts; ++p) {
-                    @Nullable MvPartitionStorage part = table.storage().getMvPartition(p);
+            for (int p = 0; p < parts; ++p) {
+                @Nullable MvPartitionStorage part = table.storage().getMvPartition(p);
 
-                    if (part == null) {
-                        continue;
-                    }
+                if (part == null) {
+                    continue;
+                }
+
+                long upd = part.lastAppliedIndex();
+
+                partitionsRevisionCounter += upd;
+            }
+
+            long prev = lastUpd.get();
+
+            if (partitionsRevisionCounter - lastUpd.get() > updateThreshold) {

Review Comment:
   ```suggestion
               if (partitionsRevisionCounter - prev > updateThreshold) {
   ```



;30/May/23 08:44;githubbot;600","zstan commented on PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101#issuecomment-1568234105

   @korlov42 plz check last fixes ?


;30/May/23 11:04;githubbot;600","zstan merged PR #2101:
URL: https://github.com/apache/ignite-3/pull/2101


;30/May/23 12:15;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,0,13200,,,0,13200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/May/23 17:23;lunigorn;logs.zip;https://issues.apache.org/jira/secure/attachment/13058271/logs.zip","18/May/23 06:59;lunigorn;logs_with_ignored_erorr.zip;https://issues.apache.org/jira/secure/attachment/13058313/logs_with_ignored_erorr.zip",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed May 24 10:22:47 UTC 2023,,,,,,,,,,"0|z1hxmw:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"16/May/23 18:03;xtern;Exception from server log
{noformat}
Caused by: java.lang.NullPointerException
	at org.apache.ignite.internal.sql.engine.exec.rel.IndexScanNode.partitionPublisher(IndexScanNode.java:178)
	at org.apache.ignite.internal.sql.engine.exec.rel.IndexScanNode.lambda$indexPublisher$1(IndexScanNode.java:124)
	at org.apache.ignite.internal.util.TransformingIterator.next(TransformingIterator.java:50)
	at org.apache.ignite.internal.util.subscription.ConcatenatedPublisher$ConcatenatedSubscriber.drain(ConcatenatedPublisher.java:137)
	at org.apache.ignite.internal.util.subscription.ConcatenatedPublisher.subscribe(ConcatenatedPublisher.java:53)
	at org.apache.ignite.internal.sql.engine.exec.rel.StorageScanNode.requestNextBatch(StorageScanNode.java:238)
	at org.apache.ignite.internal.sql.engine.exec.rel.StorageScanNode.push(StorageScanNode.java:210)
	at org.apache.ignite.internal.sql.engine.exec.ExecutionContext.lambda$execute$0(ExecutionContext.java:315)
{noformat}
;;;","17/May/23 10:27;xtern;[~lunigorn], please describe the table you created in more detail, and even better, attach a complete reproducer, which you used to catch this issue.;;;","17/May/23 14:02;lunigorn;[~xtern] there is the code to reproduce the error https://github.com/Lunigorn/ignite3test/tree/rows-capacity-test;;;","18/May/23 07:00;lunigorn;If errors in `SELECT count( * )` are ignored then it is possible to insert at least 1 mln rows into one table (test didn't try to insert more). Logs are in attachment. But the error happens pretty frequently.
 [^logs_with_ignored_erorr.zip];;;","19/May/23 10:58;xtern;[~lunigorn],
I checked the latest server logs you provided (logs_with_ignored_erorr.zip), there is only the ""Queue full"" exception (and no NPE exception). That's another issue, and it's already fixed in IGNITE-19278, I think you should take a new version, so that this error does not bother you when testing.;;;","24/May/23 10:22;zstan;This case can`t be reproduced on current main branch, but there is present other (erroneous plan) issue, that fixed in current PR.;;;"
Incorrect schema name in sys view documentation.,IGNITE-19473,13536012,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,igusev,zstan,zstan,12/May/23 17:41,25/May/23 13:48,13/Jul/23 09:11,25/May/23 13:48,2.15,,,,,,,2.16,documentation,,,0,,,,"Schema [1] need to be changed:

_.setSchema(""IGNITE"")_ need to be changed into: _.setSchema(""SYS"")_

 

[1] [https://ignite.apache.org/docs/latest/monitoring-metrics/system-views]

 ",,zstan,,,,,"sk0x50 merged PR #10736:
URL: https://github.com/apache/ignite/pull/10736


;25/May/23 13:48;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Fri May 12 17:43:15 UTC 2023,,,,,,,,,,"0|z1hv5k:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"12/May/23 17:43;zstan;[~alex_pl]  [~igusev]  guys can you help with documentation change plz ? thanks !;;;",,,,,
Non-REPL connect command should only allow URLs,IGNITE-19446,13535648,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,vpakhnushev,vpakhnushev,10/May/23 14:05,10/May/23 15:44,13/Jul/23 09:11,10/May/23 15:44,,,,,,,,3.0.0-beta2,cli,,,0,ignite-3,,,"Running {{ignite3 connect}} prints 
{code:bash}
No TypeConverter registered for org.apache.ignite.internal.cli.commands.node.NodeNameOrUrl of field org.apache.ignite.internal.cli.commands.node.NodeNameOrUrl org.apache.ignite.internal.cli.commands.connect.ConnectCommand.nodeNameOrUrl
{code}
Node name registry is not available in non-REPL mode so the connect command should only allow URL parameter.",,aleksandr.pakhomov,vpakhnushev,,,,"valepakh opened a new pull request, #2049:
URL: https://github.com/apache/ignite-3/pull/2049

   https://issues.apache.org/jira/browse/IGNITE-19446


;10/May/23 14:15;githubbot;600","PakhomovAlexander merged PR #2049:
URL: https://github.com/apache/ignite-3/pull/2049


;10/May/23 15:43;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed May 10 15:44:28 UTC 2023,,,,,,,,,,"0|z1hswo:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"10/May/23 15:44;aleksandr.pakhomov;Merged into main: cfb398624213ea0e7041868cf08454d3a7b67fda;;;",,,,,
NPE during transaction recovery,IGNITE-19445,13535627,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,av,NSAmelchev,NSAmelchev,10/May/23 11:35,22/May/23 10:56,13/Jul/23 09:11,22/May/23 10:56,,,,,,,,2.16,,,,0,ise,,,"The transaction can be enlisted during recovery(two different threads). The {{GridIntList}} used in the {{IgniteTxStateImpl}} is not thread safe - it produces NPE:

{noformat}
[2023-05-10T12:23:32,438][ERROR][sys-#129%dht.TxRecoveryStoreEnabledTest1%][IgniteTestResources] Critical system error detected. Will be handled accordingly to configured handler [hnd=StopNodeFailureHandler [super=AbstractFailureHandler [ignoredFailureTypes=UnmodifiableSet [SYSTEM_WORKER_BLOCKED, SYSTEM_CRITICAL_OPERATION_TIMEOUT]]], failureCtx=FailureContext [type=CRITICAL_ERROR, err=class o.a.i.IgniteCheckedException: null]]
 org.apache.ignite.IgniteCheckedException: null
	at org.apache.ignite.internal.util.IgniteUtils.cast(IgniteUtils.java:7929) ~[classes/:?]
	at org.apache.ignite.internal.processors.closure.GridClosureProcessor$1.body(GridClosureProcessor.java:659) [classes/:?]
	at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:125) [classes/:?]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_352]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_352]
	at java.lang.Thread.run(Thread.java:750) [?:1.8.0_352]
Caused by: java.lang.NullPointerException
	at org.apache.ignite.internal.processors.cache.transactions.IgniteTxStateImpl.storeWriteThrough(IgniteTxStateImpl.java:342) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.transactions.IgniteTxAdapter.storeWriteThrough(IgniteTxAdapter.java:517) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.transactions.IgniteTxManager$TxRecoveryInitRunnable.run(IgniteTxManager.java:3341) ~[classes/:?]
	at org.apache.ignite.internal.util.IgniteUtils.wrapThreadLoader(IgniteUtils.java:7487) ~[classes/:?]
	at org.apache.ignite.internal.processors.closure.GridClosureProcessor$1.body(GridClosureProcessor.java:649) ~[classes/:?]
	... 4 more
{noformat}
",,av,ignitetcbot,NSAmelchev,,,"anton-vinogradov merged PR #10728:
URL: https://github.com/apache/ignite/pull/10728


;22/May/23 10:54;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,IGNITE-19529,,,,,,,,,"11/May/23 10:58;NSAmelchev;reproducer-19445.patch;https://issues.apache.org/jira/secure/attachment/13058004/reproducer-19445.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Mon May 22 10:56:03 UTC 2023,,,,,,,,,,"0|z1hss0:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"15/May/23 18:57;av;Checked that 2 threads may work with the same GridIntList simultaneously, and it's true.
Typical case:
{noformat}
""sys-stripe-0-#68%dht.TxTest1%@5510"" prio=5 tid=0x56 nid=NA sleeping
  java.lang.Thread.State: TIMED_WAITING
	  at org.apache.ignite.internal.util.GridIntList.add(GridIntList.java:189) ==============> ADDITION!
	  at org.apache.ignite.internal.processors.cache.transactions.IgniteTxStateImpl.addActiveCache(IgniteTxStateImpl.java:260)
	  at org.apache.ignite.internal.processors.cache.transactions.IgniteTxLocalAdapter.addActiveCache(IgniteTxLocalAdapter.java:1365)
	  at org.apache.ignite.internal.processors.cache.distributed.dht.GridDhtTxLocalAdapter.addEntry(GridDhtTxLocalAdapter.java:500)
	  at org.apache.ignite.internal.processors.cache.distributed.dht.GridDhtTxLocal.prepareAsync(GridDhtTxLocal.java:389)
	  at org.apache.ignite.internal.processors.cache.transactions.IgniteTxHandler.prepareNearTx(IgniteTxHandler.java:652)
	  at org.apache.ignite.internal.processors.cache.transactions.IgniteTxHandler.prepareNearTx(IgniteTxHandler.java:449)
	  at org.apache.ignite.internal.processors.cache.transactions.IgniteTxHandler.processNearTxPrepareRequest0(IgniteTxHandler.java:203)
	  at org.apache.ignite.internal.processors.cache.transactions.IgniteTxHandler.processNearTxPrepareRequest(IgniteTxHandler.java:177)
	  at org.apache.ignite.internal.processors.cache.transactions.IgniteTxHandler.access$000(IgniteTxHandler.java:137)
	  at org.apache.ignite.internal.processors.cache.transactions.IgniteTxHandler$1.apply(IgniteTxHandler.java:225)
	  at org.apache.ignite.internal.processors.cache.transactions.IgniteTxHandler$1.apply(IgniteTxHandler.java:223)
	  at org.apache.ignite.internal.processors.cache.GridCacheIoManager.processMessage(GridCacheIoManager.java:1164)
	  at org.apache.ignite.internal.processors.cache.GridCacheIoManager.onMessage0(GridCacheIoManager.java:605)
	  at org.apache.ignite.internal.processors.cache.GridCacheIoManager.handleMessage(GridCacheIoManager.java:406)
	  at org.apache.ignite.internal.processors.cache.GridCacheIoManager.handleMessage(GridCacheIoManager.java:324)
	  at org.apache.ignite.internal.processors.cache.GridCacheIoManager.access$100(GridCacheIoManager.java:112)
	  at org.apache.ignite.internal.processors.cache.GridCacheIoManager$1.onMessage(GridCacheIoManager.java:314)
	  at org.apache.ignite.internal.managers.communication.GridIoManager.invokeListener(GridIoManager.java:1907)
	  at org.apache.ignite.internal.managers.communication.GridIoManager.processRegularMessage0(GridIoManager.java:1528)
	  at org.apache.ignite.internal.managers.communication.GridIoManager.access$5300(GridIoManager.java:243)
	  at org.apache.ignite.internal.managers.communication.GridIoManager$9.execute(GridIoManager.java:1421)
	  at org.apache.ignite.internal.managers.communication.TraceRunnable.run(TraceRunnable.java:55)
	  at org.apache.ignite.internal.util.StripedExecutor$Stripe.body(StripedExecutor.java:637)
	  at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:125)
	  at java.lang.Thread.run(Thread.java:750)


""sys-#131%dht.TxTest1%@5876"" prio=5 tid=0x96 nid=NA runnable
  java.lang.Thread.State: RUNNABLE
	  at org.apache.ignite.internal.util.GridIntList.get(GridIntList.java:277) ==============> GET!
	  at org.apache.ignite.internal.processors.cache.transactions.IgniteTxStateImpl.storeWriteThrough(IgniteTxStateImpl.java:339)
	  at org.apache.ignite.internal.processors.cache.transactions.IgniteTxAdapter.storeWriteThrough(IgniteTxAdapter.java:517)
	  at org.apache.ignite.internal.processors.cache.transactions.IgniteTxManager$TxRecoveryInitRunnable.run(IgniteTxManager.java:3340)
	  at org.apache.ignite.internal.util.IgniteUtils.wrapThreadLoader(IgniteUtils.java:7487)
	  at org.apache.ignite.internal.processors.closure.GridClosureProcessor$1.body(GridClosureProcessor.java:649)
	  at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:125)
	  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	  at java.lang.Thread.run(Thread.java:750)

{noformat};;;","19/May/23 12:00;av;Ad-hoc fix here.

Proper fix is expected at  !https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype|width=16,height=16!  IGNITE-19529;;;","21/May/23 16:00;ignitetcbot;{panel:title=Branch: [pull/10728/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10728/head] Base: [master] : No new tests found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7181392&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","22/May/23 10:56;av;Merged to the master.

[~NSAmelchev], thanks for the reproducer.

[~ivandasch] thanks for the review.;;;",,
Excess size of serialized lease ,IGNITE-19444,13535600,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Denis Chudov,Denis Chudov,Denis Chudov,10/May/23 07:43,18/May/23 08:45,13/Jul/23 09:11,12/May/23 13:14,,,,,,,,3.0.0-beta2,,,,0,iep-101,ignite-3,,"*Motivation*

The size of serialized lease along with it's key is close to 1 kb, in spite of that the lease consists of cluster node, two timestamps and couple of booleans. It is important because there are plenty of leases that are saved to meta storage every few seconds. ClusterNode should be replaced with node name, and algorithm of serialization should be changed in order to optimize size, in general, the size of serialized lease can be a several dozens of bytes.

Currently this leads to degradation during the execution of integration tests, the time of raft calls for meta storage group raises and starts to time out after some time, so multiple tests are failing after enabling PlacementDriverManager in IgniteImpl:
{code:java}
2023-05-11 17:20:18:946 +0300 [WARNING][CompletableFutureDelayScheduler][RaftGroupServiceImpl] Recoverable error during the request type=ActionRequestImpl occurred (will be retried on the randomly selected node): 
java.util.concurrent.CompletionException: java.util.concurrent.TimeoutException
    at java.base/java.util.concurrent.CompletableFuture.encodeRelay(CompletableFuture.java:367)
    at java.base/java.util.concurrent.CompletableFuture.completeRelay(CompletableFuture.java:376)
    at java.base/java.util.concurrent.CompletableFuture$UniRelay.tryFire(CompletableFuture.java:1093)
    at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
    at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2159)
    at java.base/java.util.concurrent.CompletableFuture$Timeout.run(CompletableFuture.java:2871)
    at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
    at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
    at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
    at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
    at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
    at java.base/java.lang.Thread.run(Thread.java:830)
Caused by: java.util.concurrent.TimeoutException
    ... 7 more {code}
It should be fixed for integrating the placement driver into Ignite.

*Definition of done*

The size of serialized lease is significantly reduced.",,Denis Chudov,v.pyatkov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-18990,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-18524,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri May 12 13:14:38 UTC 2023,,,,,,,,,,"0|z1hsm0:",9223372036854775807,,,v.pyatkov,,,,,,,,,,,,,,,,,,"12/May/23 13:14;v.pyatkov;LGTM
Merged 9f4f78721029e21194ed469e8764d5f2ef67d204;;;",,,,,
Empty data nodes shouldn't be propagated to pending assignments  after filtering ,IGNITE-19443,13535521,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,maliev,maliev,maliev,09/May/23 12:40,18/May/23 20:13,13/Jul/23 09:11,18/May/23 20:13,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"*Motivation:*
After https://issues.apache.org/jira/browse/IGNITE-18955 is implemented, it is possible, that data nodes will be empty according to provided filter. Such data nodes should not be propagated to pending assignments (meaning that new rebalance should not be triggered)

*Definition of done:*
* We have two places, where such propagation can be done, one is a reaction on replica factor hanging, another one is when data nodes was changed. Both places must skip pending key propagation if data nodes become empty after filtering.
* Corresponding tests for both scenarios must be provided",,alapin,maliev,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-18528,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu May 18 20:13:30 UTC 2023,,,,,,,,,,"0|z1hs4g:",9223372036854775807,,,alapin,,,,,,,,,,,,,,,,,,"18/May/23 20:13;alapin;[~maliev] LGTM, thanks!;;;",,,,,
AssertionError in RemoveWriteOnGcInvokeClosure during insertion,IGNITE-19439,13535468,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ibessonov,korlov,korlov,09/May/23 06:32,10/May/23 15:13,13/Jul/23 09:11,10/May/23 15:13,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"I run a test that in an endless loop inserts 10k rows , clears the table, and starts over, but it failed on 4th iteration with AssertionError.

The test is as follow:
{code:java}
// org.apache.ignite.internal.sql.engine.ItDmlTest

private static final String STRING_PAYLOAD = IgniteTestUtils.randomString(new Random(), 32);

@Test
public void test() throws SQLException {
    int TABLE_SIZE = 10_000;
    sql(""CREATE TABLE t (id INT PRIMARY KEY, name VARCHAR, surname VARCHAR, age TINYINT)"");

    int iteration = 1;
    do {
        System.out.println(""Iteration "" + (iteration++) + "" started"");
        long before = System.currentTimeMillis();
        for (int i = 1; i <= TABLE_SIZE; i++) {
            sql(""INSERT INTO t VALUES (?, ?, ?, ?)"", i, STRING_PAYLOAD, STRING_PAYLOAD, (byte) i);

            if (i % 10 == 0) {
                long after = System.currentTimeMillis();
                System.out.println(i + "" rows inserted. dT="" + Duration.ofMillis(after - before));

                before = after;
            }
        }

        sql(""DELETE FROM t"");
    } while (true);
} {code}
The assertion is:
{code:java}
023-05-08 20:17:51:016 +0300 [WARNING][%idt_n_0%JRaft-Request-Processor-0][ReplicaManager] Failed to process replica request [request=ReadWriteMultiRowReplicaRequestImpl [binaryRows=ArrayList [org.apache.ignite.internal.schema.row.Row@2b6ae605], commitPartitionId=f6b9512f-b735-446e-85a3-d6b8636c847c_part_18, groupId=f6b9512f-b735-446e-85a3-d6b8636c847c_part_1, requestType=RW_INSERT_ALL, term=1, timestampLong=110334199137239040, transactionId=0187fc5e-9a26-0000-0000-000063a26a19]]
java.util.concurrent.CompletionException: org.apache.ignite.internal.storage.StorageException: IGN-STORAGE-1 TraceId:c48307b5-59a0-4895-a79d-63153a9d47c6 Error removing row version from version chain on garbage collection: [rowId=RowId [partitionId=1, uuid=ca451c56-ea47-422e-b228-67c093ae1a10], rowTimestamp=HybridTimestamp [time=110334012513058818], table=T, partitionId=1]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:314)
	at java.base/java.util.concurrent.CompletableFuture.uniComposeStage(CompletableFuture.java:1113)
	at java.base/java.util.concurrent.CompletableFuture.thenCompose(CompletableFuture.java:2235)
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$processMultiEntryAction$75(PartitionReplicaListener.java:1487)
	at java.base/java.util.concurrent.CompletableFuture.uniComposeStage(CompletableFuture.java:1106)
	at java.base/java.util.concurrent.CompletableFuture.thenCompose(CompletableFuture.java:2235)
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.processMultiEntryAction(PartitionReplicaListener.java:1445)
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$processRequest$2(PartitionReplicaListener.java:285)
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.appendTxCommand(PartitionReplicaListener.java:1197)
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.processRequest(PartitionReplicaListener.java:285)
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$invoke$0(PartitionReplicaListener.java:274)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1072)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
	at org.apache.ignite.internal.raft.RaftGroupServiceImpl.lambda$sendWithRetry$39(RaftGroupServiceImpl.java:538)
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859)
	at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:837)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
	at org.apache.ignite.network.DefaultMessagingService.onInvokeResponse(DefaultMessagingService.java:371)
	at org.apache.ignite.network.DefaultMessagingService.send0(DefaultMessagingService.java:194)
	at org.apache.ignite.network.DefaultMessagingService.respond(DefaultMessagingService.java:137)
	at org.apache.ignite.network.MessagingService.respond(MessagingService.java:89)
	at org.apache.ignite.raft.jraft.rpc.impl.IgniteRpcServer$NetworkRpcContext.sendResponse(IgniteRpcServer.java:233)
	at org.apache.ignite.raft.jraft.rpc.RpcRequestProcessor.handleRequest(RpcRequestProcessor.java:52)
	at org.apache.ignite.raft.jraft.rpc.RpcRequestProcessor.handleRequest(RpcRequestProcessor.java:29)
	at org.apache.ignite.raft.jraft.rpc.impl.IgniteRpcServer$RpcMessageHandler.lambda$onReceived$0(IgniteRpcServer.java:192)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: org.apache.ignite.internal.storage.StorageException: IGN-STORAGE-1 TraceId:c48307b5-59a0-4895-a79d-63153a9d47c6 Error removing row version from version chain on garbage collection: [rowId=RowId [partitionId=1, uuid=ca451c56-ea47-422e-b228-67c093ae1a10], rowTimestamp=HybridTimestamp [time=110334012513058818], table=T, partitionId=1]
	at org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.removeWriteOnGc(AbstractPageMemoryMvPartitionStorage.java:968)
	at org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.vacuum(AbstractPageMemoryMvPartitionStorage.java:952)
	at org.apache.ignite.internal.storage.MvPartitionStorage.lambda$pollForVacuum$0(MvPartitionStorage.java:292)
	at org.apache.ignite.internal.storage.pagememory.mv.PersistentPageMemoryMvPartitionStorage.runConsistently(PersistentPageMemoryMvPartitionStorage.java:143)
	at org.apache.ignite.internal.storage.MvPartitionStorage.pollForVacuum(MvPartitionStorage.java:282)
	at org.apache.ignite.internal.table.distributed.raft.snapshot.outgoing.SnapshotAwarePartitionDataStorage.pollForVacuum(SnapshotAwarePartitionDataStorage.java:141)
	at org.apache.ignite.internal.table.distributed.StorageUpdateHandler.internalVacuum(StorageUpdateHandler.java:345)
	at org.apache.ignite.internal.table.distributed.StorageUpdateHandler.lambda$vacuumBatch$4(StorageUpdateHandler.java:332)
	at org.apache.ignite.internal.storage.pagememory.mv.PersistentPageMemoryMvPartitionStorage.lambda$runConsistently$0(PersistentPageMemoryMvPartitionStorage.java:155)
	at org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.busy(AbstractPageMemoryMvPartitionStorage.java:774)
	at org.apache.ignite.internal.storage.pagememory.mv.PersistentPageMemoryMvPartitionStorage.runConsistently(PersistentPageMemoryMvPartitionStorage.java:145)
	at org.apache.ignite.internal.table.distributed.raft.snapshot.outgoing.SnapshotAwarePartitionDataStorage.runConsistently(SnapshotAwarePartitionDataStorage.java:66)
	at org.apache.ignite.internal.table.distributed.StorageUpdateHandler.vacuumBatch(StorageUpdateHandler.java:332)
	at org.apache.ignite.internal.table.distributed.StorageUpdateHandler.executeBatchGc(StorageUpdateHandler.java:202)
	at org.apache.ignite.internal.table.distributed.StorageUpdateHandler.handleUpdateAll(StorageUpdateHandler.java:192)
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.applyUpdateAllCommand(PartitionReplicaListener.java:1600)
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$processMultiEntryAction$72(PartitionReplicaListener.java:1487)
	at java.base/java.util.concurrent.CompletableFuture.uniComposeStage(CompletableFuture.java:1106)
	... 28 more
Caused by: org.apache.ignite.internal.pagememory.tree.CorruptedTreeException: IGN-CMN-65535 TraceId:0f815e82-c0df-4f6e-8784-be38e9ed94cc B+Tree is corrupted [groupId=1, pageIds=[562954248388665], groupName=T, msg=Runtime failure on search row: org.apache.ignite.internal.storage.pagememory.mv.VersionChainKey@13e0d6a6]
	at org.apache.ignite.internal.pagememory.tree.BplusTree.corruptedTreeException(BplusTree.java:6724)
	at org.apache.ignite.internal.pagememory.tree.BplusTree.invoke(BplusTree.java:2135)
	at org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.removeWriteOnGc(AbstractPageMemoryMvPartitionStorage.java:961)
	... 45 more
Caused by: java.lang.AssertionError: rowId=RowId [partitionId=1, uuid=ca451c56-ea47-422e-b228-67c093ae1a10], storage=table=T, partitionId=1
	at org.apache.ignite.internal.storage.pagememory.mv.RemoveWriteOnGcInvokeClosure.call(RemoveWriteOnGcInvokeClosure.java:70)
	at org.apache.ignite.internal.storage.pagememory.mv.RemoveWriteOnGcInvokeClosure.call(RemoveWriteOnGcInvokeClosure.java:42)
	at org.apache.ignite.internal.pagememory.tree.BplusTree$Invoke.invokeClosure(BplusTree.java:4298)
	at org.apache.ignite.internal.pagememory.tree.BplusTree.invokeDown(BplusTree.java:2209)
	at org.apache.ignite.internal.pagememory.tree.BplusTree.invokeDown(BplusTree.java:2191)
	at org.apache.ignite.internal.pagememory.tree.BplusTree.invoke(BplusTree.java:2109)
	... 46 more
 {code}
Full log is attached below. [^logs.txt]",,korlov,ktkalenko@gridgain.com,,,,"ibessonov opened a new pull request, #2050:
URL: https://github.com/apache/ignite-3/pull/2050

   https://issues.apache.org/jira/browse/IGNITE-19439


;10/May/23 14:29;githubbot;600","ibessonov closed pull request #2050: IGNITE-19439 Fixed bug in VersionChainIo that lead to tree corruption
URL: https://github.com/apache/ignite-3/pull/2050


;10/May/23 14:35;githubbot;600","ibessonov opened a new pull request, #2054:
URL: https://github.com/apache/ignite-3/pull/2054

   https://issues.apache.org/jira/browse/IGNITE-19439


;10/May/23 14:42;githubbot;600","ibessonov commented on PR #2050:
URL: https://github.com/apache/ignite-3/pull/2050#issuecomment-1542330869

   https://github.com/apache/ignite-3/pull/2054


;10/May/23 14:43;githubbot;600","ibessonov merged PR #2054:
URL: https://github.com/apache/ignite-3/pull/2054


;10/May/23 15:13;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"09/May/23 06:32;korlov;logs.txt;https://issues.apache.org/jira/secure/attachment/13057921/logs.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed May 10 14:48:14 UTC 2023,,,,,,,,,,"0|z1hrso:",9223372036854775807,,,ktkalenko@gridgain.com,,,,,,,,,,,,,,,,,,"10/May/23 14:48;ktkalenko@gridgain.com;Looks good.;;;",,,,,
Tests in PartitionReplicaListenerTest are not independent,IGNITE-19432,13535185,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,rpuch,rpuch,rpuch,05/May/23 14:23,09/May/23 12:24,13/Jul/23 09:11,08/May/23 07:05,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"If test methods execution order is changed, the tests start falling (for instance, this happens if one changes 'Retrive' to 'Retrieve' in method names). This is because test fixtures are static and mocks are not reset between test invocations. This can be fixed by making fixtures non-static (as nothing mandates them to be static) and use Mockito standard features to make the mocks reset properly.

While doing this, we can also clean the code of the class a bit as in IDEA too many warnings are seen.",,ktkalenko@gridgain.com,rpuch,,,,"rpuch opened a new pull request, #2034:
URL: https://github.com/apache/ignite-3/pull/2034

   https://issues.apache.org/jira/browse/IGNITE-19432


;05/May/23 14:32;githubbot;600","tkalkirill commented on code in PR #2034:
URL: https://github.com/apache/ignite-3/pull/2034#discussion_r1187041683


##########
modules/table/src/test/java/org/apache/ignite/internal/table/distributed/replication/PartitionReplicaListenerTest.java:
##########
@@ -125,39 +125,45 @@
 import org.apache.ignite.network.NetworkAddress;
 import org.apache.ignite.network.TopologyService;
 import org.apache.ignite.tx.TransactionException;
-import org.junit.jupiter.api.BeforeAll;
+import org.jetbrains.annotations.Nullable;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
+import org.junitpioneer.jupiter.cartesian.CartesianTest;
+import org.junitpioneer.jupiter.cartesian.CartesianTest.Values;
 import org.mockito.Mock;
+import org.mockito.junit.jupiter.MockitoExtension;
 
-/** There are tests for partition replica listener. */
+/** Tests for partition replica listener. */
 @ExtendWith(ConfigurationExtension.class)
+@ExtendWith(MockitoExtension.class)
 public class PartitionReplicaListenerTest extends IgniteAbstractTest {
     /** Partition id. */
     private static final int partId = 0;
 
     /** Table id. */
-    private static final UUID tblId = UUID.randomUUID();
+    private final UUID tblId = UUID.randomUUID();
 
-    private static final Map<UUID, Set<RowId>> pendingRows = new ConcurrentHashMap<>();
+    private final Map<UUID, Set<RowId>> pendingRows = new ConcurrentHashMap<>();
 
     /** The storage stores partition data. */
-    private static final TestMvPartitionStorage testMvPartitionStorage = new TestMvPartitionStorage(partId);
+    private final TestMvPartitionStorage testMvPartitionStorage = new TestMvPartitionStorage(partId);
 
-    private static final LockManager lockManager = new HeapLockManager();
+    private final LockManager lockManager = new HeapLockManager();
 
-    private static final Function<PartitionCommand, CompletableFuture<?>> DEFAULT_MOCK_RAFT_FUTURE_CLOSURE = cmd -> {
+    private final Function<PartitionCommand, CompletableFuture<?>> defaultMockRaftFutureClosure = cmd -> {
         if (cmd instanceof TxCleanupCommand) {
             Set<RowId> rows = pendingRows.remove(cmd.txId());
 
+            HybridTimestamp commitTimestamp = Objects.requireNonNull(((TxCleanupCommand) cmd).commitTimestamp());

Review Comment:
   Personally, I prefer `assertNotNull` instead of `requireNonNull` in tests, at your discretion.



##########
modules/table/src/test/java/org/apache/ignite/internal/table/distributed/replication/PartitionReplicaListenerTest.java:
##########
@@ -1217,53 +1215,57 @@ private void cleanup(UUID txId) {
         txState = TxState.COMMITED;
     }
 
-    private static BinaryTuplePrefix toIndexBound(int val) {
+    private BinaryTuplePrefix toIndexBound(int val) {
         ByteBuffer tuple = new BinaryTuplePrefixBuilder(1, 1).appendInt(val).build();
 
         return new BinaryTuplePrefix(sortedIndexBinarySchema, tuple);
     }
 
-    private static BinaryTuple toIndexKey(int val) {
+    private BinaryTuple toIndexKey(int val) {
         ByteBuffer tuple = new BinaryTupleBuilder(1, true).appendInt(val).build();
 
         return new BinaryTuple(sortedIndexBinarySchema, tuple);
     }
 
-    private static BinaryRow nextBinaryKey() {
+    private BinaryRow nextBinaryKey() {
         try {
-            int nextInt = (int) System.nanoTime();
+            int nextInt = monotonicInt();
 
             return kvMarshaller.marshal(new TestKey(nextInt, ""key "" + nextInt));

Review Comment:
   ```suggestion
               return kvMarshaller.marshal(new TestKey(nextInt, ""key "" + monotonicInt()));
   ```



##########
modules/table/src/test/java/org/apache/ignite/internal/table/distributed/replication/PartitionReplicaListenerTest.java:
##########
@@ -1217,53 +1215,57 @@ private void cleanup(UUID txId) {
         txState = TxState.COMMITED;
     }
 
-    private static BinaryTuplePrefix toIndexBound(int val) {
+    private BinaryTuplePrefix toIndexBound(int val) {
         ByteBuffer tuple = new BinaryTuplePrefixBuilder(1, 1).appendInt(val).build();
 
         return new BinaryTuplePrefix(sortedIndexBinarySchema, tuple);
     }
 
-    private static BinaryTuple toIndexKey(int val) {
+    private BinaryTuple toIndexKey(int val) {
         ByteBuffer tuple = new BinaryTupleBuilder(1, true).appendInt(val).build();
 
         return new BinaryTuple(sortedIndexBinarySchema, tuple);
     }
 
-    private static BinaryRow nextBinaryKey() {
+    private BinaryRow nextBinaryKey() {
         try {
-            int nextInt = (int) System.nanoTime();
+            int nextInt = monotonicInt();
 
             return kvMarshaller.marshal(new TestKey(nextInt, ""key "" + nextInt));
         } catch (MarshallerException e) {
             throw new IgniteException(e);
         }
     }
 
-    protected static BinaryRow binaryRow(int i) {
+    private static int monotonicInt() {
+        return nextMonotonicInt.getAndIncrement();
+    }
+
+    protected BinaryRow binaryRow(int i) {
         try {
             return kvMarshaller.marshal(new TestKey(i, ""k"" + i), new TestValue(i, ""v"" + i));
         } catch (MarshallerException e) {
-            throw new IgniteException(e);
+            throw new RuntimeException(e);
         }
     }
 
-    private static BinaryRow binaryRow(TestKey key, TestValue value) {
+    private BinaryRow binaryRow(TestKey key, TestValue value) {
         try {
             return kvMarshaller.marshal(key, value);
         } catch (MarshallerException e) {
-            throw new IgniteException(e);
+            throw new RuntimeException(e);
         }
     }
 
-    private static TestKey key(BinaryRow binaryRow) {
+    private TestKey key(BinaryRow binaryRow) {
         try {
             return kvMarshaller.unmarshalKey(new Row(schemaDescriptor, binaryRow));
         } catch (MarshallerException e) {
-            throw new IgniteException(e);
+            throw new RuntimeException(e);

Review Comment:
   ```suggestion
               throw new AssertionError(e);
   ```



##########
modules/table/src/test/java/org/apache/ignite/internal/table/distributed/replication/PartitionReplicaListenerTest.java:
##########
@@ -1217,53 +1215,57 @@ private void cleanup(UUID txId) {
         txState = TxState.COMMITED;
     }
 
-    private static BinaryTuplePrefix toIndexBound(int val) {
+    private BinaryTuplePrefix toIndexBound(int val) {
         ByteBuffer tuple = new BinaryTuplePrefixBuilder(1, 1).appendInt(val).build();
 
         return new BinaryTuplePrefix(sortedIndexBinarySchema, tuple);
     }
 
-    private static BinaryTuple toIndexKey(int val) {
+    private BinaryTuple toIndexKey(int val) {
         ByteBuffer tuple = new BinaryTupleBuilder(1, true).appendInt(val).build();
 
         return new BinaryTuple(sortedIndexBinarySchema, tuple);
     }
 
-    private static BinaryRow nextBinaryKey() {
+    private BinaryRow nextBinaryKey() {
         try {
-            int nextInt = (int) System.nanoTime();
+            int nextInt = monotonicInt();
 
             return kvMarshaller.marshal(new TestKey(nextInt, ""key "" + nextInt));
         } catch (MarshallerException e) {
             throw new IgniteException(e);
         }
     }
 
-    protected static BinaryRow binaryRow(int i) {
+    private static int monotonicInt() {
+        return nextMonotonicInt.getAndIncrement();
+    }
+
+    protected BinaryRow binaryRow(int i) {
         try {
             return kvMarshaller.marshal(new TestKey(i, ""k"" + i), new TestValue(i, ""v"" + i));
         } catch (MarshallerException e) {
-            throw new IgniteException(e);
+            throw new RuntimeException(e);

Review Comment:
   ```suggestion
               throw new AssertionError(e);
   ```



##########
modules/table/src/test/java/org/apache/ignite/internal/table/distributed/replication/PartitionReplicaListenerTest.java:
##########
@@ -1217,53 +1215,57 @@ private void cleanup(UUID txId) {
         txState = TxState.COMMITED;
     }
 
-    private static BinaryTuplePrefix toIndexBound(int val) {
+    private BinaryTuplePrefix toIndexBound(int val) {
         ByteBuffer tuple = new BinaryTuplePrefixBuilder(1, 1).appendInt(val).build();
 
         return new BinaryTuplePrefix(sortedIndexBinarySchema, tuple);
     }
 
-    private static BinaryTuple toIndexKey(int val) {
+    private BinaryTuple toIndexKey(int val) {
         ByteBuffer tuple = new BinaryTupleBuilder(1, true).appendInt(val).build();
 
         return new BinaryTuple(sortedIndexBinarySchema, tuple);
     }
 
-    private static BinaryRow nextBinaryKey() {
+    private BinaryRow nextBinaryKey() {
         try {
-            int nextInt = (int) System.nanoTime();
+            int nextInt = monotonicInt();
 
             return kvMarshaller.marshal(new TestKey(nextInt, ""key "" + nextInt));
         } catch (MarshallerException e) {
             throw new IgniteException(e);
         }
     }
 
-    protected static BinaryRow binaryRow(int i) {
+    private static int monotonicInt() {
+        return nextMonotonicInt.getAndIncrement();
+    }
+
+    protected BinaryRow binaryRow(int i) {
         try {
             return kvMarshaller.marshal(new TestKey(i, ""k"" + i), new TestValue(i, ""v"" + i));
         } catch (MarshallerException e) {
-            throw new IgniteException(e);
+            throw new RuntimeException(e);
         }
     }
 
-    private static BinaryRow binaryRow(TestKey key, TestValue value) {
+    private BinaryRow binaryRow(TestKey key, TestValue value) {
         try {
             return kvMarshaller.marshal(key, value);
         } catch (MarshallerException e) {
-            throw new IgniteException(e);
+            throw new RuntimeException(e);

Review Comment:
   ```suggestion
               throw new AssertionError(e);
   ```



;08/May/23 06:03;githubbot;600","tkalkirill merged PR #2034:
URL: https://github.com/apache/ignite-3/pull/2034


;08/May/23 07:04;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Mon May 08 07:08:36 UTC 2023,,,,,,,,,,"0|z1hq20:",9223372036854775807,,,ktkalenko@gridgain.com,,,,,,,,,,,,,,,,,,"05/May/23 18:47;rpuch;[~ktkalenko@gridgain.com] could you please take a look at the attached PR?;;;","08/May/23 06:03;ktkalenko@gridgain.com;Looks good.;;;","08/May/23 07:08;rpuch;Thanks!;;;",,,
Forgot to wait for the RaftServer#raftNodeReadyFuture when start the raft node metastorage,IGNITE-19429,13535172,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,ktkalenko@gridgain.com,ktkalenko@gridgain.com,ktkalenko@gridgain.com,05/May/23 13:37,05/May/23 15:24,13/Jul/23 09:11,05/May/23 15:24,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Forgot to wait for the *org.apache.ignite.internal.raft.server.RaftServer#raftNodeReadyFuture* when starting the raft node metastorage (*org.apache.ignite.internal.raft.Loza#startRaftGroupNode(org.apache.ignite.internal.raft.RaftNodeId, org.apache.ignite.internal.raft.PeersAndLearners, org.apache.ignite.internal.raft.service.RaftGroupListener, org.apache.ignite.internal.raft.RaftGroupEventsListener)*), which can lead to hangs on restarting the node.",,ktkalenko@gridgain.com,,,,,"tkalkirill opened a new pull request, #2033:
URL: https://github.com/apache/ignite-3/pull/2033

   https://issues.apache.org/jira/browse/IGNITE-19429


;05/May/23 14:02;githubbot;600","tkalkirill merged PR #2033:
URL: https://github.com/apache/ignite-3/pull/2033


;05/May/23 15:24;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-05-05 13:37:05.0,,,,,,,,,,"0|z1hpz4:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
Change the default value of dataNodesAutoAdjustScaleUp for custom distribution zones to IMMEDIATE_TIMER_VALUE,IGNITE-19427,13535149,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,Sergey Uttsel,Sergey Uttsel,Sergey Uttsel,05/May/23 10:48,11/May/23 15:26,13/Jul/23 09:11,11/May/23 15:26,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"h3. *Motivation*

At https://issues.apache.org/jira/browse/IGNITE-18624 the value of DistributionZoneConfigurationSchema#dataNodesAutoAdjustScaleUp was changed to IMMEDIATE_TIMER_VALUE. But this only affected the default zone. Custom zones are still created with INFINITE_TIMER_VALUE by default. We need to change default value of dataNodesAutoAdjustScaleUp for custom zones to IMMEDIATE_TIMER_VALUE.

Also this change will fix some flaky tests, for example ItPageMemoryStorageExampleTest.testPersistentExample():
{code:java}
Caused by: java.lang.AssertionError
  at org.apache.ignite.internal.raft.RaftGroupServiceImpl.randomNode(RaftGroupServiceImpl.java:680)
  at org.apache.ignite.internal.raft.RaftGroupServiceImpl.randomNode(RaftGroupServiceImpl.java:667)
  at org.apache.ignite.internal.raft.RaftGroupServiceImpl.refreshLeader(RaftGroupServiceImpl.java:222)
  at org.apache.ignite.internal.raft.RaftGroupServiceImpl.start(RaftGroupServiceImpl.java:178) {code}
h3. *Definition of Done*

dataNodesAutoAdjustScaleUp is IMMEDIATE_TIMER_VALUE for new custom zones.",,alapin,Sergey Uttsel,,,,"sergeyuttsel opened a new pull request, #2027:
URL: https://github.com/apache/ignite-3/pull/2027

   https://issues.apache.org/jira/browse/IGNITE-19427


;05/May/23 10:54;githubbot;600","sanpwc merged PR #2027:
URL: https://github.com/apache/ignite-3/pull/2027


;05/May/23 11:50;githubbot;600","sergeyuttsel opened a new pull request, #2061:
URL: https://github.com/apache/ignite-3/pull/2061

   (no comment)


;11/May/23 11:52;githubbot;600","sergeyuttsel opened a new pull request, #2063:
URL: https://github.com/apache/ignite-3/pull/2063

   (no comment)


;11/May/23 12:35;githubbot;600","sanpwc commented on code in PR #2063:
URL: https://github.com/apache/ignite-3/pull/2063#discussion_r1191262539


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -370,10 +370,13 @@ public CompletableFuture<Integer> createZone(DistributionZoneConfigurationParame
                         }
 
                         if (distributionZoneCfg.dataNodesAutoAdjustScaleUp() == null) {
-                            zoneChange.changeDataNodesAutoAdjustScaleUp(INFINITE_TIMER_VALUE);
+                            if (distributionZoneCfg.dataNodesAutoAdjust() == null) {
+                                zoneChange.changeDataNodesAutoAdjustScaleUp(IMMEDIATE_TIMER_VALUE);

Review Comment:
   Do we really need it? Seems that we shouldn't manually set default value specified in DistributionZoneConfigurationSchema.



;11/May/23 14:32;githubbot;600","sanpwc commented on code in PR #2063:
URL: https://github.com/apache/ignite-3/pull/2063#discussion_r1191278984


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneManagerTest.java:
##########
@@ -247,12 +248,6 @@ private void testUpdateZone(String zoneName) throws Exception {
         assertEquals(INFINITE_TIMER_VALUE, zone.dataNodesAutoAdjustScaleDown().value(), ""dataNodesAutoAdjustScaleDown is wrong."");
         assertEquals(100, zone.dataNodesAutoAdjust().value(), ""dataNodesAutoAdjust is wrong."");
 
-        assertNotNull(zone, ""Zone was not created."");

Review Comment:
   Is it just a duplication of lines 244-249?



;11/May/23 14:39;githubbot;600","sergeyuttsel commented on code in PR #2063:
URL: https://github.com/apache/ignite-3/pull/2063#discussion_r1191286654


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneManagerTest.java:
##########
@@ -247,12 +248,6 @@ private void testUpdateZone(String zoneName) throws Exception {
         assertEquals(INFINITE_TIMER_VALUE, zone.dataNodesAutoAdjustScaleDown().value(), ""dataNodesAutoAdjustScaleDown is wrong."");
         assertEquals(100, zone.dataNodesAutoAdjust().value(), ""dataNodesAutoAdjust is wrong."");
 
-        assertNotNull(zone, ""Zone was not created."");

Review Comment:
   Yes. Double check :)



;11/May/23 14:43;githubbot;600","sergeyuttsel commented on code in PR #2063:
URL: https://github.com/apache/ignite-3/pull/2063#discussion_r1191307525


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -370,10 +370,13 @@ public CompletableFuture<Integer> createZone(DistributionZoneConfigurationParame
                         }
 
                         if (distributionZoneCfg.dataNodesAutoAdjustScaleUp() == null) {
-                            zoneChange.changeDataNodesAutoAdjustScaleUp(INFINITE_TIMER_VALUE);
+                            if (distributionZoneCfg.dataNodesAutoAdjust() == null) {
+                                zoneChange.changeDataNodesAutoAdjustScaleUp(IMMEDIATE_TIMER_VALUE);

Review Comment:
   Thanks. Fixed.



;11/May/23 14:55;githubbot;600","sanpwc merged PR #2063:
URL: https://github.com/apache/ignite-3/pull/2063


;11/May/23 15:26;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,5400,,,0,5400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu May 11 15:00:27 UTC 2023,,,,,,,,,,"0|z1hpu0:",9223372036854775807,,,alapin,,,,,,,,,,,,,,,,,,"11/May/23 15:00;alapin;[~Sergey Uttsel] LGTM, Thanks!;;;",,,,,
Control utility is not working out of the box for slim and lgpl assemblies,IGNITE-19426,13535128,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,alex_pl,alex_pl,alex_pl,05/May/23 09:08,05/May/23 12:26,13/Jul/23 09:11,05/May/23 12:26,,,,,,,,2.16,,,,0,,,,During {{slim}} and {{lgpl}} assemblies creation module {{control-utility}} is copied to {{libs/optional}} instead of {{libs}}.,,alex_pl,,,,,"alex-plekhanov opened a new pull request, #10705:
URL: https://github.com/apache/ignite/pull/10705

   …semblies
   
   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;05/May/23 10:01;githubbot;600","sonarcloud[bot] commented on PR #10705:
URL: https://github.com/apache/ignite/pull/10705#issuecomment-1536031821

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10705)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10705&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10705&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10705&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=CODE_SMELL)
   
   [![No Coverage information](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/NoCoverageInfo-16px.png 'No Coverage information')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10705) No Coverage information  
   [![No Duplication information](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/NoDuplicationInfo-16px.png 'No Duplication information')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10705&metric=duplicated_lines_density&view=list) No Duplication information
   
   


;05/May/23 10:09;githubbot;600","sonarcloud[bot] commented on PR #10705:
URL: https://github.com/apache/ignite/pull/10705#issuecomment-1536109047

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10705)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10705&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10705&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10705&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10705&resolved=false&types=CODE_SMELL)
   
   [![No Coverage information](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/NoCoverageInfo-16px.png 'No Coverage information')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10705) No Coverage information  
   [![No Duplication information](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/NoDuplicationInfo-16px.png 'No Duplication information')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10705&metric=duplicated_lines_density&view=list) No Duplication information
   
   


;05/May/23 11:18;githubbot;600","asfgit closed pull request #10705: IGNITE-19426 Fix control-utility module location for slim and lgpl as…
URL: https://github.com/apache/ignite/pull/10705


;05/May/23 12:25;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Fri May 05 12:26:27 UTC 2023,,,,,,,,,,"0|z1hppc:",9223372036854775807,Fixed control-utility module location for slim and LGPL assemblies,,,,,,,,,,,,,,,,,,,,"05/May/23 10:02;alex_pl;Checked assemblies with commands:

{noformat}
mvn initialize -Prelease -Dignite.edition=apache-ignite-slim
mvn initialize -Prelease -Dignite.edition=apache-ignite-lgpl
{noformat}
;;;","05/May/23 12:26;alex_pl;[~NSAmelchev], thanks for the review! Merged to master.;;;",,,,
"Return latest data in ""get"" index cursor",IGNITE-19422,13535009,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ibessonov,ibessonov,ibessonov,04/May/23 14:53,08/Jun/23 09:54,13/Jul/23 09:11,08/Jun/23 09:54,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"During the implementation https://issues.apache.org/jira/browse/IGNITE-19394 it was noted, that ""get"" method doesn't work properly in concurrent environment. We should fix it, so that it works more like ""scan"" in sorted indexes.",,ibessonov,ktkalenko@gridgain.com,,,,"ibessonov opened a new pull request, #2161:
URL: https://github.com/apache/ignite-3/pull/2161

   https://issues.apache.org/jira/browse/IGNITE-19422


;07/Jun/23 12:37;githubbot;600","tkalkirill commented on code in PR #2161:
URL: https://github.com/apache/ignite-3/pull/2161#discussion_r1222612347


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/index/AbstractPageMemoryIndexStorage.java:
##########
@@ -192,6 +196,123 @@ public void finishCleanup() {
         state.compareAndSet(StorageState.CLEANUP, StorageState.RUNNABLE);
     }
 
+    /** Constant that represents the absence of value in {@link ScanCursor}. */
+    private static final IndexRowKey NO_INDEX_ROW = () -> null;

Review Comment:
   Optional: What about `NULL_INDEX_ROW`? seems more obvious.



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/index/AbstractPageMemoryIndexStorage.java:
##########
@@ -192,6 +196,123 @@ public void finishCleanup() {
         state.compareAndSet(StorageState.CLEANUP, StorageState.RUNNABLE);
     }
 
+    /** Constant that represents the absence of value in {@link ScanCursor}. */
+    private static final IndexRowKey NO_INDEX_ROW = () -> null;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     *
+     * @param <R> Type of the returned value.
+     */
+    protected abstract class ScanCursor<R> implements PeekCursor<R> {
+        private final BplusTree<K, V> indexTree;
+
+        @Nullable
+        private Boolean hasNext;
+
+        @Nullable
+        private final K lower;

Review Comment:
   ```suggestion
           private final @Nullable K lower;
   ```



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/index/AbstractPageMemoryIndexStorage.java:
##########
@@ -192,6 +196,123 @@ public void finishCleanup() {
         state.compareAndSet(StorageState.CLEANUP, StorageState.RUNNABLE);
     }
 
+    /** Constant that represents the absence of value in {@link ScanCursor}. */
+    private static final IndexRowKey NO_INDEX_ROW = () -> null;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     *
+     * @param <R> Type of the returned value.
+     */
+    protected abstract class ScanCursor<R> implements PeekCursor<R> {
+        private final BplusTree<K, V> indexTree;
+
+        @Nullable
+        private Boolean hasNext;

Review Comment:
   ```suggestion
           private @Nullable Boolean hasNext;
   ```



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/index/AbstractPageMemoryIndexStorage.java:
##########
@@ -192,6 +196,123 @@ public void finishCleanup() {
         state.compareAndSet(StorageState.CLEANUP, StorageState.RUNNABLE);
     }
 
+    /** Constant that represents the absence of value in {@link ScanCursor}. */
+    private static final IndexRowKey NO_INDEX_ROW = () -> null;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     *
+     * @param <R> Type of the returned value.
+     */
+    protected abstract class ScanCursor<R> implements PeekCursor<R> {
+        private final BplusTree<K, V> indexTree;
+
+        @Nullable
+        private Boolean hasNext;
+
+        @Nullable
+        private final K lower;
+
+        @Nullable
+        private V treeRow;
+
+        @Nullable
+        private V peekedRow = (V) NO_INDEX_ROW;

Review Comment:
   ```suggestion
           private @Nullable V peekedRow = (V) NO_INDEX_ROW;
   ```



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/index/AbstractPageMemoryIndexStorage.java:
##########
@@ -192,6 +196,123 @@ public void finishCleanup() {
         state.compareAndSet(StorageState.CLEANUP, StorageState.RUNNABLE);
     }
 
+    /** Constant that represents the absence of value in {@link ScanCursor}. */
+    private static final IndexRowKey NO_INDEX_ROW = () -> null;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     *
+     * @param <R> Type of the returned value.
+     */
+    protected abstract class ScanCursor<R> implements PeekCursor<R> {
+        private final BplusTree<K, V> indexTree;
+
+        @Nullable
+        private Boolean hasNext;
+
+        @Nullable
+        private final K lower;
+
+        @Nullable
+        private V treeRow;

Review Comment:
   ```suggestion
           private @Nullable V treeRow;
   ```



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/index/AbstractPageMemoryIndexStorage.java:
##########
@@ -192,6 +196,123 @@ public void finishCleanup() {
         state.compareAndSet(StorageState.CLEANUP, StorageState.RUNNABLE);
     }
 
+    /** Constant that represents the absence of value in {@link ScanCursor}. */
+    private static final IndexRowKey NO_INDEX_ROW = () -> null;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     *
+     * @param <R> Type of the returned value.
+     */
+    protected abstract class ScanCursor<R> implements PeekCursor<R> {
+        private final BplusTree<K, V> indexTree;
+
+        @Nullable
+        private Boolean hasNext;
+
+        @Nullable
+        private final K lower;
+
+        @Nullable
+        private V treeRow;
+
+        @Nullable
+        private V peekedRow = (V) NO_INDEX_ROW;
+
+        protected ScanCursor(@Nullable K lower, BplusTree<K, V> indexTree) {
+            this.lower = lower;
+            this.indexTree = indexTree;
+        }
+
+        /**
+         * Maps value from the index tree into the required result.
+         */
+        protected abstract R map(V value);
+
+        /**
+         * Check whether the passed value exceeds the upper bound for the scan.
+         */
+        protected abstract boolean halt(V value);

Review Comment:
   Not an obvious name, maybe call it `exceedUppderBoun`?



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/index/AbstractPageMemoryIndexStorage.java:
##########
@@ -192,6 +196,123 @@ public void finishCleanup() {
         state.compareAndSet(StorageState.CLEANUP, StorageState.RUNNABLE);
     }
 
+    /** Constant that represents the absence of value in {@link ScanCursor}. */
+    private static final IndexRowKey NO_INDEX_ROW = () -> null;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     *
+     * @param <R> Type of the returned value.
+     */
+    protected abstract class ScanCursor<R> implements PeekCursor<R> {
+        private final BplusTree<K, V> indexTree;
+
+        @Nullable
+        private Boolean hasNext;
+
+        @Nullable
+        private final K lower;
+
+        @Nullable
+        private V treeRow;
+
+        @Nullable
+        private V peekedRow = (V) NO_INDEX_ROW;
+
+        protected ScanCursor(@Nullable K lower, BplusTree<K, V> indexTree) {
+            this.lower = lower;
+            this.indexTree = indexTree;
+        }
+
+        /**
+         * Maps value from the index tree into the required result.
+         */
+        protected abstract R map(V value);
+
+        /**
+         * Check whether the passed value exceeds the upper bound for the scan.
+         */
+        protected abstract boolean halt(V value);
+
+        @Override
+        public void close() {
+            // No-op.
+        }
+
+        @Override
+        public boolean hasNext() {
+            return busy(() -> {
+                try {
+                    return advanceIfNeeded();
+                } catch (IgniteInternalCheckedException e) {
+                    throw new StorageException(""Error while advancing the cursor"", e);
+                }
+            });
+        }
+
+        @Override
+        public R next() {
+            return busy(() -> {
+                try {
+                    if (!advanceIfNeeded()) {
+                        throw new NoSuchElementException();
+                    }
+
+                    this.hasNext = null;
+
+                    return map(treeRow);
+                } catch (IgniteInternalCheckedException e) {
+                    throw new StorageException(""Error while advancing the cursor"", e);
+                }
+            });
+        }
+
+        @Override
+        public @Nullable R peek() {
+            return busy(() -> {
+                throwExceptionIfStorageInProgressOfRebalance(state.get(), AbstractPageMemoryIndexStorage.this::createStorageInfo);
+
+                try {
+                    return map(peekBusy());
+                } catch (IgniteInternalCheckedException e) {
+                    throw new StorageException(""Error when peeking next element"", e);
+                }
+            });
+        }
+
+        private @Nullable V peekBusy() throws IgniteInternalCheckedException {
+            if (hasNext != null) {
+                return treeRow;
+            }
+
+            if (treeRow == null) {
+                peekedRow = lower == null ? indexTree.findFirst() : indexTree.findNext(lower, true);
+            } else {
+                peekedRow = indexTree.findNext(treeRow, false);
+            }
+
+            if (peekedRow != null && halt(peekedRow)) {
+                peekedRow = null;
+            }
+
+            return peekedRow;
+        }
+
+        private boolean advanceIfNeeded() throws IgniteInternalCheckedException {

Review Comment:
   ```suggestion
           private boolean advanceIfNeededBusy() throws IgniteInternalCheckedException {
   ```



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/index/AbstractPageMemoryIndexStorage.java:
##########
@@ -192,6 +196,123 @@ public void finishCleanup() {
         state.compareAndSet(StorageState.CLEANUP, StorageState.RUNNABLE);
     }
 
+    /** Constant that represents the absence of value in {@link ScanCursor}. */
+    private static final IndexRowKey NO_INDEX_ROW = () -> null;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     *
+     * @param <R> Type of the returned value.
+     */
+    protected abstract class ScanCursor<R> implements PeekCursor<R> {
+        private final BplusTree<K, V> indexTree;
+
+        @Nullable
+        private Boolean hasNext;
+
+        @Nullable
+        private final K lower;
+
+        @Nullable
+        private V treeRow;

Review Comment:
   Missing javadoc



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/index/AbstractRocksDbIndexStorage.java:
##########
@@ -201,4 +214,125 @@ String createStorageInfo() {
      * @throws RocksDBException If failed to delete data.
      */
     abstract void destroyData(WriteBatch writeBatch) throws RocksDBException;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     */
+    protected final class UpToDatePeekCursor<T> implements PeekCursor<T> {
+        private final Slice upperBoundSlice;
+        private final byte[] lowerBound;
+
+        private final ReadOptions options;
+        private final RocksIterator it;
+        private final Function<ByteBuffer, T> mapper;

Review Comment:
   https://memesmix.net/media/created/250/k5md75.jpg



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/index/AbstractRocksDbIndexStorage.java:
##########
@@ -201,4 +214,125 @@ String createStorageInfo() {
      * @throws RocksDBException If failed to delete data.
      */
     abstract void destroyData(WriteBatch writeBatch) throws RocksDBException;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     */
+    protected final class UpToDatePeekCursor<T> implements PeekCursor<T> {
+        private final Slice upperBoundSlice;
+        private final byte[] lowerBound;
+
+        private final ReadOptions options;
+        private final RocksIterator it;
+        private final Function<ByteBuffer, T> mapper;
+
+        @Nullable
+        private Boolean hasNext;
+
+        private byte @Nullable [] key;

Review Comment:
   Missing javadoc



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/index/AbstractRocksDbIndexStorage.java:
##########
@@ -201,4 +214,125 @@ String createStorageInfo() {
      * @throws RocksDBException If failed to delete data.
      */
     abstract void destroyData(WriteBatch writeBatch) throws RocksDBException;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     */
+    protected final class UpToDatePeekCursor<T> implements PeekCursor<T> {
+        private final Slice upperBoundSlice;
+        private final byte[] lowerBound;
+
+        private final ReadOptions options;
+        private final RocksIterator it;
+        private final Function<ByteBuffer, T> mapper;
+
+        @Nullable
+        private Boolean hasNext;

Review Comment:
   ```suggestion
           private @Nullable Boolean hasNext;
   ```



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/index/AbstractRocksDbIndexStorage.java:
##########
@@ -201,4 +214,125 @@ String createStorageInfo() {
      * @throws RocksDBException If failed to delete data.
      */
     abstract void destroyData(WriteBatch writeBatch) throws RocksDBException;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     */
+    protected final class UpToDatePeekCursor<T> implements PeekCursor<T> {
+        private final Slice upperBoundSlice;
+        private final byte[] lowerBound;
+
+        private final ReadOptions options;
+        private final RocksIterator it;
+        private final Function<ByteBuffer, T> mapper;
+
+        @Nullable
+        private Boolean hasNext;
+
+        private byte @Nullable [] key;
+
+        private byte @Nullable [] peekedKey = BYTE_EMPTY_ARRAY;
+
+        UpToDatePeekCursor(byte[] upperBound, ColumnFamily indexCf, Function<ByteBuffer, T> mapper, byte[] lowerBound) {
+            this.lowerBound = lowerBound;
+            upperBoundSlice = new Slice(upperBound);
+            options = new ReadOptions().setIterateUpperBound(upperBoundSlice);
+            it = indexCf.newIterator(options);
+
+            this.mapper = mapper;
+        }
+
+        @Override
+        public void close() {
+            try {
+                closeAll(it, options, upperBoundSlice);
+            } catch (Exception e) {
+                throw new StorageException(""Error closing cursor"", e);
+            }
+        }
+
+        @Override
+        public boolean hasNext() {
+            return busy(this::advanceIfNeeded);
+        }
+
+        @Override
+        public T next() {
+            return busy(() -> {
+                if (!advanceIfNeeded()) {
+                    throw new NoSuchElementException();
+                }
+
+                this.hasNext = null;
+
+                return mapper.apply(ByteBuffer.wrap(key).order(KEY_BYTE_ORDER));
+            });
+        }
+
+        @Override
+        public @Nullable T peek() {
+            return busy(() -> {
+                throwExceptionIfStorageInProgressOfRebalance(state.get(), AbstractRocksDbIndexStorage.this::createStorageInfo);
+
+                byte[] res = peek0();
+
+                if (res == null) {
+                    return null;
+                } else {
+                    return mapper.apply(ByteBuffer.wrap(res).order(KEY_BYTE_ORDER));
+                }
+            });
+        }
+
+        private byte @Nullable [] peek0() {
+            if (hasNext != null) {
+                return key;
+            }
+
+            refreshAndPrepareRocksIterator();
+
+            if (!it.isValid()) {
+                RocksUtils.checkIterator(it);
+
+                peekedKey = null;
+            } else {
+                peekedKey = it.key();
+            }
+
+            return peekedKey;
+        }
+
+        private boolean advanceIfNeeded() throws StorageException {

Review Comment:
   ```suggestion
           private boolean advanceIfNeededBusy() throws StorageException {
   ```



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/index/AbstractRocksDbIndexStorage.java:
##########
@@ -201,4 +214,125 @@ String createStorageInfo() {
      * @throws RocksDBException If failed to delete data.
      */
     abstract void destroyData(WriteBatch writeBatch) throws RocksDBException;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     */
+    protected final class UpToDatePeekCursor<T> implements PeekCursor<T> {
+        private final Slice upperBoundSlice;
+        private final byte[] lowerBound;
+
+        private final ReadOptions options;
+        private final RocksIterator it;
+        private final Function<ByteBuffer, T> mapper;
+
+        @Nullable
+        private Boolean hasNext;
+
+        private byte @Nullable [] key;
+
+        private byte @Nullable [] peekedKey = BYTE_EMPTY_ARRAY;
+
+        UpToDatePeekCursor(byte[] upperBound, ColumnFamily indexCf, Function<ByteBuffer, T> mapper, byte[] lowerBound) {
+            this.lowerBound = lowerBound;
+            upperBoundSlice = new Slice(upperBound);
+            options = new ReadOptions().setIterateUpperBound(upperBoundSlice);
+            it = indexCf.newIterator(options);
+
+            this.mapper = mapper;
+        }
+
+        @Override
+        public void close() {
+            try {
+                closeAll(it, options, upperBoundSlice);
+            } catch (Exception e) {
+                throw new StorageException(""Error closing cursor"", e);
+            }
+        }
+
+        @Override
+        public boolean hasNext() {
+            return busy(this::advanceIfNeeded);
+        }
+
+        @Override
+        public T next() {
+            return busy(() -> {
+                if (!advanceIfNeeded()) {
+                    throw new NoSuchElementException();
+                }
+
+                this.hasNext = null;
+
+                return mapper.apply(ByteBuffer.wrap(key).order(KEY_BYTE_ORDER));
+            });
+        }
+
+        @Override
+        public @Nullable T peek() {
+            return busy(() -> {
+                throwExceptionIfStorageInProgressOfRebalance(state.get(), AbstractRocksDbIndexStorage.this::createStorageInfo);
+
+                byte[] res = peek0();
+
+                if (res == null) {
+                    return null;
+                } else {
+                    return mapper.apply(ByteBuffer.wrap(res).order(KEY_BYTE_ORDER));
+                }
+            });
+        }
+
+        private byte @Nullable [] peek0() {
+            if (hasNext != null) {
+                return key;
+            }
+
+            refreshAndPrepareRocksIterator();
+
+            if (!it.isValid()) {
+                RocksUtils.checkIterator(it);
+
+                peekedKey = null;
+            } else {
+                peekedKey = it.key();
+            }
+
+            return peekedKey;
+        }
+
+        private boolean advanceIfNeeded() throws StorageException {
+            throwExceptionIfStorageInProgressOfRebalance(state.get(), AbstractRocksDbIndexStorage.this::createStorageInfo);
+
+            //noinspection ArrayEquality
+            key = (peekedKey == BYTE_EMPTY_ARRAY) ? peek0() : peekedKey;
+            peekedKey = BYTE_EMPTY_ARRAY;
+
+            hasNext = key != null;
+            return hasNext;
+        }
+
+        private void refreshAndPrepareRocksIterator() {

Review Comment:
   ```suggestion
           private void refreshAndPrepareRocksIteratorBusy() {
   ```



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/index/AbstractPageMemoryIndexStorage.java:
##########
@@ -192,6 +196,123 @@ public void finishCleanup() {
         state.compareAndSet(StorageState.CLEANUP, StorageState.RUNNABLE);
     }
 
+    /** Constant that represents the absence of value in {@link ScanCursor}. */
+    private static final IndexRowKey NO_INDEX_ROW = () -> null;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     *
+     * @param <R> Type of the returned value.
+     */
+    protected abstract class ScanCursor<R> implements PeekCursor<R> {
+        private final BplusTree<K, V> indexTree;
+
+        @Nullable
+        private Boolean hasNext;
+
+        @Nullable
+        private final K lower;
+
+        @Nullable
+        private V treeRow;
+
+        @Nullable
+        private V peekedRow = (V) NO_INDEX_ROW;

Review Comment:
   Missing javadoc



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/index/AbstractRocksDbIndexStorage.java:
##########
@@ -201,4 +214,125 @@ String createStorageInfo() {
      * @throws RocksDBException If failed to delete data.
      */
     abstract void destroyData(WriteBatch writeBatch) throws RocksDBException;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     */
+    protected final class UpToDatePeekCursor<T> implements PeekCursor<T> {
+        private final Slice upperBoundSlice;
+        private final byte[] lowerBound;
+
+        private final ReadOptions options;
+        private final RocksIterator it;
+        private final Function<ByteBuffer, T> mapper;
+
+        @Nullable
+        private Boolean hasNext;
+
+        private byte @Nullable [] key;
+
+        private byte @Nullable [] peekedKey = BYTE_EMPTY_ARRAY;

Review Comment:
   Missing javadoc



##########
modules/storage-rocksdb/src/main/java/org/apache/ignite/internal/storage/rocksdb/index/AbstractRocksDbIndexStorage.java:
##########
@@ -201,4 +214,125 @@ String createStorageInfo() {
      * @throws RocksDBException If failed to delete data.
      */
     abstract void destroyData(WriteBatch writeBatch) throws RocksDBException;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     */
+    protected final class UpToDatePeekCursor<T> implements PeekCursor<T> {
+        private final Slice upperBoundSlice;
+        private final byte[] lowerBound;
+
+        private final ReadOptions options;
+        private final RocksIterator it;
+        private final Function<ByteBuffer, T> mapper;
+
+        @Nullable
+        private Boolean hasNext;
+
+        private byte @Nullable [] key;
+
+        private byte @Nullable [] peekedKey = BYTE_EMPTY_ARRAY;
+
+        UpToDatePeekCursor(byte[] upperBound, ColumnFamily indexCf, Function<ByteBuffer, T> mapper, byte[] lowerBound) {
+            this.lowerBound = lowerBound;
+            upperBoundSlice = new Slice(upperBound);
+            options = new ReadOptions().setIterateUpperBound(upperBoundSlice);
+            it = indexCf.newIterator(options);
+
+            this.mapper = mapper;
+        }
+
+        @Override
+        public void close() {
+            try {
+                closeAll(it, options, upperBoundSlice);
+            } catch (Exception e) {
+                throw new StorageException(""Error closing cursor"", e);
+            }
+        }
+
+        @Override
+        public boolean hasNext() {
+            return busy(this::advanceIfNeeded);
+        }
+
+        @Override
+        public T next() {
+            return busy(() -> {
+                if (!advanceIfNeeded()) {
+                    throw new NoSuchElementException();
+                }
+
+                this.hasNext = null;
+
+                return mapper.apply(ByteBuffer.wrap(key).order(KEY_BYTE_ORDER));
+            });
+        }
+
+        @Override
+        public @Nullable T peek() {
+            return busy(() -> {
+                throwExceptionIfStorageInProgressOfRebalance(state.get(), AbstractRocksDbIndexStorage.this::createStorageInfo);
+
+                byte[] res = peek0();
+
+                if (res == null) {
+                    return null;
+                } else {
+                    return mapper.apply(ByteBuffer.wrap(res).order(KEY_BYTE_ORDER));
+                }
+            });
+        }
+
+        private byte @Nullable [] peek0() {

Review Comment:
   ```suggestion
           private byte @Nullable [] peekBusy() {
   ```



;08/Jun/23 08:36;githubbot;600","ibessonov commented on code in PR #2161:
URL: https://github.com/apache/ignite-3/pull/2161#discussion_r1222659933


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/index/AbstractPageMemoryIndexStorage.java:
##########
@@ -192,6 +196,123 @@ public void finishCleanup() {
         state.compareAndSet(StorageState.CLEANUP, StorageState.RUNNABLE);
     }
 
+    /** Constant that represents the absence of value in {@link ScanCursor}. */
+    private static final IndexRowKey NO_INDEX_ROW = () -> null;

Review Comment:
   I use ""null"" for ""null"", so ""NO"" seems more obvious to me. But I'll take a look at this code and think about renaming, thank you!



;08/Jun/23 08:43;githubbot;600","ibessonov commented on code in PR #2161:
URL: https://github.com/apache/ignite-3/pull/2161#discussion_r1222663971


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/index/AbstractPageMemoryIndexStorage.java:
##########
@@ -192,6 +196,123 @@ public void finishCleanup() {
         state.compareAndSet(StorageState.CLEANUP, StorageState.RUNNABLE);
     }
 
+    /** Constant that represents the absence of value in {@link ScanCursor}. */
+    private static final IndexRowKey NO_INDEX_ROW = () -> null;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     *
+     * @param <R> Type of the returned value.
+     */
+    protected abstract class ScanCursor<R> implements PeekCursor<R> {
+        private final BplusTree<K, V> indexTree;
+
+        @Nullable
+        private Boolean hasNext;
+
+        @Nullable
+        private final K lower;
+
+        @Nullable
+        private V treeRow;
+
+        @Nullable
+        private V peekedRow = (V) NO_INDEX_ROW;
+
+        protected ScanCursor(@Nullable K lower, BplusTree<K, V> indexTree) {
+            this.lower = lower;
+            this.indexTree = indexTree;
+        }
+
+        /**
+         * Maps value from the index tree into the required result.
+         */
+        protected abstract R map(V value);
+
+        /**
+         * Check whether the passed value exceeds the upper bound for the scan.
+         */
+        protected abstract boolean halt(V value);

Review Comment:
   ""uppder boun""?
   What's wrong with ""halt"", that's a common name for stopping something



;08/Jun/23 08:46;githubbot;600","tkalkirill commented on code in PR #2161:
URL: https://github.com/apache/ignite-3/pull/2161#discussion_r1222701658


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/index/AbstractPageMemoryIndexStorage.java:
##########
@@ -192,6 +196,123 @@ public void finishCleanup() {
         state.compareAndSet(StorageState.CLEANUP, StorageState.RUNNABLE);
     }
 
+    /** Constant that represents the absence of value in {@link ScanCursor}. */
+    private static final IndexRowKey NO_INDEX_ROW = () -> null;
+
+    /**
+     * Cursor that always returns up-to-date next element.
+     *
+     * @param <R> Type of the returned value.
+     */
+    protected abstract class ScanCursor<R> implements PeekCursor<R> {
+        private final BplusTree<K, V> indexTree;
+
+        @Nullable
+        private Boolean hasNext;
+
+        @Nullable
+        private final K lower;
+
+        @Nullable
+        private V treeRow;
+
+        @Nullable
+        private V peekedRow = (V) NO_INDEX_ROW;
+
+        protected ScanCursor(@Nullable K lower, BplusTree<K, V> indexTree) {
+            this.lower = lower;
+            this.indexTree = indexTree;
+        }
+
+        /**
+         * Maps value from the index tree into the required result.
+         */
+        protected abstract R map(V value);
+
+        /**
+         * Check whether the passed value exceeds the upper bound for the scan.
+         */
+        protected abstract boolean halt(V value);

Review Comment:
   I tried to find in our project at least one use of such a name or similar to it - there is none.



;08/Jun/23 09:19;githubbot;600","ibessonov merged PR #2161:
URL: https://github.com/apache/ignite-3/pull/2161


;08/Jun/23 09:54;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3600,,,0,3600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jun 08 09:53:25 UTC 2023,,,,,,,,,,"0|z1hoyw:",9223372036854775807,,,ktkalenko@gridgain.com,,,,,,,,,,,,,,,,,,"08/Jun/23 09:53;ktkalenko@gridgain.com;Looks good.;;;",,,,,
Fix gradle build with JDK 17,IGNITE-19418,13534961,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,vpakhnushev,vpakhnushev,04/May/23 10:54,08/May/23 09:59,13/Jul/23 09:11,08/May/23 09:59,,,,,,,,3.0.0-beta2,build,,,0,ignite-3,,,"Running {{./gradlew check}} with JAVA_HOME set to JDK 17, build fails with the following message:
{noformat}
Could not determine the dependencies of task ':ignite-arch-test:checkstyleTest'.
> Could not resolve all task dependencies for configuration ':ignite-arch-test:testCompileClasspath'.
   > Could not resolve project :packaging.
     Required by:
         project :ignite-arch-test
      > No matching variant of project :packaging was found. The consumer was configured to find an API of a library compatible with Java 11, preferably in the form of class files, preferably optimized for standard JVMs, and its dependencies declared externally but:
          - Variant 'apiElements' capability org.apache.ignite:packaging:3.0.0-SNAPSHOT declares an API of a library, packaged as a jar, and its dependencies declared externally:
              - Incompatible because this component declares a component compatible with Java 17 and the consumer needed a component compatible with Java 11
{noformat}
",,aleksandr.pakhomov,vpakhnushev,,,,"valepakh opened a new pull request, #2023:
URL: https://github.com/apache/ignite-3/pull/2023

   https://issues.apache.org/jira/browse/IGNITE-19418


;04/May/23 10:54;githubbot;600","PakhomovAlexander merged PR #2023:
URL: https://github.com/apache/ignite-3/pull/2023


;08/May/23 09:58;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon May 08 09:59:37 UTC 2023,,,,,,,,,,"0|z1hoo8:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"08/May/23 09:59;aleksandr.pakhomov;Thanks for the fix, merged into main: fc814e06dafadaddbbfff507e240f7c08c606f10;;;",,,,,
Test JavaThinCompatibilityTest.testCurrentClientToOldServer(Version 2.14.0) fails,IGNITE-19416,13534869,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,alex_pl,alex_pl,alex_pl,03/May/23 17:48,04/May/23 09:14,13/Jul/23 09:11,04/May/23 09:14,,,,,,,,2.16,,,,0,MakeTeamcityGreenAgain,,,Test JavaThinCompatibilityTest.testCurrentClientToOldServer(Version 2.14.0) always fails after IGNITE-17449,,alex_pl,,,,,"alex-plekhanov opened a new pull request, #10699:
URL: https://github.com/apache/ignite/pull/10699

   …er(Version 2.14.0)
   
   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;03/May/23 17:51;githubbot;600","sonarcloud[bot] commented on PR #10699:
URL: https://github.com/apache/ignite/pull/10699#issuecomment-1533478151

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10699)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10699&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10699&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10699&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=CODE_SMELL)
   
   [![No Coverage information](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/NoCoverageInfo-16px.png 'No Coverage information')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10699) No Coverage information  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10699&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10699&metric=new_duplicated_lines_density&view=list)
   
   


;03/May/23 17:58;githubbot;600","sonarcloud[bot] commented on PR #10699:
URL: https://github.com/apache/ignite/pull/10699#issuecomment-1533489664

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10699)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10699&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10699&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10699&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10699&resolved=false&types=CODE_SMELL)
   
   [![No Coverage information](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/NoCoverageInfo-16px.png 'No Coverage information')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10699) No Coverage information  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10699&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10699&metric=new_duplicated_lines_density&view=list)
   
   


;03/May/23 18:07;githubbot;600","asfgit closed pull request #10699: IGNITE-19416 Fix JavaThinCompatibilityTest.testCurrentClientToOldServ…
URL: https://github.com/apache/ignite/pull/10699


;04/May/23 09:14;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu May 04 09:14:52 UTC 2023,,,,,,,,,,"0|z1ho3s:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"04/May/23 09:14;alex_pl;[~NIzhikov], thanks for the review! Merged to master.;;;",,,,,
Potential memory leak in MailboxRegistryImpl under intensive SQL load,IGNITE-19412,13534831,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,korlov,akhitrin,akhitrin,03/May/23 12:53,16/May/23 09:39,13/Jul/23 09:11,11/May/23 13:50,3.0.0-beta1,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,sql,,"I tried to run a SQL benchmark (slightly modified [Benchbase TPC-C scenario|https://github.com/cmu-db/benchbase/wiki/TPC-C]) against Ignite3 (commit hash b48ddcba7cd2bd3b9a053ae131c25b44a0400e27).

Ignite3 was running with -Xmx6G -Xms6G memory limit. After some time it has reached memory limits and failed due to OutOfMemoryError. A heap dump was generated on failure. I can't attach this dump due to its size, but I've opened it in MAT and created a report (see zip file attached).

The report says that most of the retained heap (almost 5G) is occupied by a single instance of o.a.i.internal.sql.engine.exec.MailboxRegistryImpl class (see image attached).

{*}Hypothesis{*}: on an intense load, MailboxRegistryImpl creates a lot of lambda expressions. This happens faster than they're being utilized. With limited memory size, it could lead to OOM at some moment.

Benchmark is quite trivial by mechanics:

1. Create a table structure (see DDL file attached)
2. Fill tables with randomized data (several tens of thousands rows is enough)
3. Run select queries in a loop (actually, it wouldn't happen; OOM was raised on data insertion).",,akhitrin,korlov,xtern,,,"korlov42 opened a new pull request, #2043:
URL: https://github.com/apache/ignite-3/pull/2043

   (no comment)


;10/May/23 07:22;githubbot;600","korlov42 merged PR #2043:
URL: https://github.com/apache/ignite-3/pull/2043


;11/May/23 13:49;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,IGNITE-19419,,,,,,,,,,,,,IGNITE-19247,,,,,,,"03/May/23 12:26;akhitrin;Screenshot_20230503_172458.png;https://issues.apache.org/jira/secure/attachment/13057809/Screenshot_20230503_172458.png","03/May/23 12:33;akhitrin;ddl-ignite3.sql;https://issues.apache.org/jira/secure/attachment/13057808/ddl-ignite3.sql","03/May/23 12:23;akhitrin;java_pid4802_Leak_Suspects.zip;https://issues.apache.org/jira/secure/attachment/13057810/java_pid4802_Leak_Suspects.zip",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu May 11 13:50:52 UTC 2023,,,,,,,,,,"0|z1hnvc:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"11/May/23 13:50;korlov;Merged to [main|https://github.com/apache/ignite-3/commit/c2afff94d80f479a4e6099ab6e126efe9b232a17].;;;",,,,,
Node failure in case multiple nodes  join and leave a cluster simultaneously with security is enabled.,IGNITE-19410,13534828,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,PetrovMikhail,PetrovMikhail,PetrovMikhail,03/May/23 12:34,06/Jun/23 15:40,13/Jul/23 09:11,25/May/23 08:25,,,,,,,,2.16,security,,,0,ise,,,"The case when nodes with security enabled join and leave the cluster simultaneously can cause the joining nodes to fail with the following exception:


{code:java}
[2023-05-03T14:54:31,208][ERROR][disco-notifier-worker-#332%ignite.NodeSecurityContextTest2%][IgniteTestResources] Critical system error detected. Will be handled accordingly to configured handler [hnd=StopNodeOrHaltFailureHandler [tryStop=false, timeout=0, super=AbstractFailureHandler [ignoredFailureTypes=UnmodifiableSet [SYSTEM_WORKER_BLOCKED, SYSTEM_CRITICAL_OPERATION_TIMEOUT]]], failureCtx=FailureContext [type=SYSTEM_WORKER_TERMINATION, err=java.lang.IllegalStateException: Failed to find security context for subject with given ID : 4725544a-f144-4486-a705-46b2ac200011]]
 java.lang.IllegalStateException: Failed to find security context for subject with given ID : 4725544a-f144-4486-a705-46b2ac200011
    at org.apache.ignite.internal.processors.security.IgniteSecurityProcessor.withContext(IgniteSecurityProcessor.java:164) ~[classes/:?]
    at org.apache.ignite.internal.managers.discovery.GridDiscoveryManager$3$SecurityAwareNotificationTask.run(GridDiscoveryManager.java:949) ~[classes/:?]
    at org.apache.ignite.internal.managers.discovery.GridDiscoveryManager$DiscoveryMessageNotifierWorker.body0(GridDiscoveryManager.java:2822) ~[classes/:?]
    at org.apache.ignite.internal.managers.discovery.GridDiscoveryManager$DiscoveryMessageNotifierWorker.body(GridDiscoveryManager.java:2860) [classes/:?]
    at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:125) [classes/:?]
    at java.lang.Thread.run(Thread.java:750) [?:1.8.0_351] {code}
Reproducer is attached.

Simplified steps that leads to the failure:

1. The client node sends an arbitrary discovery message which produces an acknowledgement message when it processed by the all cluster nodes .
2. The client node gracefully leaves the cluster.
3. The new node joins the cluster and receives a topology snapshot that does not include the left client node.
4. The new node receives an acknowledgment for the message from the step 1 and fails during its processing because message originator node is not listed in the current discovery cache or discovery cache history (see IgniteSecurityProcessor#withContext(java.util.UUID)) . This is because currently the GridDiscoveryManager#historicalNode method only aware of the topology history that occurs after a node has joined the cluster. The complete cluster topology history that exists at the time a new node joined the cluster is stored in GridDiscoveryManager#topHist and is not taken into account by the GridDiscoveryManager#historicalNode method.

 ",,ignitetcbot,PetrovMikhail,slava.koptilin,,,"petrov-mg opened a new pull request, #10701:
URL: https://github.com/apache/ignite/pull/10701

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;04/May/23 13:20;githubbot;600","sonarcloud[bot] commented on PR #10701:
URL: https://github.com/apache/ignite/pull/10701#issuecomment-1534802050

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10701)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [1 Code Smell](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list)
   
   


;04/May/23 13:40;githubbot;600","sonarcloud[bot] commented on PR #10701:
URL: https://github.com/apache/ignite/pull/10701#issuecomment-1555876092

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10701)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [1 Code Smell](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list)
   
   


;20/May/23 09:49;githubbot;600","petrov-mg commented on code in PR #10701:
URL: https://github.com/apache/ignite/pull/10701#discussion_r1199705986


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/security/NodeSecurityContextPropagationTest.java:
##########
@@ -0,0 +1,556 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.security;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.UUID;
+import java.util.concurrent.BlockingDeque;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import org.apache.commons.lang3.reflect.FieldUtils;
+import org.apache.ignite.IgniteCheckedException;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.failure.StopNodeOrHaltFailureHandler;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.events.DiscoveryCustomEvent;
+import org.apache.ignite.internal.managers.discovery.CustomMessageWrapper;
+import org.apache.ignite.internal.managers.discovery.DiscoCache;
+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;
+import org.apache.ignite.internal.managers.discovery.GridDiscoveryManager;
+import org.apache.ignite.internal.managers.discovery.SecurityAwareCustomMessageWrapper;
+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;
+import org.apache.ignite.internal.util.typedef.F;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.lang.IgniteUuid;
+import org.apache.ignite.spi.discovery.DiscoverySpi;
+import org.apache.ignite.spi.discovery.DiscoverySpiCustomMessage;
+import org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;
+import org.apache.ignite.spi.discovery.tcp.ipfinder.vm.TcpDiscoveryVmIpFinder;
+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryAbstractMessage;
+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryCustomEventMessage;
+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryNodeAddedMessage;
+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryNodeLeftMessage;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.junit.Test;
+
+import static org.apache.ignite.events.EventType.EVT_NODE_LEFT;
+import static org.apache.ignite.internal.IgniteNodeAttributes.ATTR_IGNITE_INSTANCE_NAME;
+import static org.apache.ignite.internal.events.DiscoveryCustomEvent.EVT_DISCOVERY_CUSTOM_EVT;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;
+
+/** */
+public class NodeSecurityContextPropagationTest extends AbstractSecurityTest {
+    /** */
+    private static final Collection<UUID> TEST_MESSAGE_ACCEPTED_NODES = new HashSet<>();
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return getConfiguration(igniteInstanceName, false);
+    }
+
+    /** */
+    private IgniteConfiguration getConfiguration(String igniteInstanceName, boolean isClient) throws Exception {
+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName)
+            .setFailureHandler(new StopNodeOrHaltFailureHandler())
+            .setDataStorageConfiguration(new DataStorageConfiguration())
+            .setClientMode(isClient)
+            .setLocalEventListeners(
+                Collections.singletonMap(e -> {
+                    DiscoveryCustomEvent discoEvt = (DiscoveryCustomEvent)e;
+
+                    if (discoEvt.customMessage() instanceof TestDiscoveryAcknowledgeMessage)
+                        TEST_MESSAGE_ACCEPTED_NODES.add(discoEvt.node().id());
+
+                    return true;
+                }, new int[] {EVT_DISCOVERY_CUSTOM_EVT})
+            )
+            .setDataStorageConfiguration(new DataStorageConfiguration()
+                .setDefaultDataRegionConfiguration(new DataRegionConfiguration()
+                    .setPersistenceEnabled(true)
+                    .setMaxSize(100L * 1024 * 1024)))
+            .setAuthenticationEnabled(true);
+
+        ((TcpDiscoverySpi)cfg.getDiscoverySpi())
+            .setIpFinder(new TcpDiscoveryVmIpFinder()
+                .setAddresses(Collections.singleton(""127.0.0.1:47500"")));
+
+        return cfg;
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteEx startGrid(int idx) throws Exception {
+        IgniteEx ignite = super.startGrid(idx);
+
+        wrapRingMessageWorkerQueue(ignite);
+
+        return ignite;
+    }
+
+    /** */
+    @Test
+    public void test() throws Exception {
+        IgniteEx crd = startGrid(0);
+
+        IgniteEx cli = startClientNode(11);
+
+        IgniteEx srv = startGrid(1);
+
+        CountDownLatch cliLefEvtProcessedByCoordinator = new CountDownLatch(1);
+
+        crd.events().localListen(
+            evt -> {
+                cliLefEvtProcessedByCoordinator.countDown();
+
+                return true;
+            },
+            EVT_NODE_LEFT
+        );
+
+        discoveryMessageQueue(srv).block();
+
+        long pollingTimeout = U.field(discoveryMessageWorker(srv), ""pollingTimeout"");
+
+        // We need to wait for any active BlockingDeque#poll operation to complete.
+        U.sleep(5 * pollingTimeout);
+
+        cli.context().discovery().sendCustomEvent(new TestDiscoveryMessage());
+
+        waitForCondition(() -> !getReceivedMessages(srv, TestDiscoveryMessage.class).isEmpty(), getTestTimeout());
+
+        runAsync(() -> stopGrid(11));
+
+        cliLefEvtProcessedByCoordinator.await();
+
+        waitForCondition(() -> !getReceivedMessages(srv, TcpDiscoveryNodeLeftMessage.class).isEmpty(), getTestTimeout());
+
+        runAsync(() -> startGrid(2));
+
+        waitForCondition(() -> isNodeAddedMessageReceived(srv, 2), getTestTimeout());
+
+        runAsync(() -> startGrid(3));
+
+        waitForCondition(() -> isNodeAddedMessageReceived(srv, 3), getTestTimeout());
+
+        discoveryMessageQueue(srv).unblock();
+
+        waitForCondition(
+            () -> grid(0).cluster().nodes().size() == 4
+                && TEST_MESSAGE_ACCEPTED_NODES.contains(grid(2).cluster().localNode().id()),
+            getTestTimeout());
+    }
+
+    /** */
+    private IgniteEx startClientNode(int idx) throws Exception {
+        return startGrid(getConfiguration(getTestIgniteInstanceName(idx), true));
+    }
+
+    /** */
+    private boolean isNodeAddedMessageReceived(IgniteEx ignite, int nodeIdx) {

Review Comment:
   I refactored the `getReceivedMessages` method to use `Predicate` as its parameter. This made the test logic a bit clearer. But a separate method for checking whether an arbitrary message is a DiscoveryNodeAddedMessage message sill remains.



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/security/NodeSecurityContextPropagationTest.java:
##########
@@ -0,0 +1,556 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.security;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.UUID;
+import java.util.concurrent.BlockingDeque;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import org.apache.commons.lang3.reflect.FieldUtils;
+import org.apache.ignite.IgniteCheckedException;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.failure.StopNodeOrHaltFailureHandler;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.events.DiscoveryCustomEvent;
+import org.apache.ignite.internal.managers.discovery.CustomMessageWrapper;
+import org.apache.ignite.internal.managers.discovery.DiscoCache;
+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;
+import org.apache.ignite.internal.managers.discovery.GridDiscoveryManager;
+import org.apache.ignite.internal.managers.discovery.SecurityAwareCustomMessageWrapper;
+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;
+import org.apache.ignite.internal.util.typedef.F;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.lang.IgniteUuid;
+import org.apache.ignite.spi.discovery.DiscoverySpi;
+import org.apache.ignite.spi.discovery.DiscoverySpiCustomMessage;
+import org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;
+import org.apache.ignite.spi.discovery.tcp.ipfinder.vm.TcpDiscoveryVmIpFinder;
+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryAbstractMessage;
+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryCustomEventMessage;
+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryNodeAddedMessage;
+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryNodeLeftMessage;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.junit.Test;
+
+import static org.apache.ignite.events.EventType.EVT_NODE_LEFT;
+import static org.apache.ignite.internal.IgniteNodeAttributes.ATTR_IGNITE_INSTANCE_NAME;
+import static org.apache.ignite.internal.events.DiscoveryCustomEvent.EVT_DISCOVERY_CUSTOM_EVT;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;
+
+/** */
+public class NodeSecurityContextPropagationTest extends AbstractSecurityTest {
+    /** */
+    private static final Collection<UUID> TEST_MESSAGE_ACCEPTED_NODES = new HashSet<>();
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return getConfiguration(igniteInstanceName, false);
+    }
+
+    /** */
+    private IgniteConfiguration getConfiguration(String igniteInstanceName, boolean isClient) throws Exception {
+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName)
+            .setFailureHandler(new StopNodeOrHaltFailureHandler())
+            .setDataStorageConfiguration(new DataStorageConfiguration())
+            .setClientMode(isClient)
+            .setLocalEventListeners(
+                Collections.singletonMap(e -> {
+                    DiscoveryCustomEvent discoEvt = (DiscoveryCustomEvent)e;
+
+                    if (discoEvt.customMessage() instanceof TestDiscoveryAcknowledgeMessage)
+                        TEST_MESSAGE_ACCEPTED_NODES.add(discoEvt.node().id());
+
+                    return true;
+                }, new int[] {EVT_DISCOVERY_CUSTOM_EVT})
+            )
+            .setDataStorageConfiguration(new DataStorageConfiguration()
+                .setDefaultDataRegionConfiguration(new DataRegionConfiguration()
+                    .setPersistenceEnabled(true)
+                    .setMaxSize(100L * 1024 * 1024)))
+            .setAuthenticationEnabled(true);
+
+        ((TcpDiscoverySpi)cfg.getDiscoverySpi())
+            .setIpFinder(new TcpDiscoveryVmIpFinder()
+                .setAddresses(Collections.singleton(""127.0.0.1:47500"")));
+
+        return cfg;
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteEx startGrid(int idx) throws Exception {
+        IgniteEx ignite = super.startGrid(idx);
+
+        wrapRingMessageWorkerQueue(ignite);
+
+        return ignite;
+    }
+
+    /** */
+    @Test
+    public void test() throws Exception {
+        IgniteEx crd = startGrid(0);
+
+        IgniteEx cli = startClientNode(11);
+
+        IgniteEx srv = startGrid(1);
+
+        CountDownLatch cliLefEvtProcessedByCoordinator = new CountDownLatch(1);
+
+        crd.events().localListen(
+            evt -> {
+                cliLefEvtProcessedByCoordinator.countDown();
+
+                return true;
+            },
+            EVT_NODE_LEFT
+        );
+
+        discoveryMessageQueue(srv).block();
+
+        long pollingTimeout = U.field(discoveryMessageWorker(srv), ""pollingTimeout"");
+
+        // We need to wait for any active BlockingDeque#poll operation to complete.
+        U.sleep(5 * pollingTimeout);
+
+        cli.context().discovery().sendCustomEvent(new TestDiscoveryMessage());
+
+        waitForCondition(() -> !getReceivedMessages(srv, TestDiscoveryMessage.class).isEmpty(), getTestTimeout());
+
+        runAsync(() -> stopGrid(11));
+
+        cliLefEvtProcessedByCoordinator.await();
+
+        waitForCondition(() -> !getReceivedMessages(srv, TcpDiscoveryNodeLeftMessage.class).isEmpty(), getTestTimeout());
+
+        runAsync(() -> startGrid(2));
+
+        waitForCondition(() -> isNodeAddedMessageReceived(srv, 2), getTestTimeout());
+
+        runAsync(() -> startGrid(3));
+
+        waitForCondition(() -> isNodeAddedMessageReceived(srv, 3), getTestTimeout());
+
+        discoveryMessageQueue(srv).unblock();
+
+        waitForCondition(
+            () -> grid(0).cluster().nodes().size() == 4
+                && TEST_MESSAGE_ACCEPTED_NODES.contains(grid(2).cluster().localNode().id()),
+            getTestTimeout());
+    }
+
+    /** */
+    private IgniteEx startClientNode(int idx) throws Exception {

Review Comment:
   Fixed.



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/security/NodeSecurityContextPropagationTest.java:
##########
@@ -0,0 +1,556 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.security;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.UUID;
+import java.util.concurrent.BlockingDeque;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import org.apache.commons.lang3.reflect.FieldUtils;
+import org.apache.ignite.IgniteCheckedException;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.failure.StopNodeOrHaltFailureHandler;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.events.DiscoveryCustomEvent;
+import org.apache.ignite.internal.managers.discovery.CustomMessageWrapper;
+import org.apache.ignite.internal.managers.discovery.DiscoCache;
+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;
+import org.apache.ignite.internal.managers.discovery.GridDiscoveryManager;
+import org.apache.ignite.internal.managers.discovery.SecurityAwareCustomMessageWrapper;
+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;
+import org.apache.ignite.internal.util.typedef.F;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.lang.IgniteUuid;
+import org.apache.ignite.spi.discovery.DiscoverySpi;
+import org.apache.ignite.spi.discovery.DiscoverySpiCustomMessage;
+import org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;
+import org.apache.ignite.spi.discovery.tcp.ipfinder.vm.TcpDiscoveryVmIpFinder;
+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryAbstractMessage;
+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryCustomEventMessage;
+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryNodeAddedMessage;
+import org.apache.ignite.spi.discovery.tcp.messages.TcpDiscoveryNodeLeftMessage;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.junit.Test;
+
+import static org.apache.ignite.events.EventType.EVT_NODE_LEFT;
+import static org.apache.ignite.internal.IgniteNodeAttributes.ATTR_IGNITE_INSTANCE_NAME;
+import static org.apache.ignite.internal.events.DiscoveryCustomEvent.EVT_DISCOVERY_CUSTOM_EVT;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+import static org.apache.ignite.testframework.GridTestUtils.waitForCondition;
+
+/** */
+public class NodeSecurityContextPropagationTest extends AbstractSecurityTest {
+    /** */
+    private static final Collection<UUID> TEST_MESSAGE_ACCEPTED_NODES = new HashSet<>();
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return getConfiguration(igniteInstanceName, false);
+    }
+
+    /** */
+    private IgniteConfiguration getConfiguration(String igniteInstanceName, boolean isClient) throws Exception {
+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName)
+            .setFailureHandler(new StopNodeOrHaltFailureHandler())
+            .setDataStorageConfiguration(new DataStorageConfiguration())

Review Comment:
   Fixed.
   



;21/May/23 06:40;githubbot;600","petrov-mg commented on code in PR #10701:
URL: https://github.com/apache/ignite/pull/10701#discussion_r1199706055


##########
modules/core/src/main/java/org/apache/ignite/internal/managers/discovery/GridDiscoveryManager.java:
##########
@@ -2678,6 +2678,13 @@ public ClusterNode historicalNode(UUID nodeId) {
                 return node;
         }
 
+        for (Collection<ClusterNode> top : topHist.values()) {

Review Comment:
   Fixed.



;21/May/23 06:40;githubbot;600","sonarcloud[bot] commented on PR #10701:
URL: https://github.com/apache/ignite/pull/10701#issuecomment-1556991355

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10701)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [![B](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/B-16px.png 'B')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [1 Bug](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list)
   
   


;22/May/23 10:46;githubbot;600","sonarcloud[bot] commented on PR #10701:
URL: https://github.com/apache/ignite/pull/10701#issuecomment-1557335173

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10701)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [![B](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/B-16px.png 'B')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [1 Bug](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list)
   
   


;22/May/23 14:35;githubbot;600","sonarcloud[bot] commented on PR #10701:
URL: https://github.com/apache/ignite/pull/10701#issuecomment-1557436949

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10701)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [![B](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/B-16px.png 'B')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [1 Bug](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [1 Code Smell](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list)
   
   


;22/May/23 15:33;githubbot;600","sonarcloud[bot] commented on PR #10701:
URL: https://github.com/apache/ignite/pull/10701#issuecomment-1559387069

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10701)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [![B](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/B-16px.png 'B')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [1 Bug](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list)
   
   


;23/May/23 13:38;githubbot;600","sonarcloud[bot] commented on PR #10701:
URL: https://github.com/apache/ignite/pull/10701#issuecomment-1559415048

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10701)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [![B](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/B-16px.png 'B')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [1 Bug](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list)
   
   


;23/May/23 13:49;githubbot;600","sonarcloud[bot] commented on PR #10701:
URL: https://github.com/apache/ignite/pull/10701#issuecomment-1559499662

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10701)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [![B](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/B-16px.png 'B')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [1 Bug](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list)
   
   


;23/May/23 14:18;githubbot;600","timoninmaxim commented on code in PR #10701:
URL: https://github.com/apache/ignite/pull/10701#discussion_r1200525583


##########
modules/zookeeper/src/main/java/org/apache/ignite/spi/discovery/zk/internal/ZookeeperDiscoveryImpl.java:
##########
@@ -586,7 +586,7 @@ private void notifySegmented() {
                 rtState.evtsData != null ? rtState.evtsData.topVer : 1L,
                 locNode,
                 nodes,
-                Collections.emptyMap(),
+                 Collections.emptyNavigableMap(),

Review Comment:
   Excess whitespace



;23/May/23 15:22;githubbot;600","sonarcloud[bot] commented on PR #10701:
URL: https://github.com/apache/ignite/pull/10701#issuecomment-1559661582

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10701)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [![B](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/B-16px.png 'B')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [1 Bug](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list)
   
   


;23/May/23 15:24;githubbot;600","sonarcloud[bot] commented on PR #10701:
URL: https://github.com/apache/ignite/pull/10701#issuecomment-1559678969

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10701)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [![B](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/B-16px.png 'B')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [1 Bug](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list)
   
   


;23/May/23 15:34;githubbot;600","sonarcloud[bot] commented on PR #10701:
URL: https://github.com/apache/ignite/pull/10701#issuecomment-1559808679

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10701)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [![B](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/B-16px.png 'B')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG) [1 Bug](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10701&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10701&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10701&metric=new_duplicated_lines_density&view=list)
   
   


;23/May/23 16:45;githubbot;600","petrov-mg opened a new pull request, #10748:
URL: https://github.com/apache/ignite/pull/10748

   This reverts commit 17928fe8b7d8c02c29c2a8360f8a3ada479d6a2d.
   
   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;29/May/23 07:54;githubbot;600","sonarcloud[bot] commented on PR #10748:
URL: https://github.com/apache/ignite/pull/10748#issuecomment-1566722433

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10748)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10748&resolved=false&types=BUG) [![B](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/B-16px.png 'B')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10748&resolved=false&types=BUG) [1 Bug](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10748&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10748&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10748&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10748&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10748&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10748&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10748&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10748&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10748&resolved=false&types=CODE_SMELL) [1 Code Smell](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10748&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10748&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10748&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10748&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10748&metric=new_duplicated_lines_density&view=list)
   
   


;29/May/23 08:01;githubbot;600","petrov-mg closed pull request #10748: Revert ""IGNITE-19410 Fixed node crash due to SecurityContext not being found during discovery message processing. (#10701)""
URL: https://github.com/apache/ignite/pull/10748


;06/Jun/23 15:40;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,10800,,,0,10800,,,,,,,,,,,,,,,,,,,,IGNITE-18693,,,,IGNITE-18693,IGNITE-15966,,,,,,"03/May/23 11:59;PetrovMikhail;NodeSecurityContextTest.java;https://issues.apache.org/jira/secure/attachment/13057807/NodeSecurityContextTest.java",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu May 25 08:26:40 UTC 2023,,,,,,,,,,"0|z1hnuo:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"24/May/23 19:40;ignitetcbot;{panel:title=Branch: [pull/10701/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10701/head] Base: [master] : New Tests (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Security{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7188616]]
* {color:#013220}SecurityTestSuite: NodeSecurityContextPropagationTest.testProcessCustomDiscoveryMessageFromLeftNode - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7186616&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","25/May/23 08:26;PetrovMikhail;[~timoninmaxim] Thank you for the review.;;;",,,,
RW index scan may skip entries because of GC,IGNITE-19394,13534658,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ibessonov,ibessonov,ibessonov,02/May/23 07:50,05/May/23 11:59,13/Jul/23 09:11,05/May/23 11:59,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"The problem is in a peek cursor contract.

Right now, SortedIndexLocker#acquireLockNextKey assumes that if ""peek"" returned a value with successfully acquired lock, ""next"" will iterate over the same value.

This is not true, if the result of ""peek"" call was removed by GC. In such case, ""next"" will actually skip the real next value, that should have been returned to the user.

We must introduce a new invariant - ""hasNext"" and ""next"" always take into account latest result of ""peek"", it it's been called *after* previous ""hasNext""/""next"". This will fix the bug.

Tricky concurrent test required.
h4. Tangent issues

Two consecutive calls of ""peek"", before and after the lock, make us scan index twice. Not sure if there's an easy way to reduce the amount of reads though.

Also, RW and RO cursors should probably be implemented differently, forcing all these features into a single implementation is nonsense. RO cursor should never peek anything, it may even throw an exception. This will allow it to have internal cache, for example, making it much more efficient.",,ibessonov,,,,,"ibessonov opened a new pull request, #2021:
URL: https://github.com/apache/ignite-3/pull/2021

   https://issues.apache.org/jira/browse/IGNITE-19394


;04/May/23 07:50;githubbot;600","tkalkirill commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184741354


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -61,8 +54,21 @@ public class TestSortedIndexStorage extends AbstractTestIndexStorage implements
     public TestSortedIndexStorage(int partitionId, SortedIndexDescriptor descriptor) {
         super(partitionId);
 
+        BinaryTupleComparator binaryTupleComparator = new BinaryTupleComparator(descriptor);
+
         this.descriptor = descriptor;
-        this.index = new ConcurrentSkipListMap<>(new BinaryTupleComparator(descriptor));
+        this.index = new ConcurrentSkipListSet<>((indexRow0, indexRow1) -> {

Review Comment:
   A separate class for `Camparator` would be more useful I guess.



##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/AbstractSortedIndexStorageTest.java:
##########
@@ -1506,6 +1505,49 @@ void testScanPeekReplaceRow() {
         assertNull(scan.peek());
     }
 
+    @Test
+    void testScanPeekRemoveNext() {
+        SortedIndexDefinition indexDefinition = SchemaBuilders.sortedIndex(""TEST_IDX"")
+                .addIndexColumn(ColumnType.INT32.typeSpec().name()).asc().done()
+                .build();
+
+        SortedIndexStorage indexStorage = createIndexStorage(indexDefinition);
+
+        BinaryTupleRowSerializer serializer = new BinaryTupleRowSerializer(indexStorage.indexDescriptor());
+
+        PeekCursor<IndexRow> scan = indexStorage.scan(null, null, 0);
+
+        RowId rowId = new RowId(TEST_PARTITION);
+
+        // index  =  [0]
+        // cursor = ^ with no cached row
+        put(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // index  =  [0] [1]

Review Comment:
   I don't think `[1]` is here.



##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -118,23 +122,34 @@ public PeekCursor<IndexRow> scan(
             setEqualityFlag(upperBound);
         }
 
-        NavigableMap<ByteBuffer, NavigableMap<RowId, Object>> navigableMap;
+        NavigableSet<IndexRow> navigableSet;
 
         if (lowerBound == null && upperBound == null) {
-            navigableMap = index;
+            navigableSet = index;
         } else if (lowerBound == null) {
-            navigableMap = index.headMap(upperBound.byteBuffer());
+            navigableSet = index.headSet(prefixToIndexRow(upperBound, highestRowId(partitionId)), true);
         } else if (upperBound == null) {
-            navigableMap = index.tailMap(lowerBound.byteBuffer());
+            navigableSet = index.tailSet(prefixToIndexRow(lowerBound, lowestRowId(partitionId)), true);
         } else {
             try {
-                navigableMap = index.subMap(lowerBound.byteBuffer(), upperBound.byteBuffer());
+                navigableSet = index.subSet(
+                        prefixToIndexRow(lowerBound, lowestRowId(partitionId)),
+                        true,
+                        prefixToIndexRow(upperBound, highestRowId(partitionId)),
+                        true
+                );
             } catch (IllegalArgumentException e) {
-                navigableMap = emptyNavigableMap();
+                navigableSet = emptyNavigableSet();

Review Comment:
   Why is exception handling happening, what can go wrong here?



##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -175,112 +192,54 @@ public void close() {
         public boolean hasNext() {
             checkStorageClosedOrInProcessOfRebalance();
 
-            advanceIfNeeded();
+            if (hasNext != null) {
+                return hasNext;
+            }
+
+            currentRow = peekedRow == NO_PEEKED_ROW ? peek() : peekedRow;
+            peekedRow = NO_PEEKED_ROW;
 
+            hasNext = currentRow != null;
             return hasNext;
         }
 
         @Override
         public IndexRow next() {
-            checkStorageClosedOrInProcessOfRebalance();
-
-            advanceIfNeeded();
-
-            boolean hasNext = this.hasNext;
-
-            if (!hasNext) {
+            if (!hasNext()) {
                 throw new NoSuchElementException();
             }
 
             this.hasNext = null;
 
-            return new IndexRowImpl(new BinaryTuple(descriptor.binaryTupleSchema(), currentEntry.getKey()), rowId);
+            return currentRow;
         }
 
         @Override
         public @Nullable IndexRow peek() {
             checkStorageClosedOrInProcessOfRebalance();
 
             if (hasNext != null) {
-                if (hasNext) {
-                    return new IndexRowImpl(new BinaryTuple(descriptor.binaryTupleSchema(), currentEntry.getKey()), rowId);
-                }
-
-                return null;
+                return currentRow;
             }
 
-            Entry<ByteBuffer, NavigableMap<RowId, Object>> indexMapEntry0 = currentEntry == null ? indexMap.firstEntry() : currentEntry;
-
-            RowId nextRowId = null;
-
-            if (rowId == null) {
-                if (indexMapEntry0 != null) {
-                    nextRowId = getRowId(indexMapEntry0.getValue().firstEntry());
-                }
-            } else {
-                Entry<RowId, Object> nextRowIdEntry = indexMapEntry0.getValue().higherEntry(rowId);
-
-                if (nextRowIdEntry != null) {
-                    nextRowId = nextRowIdEntry.getKey();
-                } else {
-                    indexMapEntry0 = indexMap.higherEntry(indexMapEntry0.getKey());
-
-                    if (indexMapEntry0 != null) {
-                        nextRowId = getRowId(indexMapEntry0.getValue().firstEntry());
-                    }
-                }
-            }
-
-            return nextRowId == null
-                    ? null : new IndexRowImpl(new BinaryTuple(descriptor.binaryTupleSchema(), indexMapEntry0.getKey()), nextRowId);
-        }
-
-        private void advanceIfNeeded() {
-            if (hasNext != null) {
-                return;
-            }
-
-            if (currentEntry == null) {
-                currentEntry = indexMap.firstEntry();
-            }
-
-            if (rowId == null) {
-                if (currentEntry != null) {
-                    rowId = getRowId(currentEntry.getValue().firstEntry());
+            if (currentRow == null) {
+                try {
+                    peekedRow = indexSet.first();
+                } catch (NoSuchElementException e) {
+                    peekedRow = null;

Review Comment:
   Exception logic is an anti-pattern, we can avoid them if we use a `NavigableMap`.



##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/AbstractSortedIndexStorageTest.java:
##########
@@ -1506,6 +1505,49 @@ void testScanPeekReplaceRow() {
         assertNull(scan.peek());
     }
 
+    @Test
+    void testScanPeekRemoveNext() {
+        SortedIndexDefinition indexDefinition = SchemaBuilders.sortedIndex(""TEST_IDX"")
+                .addIndexColumn(ColumnType.INT32.typeSpec().name()).asc().done()
+                .build();
+
+        SortedIndexStorage indexStorage = createIndexStorage(indexDefinition);
+
+        BinaryTupleRowSerializer serializer = new BinaryTupleRowSerializer(indexStorage.indexDescriptor());
+
+        PeekCursor<IndexRow> scan = indexStorage.scan(null, null, 0);
+
+        RowId rowId = new RowId(TEST_PARTITION);
+
+        // index  =  [0]
+        // cursor = ^ with no cached row
+        put(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // index  =  [0] [1]
+        // cursor = ^ with no cached row
+        assertEquals(SimpleRow.of(0, rowId), SimpleRow.of(scan.peek(), firstColumn(serializer)));
+
+        // index  =
+        // cursor = ^ with no cached row (but it remembers the last peek call)
+        remove(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // ""hasNext"" and ""next"" must return the result of last ""peek"" operation. This is crucial for RW scans.
+        assertTrue(scan.hasNext());
+        assertEquals(SimpleRow.of(0, rowId), SimpleRow.of(scan.next(), firstColumn(serializer)));
+
+        // index  =
+        // cursor = ^ with no cached row
+        assertNull(scan.peek());

Review Comment:
   What happens if we insert a new row and call the `peek()`?



##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -72,31 +78,29 @@ public SortedIndexDescriptor indexDescriptor() {
 
     @Override
     Iterator<RowId> getRowIdIteratorForGetByBinaryTuple(BinaryTuple key) {
-        return index.getOrDefault(key.byteBuffer(), emptyNavigableMap()).keySet().iterator();
+        // These must be two different instances, because ""scan"" call messes up headers.
+        BinaryTuplePrefix lowerBound = BinaryTuplePrefix.fromBinaryTuple(key);
+        BinaryTuplePrefix higherBound = BinaryTuplePrefix.fromBinaryTuple(key);
+
+        //noinspection resource
+        return scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL)
+                .stream()
+                .map(IndexRow::rowId)
+                .iterator();

Review Comment:
   As far as I remember, there may be a problem due to row caching inside the stream api when creating an iterator.



;04/May/23 09:23;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184777083


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/AbstractSortedIndexStorageTest.java:
##########
@@ -1506,6 +1505,49 @@ void testScanPeekReplaceRow() {
         assertNull(scan.peek());
     }
 
+    @Test
+    void testScanPeekRemoveNext() {
+        SortedIndexDefinition indexDefinition = SchemaBuilders.sortedIndex(""TEST_IDX"")
+                .addIndexColumn(ColumnType.INT32.typeSpec().name()).asc().done()
+                .build();
+
+        SortedIndexStorage indexStorage = createIndexStorage(indexDefinition);
+
+        BinaryTupleRowSerializer serializer = new BinaryTupleRowSerializer(indexStorage.indexDescriptor());
+
+        PeekCursor<IndexRow> scan = indexStorage.scan(null, null, 0);
+
+        RowId rowId = new RowId(TEST_PARTITION);
+
+        // index  =  [0]
+        // cursor = ^ with no cached row
+        put(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // index  =  [0] [1]

Review Comment:
   That's right, I forgot to remove it, thank you!



##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -61,8 +54,21 @@ public class TestSortedIndexStorage extends AbstractTestIndexStorage implements
     public TestSortedIndexStorage(int partitionId, SortedIndexDescriptor descriptor) {
         super(partitionId);
 
+        BinaryTupleComparator binaryTupleComparator = new BinaryTupleComparator(descriptor);
+
         this.descriptor = descriptor;
-        this.index = new ConcurrentSkipListMap<>(new BinaryTupleComparator(descriptor));
+        this.index = new ConcurrentSkipListSet<>((indexRow0, indexRow1) -> {

Review Comment:
   I'll make the code shorter instead



;04/May/23 09:33;githubbot;600","sashapolo commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184753129


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -61,8 +54,21 @@ public class TestSortedIndexStorage extends AbstractTestIndexStorage implements
     public TestSortedIndexStorage(int partitionId, SortedIndexDescriptor descriptor) {
         super(partitionId);
 
+        BinaryTupleComparator binaryTupleComparator = new BinaryTupleComparator(descriptor);
+
         this.descriptor = descriptor;
-        this.index = new ConcurrentSkipListMap<>(new BinaryTupleComparator(descriptor));
+        this.index = new ConcurrentSkipListSet<>((indexRow0, indexRow1) -> {
+            int cmp = binaryTupleComparator.compare(

Review Comment:
   Can be written shorter:
   ```
   Comparator<IndexRow> comparator = Comparator.comparing((IndexRow row) -> row.indexColumns().byteBuffer(), binaryTupleComparator)
           .thenComparing(IndexRow::rowId);
   ```
           



##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/AbstractTestIndexStorage.java:
##########
@@ -30,6 +30,8 @@
  * Test-only abstract index storage class.
  */
 abstract class AbstractTestIndexStorage implements IndexStorage {
+    protected final int partitionId;

Review Comment:
   This field is only used in `TestSortedIndexStorage` maybe it should be moved there



;04/May/23 09:33;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184777712


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/AbstractSortedIndexStorageTest.java:
##########
@@ -1506,6 +1505,49 @@ void testScanPeekReplaceRow() {
         assertNull(scan.peek());
     }
 
+    @Test
+    void testScanPeekRemoveNext() {
+        SortedIndexDefinition indexDefinition = SchemaBuilders.sortedIndex(""TEST_IDX"")
+                .addIndexColumn(ColumnType.INT32.typeSpec().name()).asc().done()
+                .build();
+
+        SortedIndexStorage indexStorage = createIndexStorage(indexDefinition);
+
+        BinaryTupleRowSerializer serializer = new BinaryTupleRowSerializer(indexStorage.indexDescriptor());
+
+        PeekCursor<IndexRow> scan = indexStorage.scan(null, null, 0);
+
+        RowId rowId = new RowId(TEST_PARTITION);
+
+        // index  =  [0]
+        // cursor = ^ with no cached row
+        put(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // index  =  [0] [1]
+        // cursor = ^ with no cached row
+        assertEquals(SimpleRow.of(0, rowId), SimpleRow.of(scan.peek(), firstColumn(serializer)));
+
+        // index  =
+        // cursor = ^ with no cached row (but it remembers the last peek call)
+        remove(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // ""hasNext"" and ""next"" must return the result of last ""peek"" operation. This is crucial for RW scans.
+        assertTrue(scan.hasNext());
+        assertEquals(SimpleRow.of(0, rowId), SimpleRow.of(scan.next(), firstColumn(serializer)));
+
+        // index  =
+        // cursor = ^ with no cached row
+        assertNull(scan.peek());

Review Comment:
   I think it's already tested in your tests. New row will be returned



;04/May/23 09:34;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184782560


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -72,31 +78,29 @@ public SortedIndexDescriptor indexDescriptor() {
 
     @Override
     Iterator<RowId> getRowIdIteratorForGetByBinaryTuple(BinaryTuple key) {
-        return index.getOrDefault(key.byteBuffer(), emptyNavigableMap()).keySet().iterator();
+        // These must be two different instances, because ""scan"" call messes up headers.
+        BinaryTuplePrefix lowerBound = BinaryTuplePrefix.fromBinaryTuple(key);
+        BinaryTuplePrefix higherBound = BinaryTuplePrefix.fromBinaryTuple(key);
+
+        //noinspection resource
+        return scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL)
+                .stream()
+                .map(IndexRow::rowId)
+                .iterator();

Review Comment:
   This is definitely not tested. You're right, we need to fix it and cover it with tests.



;04/May/23 09:38;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184784848


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -118,23 +122,34 @@ public PeekCursor<IndexRow> scan(
             setEqualityFlag(upperBound);
         }
 
-        NavigableMap<ByteBuffer, NavigableMap<RowId, Object>> navigableMap;
+        NavigableSet<IndexRow> navigableSet;
 
         if (lowerBound == null && upperBound == null) {
-            navigableMap = index;
+            navigableSet = index;
         } else if (lowerBound == null) {
-            navigableMap = index.headMap(upperBound.byteBuffer());
+            navigableSet = index.headSet(prefixToIndexRow(upperBound, highestRowId(partitionId)), true);
         } else if (upperBound == null) {
-            navigableMap = index.tailMap(lowerBound.byteBuffer());
+            navigableSet = index.tailSet(prefixToIndexRow(lowerBound, lowestRowId(partitionId)), true);
         } else {
             try {
-                navigableMap = index.subMap(lowerBound.byteBuffer(), upperBound.byteBuffer());
+                navigableSet = index.subSet(
+                        prefixToIndexRow(lowerBound, lowestRowId(partitionId)),
+                        true,
+                        prefixToIndexRow(upperBound, highestRowId(partitionId)),
+                        true
+                );
             } catch (IllegalArgumentException e) {
-                navigableMap = emptyNavigableMap();
+                navigableSet = emptyNavigableSet();

Review Comment:
   This was here before. Exception may happen if upper bound is below the lower bound.



;04/May/23 09:39;githubbot;600","tkalkirill commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184785303


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/AbstractSortedIndexStorageTest.java:
##########
@@ -1506,6 +1505,49 @@ void testScanPeekReplaceRow() {
         assertNull(scan.peek());
     }
 
+    @Test
+    void testScanPeekRemoveNext() {
+        SortedIndexDefinition indexDefinition = SchemaBuilders.sortedIndex(""TEST_IDX"")
+                .addIndexColumn(ColumnType.INT32.typeSpec().name()).asc().done()
+                .build();
+
+        SortedIndexStorage indexStorage = createIndexStorage(indexDefinition);
+
+        BinaryTupleRowSerializer serializer = new BinaryTupleRowSerializer(indexStorage.indexDescriptor());
+
+        PeekCursor<IndexRow> scan = indexStorage.scan(null, null, 0);
+
+        RowId rowId = new RowId(TEST_PARTITION);
+
+        // index  =  [0]
+        // cursor = ^ with no cached row
+        put(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // index  =  [0] [1]
+        // cursor = ^ with no cached row
+        assertEquals(SimpleRow.of(0, rowId), SimpleRow.of(scan.peek(), firstColumn(serializer)));
+
+        // index  =
+        // cursor = ^ with no cached row (but it remembers the last peek call)
+        remove(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // ""hasNext"" and ""next"" must return the result of last ""peek"" operation. This is crucial for RW scans.
+        assertTrue(scan.hasNext());
+        assertEquals(SimpleRow.of(0, rowId), SimpleRow.of(scan.next(), firstColumn(serializer)));
+
+        // index  =
+        // cursor = ^ with no cached row
+        assertNull(scan.peek());

Review Comment:
   I suggest adding this check so as not to assume.



;04/May/23 09:39;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184785584


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -175,112 +192,54 @@ public void close() {
         public boolean hasNext() {
             checkStorageClosedOrInProcessOfRebalance();
 
-            advanceIfNeeded();
+            if (hasNext != null) {
+                return hasNext;
+            }
+
+            currentRow = peekedRow == NO_PEEKED_ROW ? peek() : peekedRow;
+            peekedRow = NO_PEEKED_ROW;
 
+            hasNext = currentRow != null;
             return hasNext;
         }
 
         @Override
         public IndexRow next() {
-            checkStorageClosedOrInProcessOfRebalance();
-
-            advanceIfNeeded();
-
-            boolean hasNext = this.hasNext;
-
-            if (!hasNext) {
+            if (!hasNext()) {
                 throw new NoSuchElementException();
             }
 
             this.hasNext = null;
 
-            return new IndexRowImpl(new BinaryTuple(descriptor.binaryTupleSchema(), currentEntry.getKey()), rowId);
+            return currentRow;
         }
 
         @Override
         public @Nullable IndexRow peek() {
             checkStorageClosedOrInProcessOfRebalance();
 
             if (hasNext != null) {
-                if (hasNext) {
-                    return new IndexRowImpl(new BinaryTuple(descriptor.binaryTupleSchema(), currentEntry.getKey()), rowId);
-                }
-
-                return null;
+                return currentRow;
             }
 
-            Entry<ByteBuffer, NavigableMap<RowId, Object>> indexMapEntry0 = currentEntry == null ? indexMap.firstEntry() : currentEntry;
-
-            RowId nextRowId = null;
-
-            if (rowId == null) {
-                if (indexMapEntry0 != null) {
-                    nextRowId = getRowId(indexMapEntry0.getValue().firstEntry());
-                }
-            } else {
-                Entry<RowId, Object> nextRowIdEntry = indexMapEntry0.getValue().higherEntry(rowId);
-
-                if (nextRowIdEntry != null) {
-                    nextRowId = nextRowIdEntry.getKey();
-                } else {
-                    indexMapEntry0 = indexMap.higherEntry(indexMapEntry0.getKey());
-
-                    if (indexMapEntry0 != null) {
-                        nextRowId = getRowId(indexMapEntry0.getValue().firstEntry());
-                    }
-                }
-            }
-
-            return nextRowId == null
-                    ? null : new IndexRowImpl(new BinaryTuple(descriptor.binaryTupleSchema(), indexMapEntry0.getKey()), nextRowId);
-        }
-
-        private void advanceIfNeeded() {
-            if (hasNext != null) {
-                return;
-            }
-
-            if (currentEntry == null) {
-                currentEntry = indexMap.firstEntry();
-            }
-
-            if (rowId == null) {
-                if (currentEntry != null) {
-                    rowId = getRowId(currentEntry.getValue().firstEntry());
+            if (currentRow == null) {
+                try {
+                    peekedRow = indexSet.first();
+                } catch (NoSuchElementException e) {
+                    peekedRow = null;

Review Comment:
   Why is this an anti-pattern, if I use Java API the way it's intended to be used?
   I think that using Map instead of Set is anti-pattern



##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/AbstractTestIndexStorage.java:
##########
@@ -30,6 +30,8 @@
  * Test-only abstract index storage class.
  */
 abstract class AbstractTestIndexStorage implements IndexStorage {
+    protected final int partitionId;

Review Comment:
   Ok



;04/May/23 09:40;githubbot;600","tkalkirill commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184787821


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -118,23 +122,34 @@ public PeekCursor<IndexRow> scan(
             setEqualityFlag(upperBound);
         }
 
-        NavigableMap<ByteBuffer, NavigableMap<RowId, Object>> navigableMap;
+        NavigableSet<IndexRow> navigableSet;
 
         if (lowerBound == null && upperBound == null) {
-            navigableMap = index;
+            navigableSet = index;
         } else if (lowerBound == null) {
-            navigableMap = index.headMap(upperBound.byteBuffer());
+            navigableSet = index.headSet(prefixToIndexRow(upperBound, highestRowId(partitionId)), true);
         } else if (upperBound == null) {
-            navigableMap = index.tailMap(lowerBound.byteBuffer());
+            navigableSet = index.tailSet(prefixToIndexRow(lowerBound, lowestRowId(partitionId)), true);
         } else {
             try {
-                navigableMap = index.subMap(lowerBound.byteBuffer(), upperBound.byteBuffer());
+                navigableSet = index.subSet(
+                        prefixToIndexRow(lowerBound, lowestRowId(partitionId)),
+                        true,
+                        prefixToIndexRow(upperBound, highestRowId(partitionId)),
+                        true
+                );
             } catch (IllegalArgumentException e) {
-                navigableMap = emptyNavigableMap();
+                navigableSet = emptyNavigableSet();

Review Comment:
   Please leave a comment.



;04/May/23 09:42;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184788936


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/AbstractSortedIndexStorageTest.java:
##########
@@ -1506,6 +1505,49 @@ void testScanPeekReplaceRow() {
         assertNull(scan.peek());
     }
 
+    @Test
+    void testScanPeekRemoveNext() {
+        SortedIndexDefinition indexDefinition = SchemaBuilders.sortedIndex(""TEST_IDX"")
+                .addIndexColumn(ColumnType.INT32.typeSpec().name()).asc().done()
+                .build();
+
+        SortedIndexStorage indexStorage = createIndexStorage(indexDefinition);
+
+        BinaryTupleRowSerializer serializer = new BinaryTupleRowSerializer(indexStorage.indexDescriptor());
+
+        PeekCursor<IndexRow> scan = indexStorage.scan(null, null, 0);
+
+        RowId rowId = new RowId(TEST_PARTITION);
+
+        // index  =  [0]
+        // cursor = ^ with no cached row
+        put(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // index  =  [0] [1]
+        // cursor = ^ with no cached row
+        assertEquals(SimpleRow.of(0, rowId), SimpleRow.of(scan.peek(), firstColumn(serializer)));
+
+        // index  =
+        // cursor = ^ with no cached row (but it remembers the last peek call)
+        remove(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // ""hasNext"" and ""next"" must return the result of last ""peek"" operation. This is crucial for RW scans.
+        assertTrue(scan.hasNext());
+        assertEquals(SimpleRow.of(0, rowId), SimpleRow.of(scan.next(), firstColumn(serializer)));
+
+        // index  =
+        // cursor = ^ with no cached row
+        assertNull(scan.peek());

Review Comment:
   It is covered in `testScanPeekForFinishedCursor`. I don't want to duplicate test scenarios for no reason



;04/May/23 09:43;githubbot;600","tkalkirill commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184789186


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -175,112 +192,54 @@ public void close() {
         public boolean hasNext() {
             checkStorageClosedOrInProcessOfRebalance();
 
-            advanceIfNeeded();
+            if (hasNext != null) {
+                return hasNext;
+            }
+
+            currentRow = peekedRow == NO_PEEKED_ROW ? peek() : peekedRow;
+            peekedRow = NO_PEEKED_ROW;
 
+            hasNext = currentRow != null;
             return hasNext;
         }
 
         @Override
         public IndexRow next() {
-            checkStorageClosedOrInProcessOfRebalance();
-
-            advanceIfNeeded();
-
-            boolean hasNext = this.hasNext;
-
-            if (!hasNext) {
+            if (!hasNext()) {
                 throw new NoSuchElementException();
             }
 
             this.hasNext = null;
 
-            return new IndexRowImpl(new BinaryTuple(descriptor.binaryTupleSchema(), currentEntry.getKey()), rowId);
+            return currentRow;
         }
 
         @Override
         public @Nullable IndexRow peek() {
             checkStorageClosedOrInProcessOfRebalance();
 
             if (hasNext != null) {
-                if (hasNext) {
-                    return new IndexRowImpl(new BinaryTuple(descriptor.binaryTupleSchema(), currentEntry.getKey()), rowId);
-                }
-
-                return null;
+                return currentRow;
             }
 
-            Entry<ByteBuffer, NavigableMap<RowId, Object>> indexMapEntry0 = currentEntry == null ? indexMap.firstEntry() : currentEntry;
-
-            RowId nextRowId = null;
-
-            if (rowId == null) {
-                if (indexMapEntry0 != null) {
-                    nextRowId = getRowId(indexMapEntry0.getValue().firstEntry());
-                }
-            } else {
-                Entry<RowId, Object> nextRowIdEntry = indexMapEntry0.getValue().higherEntry(rowId);
-
-                if (nextRowIdEntry != null) {
-                    nextRowId = nextRowIdEntry.getKey();
-                } else {
-                    indexMapEntry0 = indexMap.higherEntry(indexMapEntry0.getKey());
-
-                    if (indexMapEntry0 != null) {
-                        nextRowId = getRowId(indexMapEntry0.getValue().firstEntry());
-                    }
-                }
-            }
-
-            return nextRowId == null
-                    ? null : new IndexRowImpl(new BinaryTuple(descriptor.binaryTupleSchema(), indexMapEntry0.getKey()), nextRowId);
-        }
-
-        private void advanceIfNeeded() {
-            if (hasNext != null) {
-                return;
-            }
-
-            if (currentEntry == null) {
-                currentEntry = indexMap.firstEntry();
-            }
-
-            if (rowId == null) {
-                if (currentEntry != null) {
-                    rowId = getRowId(currentEntry.getValue().firstEntry());
+            if (currentRow == null) {
+                try {
+                    peekedRow = indexSet.first();
+                } catch (NoSuchElementException e) {
+                    peekedRow = null;

Review Comment:
   If you use a map, then it can return `null` instead of an exception, this is better and more performant.



;04/May/23 09:43;githubbot;600","tkalkirill commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184791475


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/AbstractSortedIndexStorageTest.java:
##########
@@ -1506,6 +1505,49 @@ void testScanPeekReplaceRow() {
         assertNull(scan.peek());
     }
 
+    @Test
+    void testScanPeekRemoveNext() {
+        SortedIndexDefinition indexDefinition = SchemaBuilders.sortedIndex(""TEST_IDX"")
+                .addIndexColumn(ColumnType.INT32.typeSpec().name()).asc().done()
+                .build();
+
+        SortedIndexStorage indexStorage = createIndexStorage(indexDefinition);
+
+        BinaryTupleRowSerializer serializer = new BinaryTupleRowSerializer(indexStorage.indexDescriptor());
+
+        PeekCursor<IndexRow> scan = indexStorage.scan(null, null, 0);
+
+        RowId rowId = new RowId(TEST_PARTITION);
+
+        // index  =  [0]
+        // cursor = ^ with no cached row
+        put(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // index  =  [0] [1]
+        // cursor = ^ with no cached row
+        assertEquals(SimpleRow.of(0, rowId), SimpleRow.of(scan.peek(), firstColumn(serializer)));
+
+        // index  =
+        // cursor = ^ with no cached row (but it remembers the last peek call)
+        remove(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // ""hasNext"" and ""next"" must return the result of last ""peek"" operation. This is crucial for RW scans.
+        assertTrue(scan.hasNext());
+        assertEquals(SimpleRow.of(0, rowId), SimpleRow.of(scan.next(), firstColumn(serializer)));
+
+        // index  =
+        // cursor = ^ with no cached row
+        assertNull(scan.peek());

Review Comment:
   Then why a new test, can you improve the current ones?



;04/May/23 09:45;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184793864


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -72,31 +78,29 @@ public SortedIndexDescriptor indexDescriptor() {
 
     @Override
     Iterator<RowId> getRowIdIteratorForGetByBinaryTuple(BinaryTuple key) {
-        return index.getOrDefault(key.byteBuffer(), emptyNavigableMap()).keySet().iterator();
+        // These must be two different instances, because ""scan"" call messes up headers.
+        BinaryTuplePrefix lowerBound = BinaryTuplePrefix.fromBinaryTuple(key);
+        BinaryTuplePrefix higherBound = BinaryTuplePrefix.fromBinaryTuple(key);
+
+        //noinspection resource
+        return scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL)
+                .stream()
+                .map(IndexRow::rowId)
+                .iterator();

Review Comment:
   By the way, this property is already violated in hash indexes



;04/May/23 09:48;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184799821


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/AbstractSortedIndexStorageTest.java:
##########
@@ -1506,6 +1505,49 @@ void testScanPeekReplaceRow() {
         assertNull(scan.peek());
     }
 
+    @Test
+    void testScanPeekRemoveNext() {
+        SortedIndexDefinition indexDefinition = SchemaBuilders.sortedIndex(""TEST_IDX"")
+                .addIndexColumn(ColumnType.INT32.typeSpec().name()).asc().done()
+                .build();
+
+        SortedIndexStorage indexStorage = createIndexStorage(indexDefinition);
+
+        BinaryTupleRowSerializer serializer = new BinaryTupleRowSerializer(indexStorage.indexDescriptor());
+
+        PeekCursor<IndexRow> scan = indexStorage.scan(null, null, 0);
+
+        RowId rowId = new RowId(TEST_PARTITION);
+
+        // index  =  [0]
+        // cursor = ^ with no cached row
+        put(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // index  =  [0] [1]
+        // cursor = ^ with no cached row
+        assertEquals(SimpleRow.of(0, rowId), SimpleRow.of(scan.peek(), firstColumn(serializer)));
+
+        // index  =
+        // cursor = ^ with no cached row (but it remembers the last peek call)
+        remove(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // ""hasNext"" and ""next"" must return the result of last ""peek"" operation. This is crucial for RW scans.
+        assertTrue(scan.hasNext());
+        assertEquals(SimpleRow.of(0, rowId), SimpleRow.of(scan.next(), firstColumn(serializer)));
+
+        // index  =
+        // cursor = ^ with no cached row
+        assertNull(scan.peek());

Review Comment:
   Current test is already too long. I test specific contract in this smaller test.



;04/May/23 09:52;githubbot;600","tkalkirill commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184801914


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -72,31 +78,29 @@ public SortedIndexDescriptor indexDescriptor() {
 
     @Override
     Iterator<RowId> getRowIdIteratorForGetByBinaryTuple(BinaryTuple key) {
-        return index.getOrDefault(key.byteBuffer(), emptyNavigableMap()).keySet().iterator();
+        // These must be two different instances, because ""scan"" call messes up headers.
+        BinaryTuplePrefix lowerBound = BinaryTuplePrefix.fromBinaryTuple(key);
+        BinaryTuplePrefix higherBound = BinaryTuplePrefix.fromBinaryTuple(key);
+
+        //noinspection resource
+        return scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL)
+                .stream()
+                .map(IndexRow::rowId)
+                .iterator();

Review Comment:
   That's no reason not to fix it.



;04/May/23 09:54;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184804387


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -118,23 +122,34 @@ public PeekCursor<IndexRow> scan(
             setEqualityFlag(upperBound);
         }
 
-        NavigableMap<ByteBuffer, NavigableMap<RowId, Object>> navigableMap;
+        NavigableSet<IndexRow> navigableSet;
 
         if (lowerBound == null && upperBound == null) {
-            navigableMap = index;
+            navigableSet = index;
         } else if (lowerBound == null) {
-            navigableMap = index.headMap(upperBound.byteBuffer());
+            navigableSet = index.headSet(prefixToIndexRow(upperBound, highestRowId(partitionId)), true);
         } else if (upperBound == null) {
-            navigableMap = index.tailMap(lowerBound.byteBuffer());
+            navigableSet = index.tailSet(prefixToIndexRow(lowerBound, lowestRowId(partitionId)), true);
         } else {
             try {
-                navigableMap = index.subMap(lowerBound.byteBuffer(), upperBound.byteBuffer());
+                navigableSet = index.subSet(
+                        prefixToIndexRow(lowerBound, lowestRowId(partitionId)),
+                        true,
+                        prefixToIndexRow(upperBound, highestRowId(partitionId)),
+                        true
+                );
             } catch (IllegalArgumentException e) {
-                navigableMap = emptyNavigableMap();
+                navigableSet = emptyNavigableSet();

Review Comment:
   `subSet` documentation is explicit about it, but ok, I'll add a comment.



;04/May/23 09:57;githubbot;600","tkalkirill commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184804188


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -83,10 +79,19 @@ Iterator<RowId> getRowIdIteratorForGetByBinaryTuple(BinaryTuple key) {
         BinaryTuplePrefix higherBound = BinaryTuplePrefix.fromBinaryTuple(key);
 
         //noinspection resource
-        return scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL)
-                .stream()
-                .map(IndexRow::rowId)
-                .iterator();
+        PeekCursor<IndexRow> peekCursor = scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL);
+
+        return new Iterator<>() {

Review Comment:
   Why an inner class and not a method or a separate class.
   You can use for example `org.apache.ignite.internal.util.CollectionUtils#viewReadOnly(java.util.Collection<? extends T1>, java.util.function.Function<? super T1,? extends T2>)`.



;04/May/23 09:57;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184806989


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -175,112 +192,54 @@ public void close() {
         public boolean hasNext() {
             checkStorageClosedOrInProcessOfRebalance();
 
-            advanceIfNeeded();
+            if (hasNext != null) {
+                return hasNext;
+            }
+
+            currentRow = peekedRow == NO_PEEKED_ROW ? peek() : peekedRow;
+            peekedRow = NO_PEEKED_ROW;
 
+            hasNext = currentRow != null;
             return hasNext;
         }
 
         @Override
         public IndexRow next() {
-            checkStorageClosedOrInProcessOfRebalance();
-
-            advanceIfNeeded();
-
-            boolean hasNext = this.hasNext;
-
-            if (!hasNext) {
+            if (!hasNext()) {
                 throw new NoSuchElementException();
             }
 
             this.hasNext = null;
 
-            return new IndexRowImpl(new BinaryTuple(descriptor.binaryTupleSchema(), currentEntry.getKey()), rowId);
+            return currentRow;
         }
 
         @Override
         public @Nullable IndexRow peek() {
             checkStorageClosedOrInProcessOfRebalance();
 
             if (hasNext != null) {
-                if (hasNext) {
-                    return new IndexRowImpl(new BinaryTuple(descriptor.binaryTupleSchema(), currentEntry.getKey()), rowId);
-                }
-
-                return null;
+                return currentRow;
             }
 
-            Entry<ByteBuffer, NavigableMap<RowId, Object>> indexMapEntry0 = currentEntry == null ? indexMap.firstEntry() : currentEntry;
-
-            RowId nextRowId = null;
-
-            if (rowId == null) {
-                if (indexMapEntry0 != null) {
-                    nextRowId = getRowId(indexMapEntry0.getValue().firstEntry());
-                }
-            } else {
-                Entry<RowId, Object> nextRowIdEntry = indexMapEntry0.getValue().higherEntry(rowId);
-
-                if (nextRowIdEntry != null) {
-                    nextRowId = nextRowIdEntry.getKey();
-                } else {
-                    indexMapEntry0 = indexMap.higherEntry(indexMapEntry0.getKey());
-
-                    if (indexMapEntry0 != null) {
-                        nextRowId = getRowId(indexMapEntry0.getValue().firstEntry());
-                    }
-                }
-            }
-
-            return nextRowId == null
-                    ? null : new IndexRowImpl(new BinaryTuple(descriptor.binaryTupleSchema(), indexMapEntry0.getKey()), nextRowId);
-        }
-
-        private void advanceIfNeeded() {
-            if (hasNext != null) {
-                return;
-            }
-
-            if (currentEntry == null) {
-                currentEntry = indexMap.firstEntry();
-            }
-
-            if (rowId == null) {
-                if (currentEntry != null) {
-                    rowId = getRowId(currentEntry.getValue().firstEntry());
+            if (currentRow == null) {
+                try {
+                    peekedRow = indexSet.first();
+                } catch (NoSuchElementException e) {
+                    peekedRow = null;

Review Comment:
   I wouldn't use the performance argument in such case, it's too preliminary.
   > it can return null instead of an exception
   
   Ok, why is it better? Is this really a good reason to use the structure that doesn't fit my goals?



;04/May/23 09:59;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184806989


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -175,112 +192,54 @@ public void close() {
         public boolean hasNext() {
             checkStorageClosedOrInProcessOfRebalance();
 
-            advanceIfNeeded();
+            if (hasNext != null) {
+                return hasNext;
+            }
+
+            currentRow = peekedRow == NO_PEEKED_ROW ? peek() : peekedRow;
+            peekedRow = NO_PEEKED_ROW;
 
+            hasNext = currentRow != null;
             return hasNext;
         }
 
         @Override
         public IndexRow next() {
-            checkStorageClosedOrInProcessOfRebalance();
-
-            advanceIfNeeded();
-
-            boolean hasNext = this.hasNext;
-
-            if (!hasNext) {
+            if (!hasNext()) {
                 throw new NoSuchElementException();
             }
 
             this.hasNext = null;
 
-            return new IndexRowImpl(new BinaryTuple(descriptor.binaryTupleSchema(), currentEntry.getKey()), rowId);
+            return currentRow;
         }
 
         @Override
         public @Nullable IndexRow peek() {
             checkStorageClosedOrInProcessOfRebalance();
 
             if (hasNext != null) {
-                if (hasNext) {
-                    return new IndexRowImpl(new BinaryTuple(descriptor.binaryTupleSchema(), currentEntry.getKey()), rowId);
-                }
-
-                return null;
+                return currentRow;
             }
 
-            Entry<ByteBuffer, NavigableMap<RowId, Object>> indexMapEntry0 = currentEntry == null ? indexMap.firstEntry() : currentEntry;
-
-            RowId nextRowId = null;
-
-            if (rowId == null) {
-                if (indexMapEntry0 != null) {
-                    nextRowId = getRowId(indexMapEntry0.getValue().firstEntry());
-                }
-            } else {
-                Entry<RowId, Object> nextRowIdEntry = indexMapEntry0.getValue().higherEntry(rowId);
-
-                if (nextRowIdEntry != null) {
-                    nextRowId = nextRowIdEntry.getKey();
-                } else {
-                    indexMapEntry0 = indexMap.higherEntry(indexMapEntry0.getKey());
-
-                    if (indexMapEntry0 != null) {
-                        nextRowId = getRowId(indexMapEntry0.getValue().firstEntry());
-                    }
-                }
-            }
-
-            return nextRowId == null
-                    ? null : new IndexRowImpl(new BinaryTuple(descriptor.binaryTupleSchema(), indexMapEntry0.getKey()), nextRowId);
-        }
-
-        private void advanceIfNeeded() {
-            if (hasNext != null) {
-                return;
-            }
-
-            if (currentEntry == null) {
-                currentEntry = indexMap.firstEntry();
-            }
-
-            if (rowId == null) {
-                if (currentEntry != null) {
-                    rowId = getRowId(currentEntry.getValue().firstEntry());
+            if (currentRow == null) {
+                try {
+                    peekedRow = indexSet.first();
+                } catch (NoSuchElementException e) {
+                    peekedRow = null;

Review Comment:
   I wouldn't use the performance argument in such case, it's too preliminary.
   > it can return null instead of an exception, this is better ...
   
   Ok, why is it better? Is this really a good reason to use the structure that doesn't fit my goals?



;04/May/23 10:00;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184808166


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -83,10 +79,19 @@ Iterator<RowId> getRowIdIteratorForGetByBinaryTuple(BinaryTuple key) {
         BinaryTuplePrefix higherBound = BinaryTuplePrefix.fromBinaryTuple(key);
 
         //noinspection resource
-        return scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL)
-                .stream()
-                .map(IndexRow::rowId)
-                .iterator();
+        PeekCursor<IndexRow> peekCursor = scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL);
+
+        return new Iterator<>() {

Review Comment:
   Ok, I'll use ""viewReadOnly"", I forgot about its existence.



;04/May/23 10:01;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184809717


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -83,10 +79,19 @@ Iterator<RowId> getRowIdIteratorForGetByBinaryTuple(BinaryTuple key) {
         BinaryTuplePrefix higherBound = BinaryTuplePrefix.fromBinaryTuple(key);
 
         //noinspection resource
-        return scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL)
-                .stream()
-                .map(IndexRow::rowId)
-                .iterator();
+        PeekCursor<IndexRow> peekCursor = scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL);
+
+        return new Iterator<>() {

Review Comment:
   Wait a minute, it uses a collection, not iterator.
   I used anonymous class because it's small. It's the same approach that's used in `org.apache.ignite.internal.storage.index.impl.AbstractTestIndexStorage#get`, for example, do you have issues with that code?



;04/May/23 10:02;githubbot;600","tkalkirill commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184810811


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/AbstractSortedIndexStorageTest.java:
##########
@@ -1506,6 +1505,49 @@ void testScanPeekReplaceRow() {
         assertNull(scan.peek());
     }
 
+    @Test
+    void testScanPeekRemoveNext() {
+        SortedIndexDefinition indexDefinition = SchemaBuilders.sortedIndex(""TEST_IDX"")
+                .addIndexColumn(ColumnType.INT32.typeSpec().name()).asc().done()
+                .build();
+
+        SortedIndexStorage indexStorage = createIndexStorage(indexDefinition);
+
+        BinaryTupleRowSerializer serializer = new BinaryTupleRowSerializer(indexStorage.indexDescriptor());
+
+        PeekCursor<IndexRow> scan = indexStorage.scan(null, null, 0);
+
+        RowId rowId = new RowId(TEST_PARTITION);
+
+        // index  =  [0]
+        // cursor = ^ with no cached row
+        put(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // index  =  [0] [1]
+        // cursor = ^ with no cached row
+        assertEquals(SimpleRow.of(0, rowId), SimpleRow.of(scan.peek(), firstColumn(serializer)));
+
+        // index  =
+        // cursor = ^ with no cached row (but it remembers the last peek call)
+        remove(indexStorage, serializer.serializeRow(new Object[]{0}, rowId));
+
+        // ""hasNext"" and ""next"" must return the result of last ""peek"" operation. This is crucial for RW scans.
+        assertTrue(scan.hasNext());
+        assertEquals(SimpleRow.of(0, rowId), SimpleRow.of(scan.next(), firstColumn(serializer)));
+
+        // index  =
+        // cursor = ^ with no cached row
+        assertNull(scan.peek());

Review Comment:
   I looked at `testScanPeekForFinishedCursor`, it checks my question.



;04/May/23 10:03;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184811160


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -72,31 +78,29 @@ public SortedIndexDescriptor indexDescriptor() {
 
     @Override
     Iterator<RowId> getRowIdIteratorForGetByBinaryTuple(BinaryTuple key) {
-        return index.getOrDefault(key.byteBuffer(), emptyNavigableMap()).keySet().iterator();
+        // These must be two different instances, because ""scan"" call messes up headers.
+        BinaryTuplePrefix lowerBound = BinaryTuplePrefix.fromBinaryTuple(key);
+        BinaryTuplePrefix higherBound = BinaryTuplePrefix.fromBinaryTuple(key);
+
+        //noinspection resource
+        return scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL)
+                .stream()
+                .map(IndexRow::rowId)
+                .iterator();

Review Comment:
   I fixed it actually. Should I add tests here or in a separate issue?



;04/May/23 10:04;githubbot;600","tkalkirill commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184812297


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -72,31 +78,29 @@ public SortedIndexDescriptor indexDescriptor() {
 
     @Override
     Iterator<RowId> getRowIdIteratorForGetByBinaryTuple(BinaryTuple key) {
-        return index.getOrDefault(key.byteBuffer(), emptyNavigableMap()).keySet().iterator();
+        // These must be two different instances, because ""scan"" call messes up headers.
+        BinaryTuplePrefix lowerBound = BinaryTuplePrefix.fromBinaryTuple(key);
+        BinaryTuplePrefix higherBound = BinaryTuplePrefix.fromBinaryTuple(key);
+
+        //noinspection resource
+        return scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL)
+                .stream()
+                .map(IndexRow::rowId)
+                .iterator();

Review Comment:
   I think since you fixed it here, then you need to test it here.



;04/May/23 10:05;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184813457


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -72,31 +78,29 @@ public SortedIndexDescriptor indexDescriptor() {
 
     @Override
     Iterator<RowId> getRowIdIteratorForGetByBinaryTuple(BinaryTuple key) {
-        return index.getOrDefault(key.byteBuffer(), emptyNavigableMap()).keySet().iterator();
+        // These must be two different instances, because ""scan"" call messes up headers.
+        BinaryTuplePrefix lowerBound = BinaryTuplePrefix.fromBinaryTuple(key);
+        BinaryTuplePrefix higherBound = BinaryTuplePrefix.fromBinaryTuple(key);
+
+        //noinspection resource
+        return scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL)
+                .stream()
+                .map(IndexRow::rowId)
+                .iterator();

Review Comment:
   Great



;04/May/23 10:06;githubbot;600","tkalkirill commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184816510


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -83,10 +79,19 @@ Iterator<RowId> getRowIdIteratorForGetByBinaryTuple(BinaryTuple key) {
         BinaryTuplePrefix higherBound = BinaryTuplePrefix.fromBinaryTuple(key);
 
         //noinspection resource
-        return scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL)
-                .stream()
-                .map(IndexRow::rowId)
-                .iterator();
+        PeekCursor<IndexRow> peekCursor = scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL);
+
+        return new Iterator<>() {

Review Comment:
   Exactly, nothing will stop us from doing a similar method but for iterators.
   
   If this approach is used in `AbstractTestIndexStorage#get`, this does not mean that it is good, I think you should not foul the code with an anonymous class, but use a separate method / class.



;04/May/23 10:08;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1184838881


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -83,10 +79,19 @@ Iterator<RowId> getRowIdIteratorForGetByBinaryTuple(BinaryTuple key) {
         BinaryTuplePrefix higherBound = BinaryTuplePrefix.fromBinaryTuple(key);
 
         //noinspection resource
-        return scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL)
-                .stream()
-                .map(IndexRow::rowId)
-                .iterator();
+        PeekCursor<IndexRow> peekCursor = scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL);
+
+        return new Iterator<>() {

Review Comment:
   Ok, I'll fix it then, not a big deal



;04/May/23 10:33;githubbot;600","ibessonov commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1185144101


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/impl/TestSortedIndexStorage.java:
##########
@@ -72,31 +78,29 @@ public SortedIndexDescriptor indexDescriptor() {
 
     @Override
     Iterator<RowId> getRowIdIteratorForGetByBinaryTuple(BinaryTuple key) {
-        return index.getOrDefault(key.byteBuffer(), emptyNavigableMap()).keySet().iterator();
+        // These must be two different instances, because ""scan"" call messes up headers.
+        BinaryTuplePrefix lowerBound = BinaryTuplePrefix.fromBinaryTuple(key);
+        BinaryTuplePrefix higherBound = BinaryTuplePrefix.fromBinaryTuple(key);
+
+        //noinspection resource
+        return scan(lowerBound, higherBound, GREATER_OR_EQUAL | LESS_OR_EQUAL)
+                .stream()
+                .map(IndexRow::rowId)
+                .iterator();

Review Comment:
   That's too much work. I added a test and created issue to fix all storages: https://issues.apache.org/jira/browse/IGNITE-19422



;04/May/23 14:55;githubbot;600","tkalkirill commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1185126021


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/AbstractSortedIndexStorageTest.java:
##########
@@ -238,40 +162,11 @@ void testRowSerialization() {
 
     @Test
     void testEmpty() {
-        SortedIndexStorage index = createIndexStorage(shuffledRandomDefinitions());
+        SortedIndexStorage index = createIndexStorage(""TEST_IDX"", shuffledRandomDefinitions());

Review Comment:
   ```suggestion
           SortedIndexStorage index = createIndexStorage(INDEX_NAME"", shuffledRandomDefinitions());
   ```



##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/AbstractSortedIndexStorageTest.java:
##########
@@ -1539,7 +1375,7 @@ private List<ColumnDefinition> shuffledDefinitions(Predicate<ColumnDefinition> f
      * be removed.
      */
     private void testPutGetRemove(List<ColumnDefinition> indexSchema) {
-        SortedIndexStorage indexStorage = createIndexStorage(indexSchema);
+        SortedIndexStorage indexStorage = createIndexStorage(""TEST_IDX"", indexSchema);

Review Comment:
   ```suggestion
           SortedIndexStorage indexStorage = createIndexStorage(INDEX_NAME, indexSchema);
   ```



;04/May/23 16:30;githubbot;600","tkalkirill commented on code in PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021#discussion_r1185865922


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/index/AbstractSortedIndexStorageTest.java:
##########
@@ -215,12 +134,17 @@ protected SortedIndexStorage createIndexStorage(ColumnarIndexDefinition indexDef
         return tableStorage.getOrCreateSortedIndex(TEST_PARTITION, indexConfig.id());
     }
 
+    @Override
+    protected SortedIndexDescriptor indexDescriptor(SortedIndexStorage index) {
+        return index.indexDescriptor();
+    }
+
     /**
      * Tests that columns of all types are correctly serialized and deserialized.
      */
     @Test
     void testRowSerialization() {
-        SortedIndexStorage indexStorage = createIndexStorage(ALL_TYPES_COLUMN_DEFINITIONS);
+        SortedIndexStorage indexStorage = createIndexStorage(""TEST_IDX"", ALL_TYPES_COLUMN_DEFINITIONS);

Review Comment:
   ```suggestion
           SortedIndexStorage indexStorage = createIndexStorage(INDEX_NAME, ALL_TYPES_COLUMN_DEFINITIONS);
   ```



;05/May/23 09:12;githubbot;600","ibessonov merged PR #2021:
URL: https://github.com/apache/ignite-3/pull/2021


;05/May/23 11:59;githubbot;600",,,,,,,,,,,,,,,0,19200,,,0,19200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17304,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,2023-05-02 07:50:50.0,,,,,,,,,,"0|z1hmt4:",9223372036854775807,,,apolovtcev,,,,,,,,,,,,,,,,,,,,,,,
Java thin 3.0: testAccessLockedKeyTimesOut is flaky,IGNITE-19393,13534656,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,v.pyatkov,ptupitsyn,ptupitsyn,02/May/23 07:43,03/Jul/23 12:42,13/Jul/23 09:11,03/Jul/23 07:50,3.0.0-beta1,,,,,,,3.0.0-beta2,thin client,,,0,ignite-3,,,"{code:java}
java.lang.AssertionError: 
Expected: a string containing ""Replication is timed out""
     but: was ""IGN-TX-4 TraceId:d54813d7-793a-4d81-9456-b7140cee2209 IGN-TX-4 TraceId:d54813d7-793a-4d81-9456-b7140cee2209 IGN-TX-4 TraceId:d54813d7-793a-4d81-9456-b7140cee2209 Failed to acquire a lock due to a conflict [txId=00000187-db61-2a99-0000-0000bb66f319, conflictingWaiter=WaiterImpl [txId=00000187-db61-2a99-0000-0000bb66f318, intendedLockMode=null, lockMode=X, ex=null, isDone=true]]""
java.lang.AssertionError:
Expected: a string containing ""Replication is timed out""
     but: was ""IGN-TX-4 TraceId:d54813d7-793a-4d81-9456-b7140cee2209 IGN-TX-4 TraceId:d54813d7-793a-4d81-9456-b7140cee2209 IGN-TX-4 TraceId:d54813d7-793a-4d81-9456-b7140cee2209 Failed to acquire a lock due to a conflict [txId=00000187-db61-2a99-0000-0000bb66f319, conflictingWaiter=WaiterImpl [txId=00000187-db61-2a99-0000-0000bb66f318, intendedLockMode=null, lockMode=X, ex=null, isDone=true]]""
  at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)
  at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:6)
  at org.apache.ignite.internal.runner.app.client.ItThinClientTransactionsTest.testAccessLockedKeyTimesOut(ItThinClientTransactionsTest.java:200)
  at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
  at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
  at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
  at java.base/java.lang.reflect.Method.invoke(Method.java:566)
  at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:727)
  at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
  at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
  at org.junit.jupiter.engine.extension.SameThreadTimeoutInvocation.proceed(SameThreadTimeoutInvocation.java:45)
  at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:156)
  at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:147)
  at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:86)
  at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(InterceptingExecutableInvoker.java:103)
  at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.lambda$invoke$0(InterceptingExecutableInvoker.java:93)
  at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
  at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
  at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
  at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
  at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:92)
  at org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.invoke(InterceptingExecutableInvoker.java:86)
  at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:217)
  at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
  at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:213)
  at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:138)
  at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:68)
  at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
  at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
  at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
  at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
  at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
  at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
  at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
  at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
  at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
  at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
  at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
  at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
  at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
  at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
  at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
  at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
  at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
  at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
  at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
  at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
  at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
  at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
  at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
  at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
  at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
  at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
  at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
  at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
  at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)
  at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
  at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)
  at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:147)
  at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:127)
  at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:90)
  at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:55)
  at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:102)
  at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:54)
  at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)
  at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86)
  at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86)
  at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53)
  at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:99)
  at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79)
  at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75)
  at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61)
  at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
  at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
  at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
  at java.base/java.lang.reflect.Method.invoke(Method.java:566)
  at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
  at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
  at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33)
  at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94)
  at com.sun.proxy.$Proxy5.stop(Unknown Source)
  at org.gradle.api.internal.tasks.testing.worker.TestWorker$3.run(TestWorker.java:193)
  at org.gradle.api.internal.tasks.testing.worker.TestWorker.executeAndMaintainThreadName(TestWorker.java:129)
  at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:100)
  at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:60)
  at org.gradle.process.internal.worker.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:56)
  at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:133)
  at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:71)
  at worker.org.gradle.process.internal.worker.GradleWorkerMain.run(GradleWorkerMain.java:69)
  at worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74)
------- Stderr: -------
2023-05-02 10:33:10:928 +0300 [INFO][Test worker][ItThinClientTransactionsTest] >>> Starting test: ItThinClientTransactionsTest#testAccessLockedKeyTimesOut, displayName: testAccessLockedKeyTimesOut(), workDir: /opt/buildagent/work/b8d4df1365f1f1e5/modules/runner/build/work/ItThinClientTransactionsTest/testAccessLockedKeyTimesOut_7239297144788614
2023-05-02 10:33:10:952 +0300 [WARNING][%itctt_n_3344%JRaft-Request-Processor-41][ReplicaManager] Failed to process replica request [request=ReadWriteSingleRowReplicaRequestImpl [binaryRow=org.apache.ignite.internal.schema.row.Row@78687b9a, commitPartitionId=null, groupId=efde61e4-b791-46d5-8441-b9a47bc17736_part_7, requestType=RW_GET, term=1, timestamp=HybridTimestamp [physical=1683012790948, logical=0], transactionId=00000187-db61-2a99-0000-0000bb66f319]]
java.util.concurrent.CompletionException: org.apache.ignite.internal.tx.LockException: IGN-TX-4 TraceId:d54813d7-793a-4d81-9456-b7140cee2209 Failed to acquire a lock due to a conflict [txId=00000187-db61-2a99-0000-0000bb66f319, conflictingWaiter=WaiterImpl [txId=00000187-db61-2a99-0000-0000bb66f318, intendedLockMode=null, lockMode=X, ex=null, isDone=true]]
  at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
  at java.base/java.util.concurrent.CompletableFuture.uniApplyNow(CompletableFuture.java:670)
  at java.base/java.util.concurrent.CompletableFuture.uniApplyStage(CompletableFuture.java:658)
  at java.base/java.util.concurrent.CompletableFuture.thenApply(CompletableFuture.java:2094)
  at org.apache.ignite.internal.tx.impl.HeapLockManager.acquire(HeapLockManager.java:103)
  at org.apache.ignite.internal.table.distributed.HashIndexLocker.locksForLookup(HashIndexLocker.java:68)
  at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.resolveRowByPk(PartitionReplicaListener.java:1154)
  at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.processSingleEntryAction(PartitionReplicaListener.java:1624)
  at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$processRequest$1(PartitionReplicaListener.java:282)
  at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.appendTxCommand(PartitionReplicaListener.java:1200)
  at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.processRequest(PartitionReplicaListener.java:282)
  at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$invoke$0(PartitionReplicaListener.java:275)
  at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1072)
  at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
  at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
  at org.apache.ignite.internal.raft.RaftGroupServiceImpl.lambda$sendWithRetry$39(RaftGroupServiceImpl.java:538)
  at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859)
  at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:837)
  at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
  at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
  at org.apache.ignite.network.DefaultMessagingService.onInvokeResponse(DefaultMessagingService.java:371)
  at org.apache.ignite.network.DefaultMessagingService.send0(DefaultMessagingService.java:194)
  at org.apache.ignite.network.DefaultMessagingService.respond(DefaultMessagingService.java:137)
  at org.apache.ignite.network.MessagingService.respond(MessagingService.java:89)
  at org.apache.ignite.raft.jraft.rpc.impl.IgniteRpcServer$NetworkRpcContext.sendResponse(IgniteRpcServer.java:233)
  at org.apache.ignite.raft.jraft.rpc.RpcRequestProcessor.handleRequest(RpcRequestProcessor.java:52)
  at org.apache.ignite.raft.jraft.rpc.RpcRequestProcessor.handleRequest(RpcRequestProcessor.java:29)
  at org.apache.ignite.raft.jraft.rpc.impl.IgniteRpcServer$RpcMessageHandler.lambda$onReceived$0(IgniteRpcServer.java:192)
  at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
  at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
  at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: org.apache.ignite.internal.tx.LockException: IGN-TX-4 TraceId:d54813d7-793a-4d81-9456-b7140cee2209 Failed to acquire a lock due to a conflict [txId=00000187-db61-2a99-0000-0000bb66f319, conflictingWaiter=WaiterImpl [txId=00000187-db61-2a99-0000-0000bb66f318, intendedLockMode=null, lockMode=X, ex=null, isDone=true]]
  at org.apache.ignite.internal.tx.impl.HeapLockManager$LockState.lockException(HeapLockManager.java:303)
  at org.apache.ignite.internal.tx.impl.HeapLockManager$LockState.isWaiterReadyToNotify(HeapLockManager.java:281)
  at org.apache.ignite.internal.tx.impl.HeapLockManager$LockState.tryAcquire(HeapLockManager.java:230)
  at org.apache.ignite.internal.tx.impl.HeapLockManager.acquire(HeapLockManager.java:95)
  ... 26 more
2023-05-02 10:33:10:961 +0300 [WARNING][ForkJoinPool.commonPool-worker-3][ClientInboundMessageHandler] Error processing client request [id=5, op=12, remoteAddress=/127.0.0.1:60078]:org.apache.ignite.tx.TransactionException: IGN-TX-4 TraceId:d54813d7-793a-4d81-9456-b7140cee2209 Failed to acquire a lock due to a conflict [txId=00000187-db61-2a99-0000-0000bb66f319, conflictingWaiter=WaiterImpl [txId=00000187-db61-2a99-0000-0000bb66f318, intendedLockMode=null, lockMode=X, ex=null, isDone=true]]
java.util.concurrent.CompletionException: org.apache.ignite.tx.TransactionException: IGN-TX-4 TraceId:d54813d7-793a-4d81-9456-b7140cee2209 Failed to acquire a lock due to a conflict [txId=00000187-db61-2a99-0000-0000bb66f319, conflictingWaiter=WaiterImpl [txId=00000187-db61-2a99-0000-0000bb66f318, intendedLockMode=null, lockMode=X, ex=null, isDone=true]]
  at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:314)
  at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:319)
  at java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:932)
  at java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:907)
  at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
  at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
  at org.apache.ignite.internal.replicator.ReplicaService.lambda$sendToReplica$3(ReplicaService.java:159)
  at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859)
  at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:837)
  at java.base/java.util.concurrent.CompletableFuture$Completion.exec(CompletableFuture.java:479)
  at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
  at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1020)
  at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1656)
  at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1594)
  at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)
Caused by: org.apache.ignite.tx.TransactionException: IGN-TX-4 TraceId:d54813d7-793a-4d81-9456-b7140cee2209 Failed to acquire a lock due to a conflict [txId=00000187-db61-2a99-0000-0000bb66f319, conflictingWaiter=WaiterImpl [txId=00000187-db61-2a99-0000-0000bb66f318, intendedLockMode=null, lockMode=X, ex=null, isDone=true]]
  at org.apache.ignite.internal.util.ExceptionUtils.lambda$withCause$0(ExceptionUtils.java:346)
  at org.apache.ignite.internal.util.ExceptionUtils.withCauseInternal(ExceptionUtils.java:432)
  at org.apache.ignite.internal.util.ExceptionUtils.withCause(ExceptionUtils.java:346)
  at org.apache.ignite.internal.table.distributed.storage.InternalTableImpl.wrapReplicationException(InternalTableImpl.java:1472)
  at org.apache.ignite.internal.table.distributed.storage.InternalTableImpl.lambda$postEnlist$9(InternalTableImpl.java:480)
  at java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:930)
  at java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:907)
  at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
  at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
  at org.apache.ignite.internal.table.distributed.storage.InternalTableImpl.lambda$enlistWithRetry$5(InternalTableImpl.java:459)
  at java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:930)
  at java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:907)
  at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
  at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
  at org.apache.ignite.internal.replicator.ReplicaService.lambda$sendToReplica$3(ReplicaService.java:156)
  ... 8 more
Caused by: org.apache.ignite.internal.tx.LockException: IGN-TX-4 TraceId:d54813d7-793a-4d81-9456-b7140cee2209 Failed to acquire a lock due to a conflict [txId=00000187-db61-2a99-0000-0000bb66f319, conflictingWaiter=WaiterImpl [txId=00000187-db61-2a99-0000-0000bb66f318, intendedLockMode=null, lockMode=X, ex=null, isDone=true]]
  at org.apache.ignite.internal.tx.impl.HeapLockManager$LockState.lockException(HeapLockManager.java:303)
  at org.apache.ignite.internal.tx.impl.HeapLockManager$LockState.isWaiterReadyToNotify(HeapLockManager.java:281)
  at org.apache.ignite.internal.tx.impl.HeapLockManager$LockState.tryAcquire(HeapLockManager.java:230)
  at org.apache.ignite.internal.tx.impl.HeapLockManager.acquire(HeapLockManager.java:95)
  at org.apache.ignite.internal.table.distributed.HashIndexLocker.locksForLookup(HashIndexLocker.java:68)
  at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.resolveRowByPk(PartitionReplicaListener.java:1154)
  at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.processSingleEntryAction(PartitionReplicaListener.java:1624)
  at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$processRequest$1(PartitionReplicaListener.java:282)
  at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.appendTxCommand(PartitionReplicaListener.java:1200)
  at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.processRequest(PartitionReplicaListener.java:282)
  at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$invoke$0(PartitionReplicaListener.java:275)
  at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1072)
  at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
  at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
  at org.apache.ignite.internal.raft.RaftGroupServiceImpl.lambda$sendWithRetry$39(RaftGroupServiceImpl.java:538)
  at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859)
  at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:837)
  at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
  at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
  at org.apache.ignite.network.DefaultMessagingService.onInvokeResponse(DefaultMessagingService.java:371)
  at org.apache.ignite.network.DefaultMessagingService.send0(DefaultMessagingService.java:194)
  at org.apache.ignite.network.DefaultMessagingService.respond(DefaultMessagingService.java:137)
  at org.apache.ignite.network.MessagingService.respond(MessagingService.java:89)
  at org.apache.ignite.raft.jraft.rpc.impl.IgniteRpcServer$NetworkRpcContext.sendResponse(IgniteRpcServer.java:233)
  at org.apache.ignite.raft.jraft.rpc.RpcRequestProcessor.handleRequest(RpcRequestProcessor.java:52)
  at org.apache.ignite.raft.jraft.rpc.RpcRequestProcessor.handleRequest(RpcRequestProcessor.java:29)
  at org.apache.ignite.raft.jraft.rpc.impl.IgniteRpcServer$RpcMessageHandler.lambda$onReceived$0(IgniteRpcServer.java:192)
  at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
  at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
  at java.base/java.lang.Thread.run(Thread.java:834)
2023-05-02 10:33:10:966 +0300 [INFO][Test worker][ItThinClientTransactionsTest] >>> Stopping test: ItThinClientTransactionsTest#testAccessLockedKeyTimesOut, displayName: testAccessLockedKeyTimesOut(), cost: 39ms.
{code}
[https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_IntegrationTests_ModuleRunner/7212281?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandBuildProblemsSection=true&expandBuildTestsSection=true&expandBuildChangesSection=true]
h3. Upd 1

As [~ptupitsyn] mentioned
{code:java}
        Transaction tx1 = client().transactions().begin();
        Transaction tx2 = client().transactions().begin();

        kvView.put(tx2, -100, ""1"");

        var ex = assertThrows(IgniteException.class, () -> kvView.get(tx1, -100));
        assertThat(ex.getMessage(), containsString(""Replication is timed out"")); {code}
thows both {{TransactionException}}{color:#1d1c1d}  with  {color}{{IGN-REP-3 Rreplication is timed out}}{color:#1d1c1d}  message, and sometimes also {color}{{{}IGN-TX-4 Failed to acquire a lock due to a conflict{}}}{color:#1d1c1d}.{color}",,alapin,isapego,ptupitsyn,,,"ptupitsyn commented on PR #2015:
URL: https://github.com/apache/ignite-3/pull/2015#issuecomment-1533006954

   Won't merge - we should fix the root cause instead (see [JIRA]()https://issues.apache.org/jira/browse/IGNITE-19393 comments). 
   
   Closing.


;03/May/23 13:10;githubbot;600","ptupitsyn closed pull request #2015: IGNITE-19393 Fix testAccessLockedKeyTimesOut flakiness
URL: https://github.com/apache/ignite-3/pull/2015


;03/May/23 13:10;githubbot;600","vldpyatkov opened a new pull request, #2258:
URL: https://github.com/apache/ignite-3/pull/2258

   (no comment)


;27/Jun/23 07:43;githubbot;600","sanpwc merged PR #2258:
URL: https://github.com/apache/ignite-3/pull/2258


;03/Jul/23 07:50;githubbot;600","sanpwc opened a new pull request, #2279:
URL: https://github.com/apache/ignite-3/pull/2279

   https://issues.apache.org/jira/browse/IGNITE-19393
   
   1. TestOnly IgniteImpl#txManager method added.
   2. Assertion added in TxManagerImpl#changeState in order to check that changeState was successfully computed.
   3. TestOnly TxManager#pending added.
   4. New TxState#PENDING added


;03/Jul/23 12:42;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19849,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,Java,Mon Jul 03 07:50:33 UTC 2023,,,,,,,,,,"0|z1hmso:",9223372036854775807,,,sanpwc,,,,,,,,,,,,,,,,,,"03/May/23 05:18;ptupitsyn;[~isapego] please review.;;;","03/May/23 12:08;isapego;Looks good to me.;;;","03/May/23 13:10;ptupitsyn;Actually, it is weird that two different exceptions can be thrown. [~alapin] can you please have a look, as we discussed privately?;;;","03/Jul/23 07:50;alapin;LGTM, merged, thanks!;;;",,
Fix deployment tests,IGNITE-19387,13534559,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,vpakhnushev,vpakhnushev,30/Apr/23 12:42,02/May/23 07:12,13/Jul/23 09:11,02/May/23 07:12,,,,,,,,3.0.0-beta2,cli,,,0,ignite-3,,,After enabling tests in IGNITE-19139 they started failing due to changes in IGNITE-19107,,ptupitsyn,vpakhnushev,,,,"valepakh opened a new pull request, #2002:
URL: https://github.com/apache/ignite-3/pull/2002

   https://issues.apache.org/jira/browse/IGNITE-19387


;30/Apr/23 12:44;githubbot;600","ptupitsyn merged PR #2002:
URL: https://github.com/apache/ignite-3/pull/2002


;02/May/23 07:12;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue May 02 07:12:29 UTC 2023,,,,,,,,,,"0|z1hm7k:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"02/May/23 07:12;ptupitsyn;Merged to main: d5bafb557016bbc5481fce8f52a6212c7b5cfe34;;;",,,,,
TimestampAware messages sometimes lacks timestamps,IGNITE-19381,13534434,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,v.pyatkov,alapin,alapin,28/Apr/23 09:38,19/May/23 20:55,13/Jul/23 09:11,19/May/23 20:55,,,,,,,,,,,,0,ignite-3,,,"h3. Motivation

While HybridTimestamp refactoring [~ibessonov] noticed that RW related messages might have null as a timestamp that seems to be incorrect. Probably we've missed 
{code:java}
.timestampLong(clock.nowLong());{code}
within some RW  messages, e.g. while building ReadWriteScanRetrieveBatchReplicaRequest.
h3. Definition of done

Thus it's required to:
 * add timestampLong() wherever needed.
 * add assertion that will check that TimestampAware messages have @NotNull timestamp field.
 * replace ""nullableHybridTimestamp(...)"" call with ""hybridTimestamp(...), etc. 

 ",,alapin,maliev,v.pyatkov,,,"vldpyatkov merged PR #2083:
URL: https://github.com/apache/ignite-3/pull/2083


;19/May/23 20:47;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,IGNITE-19437,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri May 19 20:55:17 UTC 2023,,,,,,,,,,"0|z1hlfs:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"05/May/23 14:11;maliev;Waiting for [~sdanilov] PR for adding check for non-null fields in messages are set in message builders. ;;;","19/May/23 20:55;v.pyatkov;Merged 22f6d0d1d3c74f40af39ca5f540ccc73abddbae4;;;",,,,
Fix NPE on snapshot create operation for in-memory cluster,IGNITE-19380,13534415,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,NSAmelchev,NSAmelchev,NSAmelchev,28/Apr/23 07:56,28/Apr/23 20:18,13/Jul/23 09:11,28/Apr/23 20:18,,,,,,,,2.16,,,,0,ise,,,"See {{testClusterSnapshotInMemoryFail}} log for details.

{noformat}
[2023-04-28T10:43:10,983][ERROR][disco-notifier-worker-#49%snapshot.PlainSnapshotTest0%][DistributedProcess] Failed to handle InitMessage [id=7777a671-1ec6-46d2-b4c4-4ac565d8a3be]
 java.lang.NullPointerException: null
	at org.apache.ignite.internal.util.future.GridFinishedFuture.chain(GridFinishedFuture.java:145) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.persistence.snapshot.IgniteSnapshotManager.initLocalSnapshotEndStage(IgniteSnapshotManager.java:1381) ~[classes/:?]
	at org.apache.ignite.internal.util.distributed.DistributedProcess.lambda$new$2(DistributedProcess.java:151) ~[classes/:?]
	at org.apache.ignite.internal.managers.discovery.GridDiscoveryManager$3.onDiscovery0(GridDiscoveryManager.java:760) [classes/:?]
	at org.apache.ignite.internal.managers.discovery.GridDiscoveryManager$3.access$7300(GridDiscoveryManager.java:547) [classes/:?]
	at org.apache.ignite.internal.managers.discovery.GridDiscoveryManager$3$NotificationTask.run(GridDiscoveryManager.java:980) [classes/:?]
	at org.apache.ignite.internal.managers.discovery.GridDiscoveryManager$DiscoveryMessageNotifierWorker.body0(GridDiscoveryManager.java:2822) [classes/:?]
	at org.apache.ignite.internal.managers.discovery.GridDiscoveryManager$DiscoveryMessageNotifierWorker.body(GridDiscoveryManager.java:2860) [classes/:?]
	at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:125) [classes/:?]
	at java.lang.Thread.run(Thread.java:750) [?:1.8.0_352]
{noformat}
",,ignitetcbot,NSAmelchev,,,,"NSAmelchev opened a new pull request, #10674:
URL: https://github.com/apache/ignite/pull/10674

   …ster
   
   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;28/Apr/23 07:58;githubbot;600","sonarcloud[bot] commented on PR #10674:
URL: https://github.com/apache/ignite/pull/10674#issuecomment-1527156343

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10674)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10674&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10674&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10674&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10674&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10674&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10674&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10674&metric=new_duplicated_lines_density&view=list)
   
   


;28/Apr/23 08:04;githubbot;600","timoninmaxim commented on code in PR #10674:
URL: https://github.com/apache/ignite/pull/10674#discussion_r1180071745


##########
modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/snapshot/IgniteSnapshotManager.java:
##########
@@ -1408,7 +1408,8 @@ else if (!F.isEmpty(req.warnings())) {
             }
 
             return new SnapshotOperationResponse();
-        }, cctx.kernalContext().pools().getSnapshotExecutorService());
+        }, Optional.ofNullable(cctx.kernalContext().pools().getSnapshotExecutorService())

Review Comment:
   Looks very strange. In this place snpExecSvc must not be null. Let' check it in `createSnapshot`?



;28/Apr/23 08:07;githubbot;600","sonarcloud[bot] commented on PR #10674:
URL: https://github.com/apache/ignite/pull/10674#issuecomment-1527176394

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10674)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10674&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10674&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10674&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10674&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10674&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10674&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10674&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10674&metric=new_duplicated_lines_density&view=list)
   
   


;28/Apr/23 08:21;githubbot;600","NSAmelchev merged PR #10674:
URL: https://github.com/apache/ignite/pull/10674


;28/Apr/23 20:17;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Fri Apr 28 20:18:27 UTC 2023,,,,,,,,,,"0|z1hlbk:",9223372036854775807,Fixed NPE on snapshot create operation for in-memory cluster,,,,,,,,,,,,,,,,,,,,"28/Apr/23 20:16;ignitetcbot;{panel:title=Branch: [pull/10674/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10674/head] Base: [master] : No new tests found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7155147&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","28/Apr/23 20:18;NSAmelchev;Merged into the master.

[~timonin.maksim], Thank you for the review.;;;",,,,
Metadata topic offset must be stored only after commit,IGNITE-19369,13534130,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,nizhikov,nizhikov,nizhikov,26/Apr/23 10:47,19/May/23 09:09,13/Jul/23 09:11,26/Apr/23 12:57,,,,,,,,,extensions,,,0,IEP-59,ise,,"Improvement of {{KafkaToIgniteMetadataUpdater}} lead to error when data not returned to the consumer from the topic.
Read offsets must be stored only after consumer#commit successfully.",,nizhikov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-18209,,IGNITE-18992,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Wed Apr 26 12:57:10 UTC 2023,,,,,,,,,,"0|z1hjko:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"26/Apr/23 12:57;nizhikov;[~alex_pl] Thanks for the review!;;;",,,,,
"Release build failure on ""Assemble RPM/DEB packages"" step",IGNITE-19364,13534013,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,alex_pl,alex_pl,alex_pl,25/Apr/23 14:47,25/Apr/23 15:23,13/Jul/23 09:11,25/Apr/23 15:22,2.15,,,,,,,2.15,,,,0,,,,"Release build failure on ""Assemble RPM/DEB packages"" step due with error:  ""'.../ignitevisorcmd.sh': No such file or directory"". 
Visor command line tool was removed, apache-ignite.spec should reflect these changes.",,alex_pl,,,,,"alex-plekhanov opened a new pull request, #10666:
URL: https://github.com/apache/ignite/pull/10666

   …cmd)
   
   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;25/Apr/23 14:52;githubbot;600","sonarcloud[bot] commented on PR #10666:
URL: https://github.com/apache/ignite/pull/10666#issuecomment-1521959906

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10666)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10666&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10666&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10666&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10666&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10666&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10666&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10666&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10666&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10666&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10666&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10666&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10666&resolved=false&types=CODE_SMELL)
   
   [![No Coverage information](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/NoCoverageInfo-16px.png 'No Coverage information')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10666&metric=coverage&view=list) No Coverage information  
   [![No Duplication information](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/NoDuplicationInfo-16px.png 'No Duplication information')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10666&metric=duplicated_lines_density&view=list) No Duplication information
   
   


;25/Apr/23 15:08;githubbot;600","asfgit closed pull request #10666: IGNITE-19364 Fix DEB/RPM packages assembly script (remove ignitevisor…
URL: https://github.com/apache/ignite/pull/10666


;25/Apr/23 15:21;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Apr 25 15:22:43 UTC 2023,,,,,,,,,,"0|z1hiuo:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"25/Apr/23 15:22;alex_pl;[~northdragon], thanks for the review! Merged to 2.15, cherry-picked to master.;;;",,,,,
.NET: Thin client: 'Affinity keys are not supported exception' on put,IGNITE-19359,13533977,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,25/Apr/23 10:02,18/May/23 09:47,13/Jul/23 09:11,18/May/23 09:47,2.14,,,,,,,2.16,platforms,thin client,,0,.NET,,,"Reproducer from [StackOverflow|https://stackoverflow.com/questions/76099508/why-cant-i-add-data-with-an-affinitykey-into-an-apache-ignite-cache]

{code:C#}
using Apache.Ignite.Core;
using Apache.Ignite.Core.Cache.Affinity;
using Apache.Ignite.Core.Cache.Configuration;
using Apache.Ignite.Core.Cache.Query;
using Apache.Ignite.Core.Client;
using Apache.Ignite.Core.Client.Cache;

public record PERSONKEY(
    [property:AffinityKeyMapped] [property: QuerySqlField(NotNull = true)] long COMPANYID, 
    [property: QuerySqlField(NotNull = true)] long PERSONID);

public record PERSONVALUE(
    [property: QuerySqlField(NotNull = true)] string FIRSTNAME, 
    [property: QuerySqlField(NotNull = true)] string LASTNAME);

internal class Program
{
    public static void Main(string[] args)
    {
        var cfg = new IgniteClientConfiguration
        {
            Endpoints = new[] {""10.7.116.49:10800""},
        };
        using var client = Ignition.StartClient(cfg);

        var schemaBuilder = client.GetOrCreateCache<int, int>(new CacheClientConfiguration
        {
            Name = ""RR"", SqlSchema = ""PUBLIC""
        });

        schemaBuilder.Query(new SqlFieldsQuery(
            $@""CREATE TABLE IF NOT EXISTS PERSON (
                COMPANYID BIGINT NOT NULL,
                PERSONID BIGINT NOT NULL,
                FIRSTNAME VARCHAR NOT NULL,
                LASTNAME VARCHAR NOT NULL,
                PRIMARY KEY(COMPANYID, PERSONID)
            ) WITH """"TEMPLATE=PARTITIONED,BACKUPS=1,AFFINITY_KEY=COMPANYID,CACHE_NAME=PERSON,
                     KEY_TYPE={typeof(PERSONKEY).FullName},VALUE_TYPE={typeof(PERSONVALUE).FullName}""""""
        ) { Schema = ""PUBLIC"" }).GetAll();
        
        var cache = client.GetCache<PERSONKEY, PERSONVALUE>(""PERSON"");
        
        var key = new PERSONKEY(1, 2);
        var value = new PERSONVALUE(""JOHN"", ""SMITH"");
        
        // Throws an exception
        // Apache.Ignite.Core.Common.IgniteException: Affinity keys are not supported.
        // Object 'PERSONKEY { COMPANYID = 1, PERSONID = 2 }' has an affinity key.
        cache.Put(key, value);
        
        // Does not throw an exception
        cache.PutAll(new[]{KeyValuePair.Create(key, value)});
        
        var people = cache.Query(new SqlFieldsQuery(""SELECT * FROM PERSON WHERE COMPANYID = ?"", key.COMPANYID)).GetAll();
        // Correctly prints ""1 2 JOHN SMITH""
        Console.WriteLine(string.Join(""\n"", people.Select(p => $""{p[0]} {p[1]} {p[2]} {p[3]}"")));
    }
}
{code}

*Exception:*

{code}
Apache.Ignite.Core.Common.IgniteException: Affinity keys are not supported. Object 'PERSONKEY { COMPANYID = 1, PERSONID = 2 }' has an affinity key.
{code}

We should not throw an exception when partition can't be calculated. Instead, log a warning and bypass partition awareness.",,ignitetcbot,isapego,ptupitsyn,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,C#,Thu May 18 09:46:00 UTC 2023,,,,,,,,,,"0|z1himo:",9223372036854775807,.NET: Thin client: Added partition awareness support for types with affinity key.,,isapego,,,,,,,,,,,,,,,,,,"18/May/23 07:25;ptupitsyn;[~isapego] please review.;;;","18/May/23 08:29;isapego;Looks good;;;","18/May/23 09:39;ignitetcbot;{panel:title=Branch: [pull/10727/head] Base: [master] : Possible Blockers (11)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}
{color:#d04437}Snapshots{color} [[tests 0 Exit Code , Failure on metric |https://ci.ignite.apache.org/viewLog.html?buildId=7237801]]

{color:#d04437}[Check Code Style Ducktests]{color} [[tests 0 Exit Code |https://ci.ignite.apache.org/viewLog.html?buildId=7237743]]

{color:#d04437}Cache 2{color} [[tests 0 TIMEOUT , Exit Code , Failure on metric |https://ci.ignite.apache.org/viewLog.html?buildId=7237721]]

{color:#d04437}Disk Page Compressions 1{color} [[tests 1 Exit Code , Failure on metric |https://ci.ignite.apache.org/viewLog.html?buildId=7237819]]
* IgnitePdsCompressionTestSuite: WalRecoveryWithPageCompressionAndTdeTest.testRecoveryLargeNoCheckpoint - Test has low fail rate in base branch 0,0% and is not flaky

{color:#d04437}PDS 2{color} [[tests 0 TIMEOUT , Exit Code , Failure on metric |https://ci.ignite.apache.org/viewLog.html?buildId=7237775]]

{color:#d04437}Disk Page Compressions 2{color} [[tests 0 TIMEOUT , Exit Code , Failure on metric |https://ci.ignite.apache.org/viewLog.html?buildId=7237820]]

{color:#d04437}Basic 4{color} [[tests 1|https://ci.ignite.apache.org/viewLog.html?buildId=7237714]]
* IgniteBasicTestSuite2: IgniteDiagnosticMessagesTest.testSeveralLongRunningTxs - Test has low fail rate in base branch 0,0% and is not flaky

{color:#d04437}Queries 3{color} [[tests 1|https://ci.ignite.apache.org/viewLog.html?buildId=7237794]]
* IgniteBinaryCacheQueryTestSuite3: BasicSqlTypesIndexTest.testSqlTimeTypeIndex - Test has low fail rate in base branch 0,0% and is not flaky

{color:#d04437}Continuous Query 3{color} [[tests 1|https://ci.ignite.apache.org/viewLog.html?buildId=7237750]]
* IgniteCacheQuerySelfTestSuite5: GridCacheContinuousQueryConcurrentTest.testRestartReplicated - Test has low fail rate in base branch 0,0% and is not flaky

{color:#d04437}Queries 1{color} [[tests 1|https://ci.ignite.apache.org/viewLog.html?buildId=7237790]]
* IgniteBinaryCacheQueryTestSuite: BasicIndexTest.testDynamicIdxOnStaticCacheWithIdxWithoutPersistence - Test has low fail rate in base branch 0,0% and is not flaky

{panel}
{panel:title=Branch: [pull/10727/head] Base: [master] : New Tests (80)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Platform .NET (Core Linux){color} [[tests 40|https://ci.ignite.apache.org/viewLog.html?buildId=7237788]]
* {color:#013220}DotNetCore: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKeyBinarizable_RequestIsRoutedToPrimaryNode(6,2) - PASSED{color}
* {color:#013220}DotNetCore: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKeyBinarizable_SkipKey_LogsWarningAndBypassesPartitionAwareness - PASSED{color}
* {color:#013220}DotNetCore: PartitionAwarenessTest.CachePut_UserDefinedTypeWithUserTypeAffinityKey_RequestIsRoutedToPrimaryNode(1,0) - PASSED{color}
* {color:#013220}DotNetCore: PartitionAwarenessTest.CachePut_UserDefinedTypeWithUserTypeAffinityKey_RequestIsRoutedToPrimaryNode(2,0) - PASSED{color}
* {color:#013220}DotNetCore: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKeyBinarizable_RequestIsRoutedToPrimaryNode(2,0) - PASSED{color}
* {color:#013220}DotNetCore: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKeyBinarizable_RequestIsRoutedToPrimaryNode(3,0) - PASSED{color}
* {color:#013220}DotNetCore: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKeyBinarizable_RequestIsRoutedToPrimaryNode(4,1) - PASSED{color}
* {color:#013220}DotNetCore: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKeyBinarizable_RequestIsRoutedToPrimaryNode(5,1) - PASSED{color}
* {color:#013220}DotNetCore: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKey_RequestIsRoutedToPrimaryNode(4,1) - PASSED{color}
* {color:#013220}DotNetCore: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKey_RequestIsRoutedToPrimaryNode(5,1) - PASSED{color}
* {color:#013220}DotNetCore: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKey_RequestIsRoutedToPrimaryNode(6,2) - PASSED{color}
... and 29 new tests

{color:#00008b}Platform .NET (Windows){color} [[tests 40|https://ci.ignite.apache.org/viewLog.html?buildId=7237789]]
* {color:#013220}exe: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKeyBinarizable_RequestIsRoutedToPrimaryNode(4,1) - PASSED{color}
* {color:#013220}exe: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKeyBinarizable_RequestIsRoutedToPrimaryNode(5,1) - PASSED{color}
* {color:#013220}exe: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKeyBinarizable_RequestIsRoutedToPrimaryNode(6,2) - PASSED{color}
* {color:#013220}exe: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKeyBinarizable_SkipKey_LogsWarningAndBypassesPartitionAwareness - PASSED{color}
* {color:#013220}exe: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKey_RequestIsRoutedToPrimaryNode(6,2) - PASSED{color}
* {color:#013220}exe: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKeyBinarizable_RequestIsRoutedToPrimaryNode(1,1) - PASSED{color}
* {color:#013220}exe: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKeyBinarizable_RequestIsRoutedToPrimaryNode(2,0) - PASSED{color}
* {color:#013220}exe: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKeyBinarizable_RequestIsRoutedToPrimaryNode(3,0) - PASSED{color}
* {color:#013220}exe: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKey_RequestIsRoutedToPrimaryNode(2,0) - PASSED{color}
* {color:#013220}exe: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKey_RequestIsRoutedToPrimaryNode(3,0) - PASSED{color}
* {color:#013220}exe: PartitionAwarenessTest.CachePut_UserDefinedTypeWithAffinityKey_RequestIsRoutedToPrimaryNode(4,1) - PASSED{color}
... and 29 new tests

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci.ignite.apache.org/viewLog.html?buildId=7237822&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","18/May/23 09:46;ptupitsyn;Merged to master: bdfc379fe925782d7ff581985389b8268a39a3d5;;;",,
.NET: Thin 3.0: Same schema version is retrieved multiple times in concurrent scenarios,IGNITE-19355,13533846,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,24/Apr/23 12:23,15/May/23 10:59,13/Jul/23 09:11,15/May/23 10:59,,,,,,,,3.0.0-beta2,thin client,,,0,.NET,ignite-3,,"When *Table.ReadSchemaAsync* is called, we send a request for the given schema version every time, even if another request for that version is active (e.g. in case of multiple concurrent TUPLE_GET requests).

Instead of caching *ClientSchema*, we should cache *Task<ClientSchema>*, and use *GetOrAdd* to guarantee only one request for the given version. Make sure to handle failures - if a cached Task is failed, send a new request.",,isapego,ptupitsyn,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19354,,,,,,,,,,,,IGNITE-19242,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon May 15 10:58:59 UTC 2023,,,,,,,,,,"0|z1hhtk:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"15/May/23 09:21;ptupitsyn;[~isapego] please review.;;;","15/May/23 10:26;isapego;[~ptupitsyn] Looks good to me.;;;","15/May/23 10:58;ptupitsyn;Merged to main: d33cf4fa38cb2ac657742016a5a69125f5a47259;;;",,,
Java thin 3.0: Same schema version is retrieved multiple times in concurrent scenarios,IGNITE-19354,13533843,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,24/Apr/23 12:17,17/May/23 07:05,13/Jul/23 09:11,17/May/23 07:05,,,,,,,,3.0.0-beta2,thin client,,,0,ignite-3,,,"When *ClientTable.getSchema* is called, we send a request for the given schema version every time, even if another request for that version is active (e.g. in case of multiple concurrent TUPLE_GET requests).

Instead of caching *ClientSchema*, we should cache *CompletableFuture<ClientSchema>*, and use *computeIfAbsent* to guarantee only one request for the given version. Make sure to handle failures - if a cached future is failed, send a new request.",,isapego,ptupitsyn,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19355,,,,,,,,,,,,,IGNITE-19241,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed May 17 06:58:58 UTC 2023,,,,,,,,,,"0|z1hhsw:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"16/May/23 11:29;ptupitsyn;[~isapego] please review.;;;","16/May/23 12:12;isapego;Looks good to me.;;;","17/May/23 06:58;ptupitsyn;Merged to main: 91c9ce3efac3a55105ac2148d2074a0fc546cd97;;;",,,
Sql. Incorrect type conversion for dynamic parameters - CAST operation ignores type precision.,IGNITE-19353,13533841,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,mzhuravkov,mzhuravkov,mzhuravkov,24/Apr/23 12:14,28/Jun/23 14:45,13/Jul/23 09:11,28/Jun/23 14:45,,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"Current implementation of expression execution runtime incorrectly translates types of dynamic parameters because (a) it losses type informations of dynamic parameters (see https://issues.apache.org/jira/browse/IGNITE-18831), (b) it goes against the rules of calcite's enumerables/link4j (on which the code is based), which expect dynamic parameters to be converted into their java values according to their inferred types.

The following code illustrates the problem with character types:
{code:java}
 @Test
    public void test() {
        assertQuery(""SELECT CAST(? AS VARCHAR(2))"").withParams(""abcd"").returns(""ab"").check();
    }
{code}

The code returns `abcd` when `ab` is expected.

Problem with numeric types:

{code:java}
 @Test
    public void test() {
        assertQuery(""SELECT CAST(? AS DECIMAL(2))"").withParams(new BigDecimal(""123"")).check();
    }
{code}

The code returns original value where Postgres/Oracle/SQL Server return conversion error. 

*Solution*: convert values of dynamic parameters to java values according to type information inferred at the validation stage and pass converted values to expression execution runtime.


",,mzhuravkov,zstan,,,,"lowka opened a new pull request, #2220:
URL: https://github.com/apache/ignite-3/pull/2220

   (no comment)


;19/Jun/23 20:04;githubbot;600","AMashenkov commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245108429


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/exec/CastExpressionTest.java:
##########
@@ -0,0 +1,440 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.sql.engine.exec;
+
+import static org.apache.ignite.lang.IgniteStringFormatter.format;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.containsString;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.UUID;
+import java.util.stream.Stream;
+import org.apache.calcite.rel.type.RelDataType;
+import org.apache.calcite.sql.type.SqlTypeName;
+import org.apache.calcite.sql.type.SqlTypeUtil;
+import org.apache.ignite.internal.schema.NativeTypes;
+import org.apache.ignite.internal.sql.engine.AsyncCursor;
+import org.apache.ignite.internal.sql.engine.AsyncCursor.BatchedResult;
+import org.apache.ignite.internal.sql.engine.framework.DataProvider;
+import org.apache.ignite.internal.sql.engine.framework.TestBuilders;
+import org.apache.ignite.internal.sql.engine.framework.TestCluster;
+import org.apache.ignite.internal.sql.engine.framework.TestNode;
+import org.apache.ignite.internal.sql.engine.prepare.QueryPlan;
+import org.apache.ignite.internal.sql.engine.trait.IgniteDistributions;
+import org.apache.ignite.internal.sql.engine.util.Commons;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Assumptions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Cast expression tests.
+ */
+public class CastExpressionTest {
+
+    private static final String NUMERIC_OVERFLOW_ERROR = ""Numeric overflow"";
+
+    private static final String NUMERIC_FORMAT_ERROR = ""neither a decimal digit number"";
+
+    private final DataProvider<Object[]> dataProvider = DataProvider.fromRow(
+            new Object[]{42, UUID.randomUUID().toString()}, 3_333
+    );
+
+    // @formatter:off
+    private final TestCluster cluster = TestBuilders.cluster()
+            .nodes(""N1"")
+            .addTable()
+            .name(""T1"")
+            .distribution(IgniteDistributions.hash(List.of(0)))
+            .addColumn(""ID"", NativeTypes.INT32)
+            .addColumn(""VAL"", NativeTypes.stringOf(64))
+            .defaultDataProvider(dataProvider)
+            .end()
+            .build();
+    // @formatter:on
+
+    private final TestNode gatewayNode = cluster.node(""N1"");
+
+    /** Starts the cluster and prepares the plan of the query. */
+    @BeforeEach
+    public void setUp() {
+        cluster.start();
+    }
+
+    /** Stops the cluster. */
+    @AfterEach
+    public void tearDown() throws Exception {
+        cluster.stop();
+    }
+
+    /** varchar casts - literals. */
+    @ParameterizedTest
+    @MethodSource(""varcharCasts"")
+    public void testVarcharCastsLiterals(String value, RelDataType type, String result) {
+        String query = format(""SELECT CAST('{}' AS {})"", value, type);
+        sql(query).returns(result).ok();
+    }
+
+    /** varchar casts - dynamic params. */
+    @ParameterizedTest
+    @MethodSource(""varcharCasts"")
+    public void testVarcharCastsDynamicParams(String value, RelDataType type, String result) {
+        String query = format(""SELECT CAST(? AS {})"", type);
+        sql(query).withParams(value).returns(result).ok();
+    }
+
+    private static Stream<Arguments> varcharCasts() {
+        return Stream.of(
+                // varchar
+                arguments(""abcde"", varcharType(3), ""abc""),
+                arguments(""abcde"", varcharType(5), ""abcde""),
+                arguments(""abcde"", varcharType(6), ""abcde""),
+                arguments(""abcde"", varcharType(), ""abcde""),
+
+                // char
+                arguments(""abcde"", charType(), ""a""),
+                arguments(""abcde"", charType(3), ""abc"")
+        );
+    }
+
+    /** decimal casts - cast literal to decimal. */
+    @ParameterizedTest(name = ""{2}:{1} AS {3} = {4}"")
+    @MethodSource(""decimalCastFromLiterals"")
+    public void testDecimalCastsNumericLiterals(CaseStatus status, RelDataType inputType, Object input,
+            RelDataType targetType, Result<BigDecimal> result) {
+
+        Assumptions.assumeTrue(status == CaseStatus.RUN);
+
+        String literal = asLiteral(input, inputType);
+        String query = format(""SELECT CAST({} AS {})"", literal, targetType);
+
+        sql(query).expect(result);
+    }
+
+    private static Stream<Arguments> decimalCastFromLiterals() {
+        RelDataType varcharType = varcharType();
+        // ignored
+        RelDataType numeric = decimalType(4);
+
+        return Stream.of(
+                // String
+                arguments(CaseStatus.RUN, varcharType, ""100"", decimalType(3), bigDecimalVal(""100"")),
+                arguments(CaseStatus.RUN, varcharType, ""100.12"", decimalType(5, 1), bigDecimalVal(""100.1"")),
+                arguments(CaseStatus.RUN, varcharType, ""lame"", decimalType(5, 1), error(NUMERIC_FORMAT_ERROR)),
+                // TODO Uncomment these test cases after https://issues.apache.org/jira/browse/IGNITE-19822 is fixed.
+                arguments(CaseStatus.SKIP, varcharType, ""100.12"", decimalType(1, 0), error(NUMERIC_OVERFLOW_ERROR)),
+
+                // Numeric
+                arguments(CaseStatus.RUN, numeric, ""100"", decimalType(3), bigDecimalVal(""100"")),
+                arguments(CaseStatus.RUN, numeric, ""100"", decimalType(3, 0), bigDecimalVal(""100"")),
+                // TODO Uncomment these test cases after https://issues.apache.org/jira/browse/IGNITE-19822 is fixed.
+                arguments(CaseStatus.SKIP, numeric, ""100.12"", decimalType(5, 1), bigDecimalVal(""100.1"")),
+                arguments(CaseStatus.SKIP, numeric, ""100.12"", decimalType(5, 0), bigDecimalVal(""100"")),
+                arguments(CaseStatus.SKIP, numeric, ""100"", decimalType(2, 0), error(NUMERIC_OVERFLOW_ERROR)),
+                arguments(CaseStatus.SKIP, numeric, ""100.12"", decimalType(5, 2), bigDecimalVal(""100.12""))
+        );
+    }
+
+    /** decimal casts - cast dynamic param to decimal. */
+    @ParameterizedTest(name = ""{2}:?{1} AS {3} = {4}"")
+    @MethodSource(""decimalCasts"")
+    public void testDecimalCastsDynamicParams(CaseStatus ignore, RelDataType inputType, Object input,
+            RelDataType targetType, Result<BigDecimal> result) {
+        // We ignore status because every case should work for dynamic parameter.
+
+        String query = format(""SELECT CAST(? AS {})"", targetType);
+
+        sql(query).withParams(input).expect(result);
+    }
+
+    /** decimals casts - cast numeric literal to specific type then cast the result to decimal. */
+    @ParameterizedTest(name = ""{1}: {2}::{1} AS {3} = {4}"")
+    @MethodSource(""decimalCasts"")
+    public void testDecimalCastsFromNumeric(CaseStatus status, RelDataType inputType, Object input,
+            RelDataType targetType, Result<BigDecimal> result) {
+
+        Assumptions.assumeTrue(status == CaseStatus.RUN);
+
+        String literal = asLiteral(input, inputType);
+        String query = format(""SELECT CAST({}::{} AS {})"", literal, inputType, targetType);
+
+        sql(query).expect(result);
+    }
+
+    static String asLiteral(Object value, RelDataType type) {
+        if (SqlTypeUtil.isCharacter(type)) {
+            String str = (String) value;
+            return format(""'{}'"", str);
+        } else {
+            return String.valueOf(value);
+        }
+    }
+
+    /**
+     * Indicates whether a test case should run or should be skipped.
+     * We need this because the set of test cases is the same for both dynamic params
+     * and numeric values.
+     *
+     * <p>TODO Should be removed after https://issues.apache.org/jira/browse/IGNITE-19822 is fixed.
+     */
+    enum CaseStatus {
+        /** Case should run. */
+        RUN,
+        /** Case should be skipped. */
+        SKIP
+    }
+
+    private static Stream<Arguments> decimalCasts() {
+        RelDataType varcharType = varcharType();
+        RelDataType tinyIntType = sqlType(SqlTypeName.TINYINT);
+        RelDataType smallIntType = sqlType(SqlTypeName.SMALLINT);
+        RelDataType integerType = sqlType(SqlTypeName.INTEGER);
+        RelDataType bigintType = sqlType(SqlTypeName.BIGINT);
+        RelDataType realType = sqlType(SqlTypeName.REAL);
+        RelDataType doubleType = sqlType(SqlTypeName.DOUBLE);
+
+        return Stream.of(
+                // String
+                arguments(CaseStatus.RUN, varcharType, ""100"", decimalType(3), bigDecimalVal(""100"")),
+                arguments(CaseStatus.RUN, varcharType, ""100"", decimalType(3), bigDecimalVal(""100"")),
+                arguments(CaseStatus.RUN, varcharType, ""100"", decimalType(3, 0), bigDecimalVal(""100"")),
+                // TODO Uncomment these test cases after https://issues.apache.org/jira/browse/IGNITE-19822 is fixed.
+                arguments(CaseStatus.SKIP, varcharType, ""100"", decimalType(4, 1), bigDecimalVal(""100.0"")),
+                arguments(CaseStatus.SKIP, varcharType, ""100"", decimalType(2, 0), error(NUMERIC_OVERFLOW_ERROR)),
+
+                // Tinyint
+                arguments(CaseStatus.SKIP, tinyIntType, (byte) 100, decimalType(3), bigDecimalVal(""100"")),
+                arguments(CaseStatus.RUN, tinyIntType, (byte) 100, decimalType(3, 0), bigDecimalVal(""100"")),
+                // TODO Uncomment these test cases after https://issues.apache.org/jira/browse/IGNITE-19822 is fixed.
+                arguments(CaseStatus.SKIP, tinyIntType, (byte) 100, decimalType(4, 1), bigDecimalVal(""100.0"")),
+                arguments(CaseStatus.SKIP, tinyIntType, (byte) 100, decimalType(2, 0), error(NUMERIC_OVERFLOW_ERROR)),
+
+                // Smallint
+                arguments(CaseStatus.RUN, smallIntType, (short) 100, decimalType(3), bigDecimalVal(""100"")),
+                arguments(CaseStatus.RUN, smallIntType, (short) 100, decimalType(3, 0), bigDecimalVal(""100"")),
+                // TODO Uncomment these test cases after https://issues.apache.org/jira/browse/IGNITE-19822 is fixed.
+                arguments(CaseStatus.SKIP, smallIntType, (short) 100, decimalType(4, 1), bigDecimalVal(""100.0"")),
+                arguments(CaseStatus.SKIP, smallIntType, (short) 100, decimalType(2, 0), error(NUMERIC_OVERFLOW_ERROR)),
+
+                // Integer
+                arguments(CaseStatus.RUN, integerType, 100, decimalType(3), bigDecimalVal(""100"")),
+                arguments(CaseStatus.RUN, integerType, 100, decimalType(3, 0), bigDecimalVal(""100"")),
+                // TODO Uncomment these test cases after https://issues.apache.org/jira/browse/IGNITE-19822 is fixed.
+                arguments(CaseStatus.SKIP, integerType, 100, decimalType(4, 1), bigDecimalVal(""100.0"")),
+                arguments(CaseStatus.SKIP, integerType, 100, decimalType(2, 0), error(NUMERIC_OVERFLOW_ERROR)),
+
+                // Bigint
+                arguments(CaseStatus.RUN, bigintType, 100L, decimalType(3), bigDecimalVal(""100"")),
+                arguments(CaseStatus.RUN, bigintType, 100L, decimalType(3, 0), bigDecimalVal(""100"")),
+                // TODO Uncomment these test cases after https://issues.apache.org/jira/browse/IGNITE-19822 is fixed.
+                arguments(CaseStatus.SKIP, bigintType, 100L, decimalType(4, 1), bigDecimalVal(""100.0"")),
+                arguments(CaseStatus.SKIP, bigintType, 100L, decimalType(2, 0), error(NUMERIC_OVERFLOW_ERROR)),
+
+                // Real
+                // TODO Uncomment these test cases after https://issues.apache.org/jira/browse/IGNITE-19822 is fixed.
+                arguments(CaseStatus.SKIP, realType, 100.0f, decimalType(3), bigDecimalVal(""100"")),
+                arguments(CaseStatus.SKIP, realType, 100.0f, decimalType(3, 0), bigDecimalVal(""100"")),
+                arguments(CaseStatus.SKIP, realType, 100.0f, decimalType(4, 1), bigDecimalVal(""100.0"")),
+                arguments(CaseStatus.SKIP, realType, 100.0f, decimalType(2, 0), error(NUMERIC_OVERFLOW_ERROR)),
+                arguments(CaseStatus.SKIP, realType, 0.1f, decimalType(1, 1), bigDecimalVal(""0.1"")),
+                arguments(CaseStatus.SKIP, realType, 0.1f, decimalType(2, 2), bigDecimalVal(""0.10"")),
+                arguments(CaseStatus.SKIP, realType, 10.12f, decimalType(2, 1), error(NUMERIC_OVERFLOW_ERROR)),
+                arguments(CaseStatus.SKIP, realType, 0.12f, decimalType(1, 2), error(NUMERIC_OVERFLOW_ERROR)),
+
+                // Double
+                // TODO Uncomment these test cases after https://issues.apache.org/jira/browse/IGNITE-19822 is fixed.
+                arguments(CaseStatus.SKIP, doubleType, 100.0d, decimalType(3), bigDecimalVal(""100"")),
+                arguments(CaseStatus.SKIP, doubleType, 100.0d, decimalType(3, 0), bigDecimalVal(""100"")),
+                arguments(CaseStatus.SKIP, doubleType, 100.0d, decimalType(4, 1), bigDecimalVal(""100.0"")),
+                arguments(CaseStatus.SKIP, doubleType, 100.0d, decimalType(2, 0), error(NUMERIC_OVERFLOW_ERROR)),
+                arguments(CaseStatus.SKIP, doubleType, 0.1d, decimalType(1, 1), bigDecimalVal(""0.1"")),
+                arguments(CaseStatus.SKIP, doubleType, 0.1d, decimalType(2, 2), bigDecimalVal(""0.10"")),
+                arguments(CaseStatus.SKIP, doubleType, 10.12d, decimalType(2, 1), error(NUMERIC_OVERFLOW_ERROR)),
+                arguments(CaseStatus.SKIP, doubleType, 0.12d, decimalType(1, 2), error(NUMERIC_OVERFLOW_ERROR)),
+
+                // Decimal
+                arguments(CaseStatus.RUN, decimalType(1, 1), new BigDecimal(""0.1""), decimalType(1, 1), bigDecimalVal(""0.1"")),
+                arguments(CaseStatus.RUN, decimalType(3), new BigDecimal(""100""), decimalType(3), bigDecimalVal(""100"")),
+                arguments(CaseStatus.RUN, decimalType(3), new BigDecimal(""100""), decimalType(3, 0), bigDecimalVal(""100"")),
+                // TODO Uncomment these test cases after https://issues.apache.org/jira/browse/IGNITE-19822 is fixed.
+                arguments(CaseStatus.SKIP, decimalType(3), new BigDecimal(""100""), decimalType(4, 1), bigDecimalVal(""100.0"")),
+                arguments(CaseStatus.SKIP, decimalType(3), new BigDecimal(""100""), decimalType(2, 0), error(NUMERIC_OVERFLOW_ERROR)),
+                arguments(CaseStatus.SKIP, decimalType(1, 1), new BigDecimal(""0.1""), decimalType(2, 2), bigDecimalVal(""0.10"")),
+                arguments(CaseStatus.SKIP, decimalType(4, 2), new BigDecimal(""10.12""), decimalType(2, 1), error(NUMERIC_OVERFLOW_ERROR)),
+                arguments(CaseStatus.SKIP, decimalType(2, 2), new BigDecimal(""0.12""), decimalType(1, 2), error(NUMERIC_OVERFLOW_ERROR)),
+                arguments(CaseStatus.SKIP, decimalType(1, 1), new BigDecimal(""0.1""), decimalType(1, 1), bigDecimalVal(""0.1""))
+        );
+    }
+
+    private static RelDataType sqlType(SqlTypeName typeName) {
+        return Commons.typeFactory().createSqlType(typeName);
+    }
+
+    private static RelDataType decimalType(int precision, int scale) {
+        return Commons.typeFactory().createSqlType(SqlTypeName.DECIMAL, precision, scale);
+    }
+
+    private static RelDataType decimalType(int precision) {
+        return Commons.typeFactory().createSqlType(SqlTypeName.DECIMAL, precision, RelDataType.SCALE_NOT_SPECIFIED);
+    }
+
+    private static RelDataType varcharType(int length) {
+        return Commons.typeFactory().createSqlType(SqlTypeName.VARCHAR, length);
+    }
+
+    private static RelDataType varcharType() {
+        return Commons.typeFactory().createSqlType(SqlTypeName.VARCHAR);
+    }
+
+    private static RelDataType charType(int length) {
+        return Commons.typeFactory().createSqlType(SqlTypeName.CHAR, length);
+    }
+
+    private static RelDataType charType() {
+        return Commons.typeFactory().createSqlType(SqlTypeName.CHAR);
+    }
+
+    private Checker sql(String query) {
+        return new Checker(query, gatewayNode);
+    }
+
+    /**
+     * Result contains a {@code BigDecimal} value represented by the given string.
+     */
+    private static Result<BigDecimal> bigDecimalVal(String value) {
+        return new Result<>(new BigDecimal(value), null);
+    }
+
+    /** Result contains an error which message contains the following substring. */
+    private static <T> Result<T> error(String error) {
+        return new Result<>(null, error);
+    }
+
+    /**
+     * Contains result of a test case. It can either be a value or an error.
+     *
+     * @param <T> Value type.
+     */
+    private static class Result<T> {
+        final T value;
+        final String error;
+
+        Result(T value, String error) {
+            if (error != null && value != null) {
+                throw new IllegalArgumentException(""Both error and value have been specified"");
+            }
+            if (error == null && value == null) {
+                throw new IllegalArgumentException(""Neither error nor value have been specified"");
+            }
+            this.value = value;
+            this.error = error;
+        }
+
+        @Override
+        public String toString() {
+            if (value != null) {
+                return ""VAL:"" + value;
+            } else {
+                return ""ERR:"" + error;
+            }
+        }
+    }
+
+    private static class Checker {

Review Comment:
   Can we reuse or extend QueryChecker instead of creating a new one?



;28/Jun/23 12:02;githubbot;600","zstan commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245143000


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/exp/IgniteSqlFunctions.java:
##########
@@ -119,45 +120,38 @@ public static String toString(ByteString b) {
         return b == null ? null : new String(b.getBytes(), Commons.typeFactory().getDefaultCharset());
     }
 
-    private static BigDecimal setScale(int precision, int scale, BigDecimal decimal) {
-        return precision == IgniteTypeSystem.INSTANCE.getDefaultPrecision(SqlTypeName.DECIMAL)
-            ? decimal : decimal.setScale(scale, RoundingMode.HALF_UP);
-    }
-
     /** CAST(DOUBLE AS DECIMAL). */
     public static BigDecimal toBigDecimal(double val, int precision, int scale) {
-        BigDecimal decimal = BigDecimal.valueOf(val);
-        return setScale(precision, scale, decimal);
+        return toBigDecimal((Double) val, precision, scale);
     }
 
     /** CAST(FLOAT AS DECIMAL). */
     public static BigDecimal toBigDecimal(float val, int precision, int scale) {
-        BigDecimal decimal = new BigDecimal(String.valueOf(val));
-        return setScale(precision, scale, decimal);
+        return toBigDecimal((Float) val, precision, scale);
     }
 
     /** CAST(java long AS DECIMAL). */
     public static BigDecimal toBigDecimal(long val, int precision, int scale) {
         BigDecimal decimal = BigDecimal.valueOf(val);
-        return setScale(precision, scale, decimal);
+        return convertDecimal(decimal, precision, scale);
     }
 
     /** CAST(INT AS DECIMAL). */
     public static BigDecimal toBigDecimal(int val, int precision, int scale) {
         BigDecimal decimal = new BigDecimal(val);
-        return setScale(precision, scale, decimal);
+        return convertDecimal(decimal, precision, scale);
     }
 
     /** CAST(java short AS DECIMAL). */
     public static BigDecimal toBigDecimal(short val, int precision, int scale) {
         BigDecimal decimal = new BigDecimal(String.valueOf(val));
-        return setScale(precision, scale, decimal);
+        return convertDecimal(decimal, precision, scale);
     }
 
     /** CAST(java byte AS DECIMAL). */
     public static BigDecimal toBigDecimal(byte val, int precision, int scale) {
         BigDecimal decimal = new BigDecimal(String.valueOf(val));

Review Comment:
   why do we need to use _String.valueOf_ construction here ? and for _short_ the same ?



;28/Jun/23 12:35;githubbot;600","lowka commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245147975


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/exp/IgniteSqlFunctions.java:
##########
@@ -119,45 +120,38 @@ public static String toString(ByteString b) {
         return b == null ? null : new String(b.getBytes(), Commons.typeFactory().getDefaultCharset());
     }
 
-    private static BigDecimal setScale(int precision, int scale, BigDecimal decimal) {
-        return precision == IgniteTypeSystem.INSTANCE.getDefaultPrecision(SqlTypeName.DECIMAL)
-            ? decimal : decimal.setScale(scale, RoundingMode.HALF_UP);
-    }
-
     /** CAST(DOUBLE AS DECIMAL). */
     public static BigDecimal toBigDecimal(double val, int precision, int scale) {
-        BigDecimal decimal = BigDecimal.valueOf(val);
-        return setScale(precision, scale, decimal);
+        return toBigDecimal((Double) val, precision, scale);
     }
 
     /** CAST(FLOAT AS DECIMAL). */
     public static BigDecimal toBigDecimal(float val, int precision, int scale) {
-        BigDecimal decimal = new BigDecimal(String.valueOf(val));
-        return setScale(precision, scale, decimal);
+        return toBigDecimal((Float) val, precision, scale);
     }
 
     /** CAST(java long AS DECIMAL). */
     public static BigDecimal toBigDecimal(long val, int precision, int scale) {
         BigDecimal decimal = BigDecimal.valueOf(val);
-        return setScale(precision, scale, decimal);
+        return convertDecimal(decimal, precision, scale);
     }
 
     /** CAST(INT AS DECIMAL). */
     public static BigDecimal toBigDecimal(int val, int precision, int scale) {
         BigDecimal decimal = new BigDecimal(val);
-        return setScale(precision, scale, decimal);
+        return convertDecimal(decimal, precision, scale);
     }
 
     /** CAST(java short AS DECIMAL). */
     public static BigDecimal toBigDecimal(short val, int precision, int scale) {
         BigDecimal decimal = new BigDecimal(String.valueOf(val));
-        return setScale(precision, scale, decimal);
+        return convertDecimal(decimal, precision, scale);
     }
 
     /** CAST(java byte AS DECIMAL). */
     public static BigDecimal toBigDecimal(byte val, int precision, int scale) {
         BigDecimal decimal = new BigDecimal(String.valueOf(val));

Review Comment:
   @zstan  I didn't touch that code -  you can ask an author if you want to :)



;28/Jun/23 12:40;githubbot;600","zstan commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245151072


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/exp/IgniteSqlFunctions.java:
##########
@@ -119,45 +120,38 @@ public static String toString(ByteString b) {
         return b == null ? null : new String(b.getBytes(), Commons.typeFactory().getDefaultCharset());
     }
 
-    private static BigDecimal setScale(int precision, int scale, BigDecimal decimal) {
-        return precision == IgniteTypeSystem.INSTANCE.getDefaultPrecision(SqlTypeName.DECIMAL)
-            ? decimal : decimal.setScale(scale, RoundingMode.HALF_UP);
-    }
-
     /** CAST(DOUBLE AS DECIMAL). */
     public static BigDecimal toBigDecimal(double val, int precision, int scale) {
-        BigDecimal decimal = BigDecimal.valueOf(val);
-        return setScale(precision, scale, decimal);
+        return toBigDecimal((Double) val, precision, scale);
     }
 
     /** CAST(FLOAT AS DECIMAL). */
     public static BigDecimal toBigDecimal(float val, int precision, int scale) {
-        BigDecimal decimal = new BigDecimal(String.valueOf(val));
-        return setScale(precision, scale, decimal);
+        return toBigDecimal((Float) val, precision, scale);
     }
 
     /** CAST(java long AS DECIMAL). */
     public static BigDecimal toBigDecimal(long val, int precision, int scale) {
         BigDecimal decimal = BigDecimal.valueOf(val);
-        return setScale(precision, scale, decimal);
+        return convertDecimal(decimal, precision, scale);
     }
 
     /** CAST(INT AS DECIMAL). */
     public static BigDecimal toBigDecimal(int val, int precision, int scale) {
         BigDecimal decimal = new BigDecimal(val);
-        return setScale(precision, scale, decimal);
+        return convertDecimal(decimal, precision, scale);
     }
 
     /** CAST(java short AS DECIMAL). */
     public static BigDecimal toBigDecimal(short val, int precision, int scale) {
         BigDecimal decimal = new BigDecimal(String.valueOf(val));
-        return setScale(precision, scale, decimal);
+        return convertDecimal(decimal, precision, scale);
     }
 
     /** CAST(java byte AS DECIMAL). */
     public static BigDecimal toBigDecimal(byte val, int precision, int scale) {
         BigDecimal decimal = new BigDecimal(String.valueOf(val));

Review Comment:
   probably we need to fill simple issue ?



;28/Jun/23 12:42;githubbot;600","lowka commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245151091


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/exp/IgniteSqlFunctions.java:
##########
@@ -119,45 +120,38 @@ public static String toString(ByteString b) {
         return b == null ? null : new String(b.getBytes(), Commons.typeFactory().getDefaultCharset());
     }
 
-    private static BigDecimal setScale(int precision, int scale, BigDecimal decimal) {
-        return precision == IgniteTypeSystem.INSTANCE.getDefaultPrecision(SqlTypeName.DECIMAL)
-            ? decimal : decimal.setScale(scale, RoundingMode.HALF_UP);
-    }
-
     /** CAST(DOUBLE AS DECIMAL). */
     public static BigDecimal toBigDecimal(double val, int precision, int scale) {
-        BigDecimal decimal = BigDecimal.valueOf(val);
-        return setScale(precision, scale, decimal);
+        return toBigDecimal((Double) val, precision, scale);
     }
 
     /** CAST(FLOAT AS DECIMAL). */
     public static BigDecimal toBigDecimal(float val, int precision, int scale) {
-        BigDecimal decimal = new BigDecimal(String.valueOf(val));
-        return setScale(precision, scale, decimal);
+        return toBigDecimal((Float) val, precision, scale);
     }
 
     /** CAST(java long AS DECIMAL). */
     public static BigDecimal toBigDecimal(long val, int precision, int scale) {
         BigDecimal decimal = BigDecimal.valueOf(val);
-        return setScale(precision, scale, decimal);
+        return convertDecimal(decimal, precision, scale);
     }
 
     /** CAST(INT AS DECIMAL). */
     public static BigDecimal toBigDecimal(int val, int precision, int scale) {
         BigDecimal decimal = new BigDecimal(val);
-        return setScale(precision, scale, decimal);
+        return convertDecimal(decimal, precision, scale);
     }
 
     /** CAST(java short AS DECIMAL). */
     public static BigDecimal toBigDecimal(short val, int precision, int scale) {
         BigDecimal decimal = new BigDecimal(String.valueOf(val));
-        return setScale(precision, scale, decimal);
+        return convertDecimal(decimal, precision, scale);
     }
 
     /** CAST(java byte AS DECIMAL). */
     public static BigDecimal toBigDecimal(byte val, int precision, int scale) {
         BigDecimal decimal = new BigDecimal(String.valueOf(val));

Review Comment:
   @zstan removed it. I agree that it is not necessary.



;28/Jun/23 12:42;githubbot;600","lowka commented on PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#issuecomment-1611337897

   @AMashenkov I have moved tests to ignite-runner.
   


;28/Jun/23 12:47;githubbot;600","zstan commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245189875


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/exp/IgniteSqlFunctions.java:
##########
@@ -196,10 +198,42 @@ public static BigDecimal toBigDecimal(Object o, int precision, int scale) {
 
         if (o instanceof Boolean) {
             throw new UnsupportedOperationException();
+        } else if (o instanceof Number) {
+            return toBigDecimal((Number) o, precision, scale);
+        } else {
+            return toBigDecimal(o.toString(), precision, scale);
+        }
+    }
+
+    /**
+     * Converts the given {@code BigDecimal} to a decimal with the given {@code precision} and {@code scale}
+     * according to SQL spec for CAST specification: General Rules, 8.
+     */
+    public static BigDecimal convertDecimal(BigDecimal value, int precision, int scale) {
+        assert precision > 0 : ""Invalid precision: "" + precision;
+
+        int defaultPrecision = IgniteTypeSystem.INSTANCE.getDefaultPrecision(SqlTypeName.DECIMAL);
+        if (precision == defaultPrecision) {
+            // This branch covers at least one known case: access to dynamic parameter from context.
+            // In this scenario precision = DefaultTypePrecision, because types for dynamic params
+            // are created by toSql(createType(param.class)).
+            return value;
+        }
+
+        boolean nonZero = !value.unscaledValue().equals(BigInteger.ZERO);
+
+        if (nonZero && scale > precision) {
+            throw new SqlException(QUERY_INVALID_ERR, ""Numeric overflow"");

Review Comment:
   why this raises ""Numeric overflow"" ? i suppose this is something like: erroneous format or smth else ?



;28/Jun/23 13:11;githubbot;600","zstan commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245195829


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/exp/IgniteSqlFunctions.java:
##########
@@ -196,10 +198,42 @@ public static BigDecimal toBigDecimal(Object o, int precision, int scale) {
 
         if (o instanceof Boolean) {
             throw new UnsupportedOperationException();
+        } else if (o instanceof Number) {
+            return toBigDecimal((Number) o, precision, scale);
+        } else {
+            return toBigDecimal(o.toString(), precision, scale);

Review Comment:
   do we really want to try to transform any types here ?



;28/Jun/23 13:15;githubbot;600","zstan commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245197413


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/exp/IgniteSqlFunctions.java:
##########
@@ -196,10 +198,42 @@ public static BigDecimal toBigDecimal(Object o, int precision, int scale) {
 
         if (o instanceof Boolean) {
             throw new UnsupportedOperationException();
+        } else if (o instanceof Number) {
+            return toBigDecimal((Number) o, precision, scale);
+        } else {
+            return toBigDecimal(o.toString(), precision, scale);
+        }
+    }
+
+    /**
+     * Converts the given {@code BigDecimal} to a decimal with the given {@code precision} and {@code scale}
+     * according to SQL spec for CAST specification: General Rules, 8.
+     */
+    public static BigDecimal convertDecimal(BigDecimal value, int precision, int scale) {
+        assert precision > 0 : ""Invalid precision: "" + precision;
+
+        int defaultPrecision = IgniteTypeSystem.INSTANCE.getDefaultPrecision(SqlTypeName.DECIMAL);
+        if (precision == defaultPrecision) {
+            // This branch covers at least one known case: access to dynamic parameter from context.
+            // In this scenario precision = DefaultTypePrecision, because types for dynamic params
+            // are created by toSql(createType(param.class)).
+            return value;
+        }
+
+        boolean nonZero = !value.unscaledValue().equals(BigInteger.ZERO);
+
+        if (nonZero && scale > precision) {
+            throw new SqlException(QUERY_INVALID_ERR, ""Numeric overflow"");
+        }
+
+        int currentSignificantDigits = value.precision() - value.scale();

Review Comment:
   no need to calculate it if nonZero == false;



;28/Jun/23 13:16;githubbot;600","lowka commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245208804


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/exp/IgniteSqlFunctions.java:
##########
@@ -196,10 +198,42 @@ public static BigDecimal toBigDecimal(Object o, int precision, int scale) {
 
         if (o instanceof Boolean) {
             throw new UnsupportedOperationException();
+        } else if (o instanceof Number) {
+            return toBigDecimal((Number) o, precision, scale);
+        } else {
+            return toBigDecimal(o.toString(), precision, scale);
+        }
+    }
+
+    /**
+     * Converts the given {@code BigDecimal} to a decimal with the given {@code precision} and {@code scale}
+     * according to SQL spec for CAST specification: General Rules, 8.
+     */
+    public static BigDecimal convertDecimal(BigDecimal value, int precision, int scale) {
+        assert precision > 0 : ""Invalid precision: "" + precision;
+
+        int defaultPrecision = IgniteTypeSystem.INSTANCE.getDefaultPrecision(SqlTypeName.DECIMAL);
+        if (precision == defaultPrecision) {
+            // This branch covers at least one known case: access to dynamic parameter from context.
+            // In this scenario precision = DefaultTypePrecision, because types for dynamic params
+            // are created by toSql(createType(param.class)).
+            return value;
+        }
+
+        boolean nonZero = !value.unscaledValue().equals(BigInteger.ZERO);
+
+        if (nonZero && scale > precision) {
+            throw new SqlException(QUERY_INVALID_ERR, ""Numeric overflow"");

Review Comment:
   @zstan I looked at PostgeSQL and it returns the same error in both cases.



;28/Jun/23 13:25;githubbot;600","lowka commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245210318


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/exp/IgniteSqlFunctions.java:
##########
@@ -196,10 +198,42 @@ public static BigDecimal toBigDecimal(Object o, int precision, int scale) {
 
         if (o instanceof Boolean) {
             throw new UnsupportedOperationException();
+        } else if (o instanceof Number) {
+            return toBigDecimal((Number) o, precision, scale);
+        } else {
+            return toBigDecimal(o.toString(), precision, scale);

Review Comment:
   Reverted these changes (but it was just formatting) since original code does the same.
   



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/exp/IgniteSqlFunctions.java:
##########
@@ -196,10 +198,42 @@ public static BigDecimal toBigDecimal(Object o, int precision, int scale) {
 
         if (o instanceof Boolean) {
             throw new UnsupportedOperationException();
+        } else if (o instanceof Number) {
+            return toBigDecimal((Number) o, precision, scale);
+        } else {
+            return toBigDecimal(o.toString(), precision, scale);
+        }
+    }
+
+    /**
+     * Converts the given {@code BigDecimal} to a decimal with the given {@code precision} and {@code scale}
+     * according to SQL spec for CAST specification: General Rules, 8.
+     */
+    public static BigDecimal convertDecimal(BigDecimal value, int precision, int scale) {
+        assert precision > 0 : ""Invalid precision: "" + precision;
+
+        int defaultPrecision = IgniteTypeSystem.INSTANCE.getDefaultPrecision(SqlTypeName.DECIMAL);
+        if (precision == defaultPrecision) {
+            // This branch covers at least one known case: access to dynamic parameter from context.
+            // In this scenario precision = DefaultTypePrecision, because types for dynamic params
+            // are created by toSql(createType(param.class)).
+            return value;
+        }
+
+        boolean nonZero = !value.unscaledValue().equals(BigInteger.ZERO);
+
+        if (nonZero && scale > precision) {
+            throw new SqlException(QUERY_INVALID_ERR, ""Numeric overflow"");
+        }
+
+        int currentSignificantDigits = value.precision() - value.scale();

Review Comment:
   Rewrote that part.
   



;28/Jun/23 13:26;githubbot;600","zstan commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245226285


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItDataTypesTest.java:
##########
@@ -315,6 +335,252 @@ public void testDecimalLiteral() {
         assertQuery(""SELECT id FROM tbl WHERE val = DECIMAL '10.20'"").returns(1).check();
     }
 
+
+    /** decimal casts - cast literal to decimal. */
+    @ParameterizedTest(name = ""{2}:{1} AS {3} = {4}"")
+    @MethodSource(""decimalCastFromLiterals"")
+    public void testDecimalCastsNumericLiterals(CaseStatus status, RelDataType inputType, Object input,
+            RelDataType targetType, Result<BigDecimal> result) {
+
+        Assumptions.assumeTrue(status == CaseStatus.RUN);
+
+        String literal = asLiteral(input, inputType);
+        String query = format(""SELECT CAST({} AS {})"", literal, targetType);
+
+        QueryChecker checker = assertQuery(query);
+        expectResult(checker, result);
+    }
+
+    private static Stream<Arguments> decimalCastFromLiterals() {
+        RelDataType varcharType = varcharType();
+        // ignored
+        RelDataType numeric = decimalType(4);
+
+        return Stream.of(
+                // String
+                arguments(CaseStatus.RUN, varcharType, ""100"", decimalType(3), bigDecimalVal(""100"")),

Review Comment:
   can u add additional tests (or may be already exist and i miss smt?)
   ```
           String query = format(""SELECT CAST(? AS DECIMAL(5, 1))"");
   
           BigDecimal bd = new BigDecimal(""12345"");
   
           sql(query).withParams(bd) <- failed
   
           bd = new BigDecimal(""1234"");
           sql(query).withParams(bd) <- correct
   ```



;28/Jun/23 13:38;githubbot;600","zstan commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245235582


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/exp/IgniteSqlFunctions.java:
##########
@@ -209,6 +216,39 @@ public static BigDecimal toBigDecimal(Object o, int precision, int scale) {
                : toBigDecimal(o.toString(), precision, scale);
     }
 
+    /**
+     * Converts the given {@code BigDecimal} to a decimal with the given {@code precision} and {@code scale}
+     * according to SQL spec for CAST specification: General Rules, 8.
+     */
+    public static BigDecimal convertDecimal(BigDecimal value, int precision, int scale) {
+        assert precision > 0 : ""Invalid precision: "" + precision;
+
+        int defaultPrecision = IgniteTypeSystem.INSTANCE.getDefaultPrecision(SqlTypeName.DECIMAL);
+        if (precision == defaultPrecision) {
+            // This branch covers at least one known case: access to dynamic parameter from context.
+            // In this scenario precision = DefaultTypePrecision, because types for dynamic params
+            // are created by toSql(createType(param.class)).
+            return value;
+        }
+
+        boolean nonZero = !value.unscaledValue().equals(BigInteger.ZERO);
+
+        if (nonZero) {
+            if (scale > precision) {
+                throw new SqlException(QUERY_INVALID_ERR, ""Numeric overflow"");

Review Comment:
   probably ""Numeric overflow"" must be closer to PG ? i.e. ""Numeric field overflow"" ? 
   additionally why this message is not a public constant for purpose of further test usage ?



;28/Jun/23 13:45;githubbot;600","lowka commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245254713


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/exp/IgniteSqlFunctions.java:
##########
@@ -209,6 +216,39 @@ public static BigDecimal toBigDecimal(Object o, int precision, int scale) {
                : toBigDecimal(o.toString(), precision, scale);
     }
 
+    /**
+     * Converts the given {@code BigDecimal} to a decimal with the given {@code precision} and {@code scale}
+     * according to SQL spec for CAST specification: General Rules, 8.
+     */
+    public static BigDecimal convertDecimal(BigDecimal value, int precision, int scale) {
+        assert precision > 0 : ""Invalid precision: "" + precision;
+
+        int defaultPrecision = IgniteTypeSystem.INSTANCE.getDefaultPrecision(SqlTypeName.DECIMAL);
+        if (precision == defaultPrecision) {
+            // This branch covers at least one known case: access to dynamic parameter from context.
+            // In this scenario precision = DefaultTypePrecision, because types for dynamic params
+            // are created by toSql(createType(param.class)).
+            return value;
+        }
+
+        boolean nonZero = !value.unscaledValue().equals(BigInteger.ZERO);
+
+        if (nonZero) {
+            if (scale > precision) {
+                throw new SqlException(QUERY_INVALID_ERR, ""Numeric overflow"");

Review Comment:
   Changed a message to `Numeric field overflow`. Moved it to constant but I do not think is a good idea to use the same constant in tests and this method. If we use the same constant, then someone unintentionally changes the constant in `IgniteFunctions` it also changes the tests, thus changing public API. If we use separate constant for tests and system code , then unintentional changes would break tests because error messages won't match.



;28/Jun/23 13:57;githubbot;600","lowka commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245255950


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItDataTypesTest.java:
##########
@@ -315,6 +335,252 @@ public void testDecimalLiteral() {
         assertQuery(""SELECT id FROM tbl WHERE val = DECIMAL '10.20'"").returns(1).check();
     }
 
+
+    /** decimal casts - cast literal to decimal. */
+    @ParameterizedTest(name = ""{2}:{1} AS {3} = {4}"")
+    @MethodSource(""decimalCastFromLiterals"")
+    public void testDecimalCastsNumericLiterals(CaseStatus status, RelDataType inputType, Object input,
+            RelDataType targetType, Result<BigDecimal> result) {
+
+        Assumptions.assumeTrue(status == CaseStatus.RUN);
+
+        String literal = asLiteral(input, inputType);
+        String query = format(""SELECT CAST({} AS {})"", literal, targetType);
+
+        QueryChecker checker = assertQuery(query);
+        expectResult(checker, result);
+    }
+
+    private static Stream<Arguments> decimalCastFromLiterals() {
+        RelDataType varcharType = varcharType();
+        // ignored
+        RelDataType numeric = decimalType(4);
+
+        return Stream.of(
+                // String
+                arguments(CaseStatus.RUN, varcharType, ""100"", decimalType(3), bigDecimalVal(""100"")),

Review Comment:
   @zstan Added these cases.



;28/Jun/23 13:58;githubbot;600","zstan commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245263682


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/sql/IgniteSqlDecimalLiteralTest.java:
##########
@@ -66,6 +70,32 @@ public void testValueAndType() {
         assertEquals(expectedType, actualType, ""type"");
     }
 
+    /**
+     * Type of numeric literal and type of decimal literal should match.
+     */
+    @ParameterizedTest
+    @CsvSource({

Review Comment:
   if we call ""1000000000000000000000000"" here, test will fail, is it ok ?



;28/Jun/23 14:01;githubbot;600","lowka commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245269593


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/sql/IgniteSqlDecimalLiteralTest.java:
##########
@@ -66,6 +70,32 @@ public void testValueAndType() {
         assertEquals(expectedType, actualType, ""type"");
     }
 
+    /**
+     * Type of numeric literal and type of decimal literal should match.
+     */
+    @ParameterizedTest
+    @CsvSource({

Review Comment:
   `1000000000000000000000000` is a `BIGINT`, it is not a `DECIMAL`.



;28/Jun/23 14:05;githubbot;600","lowka commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245270727


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/sql/IgniteSqlDecimalLiteralTest.java:
##########
@@ -66,6 +70,32 @@ public void testValueAndType() {
         assertEquals(expectedType, actualType, ""type"");
     }
 
+    /**
+     * Type of numeric literal and type of decimal literal should match.
+     */
+    @ParameterizedTest
+    @CsvSource({

Review Comment:
   Updated test's javadoc.
   



;28/Jun/23 14:06;githubbot;600","zstan commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245226285


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItDataTypesTest.java:
##########
@@ -315,6 +335,252 @@ public void testDecimalLiteral() {
         assertQuery(""SELECT id FROM tbl WHERE val = DECIMAL '10.20'"").returns(1).check();
     }
 
+
+    /** decimal casts - cast literal to decimal. */
+    @ParameterizedTest(name = ""{2}:{1} AS {3} = {4}"")
+    @MethodSource(""decimalCastFromLiterals"")
+    public void testDecimalCastsNumericLiterals(CaseStatus status, RelDataType inputType, Object input,
+            RelDataType targetType, Result<BigDecimal> result) {
+
+        Assumptions.assumeTrue(status == CaseStatus.RUN);
+
+        String literal = asLiteral(input, inputType);
+        String query = format(""SELECT CAST({} AS {})"", literal, targetType);
+
+        QueryChecker checker = assertQuery(query);
+        expectResult(checker, result);
+    }
+
+    private static Stream<Arguments> decimalCastFromLiterals() {
+        RelDataType varcharType = varcharType();
+        // ignored
+        RelDataType numeric = decimalType(4);
+
+        return Stream.of(
+                // String
+                arguments(CaseStatus.RUN, varcharType, ""100"", decimalType(3), bigDecimalVal(""100"")),

Review Comment:
   can u add additional tests (or may be already exist and i miss smt?)
   ```
           String query = format(""SELECT CAST(? AS DECIMAL(5, 1))"");
   
           BigDecimal bd = new BigDecimal(""12345"");
   
           sql(query).withParams(bd) <- failed
   
           bd = new BigDecimal(""1234"");
           sql(query).withParams(bd) <- correct
   ```



;28/Jun/23 14:06;githubbot;600","zstan commented on code in PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220#discussion_r1245273576


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItDataTypesTest.java:
##########
@@ -315,6 +335,252 @@ public void testDecimalLiteral() {
         assertQuery(""SELECT id FROM tbl WHERE val = DECIMAL '10.20'"").returns(1).check();
     }
 
+
+    /** decimal casts - cast literal to decimal. */
+    @ParameterizedTest(name = ""{2}:{1} AS {3} = {4}"")
+    @MethodSource(""decimalCastFromLiterals"")
+    public void testDecimalCastsNumericLiterals(CaseStatus status, RelDataType inputType, Object input,
+            RelDataType targetType, Result<BigDecimal> result) {
+
+        Assumptions.assumeTrue(status == CaseStatus.RUN);
+
+        String literal = asLiteral(input, inputType);
+        String query = format(""SELECT CAST({} AS {})"", literal, targetType);
+
+        QueryChecker checker = assertQuery(query);
+        expectResult(checker, result);
+    }
+
+    private static Stream<Arguments> decimalCastFromLiterals() {
+        RelDataType varcharType = varcharType();
+        // ignored
+        RelDataType numeric = decimalType(4);
+
+        return Stream.of(
+                // String
+                arguments(CaseStatus.RUN, varcharType, ""100"", decimalType(3), bigDecimalVal(""100"")),

Review Comment:
   oh, i see these tests are present at testConvertDecimal



;28/Jun/23 14:07;githubbot;600","zstan merged PR #2220:
URL: https://github.com/apache/ignite-3/pull/2220


;28/Jun/23 14:44;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,0,13200,,,0,13200,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-18831,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jun 28 14:45:24 UTC 2023,,,,,,,,,,"0|z1hhsg:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"28/Jun/23 14:45;zstan;merged, thanks for your effort.;;;",,,,,
Fix assertion error in case of empty SQL query,IGNITE-19350,13533720,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,NSAmelchev,NSAmelchev,NSAmelchev,23/Apr/23 17:48,24/Apr/23 14:41,13/Jul/23 09:11,24/Apr/23 14:41,,,,,,,,2.16,,,,0,ise,,,"Empty SQL query throws AssertionError or IndexOutOfBoundsException. SqlParseException is more suitable for this case.

{noformat}
[20:43:59,672][SEVERE][client-connector-#84%48a3ed6f-4945-42c9-a5f6-09c1f1d26e35%][ClientListenerNioListener] Failed to process client request [req=o.a.i.i.processors.platform.client.cache.ClientCacheSqlFieldsQueryRequest@5fa679b6, msg=null]
java.lang.AssertionError
	at org.apache.ignite.internal.processors.platform.client.cache.ClientCacheSqlFieldsQueryRequest.process(ClientCacheSqlFieldsQueryRequest.java:152)
	at org.apache.ignite.internal.processors.platform.client.ClientRequestHandler.handle(ClientRequestHandler.java:101)
	at org.apache.ignite.internal.processors.odbc.ClientListenerNioListener.onMessage(ClientListenerNioListener.java:209)
	at org.apache.ignite.internal.processors.odbc.ClientListenerNioListener.onMessage(ClientListenerNioListener.java:55)
	at org.apache.ignite.internal.util.nio.GridNioFilterChain$TailFilter.onMessageReceived(GridNioFilterChain.java:279)
	at org.apache.ignite.internal.util.nio.GridNioFilterAdapter.proceedMessageReceived(GridNioFilterAdapter.java:109)
	at org.apache.ignite.internal.util.nio.GridNioAsyncNotifyFilter$3.body(GridNioAsyncNotifyFilter.java:97)
	at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:125)
	at org.apache.ignite.internal.util.worker.GridWorkerPool$1.run(GridWorkerPool.java:70)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:750)
[20:43:59] (err) Unexpected exception message.org.apache.ignite.client.ClientException: Ignite failed to process request [3]: 50000: null (server status code [1])
{noformat}

{noformat}
[20:42:55] (err) Unexpected exception.java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
	at java.util.ArrayList.rangeCheck(ArrayList.java:659)
	at java.util.ArrayList.get(ArrayList.java:435)
	at org.apache.ignite.internal.processors.query.GridQueryProcessor.querySqlFields(GridQueryProcessor.java:2985)
{noformat}
",,ignitetcbot,NSAmelchev,,,,"NSAmelchev opened a new pull request, #10663:
URL: https://github.com/apache/ignite/pull/10663

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;23/Apr/23 17:51;githubbot;600","sonarcloud[bot] commented on PR #10663:
URL: https://github.com/apache/ignite/pull/10663#issuecomment-1519121876

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10663)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10663&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10663&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10663&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10663&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10663&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10663&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10663&metric=new_duplicated_lines_density&view=list)
   
   


;23/Apr/23 17:59;githubbot;600","sonarcloud[bot] commented on PR #10663:
URL: https://github.com/apache/ignite/pull/10663#issuecomment-1519555818

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10663)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10663&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10663&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10663&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10663&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10663&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10663&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10663&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10663&metric=new_duplicated_lines_density&view=list)
   
   


;24/Apr/23 07:47;githubbot;600","NSAmelchev merged PR #10663:
URL: https://github.com/apache/ignite/pull/10663


;24/Apr/23 14:40;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Mon Apr 24 14:41:22 UTC 2023,,,,,,,,,,"0|z1hh1k:",9223372036854775807,Fixed assertion error in case of empty SQL query,,,,,,,,,,,,,,,,,,,,"24/Apr/23 12:55;ignitetcbot;{panel:title=Branch: [pull/10663/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10663/head] Base: [master] : New Tests (2)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Thin Client: Java{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7150227]]
* {color:#013220}ClientTestSuite: FunctionalQueryTest.testEmptyQuery - PASSED{color}

{color:#00008b}Calcite SQL{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7150160]]
* {color:#013220}IgniteCalciteTestSuite: CalciteQueryProcessorTest.testEmptyQuery - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7150241&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","24/Apr/23 14:41;NSAmelchev;Merged into the master.

[~alexpl], Thank you for the review.;;;",,,,
Fix test build,IGNITE-19348,13533635,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,vpakhnushev,vpakhnushev,vpakhnushev,22/Apr/23 12:19,24/Apr/23 10:02,13/Jul/23 09:11,24/Apr/23 10:02,,,,,,,,3.0.0-beta2,cli,,,0,ignite-3,,,Some methods were renamed in the IGNITE-19194 which broke test compilation after IGNITE-19036 was merged.,,ptupitsyn,vpakhnushev,,,,"valepakh opened a new pull request, #1972:
URL: https://github.com/apache/ignite-3/pull/1972

   https://issues.apache.org/jira/browse/IGNITE-19036


;22/Apr/23 12:20;githubbot;600","ptupitsyn merged PR #1972:
URL: https://github.com/apache/ignite-3/pull/1972


;24/Apr/23 10:01;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Apr 24 10:02:13 UTC 2023,,,,,,,,,,"0|z1hgjk:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"24/Apr/23 10:02;ptupitsyn;Merged to main: a08b234e2420b388a63573ff0c76322279ee1853;;;",,,,,
Allow using default trust store in client connections,IGNITE-19346,13533578,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,vpakhnushev,vpakhnushev,21/Apr/23 15:17,27/Apr/23 12:15,13/Jul/23 09:11,27/Apr/23 12:15,,,,,,,,3.0.0-beta2,security,,,0,ignite-3,,,"Java client incorrectly sets up SSL context so that if trust manager path is null, it doesn't fall back to the default Java trust store.
CLI also should support using default trust store for JDBC connections by introducing separate ssl-enabled property.
CLI REST client and Java client implementations are slightly different in that the CLI uses automatic key store type deduction while Java client requires it to be set explicitly.",,aleksandr.pakhomov,vpakhnushev,,,,"valepakh opened a new pull request, #1971:
URL: https://github.com/apache/ignite-3/pull/1971

   https://issues.apache.org/jira/browse/IGNITE-19346
   
   Testing this requires manually adding a CA to the Java cacerts trust store. You might want to back up the cacerts first.
   `keytool -importkeystore -srckeystore modules/runner/src/integrationTest/resources/ssl/truststore.jks -srcstorepass changeit -destkeystore ${JAVA_HOME}/lib/security/cacerts -deststorepass changeit`
   Then start ignite with the `rest` and `clientConnector` `keyStore` configured to the `modules/runner/src/integrationTest/resources/ssl/keystore.p12`
   Run `ignite cli config set ignite.jdbc.ssl-enabled=true`
   Then you should be able to connect to the node using just the `https://localhost:10400` node URL and if you are using REPL mode, you should be able to connect to the JDBC using `sql` command.


;21/Apr/23 15:37;githubbot;600","PakhomovAlexander merged PR #1971:
URL: https://github.com/apache/ignite-3/pull/1971


;27/Apr/23 12:14;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Thu Apr 27 12:15:38 UTC 2023,,,,,,,,,,"0|z1hg6w:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"27/Apr/23 12:15;aleksandr.pakhomov;Thank, merged into main: 2d34d76f1f9112141cc82b8908bc72c5e5bffddc;;;",,,,,
SQL: incorrect NULLIF behavior in some cases,IGNITE-19345,13533572,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,xtern,akhitrin,akhitrin,21/Apr/23 14:44,16/May/23 14:26,13/Jul/23 09:11,16/May/23 14:26,3.0.0-beta1,,,,,,,,sql,,,0,calcite,ignite-3,,"During the validation of IGNITE-18167, the following error was found:
{code:sql}
sql-cli> SELECT NULLIF(1, 1) IS NULL;
SQL query execution error
Exception while executing query [query=SELECT NULLIF(1, 1) IS NULL;]. Error message:From line 1, column 8 to line 1, column 19: Illegal mixing of types in CASE or COALESCE statement
{code}

For chars, it works correctly:
{code:sql}
sql-cli> SELECT NULLIF('1', '1') IS NULL;
╔═════════╗
║ EXPR$0  ║
╠═════════╣
║ true    ║
╚═════════╝
{code}

For slightly more complex numeric query, it also works correctly:
{code:sql}
sql-cli> SELECT x IS NULL FROM (SELECT NULLIF(1, 1) AS x);
╔═════════╗
║ EXPR$0  ║
╠═════════╣
║ true    ║
╚═════════╝
{code}",,akhitrin,jooger,xtern,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue May 16 14:26:57 UTC 2023,,,,,,,,,,"0|z1hg5k:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"16/May/23 14:12;jooger;[~xtern]  LGTM;;;","16/May/23 14:26;xtern;[Merged|https://github.com/apache/ignite-3/commit/dfb86951270d857fb527e05857d23508c7925650] to the main branch.;;;",,,,
Enable some muted test from DistributionZoneAwaitDataNodesTest,IGNITE-19343,13533568,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,Sergey Uttsel,maliev,maliev,21/Apr/23 14:17,15/May/23 12:19,13/Jul/23 09:11,15/May/23 12:18,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"h3. *Motivation*

When IGNITE-18756 was developed, some of the test were disabled, because we thought that after introduction of {{StandaloneMetaStorageManager}} it will be impossible to test some concurrent scenarios with MetaStorage. But seems that is it possible, see {{DistributionZoneManagerScaleUpTest#testScaleUpDidNotChangeDataNodesWhenTriggerKeyWasConcurrentlyChanged}}

Disabled tests: 
{{{}DistributionZoneAwaitDataNodesTest#testRemoveZoneWhileAwaitingDataNodes{}}}, 
{{DistributionZoneAwaitDataNodesTest#testScaleUpScaleDownAreChangedWhileAwaitingDataNodes}}
h3. *Definition of Done*

testRemoveZoneWhileAwaitingDataNodes and testScaleUpScaleDownAreChangedWhileAwaitingDataNodes are enabled.
h3. *Implementation Notes*

DistributedConfigurationStorage is used in BaseDistributionZoneManagerTest to fix an issue when metaStorageManager and zonesConfiguration use different storage and have different storage revisions. So https://issues.apache.org/jira/browse/IGNITE-19342 is partly implemented.",,alapin,maliev,,,,"sergeyuttsel opened a new pull request, #2059:
URL: https://github.com/apache/ignite-3/pull/2059

   * DistributedConfigurationStorage is used in BaseDistributionZoneManagerTest to fix an issue when metaStorageManager and zonesConfiguration use different storage and have different storage revisions.


;11/May/23 09:16;githubbot;600","sanpwc commented on code in PR #2059:
URL: https://github.com/apache/ignite-3/pull/2059#discussion_r1191071110


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/BaseDistributionZoneManagerTest.java:
##########
@@ -70,6 +75,10 @@ public class BaseDistributionZoneManagerTest extends BaseIgniteAbstractTest {
 
     protected VaultManager vaultMgr;
 
+    private ConfigurationStorage cfgStorage;

Review Comment:
   Idea claims that cfgStorage ""Field can be converted to a local variable "". Same for cfgMgr.



##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/BaseDistributionZoneManagerTest.java:
##########
@@ -84,6 +93,20 @@ void setUp() {
 
         components.add(metaStorageManager);
 
+        cfgStorage = new DistributedConfigurationStorage(metaStorageManager, vaultMgr);
+
+        cfgMgr =  new ConfigurationManager(
+                List.of(DistributionZonesConfiguration.KEY),
+                Set.of(),
+                cfgStorage,
+                List.of(),
+                List.of(TestPersistStorageConfigurationSchema.class)
+        );
+
+        ConfigurationRegistry registry = cfgMgr.configurationRegistry();
+
+        components.add(registry);

Review Comment:
   Why we add register and not cfgMgr to the components list?



##########
modules/distribution-zones/build.gradle:
##########
@@ -51,6 +51,7 @@ dependencies {
     testImplementation project(':ignite-network-api')
     testImplementation project(':ignite-metastorage-api')
     testImplementation project(':ignite-metastorage')
+    testImplementation project(':ignite-runner')

Review Comment:
   What classed do we use from the runner module?



##########
modules/distribution-zones/build.gradle:
##########
@@ -51,6 +51,7 @@ dependencies {
     testImplementation project(':ignite-network-api')
     testImplementation project(':ignite-metastorage-api')
     testImplementation project(':ignite-metastorage')
+    testImplementation project(':ignite-runner')

Review Comment:
   Which classed do we use from runner?



##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneAwaitDataNodesTest.java:
##########
@@ -342,20 +351,21 @@ void testWithOutAwaiting() throws Exception {
     /**
      * Test checks that data nodes futures are completed exceptionally if the zone was removed while data nodes awaiting.
      */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19255"")
     @Test
     void testRemoveZoneWhileAwaitingDataNodes() throws Exception {
         startZoneManager();
 
+        String zoneName = ""zone0"";

Review Comment:
   Seems that we use such name and also zone1 and zone2 in multiple test within given class. Let's extract them to constants.



##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneAwaitDataNodesTest.java:
##########
@@ -342,20 +351,21 @@ void testWithOutAwaiting() throws Exception {
     /**
      * Test checks that data nodes futures are completed exceptionally if the zone was removed while data nodes awaiting.
      */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19255"")
     @Test
     void testRemoveZoneWhileAwaitingDataNodes() throws Exception {
         startZoneManager();
 
+        String zoneName = ""zone0"";
+
         distributionZoneManager.createZone(
-                        new DistributionZoneConfigurationParameters.Builder(""zone0"")
+                        new DistributionZoneConfigurationParameters.Builder(zoneName)
                                 .dataNodesAutoAdjustScaleUp(IMMEDIATE_TIMER_VALUE)
                                 .dataNodesAutoAdjustScaleDown(IMMEDIATE_TIMER_VALUE)
                                 .build()
                 )
                 .get(3, SECONDS);
 
-        int zoneId = distributionZoneManager.getZoneId(""zone0"");
+        int zoneId = distributionZoneManager.getZoneId(zoneName);
 
         CompletableFuture<Set<String>> dataNodesFut0 = distributionZoneManager.topologyVersionedDataNodes(zoneId, 5);

Review Comment:
   Why do we need all that?
   ```
           CompletableFuture<Set<String>> dataNodesFut0 = distributionZoneManager.topologyVersionedDataNodes(zoneId, 5);
   
           setLogicalTopologyInMetaStorage(Set.of(""node0"", ""node1""), 100);
   
           assertFalse(dataNodesFut0.isDone());
   
           assertEquals(Set.of(""node0"", ""node1""), dataNodesFut0.get(3, SECONDS));
   ```
   If I'll comment all that lines the test will still pass. 



##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneAwaitDataNodesTest.java:
##########
@@ -342,20 +351,21 @@ void testWithOutAwaiting() throws Exception {
     /**
      * Test checks that data nodes futures are completed exceptionally if the zone was removed while data nodes awaiting.
      */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19255"")
     @Test
     void testRemoveZoneWhileAwaitingDataNodes() throws Exception {
         startZoneManager();
 
+        String zoneName = ""zone0"";
+
         distributionZoneManager.createZone(
-                        new DistributionZoneConfigurationParameters.Builder(""zone0"")
+                        new DistributionZoneConfigurationParameters.Builder(zoneName)
                                 .dataNodesAutoAdjustScaleUp(IMMEDIATE_TIMER_VALUE)
                                 .dataNodesAutoAdjustScaleDown(IMMEDIATE_TIMER_VALUE)
                                 .build()
                 )
                 .get(3, SECONDS);
 
-        int zoneId = distributionZoneManager.getZoneId(""zone0"");
+        int zoneId = distributionZoneManager.getZoneId(zoneName);

Review Comment:
   Seems that we don't need explicit zoneId retrieval, because distributionZoneManager.createZone() will return future with zoneId. Meanaing that it's enough to write following.
   
   ```
           Integer zoneId =  distributionZoneManager.createZone(
                           new DistributionZoneConfigurationParameters.Builder(""zone0"")
                           new DistributionZoneConfigurationParameters.Builder(zoneName)
                                   .dataNodesAutoAdjustScaleUp(IMMEDIATE_TIMER_VALUE)
                                   .dataNodesAutoAdjustScaleDown(IMMEDIATE_TIMER_VALUE)
                                   .build()
                   )
                   .get(3, SECONDS);
   ```
   
   And btw, let's update createZone javadoc in a way that it will explicitly denote that CompletableFuture<Integer> is a future with zoneId.



;11/May/23 13:02;githubbot;600","sanpwc commented on code in PR #2059:
URL: https://github.com/apache/ignite-3/pull/2059#discussion_r1191161452


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneAwaitDataNodesTest.java:
##########
@@ -367,20 +377,30 @@ void testRemoveZoneWhileAwaitingDataNodes() throws Exception {
 
         CompletableFuture<Set<String>> dataNodesFut1 = distributionZoneManager.topologyVersionedDataNodes(zoneId, 106);
 
+        doAnswer(invocation -> {

Review Comment:
   What are we trying to achieve with this mock? Why it's not enough to simply remove zone, meaning just call
   `distributionZoneManager.dropZone(zoneName).get();`
   By the way if I do this, test might fail because instead of expected `DistributionZoneWasRemovedException` `DistributionZoneNotFoundException` will be thrown from `org.apache.ignite.internal.distributionzones.DistributionZonesUtil#getZoneById`. We should also fix that.



;11/May/23 13:10;githubbot;600","sanpwc commented on code in PR #2059:
URL: https://github.com/apache/ignite-3/pull/2059#discussion_r1191166974


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneAwaitDataNodesTest.java:
##########
@@ -367,20 +377,30 @@ void testRemoveZoneWhileAwaitingDataNodes() throws Exception {
 
         CompletableFuture<Set<String>> dataNodesFut1 = distributionZoneManager.topologyVersionedDataNodes(zoneId, 106);
 
+        doAnswer(invocation -> {
+            If iif = invocation.getArgument(0);
+
+            byte[] key = zoneScaleUpChangeTriggerKey(zoneId).bytes();
+
+            if (Arrays.stream(iif.cond().keys()).anyMatch(k -> Arrays.equals(key, k))) {
+                //Drop the zone while dataNodesFut1 is awaiting a data nodes update.
+                distributionZoneManager.dropZone(zoneName).get();

Review Comment:
   It's better to bound future awaiting time either with `.get(3, SECONDS);` or with
   ```
           // Drop zone.
           assertThat(distributionZoneManager.dropZone(zoneName), willSucceedIn(3, SECONDS));
   ```
   From my point of view second approach is generally better.
   



;11/May/23 13:15;githubbot;600","sergeyuttsel commented on code in PR #2059:
URL: https://github.com/apache/ignite-3/pull/2059#discussion_r1191224783


##########
modules/distribution-zones/build.gradle:
##########
@@ -51,6 +51,7 @@ dependencies {
     testImplementation project(':ignite-network-api')
     testImplementation project(':ignite-metastorage-api')
     testImplementation project(':ignite-metastorage')
+    testImplementation project(':ignite-runner')

Review Comment:
   DistributedConfigurationStorage



;11/May/23 14:05;githubbot;600","sergeyuttsel commented on code in PR #2059:
URL: https://github.com/apache/ignite-3/pull/2059#discussion_r1191227594


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/BaseDistributionZoneManagerTest.java:
##########
@@ -84,6 +93,20 @@ void setUp() {
 
         components.add(metaStorageManager);
 
+        cfgStorage = new DistributedConfigurationStorage(metaStorageManager, vaultMgr);
+
+        cfgMgr =  new ConfigurationManager(
+                List.of(DistributionZonesConfiguration.KEY),
+                Set.of(),
+                cfgStorage,
+                List.of(),
+                List.of(TestPersistStorageConfigurationSchema.class)
+        );
+
+        ConfigurationRegistry registry = cfgMgr.configurationRegistry();
+
+        components.add(registry);

Review Comment:
   Thanks. I've added.



;11/May/23 14:07;githubbot;600","sergeyuttsel commented on code in PR #2059:
URL: https://github.com/apache/ignite-3/pull/2059#discussion_r1191229262


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/BaseDistributionZoneManagerTest.java:
##########
@@ -70,6 +75,10 @@ public class BaseDistributionZoneManagerTest extends BaseIgniteAbstractTest {
 
     protected VaultManager vaultMgr;
 
+    private ConfigurationStorage cfgStorage;

Review Comment:
   Fixed



;11/May/23 14:08;githubbot;600","alievmirza commented on code in PR #2059:
URL: https://github.com/apache/ignite-3/pull/2059#discussion_r1191249715


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneManagerScaleUpTest.java:
##########
@@ -1351,8 +1353,8 @@ private void preparePrerequisites() throws Exception {
 
         assertDataNodesForZone(1, clusterNodesNames, keyValueStorage);
 
-        assertZoneScaleUpChangeTriggerKey(1, 1, keyValueStorage);
-        assertZoneScaleDownChangeTriggerKey(1, 1, keyValueStorage);
+        assertZoneScaleUpChangeTriggerKey(PREREQUISITE_REVISION, 1, keyValueStorage);

Review Comment:
   let's check here that `assertZoneScaleUp/DownChangeTriggerKey` are not null and equal to each other, and after that 
   Lets initialise here `PREREQUISITE_REVISION` with the value from trigger key



##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneManagerScaleUpTest.java:
##########
@@ -721,29 +723,29 @@ void testCleanUpAfterSchedulers() throws Exception {
 
         ZoneState zoneState = distributionZoneManager.zonesTimers().get(1);
 
-        zoneState.nodesToAddToDataNodes(Set.of(""D""), 3);
-        zoneState.nodesToAddToDataNodes(Set.of(""E""), 4);
-        zoneState.nodesToRemoveFromDataNodes(Set.of(""C""), 7);
+        zoneState.nodesToAddToDataNodes(Set.of(""D""), PREREQUISITE_REVISION + 2);

Review Comment:
   please, for this and all test like testVariousScaleUpScaleDownScenarios*
   
   do not use PREREQUISITE_REVISION + x construction, but use 
   1000 + n as a revision, where n is a value before your changes



;11/May/23 14:27;githubbot;600","sergeyuttsel commented on code in PR #2059:
URL: https://github.com/apache/ignite-3/pull/2059#discussion_r1191260576


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneAwaitDataNodesTest.java:
##########
@@ -342,20 +351,21 @@ void testWithOutAwaiting() throws Exception {
     /**
      * Test checks that data nodes futures are completed exceptionally if the zone was removed while data nodes awaiting.
      */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19255"")
     @Test
     void testRemoveZoneWhileAwaitingDataNodes() throws Exception {
         startZoneManager();
 
+        String zoneName = ""zone0"";

Review Comment:
   Fixed



;11/May/23 14:30;githubbot;600","sergeyuttsel commented on code in PR #2059:
URL: https://github.com/apache/ignite-3/pull/2059#discussion_r1191267921


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneAwaitDataNodesTest.java:
##########
@@ -342,20 +351,21 @@ void testWithOutAwaiting() throws Exception {
     /**
      * Test checks that data nodes futures are completed exceptionally if the zone was removed while data nodes awaiting.
      */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19255"")
     @Test
     void testRemoveZoneWhileAwaitingDataNodes() throws Exception {
         startZoneManager();
 
+        String zoneName = ""zone0"";
+
         distributionZoneManager.createZone(
-                        new DistributionZoneConfigurationParameters.Builder(""zone0"")
+                        new DistributionZoneConfigurationParameters.Builder(zoneName)
                                 .dataNodesAutoAdjustScaleUp(IMMEDIATE_TIMER_VALUE)
                                 .dataNodesAutoAdjustScaleDown(IMMEDIATE_TIMER_VALUE)
                                 .build()
                 )
                 .get(3, SECONDS);
 
-        int zoneId = distributionZoneManager.getZoneId(""zone0"");
+        int zoneId = distributionZoneManager.getZoneId(zoneName);

Review Comment:
   Fixed



;11/May/23 14:34;githubbot;600","sergeyuttsel commented on code in PR #2059:
URL: https://github.com/apache/ignite-3/pull/2059#discussion_r1191269255


##########
modules/distribution-zones/build.gradle:
##########
@@ -51,6 +51,7 @@ dependencies {
     testImplementation project(':ignite-network-api')
     testImplementation project(':ignite-metastorage-api')
     testImplementation project(':ignite-metastorage')
+    testImplementation project(':ignite-runner')

Review Comment:
   DistributedConfigurationStorage



;11/May/23 14:35;githubbot;600","sergeyuttsel commented on code in PR #2059:
URL: https://github.com/apache/ignite-3/pull/2059#discussion_r1191275487


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneAwaitDataNodesTest.java:
##########
@@ -367,20 +377,30 @@ void testRemoveZoneWhileAwaitingDataNodes() throws Exception {
 
         CompletableFuture<Set<String>> dataNodesFut1 = distributionZoneManager.topologyVersionedDataNodes(zoneId, 106);
 
+        doAnswer(invocation -> {
+            If iif = invocation.getArgument(0);
+
+            byte[] key = zoneScaleUpChangeTriggerKey(zoneId).bytes();
+
+            if (Arrays.stream(iif.cond().keys()).anyMatch(k -> Arrays.equals(key, k))) {
+                //Drop the zone while dataNodesFut1 is awaiting a data nodes update.
+                distributionZoneManager.dropZone(zoneName).get();

Review Comment:
   Fixed



;11/May/23 14:37;githubbot;600","sergeyuttsel commented on code in PR #2059:
URL: https://github.com/apache/ignite-3/pull/2059#discussion_r1191338939


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneAwaitDataNodesTest.java:
##########
@@ -342,20 +351,21 @@ void testWithOutAwaiting() throws Exception {
     /**
      * Test checks that data nodes futures are completed exceptionally if the zone was removed while data nodes awaiting.
      */
-    @Disabled(""https://issues.apache.org/jira/browse/IGNITE-19255"")
     @Test
     void testRemoveZoneWhileAwaitingDataNodes() throws Exception {
         startZoneManager();
 
+        String zoneName = ""zone0"";
+
         distributionZoneManager.createZone(
-                        new DistributionZoneConfigurationParameters.Builder(""zone0"")
+                        new DistributionZoneConfigurationParameters.Builder(zoneName)
                                 .dataNodesAutoAdjustScaleUp(IMMEDIATE_TIMER_VALUE)
                                 .dataNodesAutoAdjustScaleDown(IMMEDIATE_TIMER_VALUE)
                                 .build()
                 )
                 .get(3, SECONDS);
 
-        int zoneId = distributionZoneManager.getZoneId(""zone0"");
+        int zoneId = distributionZoneManager.getZoneId(zoneName);
 
         CompletableFuture<Set<String>> dataNodesFut0 = distributionZoneManager.topologyVersionedDataNodes(zoneId, 5);

Review Comment:
   Yes, these are redundant steps.



;11/May/23 15:16;githubbot;600","sergeyuttsel commented on code in PR #2059:
URL: https://github.com/apache/ignite-3/pull/2059#discussion_r1191227594


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/BaseDistributionZoneManagerTest.java:
##########
@@ -84,6 +93,20 @@ void setUp() {
 
         components.add(metaStorageManager);
 
+        cfgStorage = new DistributedConfigurationStorage(metaStorageManager, vaultMgr);
+
+        cfgMgr =  new ConfigurationManager(
+                List.of(DistributionZonesConfiguration.KEY),
+                Set.of(),
+                cfgStorage,
+                List.of(),
+                List.of(TestPersistStorageConfigurationSchema.class)
+        );
+
+        ConfigurationRegistry registry = cfgMgr.configurationRegistry();
+
+        components.add(registry);

Review Comment:
   I see that ConfigurationManager.start() invokes ConfigurationRegistry.start(). Also IgniteImpl used ConfigurationManager.start() only. So I added ConfigurationManager.start() and removed ConfigurationRegistry.start().



;12/May/23 07:11;githubbot;600","sergeyuttsel commented on code in PR #2059:
URL: https://github.com/apache/ignite-3/pull/2059#discussion_r1192048005


##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneAwaitDataNodesTest.java:
##########
@@ -367,20 +377,30 @@ void testRemoveZoneWhileAwaitingDataNodes() throws Exception {
 
         CompletableFuture<Set<String>> dataNodesFut1 = distributionZoneManager.topologyVersionedDataNodes(zoneId, 106);
 
+        doAnswer(invocation -> {

Review Comment:
   It's a different test cases, so I added another test. testRemoveZoneWhileAwaitingTopologyVersion checks that DistributionZoneNotFoundException will be thrown if the zone is removed on topology version awaiting.
   testScaleUpScaleDownAreChangedWhileAwaitingDataNodes checks that DistributionZoneWasRemovedException will be thrown if the zone is removed after topology version awaiting.



;12/May/23 08:06;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,9000,,,0,9000,,,,,,,,IGNITE-19255,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon May 15 12:19:24 UTC 2023,,,,,,,,,,"0|z1hg4o:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"15/May/23 12:19;alapin;[~Sergey Uttsel] LGTM, thank you!;;;",,,,,
Use DistributedConfigurationStrorage in the several test classes of the DistributionZone module.,IGNITE-19342,13533563,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,Sergey Uttsel,maliev,maliev,21/Apr/23 13:58,16/May/23 10:56,13/Jul/23 09:11,16/May/23 10:56,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"{{DistributionZoneManagerScaleUpTest#testUpdateZoneScaleUpTriggersDataNodePropagation}}, {{DistributionZoneManagerScaleUpTest#testUpdateZoneScaleDownTriggersDataNodePropagation}} - this tests fail with the following assertion error: Expected revision that is greater or equal to already seen meta storage events. This is because {{TestConfigurationStorage}} does not use the same revision as the Meta Storage, therefore their revisions can't be compared directly. We should use {{DistributedConfigurationStrorage}} instead, so configuration will use the same revisions, as the metastorage.

Also {{DistributionZoneManagerScaleUpTest#testDropZoneDoNotPropagateDataNodesAfterScaleUp}}, {{DistributionZoneManagerScaleUpTest#testDropZoneDoNotPropagateDataNodesAfterScaleDown}} failures can be fixed with the introduction of {{DistributedConfigurationStrorage}} in the DistributionZoneManagerScaleUpTest - this test is flaky, because notifications from test configuration storage and from Meta Storage Watches are not related to each other (unlike real-life Distributed Configuration Storage which is built on top of Watches), so notifications from the configuration storage and Meta Storage can arrive in a undetermined order.

Also {{DistributionZoneManagerWatchListenerTest#testDataNodesOfDefaultZoneUpdatedOnWatchListenerEvent}} could be fixed after introduction of {{DistributedConfigurationStrorage}}  in DistributionZoneManagerWatchListenerTest - this test is flaky, probably due to some races between Watch and Configuration Listener execution (sometimes a retry on invoke happens and Mockito#verify fails).

Test {{DistributionZoneManagerScaleUpTest#testDataNodesPropagationAfterScaleUpTriggered}} could fail with 
{noformat}
java.lang.AssertionError: 
Expected: is <1L>
     but: was <3L>
java.lang.AssertionError:
Expected: is <1L>
     but: was <3L>
  at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)
  at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:6)
  at org.apache.ignite.internal.distributionzones.util.DistributionZonesTestUtil.assertValueInStorage(DistributionZonesTestUtil.java:211)
  at org.apache.ignite.internal.distributionzones.util.DistributionZonesTestUtil.assertZoneScaleUpChangeTriggerKey(DistributionZonesTestUtil.java:80)
  at org.apache.ignite.internal.distributionzones.DistributionZoneManagerScaleUpTest.testDataNodesPropagationAfterScaleUpTriggered(DistributionZoneManagerScaleUpTest.java:107)
{noformat}

This is highly likely connected to the same fact, that metastorage and configuration do not share the same storage
",,alapin,maliev,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19255,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue May 16 10:56:21 UTC 2023,,,,,,,,,,"0|z1hg3k:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"16/May/23 10:56;alapin;[~Sergey Uttsel] LGTM, Thanks!;;;",,,,,
SQL: SUBSTRING function does not support NULL values (try 2),IGNITE-19341,13533555,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,zstan,akhitrin,akhitrin,21/Apr/23 12:42,09/Jun/23 08:31,13/Jul/23 09:11,09/Jun/23 08:31,3.0.0-beta1,,,,,,,3.0.0-beta2,sql,,,0,calcite2-required,ignite-3,sql,"ANSI99 SQL specification (""6.18 <string value function>"") says the following:
{code:java}
3) If <character substring function> is specified, then:
  a) Let C be the value of the <character value expression>, ..., and let S be the value of the <start position>.
  b) If <string length> is specified, then let L be the value of <string length> ...
  c) If either C, S, or L is the null value, then the result of the <character substring function> is the null value.
{code}
So, we should expect the following behavior:
{code:sql}
SUBSTRING('text' FROM 1 FOR NULL) -> NULL
SUBSTRING('text' FROM NULL FOR 2) -> NULL
SUBSTRING(NULL FROM 1 FOR 2) -> NULL
{code}

Instead, we got errors for these queries:
{code:sql}
sql-cli> SELECT SUBSTRING('text' FROM 1 FOR NULL);
SQL query execution error
Exception while executing query [query=SELECT SUBSTRING('text' FROM 1 FOR NULL);]. Error message:From line 1, column 8
to line 1, column 40: Cannot apply 'SUBSTRING' to arguments of type 'SUBSTRING(<CHAR(4)> FROM <INTEGER> FOR <NULL>)'. Supported form(s): 'SUBSTRING(<CHAR> FROM <INTEGER>)'
'SUBSTRING(<CHAR> FROM <INTEGER> FOR <INTEGER>)'
'SUBSTRING(<VARCHAR> FROM <INTEGER>)'
'SUBSTRING(<VARCHAR> FROM <INTEGER> FOR <INTEGER>)'
'SUBSTRING(<BINARY> FROM <INTEGER>)'
'SUBSTRING(<BINARY> FROM <INTEGER> FOR <INTEGER>)'
'SUBSTRING(<VARBINARY> FROM <INTEGER>)'
'SUBSTRING(<VARBINARY> FROM <INTEGER> FOR <INTEGER>)'

sql-cli> SELECT SUBSTRING('text' FROM NULL FOR 2);
SQL query execution error
Exception while executing query [query=SELECT SUBSTRING('text' FROM NULL FOR 2);]. Error message:From line 1, column 8
to line 1, column 40: Cannot apply 'SUBSTRING' to arguments of type 'SUBSTRING(<CHAR(4)> FROM <NULL> FOR <INTEGER>)'. Supported form(s): 'SUBSTRING(<CHAR> FROM <INTEGER>)'
'SUBSTRING(<CHAR> FROM <INTEGER> FOR <INTEGER>)'
'SUBSTRING(<VARCHAR> FROM <INTEGER>)'
'SUBSTRING(<VARCHAR> FROM <INTEGER> FOR <INTEGER>)'
'SUBSTRING(<BINARY> FROM <INTEGER>)'
'SUBSTRING(<BINARY> FROM <INTEGER> FOR <INTEGER>)'
'SUBSTRING(<VARBINARY> FROM <INTEGER>)'
'SUBSTRING(<VARBINARY> FROM <INTEGER> FOR <INTEGER>)'
{code}

Only such request works fine:
{code:sql}
sql-cli> SELECT SUBSTRING(NULL FROM 1 FOR 2);
╔═════════╗
║ EXPR$0  ║
╠═════════╣
║ null    ║
╚═════════╝
{code}",,akhitrin,amashenkov,,,,"zstan opened a new pull request, #2159:
URL: https://github.com/apache/ignite-3/pull/2159

   (no comment)


;07/Jun/23 09:53;githubbot;600","AMashenkov commented on code in PR #2159:
URL: https://github.com/apache/ignite-3/pull/2159#discussion_r1221658256


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItFunctionsTest.java:
##########
@@ -285,16 +285,37 @@ public void testTypeOf() {
         assertThrowsWithCause(() -> sql(""SELECT TYPEOF(SELECT 1, 2)""), CalciteContextException.class);
     }
 
+    /**
+     * Tests for {@code SUBSTRING(str, start[, length])} function.
+     */
+    @Test
+    public void testSubstring() {
+        assertQuery(""SELECT SUBSTRING('1234567', 1, 3)"").returns(""123"").check();
+        assertQuery(""SELECT SUBSTRING('1234567', 2)"").returns(""234567"").check();
+        assertQuery(""SELECT SUBSTRING('1234567', -1)"").returns(""1234567"").check();
+        assertQuery(""SELECT SUBSTRING(1000, 1, 3)"").returns(""100"").check();
+
+        assertQuery(""SELECT SUBSTRING(NULL FROM 1 FOR 2)"").returns(null).check();
+        assertQuery(""SELECT SUBSTRING('text' FROM 1 FOR null)"").returns(null).check();
+        assertQuery(""SELECT SUBSTRING('test' FROM null FOR 2)"").returns(null).check();
+
+        // uncomment after https://issues.apache.org/jira/browse/CALCITE-5708 was merged.

Review Comment:
   We don't track Calcite tickets. 
   Maybe there Ignite ticket to fix the issue or to bump Calcite dependency version?



;07/Jun/23 14:03;githubbot;600","AMashenkov commented on code in PR #2159:
URL: https://github.com/apache/ignite-3/pull/2159#discussion_r1221658256


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItFunctionsTest.java:
##########
@@ -285,16 +285,37 @@ public void testTypeOf() {
         assertThrowsWithCause(() -> sql(""SELECT TYPEOF(SELECT 1, 2)""), CalciteContextException.class);
     }
 
+    /**
+     * Tests for {@code SUBSTRING(str, start[, length])} function.
+     */
+    @Test
+    public void testSubstring() {
+        assertQuery(""SELECT SUBSTRING('1234567', 1, 3)"").returns(""123"").check();
+        assertQuery(""SELECT SUBSTRING('1234567', 2)"").returns(""234567"").check();
+        assertQuery(""SELECT SUBSTRING('1234567', -1)"").returns(""1234567"").check();
+        assertQuery(""SELECT SUBSTRING(1000, 1, 3)"").returns(""100"").check();
+
+        assertQuery(""SELECT SUBSTRING(NULL FROM 1 FOR 2)"").returns(null).check();
+        assertQuery(""SELECT SUBSTRING('text' FROM 1 FOR null)"").returns(null).check();
+        assertQuery(""SELECT SUBSTRING('test' FROM null FOR 2)"").returns(null).check();
+
+        // uncomment after https://issues.apache.org/jira/browse/CALCITE-5708 was merged.

Review Comment:
   We don't track Calcite tickets. 
   Maybe there is an Ignite ticket to fix this issue or to bump Calcite dependency version?



;07/Jun/23 14:05;githubbot;600","zstan commented on PR #2159:
URL: https://github.com/apache/ignite-3/pull/2159#issuecomment-1582326877

   @lowka can u make a review plz ?


;08/Jun/23 10:26;githubbot;600","lowka commented on code in PR #2159:
URL: https://github.com/apache/ignite-3/pull/2159#discussion_r1223449044


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItFunctionsTest.java:
##########
@@ -285,16 +285,37 @@ public void testTypeOf() {
         assertThrowsWithCause(() -> sql(""SELECT TYPEOF(SELECT 1, 2)""), CalciteContextException.class);
     }
 
+    /**
+     * Tests for {@code SUBSTRING(str, start[, length])} function.
+     */
+    @Test
+    public void testSubstring() {
+        assertQuery(""SELECT SUBSTRING('1234567', 1, 3)"").returns(""123"").check();
+        assertQuery(""SELECT SUBSTRING('1234567', 2)"").returns(""234567"").check();
+        assertQuery(""SELECT SUBSTRING('1234567', -1)"").returns(""1234567"").check();
+        assertQuery(""SELECT SUBSTRING(1000, 1, 3)"").returns(""100"").check();
+
+        assertQuery(""SELECT SUBSTRING(NULL FROM 1 FOR 2)"").returns(null).check();
+        assertQuery(""SELECT SUBSTRING('text' FROM 1 FOR null)"").returns(null).check();
+        assertQuery(""SELECT SUBSTRING('test' FROM null FOR 2)"").returns(null).check();
+
+        // uncomment after https://issues.apache.org/jira/browse/IGNITE-19686 was implemented.
+        //assertQuery(""select SUBSTRING(s from i for l) from (values ('abc', null, 2)) as t (s, i, l);"").returns(null).check();
+
+        assertThrowsWithCause(() -> sql(""SELECT SUBSTRING('abcdefg', 1, -3)""), IgniteException.class, ""negative substring length"");

Review Comment:
   @zstan Maybe we can also check that `SELECT SUBSTRING('abcdefg' FROM 1 FOR -1)` returns an error?
   Apart from this + a tiny issue with a comment everything looks good.



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/sql/fun/IgniteSqlOperatorTable.java:
##########
@@ -103,10 +102,16 @@ public class IgniteSqlOperatorTable extends ReflectiveSqlOperatorTable {
      * Generic {@code SUBSTR(string, position [, length]} function.
      * This function works exactly the same as {@link SqlSubstringFunction SUSBSTRING(string, position [, length])}.
      */
-    public static final SqlFunction SUBSTR = new SqlFunction(""SUBSTR"", SqlKind.OTHER_FUNCTION,
-            ReturnTypes.ARG0_NULLABLE_VARYING, null,
-            OperandTypes.STRING_INTEGER_OPTIONAL_INTEGER,
-            SqlFunctionCategory.STRING);
+    public static final SqlFunction SUBSTRING = new SqlSubstringFunction();

Review Comment:
   I think `SUBSTRING` and  `SUBSTR`, since a comment over `SUBSTRING` belongs to `SUBSTR`.



;08/Jun/23 19:12;githubbot;600","lowka commented on code in PR #2159:
URL: https://github.com/apache/ignite-3/pull/2159#discussion_r1223442333


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/sql/fun/IgniteSqlOperatorTable.java:
##########
@@ -103,10 +102,16 @@ public class IgniteSqlOperatorTable extends ReflectiveSqlOperatorTable {
      * Generic {@code SUBSTR(string, position [, length]} function.
      * This function works exactly the same as {@link SqlSubstringFunction SUSBSTRING(string, position [, length])}.
      */
-    public static final SqlFunction SUBSTR = new SqlFunction(""SUBSTR"", SqlKind.OTHER_FUNCTION,
-            ReturnTypes.ARG0_NULLABLE_VARYING, null,
-            OperandTypes.STRING_INTEGER_OPTIONAL_INTEGER,
-            SqlFunctionCategory.STRING);
+    public static final SqlFunction SUBSTRING = new SqlSubstringFunction();

Review Comment:
   I think it would be better swap `SUBSTRING` and  `SUBSTR`, since a comment over `SUBSTRING` belongs to `SUBSTR`.



;08/Jun/23 19:12;githubbot;600","AMashenkov merged PR #2159:
URL: https://github.com/apache/ignite-3/pull/2159


;09/Jun/23 08:31;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,4200,,,0,4200,,,,,,,,,,,,IGNITE-18488,CALCITE-5708,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Jun 09 08:31:49 UTC 2023,,,,,,,,,,"0|z1hg1s:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"09/Jun/23 08:31;amashenkov;[~zstan], merged to main.
Thanks for your contribution.;;;",,,,,
CommandHandler SSL migration (from GridSslBasicContextFactory to SslContextFactory),IGNITE-19335,13533419,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,av,av,av,20/Apr/23 15:21,28/Apr/23 11:46,13/Jul/23 09:11,21/Apr/23 09:18,,,,,,,,2.16,,,,0,,,,"Almost whole Ignite use {{Factory<SSLContext>}} at SLL configuration, while CommandHandler still uses {{GridSslContextFactory}}",,av,ignitetcbot,tledkov,,,"anton-vinogradov opened a new pull request, #10658:
URL: https://github.com/apache/ignite/pull/10658

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;20/Apr/23 15:25;githubbot;600","sonarcloud[bot] commented on PR #10658:
URL: https://github.com/apache/ignite/pull/10658#issuecomment-1516541762

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10658)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=BUG) [![C](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/C-16px.png 'C')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=BUG) [2 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10658&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10658&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10658&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_duplicated_lines_density&view=list)
   
   


;20/Apr/23 15:32;githubbot;600","sonarcloud[bot] commented on PR #10658:
URL: https://github.com/apache/ignite/pull/10658#issuecomment-1516559757

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10658)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=BUG) [![C](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/C-16px.png 'C')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=BUG) [2 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10658&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10658&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10658&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_duplicated_lines_density&view=list)
   
   


;20/Apr/23 15:45;githubbot;600","sonarcloud[bot] commented on PR #10658:
URL: https://github.com/apache/ignite/pull/10658#issuecomment-1516605630

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10658)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=BUG) [![C](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/C-16px.png 'C')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=BUG) [1 Bug](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10658&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10658&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10658&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_duplicated_lines_density&view=list)
   
   


;20/Apr/23 16:15;githubbot;600","sonarcloud[bot] commented on PR #10658:
URL: https://github.com/apache/ignite/pull/10658#issuecomment-1516624149

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10658)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=BUG) [![C](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/C-16px.png 'C')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=BUG) [1 Bug](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10658&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10658&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10658&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=CODE_SMELL) [2 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10658&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10658&metric=new_duplicated_lines_density&view=list)
   
   


;20/Apr/23 16:30;githubbot;600","anton-vinogradov merged PR #10658:
URL: https://github.com/apache/ignite/pull/10658


;21/Apr/23 09:18;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3600,,,0,3600,,,,,,,IGNITE-19370,,,,,,,,,,,,,,,IGNITE-19339,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Fri Apr 21 09:18:46 UTC 2023,,,,,,,,,,"0|z1hf7s:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"21/Apr/23 07:37;ignitetcbot;{panel:title=Branch: [pull/10658/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10658/head] Base: [master] : No new tests found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7145056&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","21/Apr/23 08:49;tledkov;[~av], OK with me.

Please file an issue and start discussion about drop {{GridSslContextFactory}} from public API.;;;","21/Apr/23 09:18;av;Merged to the master,
[~tledkov], thanks for the review.
Issue created: IGNITE-19339
;;;",,,
Tx. POSITIVE_INF inside SortedIndexLocker is not unique across partitions,IGNITE-19329,13533377,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,v.pyatkov,korlov,korlov,20/Apr/23 10:44,17/May/23 08:10,13/Jul/23 09:11,17/May/23 08:10,,,,,,,,,,,,0,ignite-3,,,"POSITIVE_INF is a static constant using to take lock on positive infinite if no more key available in the cursor. The problem is that this value is not unique across different partitions, resulting in cross partition interference. Assume the following case:


{code:java}
        sql(""CREATE TABLE test (id INT, aff_key INT, val INT, PRIMARY KEY (id, aff_key)) COLOCATE BY (aff_key) "");
        sql(""CREATE INDEX test_val_asc_idx ON test (val ASC)"");
        sql(""INSERT INTO test VALUES (1, 1, 1), (2, 1, 2), (3, 1, 3)"");

        Transaction tx = CLUSTER_NODES.get(0).transactions().begin();

        sql(tx, ""SELECT * FROM test WHERE val <= 1 ORDER BY val"");

        sql(""INSERT INTO test VALUES (4, 1, 4)""); // <-- this INSERT uses implicit transaction
{code}

Expected behaviour is that second insert completes without delays or errors, but {{LockException: IGN-TX-4 TraceId:cd2e7f6f-ca7b-47aa-9a42-9398517660f3 Failed to acquire a lock due to a conflict}} is thrown (according to current mode of deadlock prevention).
",,Denis Chudov,korlov,v.pyatkov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed May 17 08:10:28 UTC 2023,,,,,,,,,,"0|z1heyg:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"17/May/23 07:57;Denis Chudov;[~v.pyatkov] LGTM.;;;","17/May/23 08:10;v.pyatkov;Merged cd5720b790e4cd767e374b01977cdccb229d7360;;;",,,,
Fix a bug on scheduling a new low watermark update,IGNITE-19327,13533348,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ktkalenko@gridgain.com,ktkalenko@gridgain.com,20/Apr/23 08:23,20/Apr/23 10:49,13/Jul/23 09:11,20/Apr/23 10:49,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"I found an error in the logs, I need to fix it.

{noformat}
2023-04-20 11:19:35:279 +0300 [ERROR][%sqllogic1%low-watermark-updater-0][LowWatermark] Failed to update low watermark, will schedule again: HybridTimestamp [physical=1681976065287, logical=0]
java.util.concurrent.CompletionException: java.lang.AssertionError: previous scheduled task has not finished
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:314)
	at java.base/java.util.concurrent.CompletableFuture.uniRunNow(CompletableFuture.java:819)
	at java.base/java.util.concurrent.CompletableFuture.uniRunStage(CompletableFuture.java:799)
	at java.base/java.util.concurrent.CompletableFuture.thenRun(CompletableFuture.java:2121)
	at org.apache.ignite.internal.table.distributed.LowWatermark.lambda$updateLowWatermark$10(LowWatermark.java:186)
	at org.apache.ignite.internal.util.IgniteUtils.inBusyLock(IgniteUtils.java:889)
	at org.apache.ignite.internal.table.distributed.LowWatermark.updateLowWatermark(LowWatermark.java:175)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:264)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.AssertionError: previous scheduled task has not finished
	at org.apache.ignite.internal.table.distributed.LowWatermark.scheduleUpdateLowWatermarkBusy(LowWatermark.java:214)
	at org.apache.ignite.internal.table.distributed.LowWatermark.runGcAndScheduleUpdateLowWatermarkBusy(LowWatermark.java:208)
	at org.apache.ignite.internal.table.distributed.LowWatermark.lambda$updateLowWatermark$7(LowWatermark.java:189)
	at org.apache.ignite.internal.util.IgniteUtils.inBusyLock(IgniteUtils.java:889)
	at org.apache.ignite.internal.table.distributed.LowWatermark.lambda$updateLowWatermark$8(LowWatermark.java:186)
	at java.base/java.util.concurrent.CompletableFuture.uniRunNow(CompletableFuture.java:815)
	... 12 more
{noformat}",,ktkalenko@gridgain.com,sdanilov,,,,"tkalkirill opened a new pull request, #1962:
URL: https://github.com/apache/ignite-3/pull/1962

   https://issues.apache.org/jira/browse/IGNITE-19327


;20/Apr/23 10:01;githubbot;600","tkalkirill merged PR #1962:
URL: https://github.com/apache/ignite-3/pull/1962


;20/Apr/23 10:49;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17571,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Apr 20 10:49:46 UTC 2023,,,,,,,,,,"0|z1hes0:",9223372036854775807,,,sdanilov,,,,,,,,,,,,,,,,,,"20/Apr/23 10:49;sdanilov;This patch looks good to me;;;",,,,,
NPE on connection close (if there was 0 operation),IGNITE-19320,13533223,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,xtern,Berkov,Berkov,19/Apr/23 13:09,02/May/23 09:12,13/Jul/23 09:11,02/May/23 09:12,3.0,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"Exception
{noformat}
WARNING: Exception in client connector pipeline [remoteAddress=/127.0.0.1:51586]: IGN-CMN-65535 TraceId:fb08f569-9e4a-4d15-80a6-dafdcbff7acd
org.apache.ignite.lang.IgniteInternalException: IGN-CMN-65535 TraceId:fb08f569-9e4a-4d15-80a6-dafdcbff7acd
    at org.apache.ignite.client.handler.ClientResourceRegistry.close(ClientResourceRegistry.java:130)
    at org.apache.ignite.client.handler.ClientInboundMessageHandler.channelInactive(ClientInboundMessageHandler.java:225)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:305)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:281)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:274)
    at io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:411)
    at io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:376)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:305)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:281)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:274)
    at io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1405)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:301)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:281)
    at io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:901)
    at io.netty.channel.AbstractChannel$AbstractUnsafe$7.run(AbstractChannel.java:813)
    at io.netty.util.concurrent.AbstractEventExecutor.runTask$$$capture(AbstractEventExecutor.java:174)
    at io.netty.util.concurrent.AbstractEventExecutor.runTask(AbstractEventExecutor.java)
    at io.netty.util.concurrent.AbstractEventExecutor.safeExecute$$$capture(AbstractEventExecutor.java:167)
    at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:470)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:566)
    at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
    at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
    at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: java.lang.NullPointerException{noformat}
on close connection without a single query:
{code:java}
public static void main(String[] args) throws InterruptedException {
    try (Connection conn = DriverManager.getConnection(""jdbc:ignite:thin://127.0.0.1:10800"")) {
        // NoOp.
    } catch (SQLException e) {
        throw new RuntimeException(e);
    }
} {code}
Because in 

{color:#000000}JdbcQueryEventHandlerImpl.{color}{color:#000000}JdbcConnectionContext{color}.close()

there is no check if connectionId is Null and SessionManager.session(SessionId) tries to get null from its 

{color:#0033b3}private final {color}{color:#000000}Map{color}<{color:#000000}SessionId{color}, {color:#000000}Session{color}> {color:#871094}activeSessions {color}= {color:#0033b3}new {color}ConcurrentHashMap<>();",,Berkov,,,,,"AMashenkov merged PR #1996:
URL: https://github.com/apache/ignite-3/pull/1996


;02/May/23 09:12;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-04-19 13:09:36.0,,,,,,,,,,"0|z1he08:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
Unable to build stand alone/fat jar with JDBC driver,IGNITE-19318,13533205,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,Berkov,Berkov,19/Apr/23 12:05,15/May/23 13:31,13/Jul/23 09:11,15/May/23 13:31,3.0,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"After running

 
{noformat}
gradlew ignite-jdbc:shadowJar{noformat}
in modules/jdbc/build/libs/ignite-jdbc-3.0.0-SNAPSHOT-all.jar file size is only 806 bytes.

 

{color:#d1d2d3} {color}",,aleksandr.pakhomov,Berkov,Mikhail Pochatkin,,,"valepakh opened a new pull request, #2048:
URL: https://github.com/apache/ignite-3/pull/2048

   https://issues.apache.org/jira/browse/IGNITE-19318
   
   Minimizing doesn't work with services, it can't detect that the class is used and there's no way to tell the plugin to include it.


;10/May/23 13:44;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,,,,Mon May 15 13:31:45 UTC 2023,,,,,,,,,,"0|z1hdw8:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"12/May/23 09:51;Mikhail Pochatkin;LGTM. [~Berkov] May you verify that all right now?;;;","15/May/23 13:31;aleksandr.pakhomov;Thanks for the contribution, merged into main: a4912c631cba1a6faba490eacb6d043f2afe7771;;;",,,,
ClusterConfigRegistryImpl should update its internal state,IGNITE-19316,13533177,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,aleksandr.pakhomov,aleksandr.pakhomov,aleksandr.pakhomov,19/Apr/23 09:14,03/May/23 12:02,13/Jul/23 09:11,03/May/23 12:02,,,,,,,,3.0.0-beta2,cli,,,0,ignite-3,,,"ItIgnitePicocliCommandsTest.clusterConfigShowSuggested is flaky because ClusterConfigRegistryImpl returns an empty config. Probably, we have to log exceptions if the onConnect method. At least, we will know why it is happening.

Also, I would like to add some robust code that will try to update the internal config instance if it is empty.

 
{code:java}
org.awaitility.core.ConditionTimeoutException: Condition with alias 'For given parsed words: [cluster, config, show,  --node-name, nodeName, ]' didn't complete within 10 seconds because lambda expression in org.apache.ignite.internal.cli.core.repl.executor.ItIgnitePicocliCommandsTest: expected iterable with items [""aimem"", ""aipersist"", ""metrics"", ""rocksDb"", ""table"", ""zone"", ""security"", ""schemaSync""] in any order but no item matches: ""aimem"", ""aipersist"", ""metrics"", ""rocksDb"", ""table"", ""zone"", ""security"", ""schemaSync"" in [].
          at app//org.awaitility.core.ConditionAwaiter.await(ConditionAwaiter.java:167)
{code}
",,aleksandr.pakhomov,,,,,"valepakh commented on code in PR #2008:
URL: https://github.com/apache/ignite-3/pull/2008#discussion_r1183494595


##########
modules/cli/src/main/java/org/apache/ignite/internal/cli/core/repl/registry/impl/MetricRegistryImpl.java:
##########
@@ -49,23 +52,19 @@ public Set<String> metricSources() {
      */
     @Override
     public void onConnect(SessionInfo sessionInfo) {
-        CompletableFuture.runAsync(() -> {
-            try {
-                //TODO https://issues.apache.org/jira/browse/IGNITE-17416
-                metricSourceListCall.execute(new UrlCallInput(sessionInfo.nodeUrl()))
-                        .body()
-                        .forEach(source -> metricSources.add(source.getName()));
-            } catch (Exception ignored) {
-                // no-op
-            }
-        });
+        metricSourcesRef = new LazyObjectRef<>(() -> fetchMetricSources(sessionInfo));
+    }
+
+    @NotNull

Review Comment:
   ```suggestion
   ```



##########
modules/cli/src/main/java/org/apache/ignite/internal/cli/core/repl/registry/impl/LazyObjectRef.java:
##########
@@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.cli.core.repl.registry.impl;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Supplier;
+import org.apache.ignite.internal.cli.logger.CliLoggers;
+import org.apache.ignite.internal.logger.IgniteLogger;
+import org.jetbrains.annotations.Nullable;
+
+/** Lazy async reference that will fetch the value from the source until the value is not null. */
+public final class LazyObjectRef<R> {
+
+    private static final IgniteLogger LOG = CliLoggers.forClass(LazyObjectRef.class);
+
+    private final Supplier<R> source;
+
+    private final AtomicReference<R> ref = new AtomicReference<>(null);
+
+    private final AtomicReference<Boolean> execInProgress = new AtomicReference<>(false);
+
+    public LazyObjectRef(Supplier<R> source) {
+        this.source = source;
+        fetchFrom(source);
+    }
+
+    private void fetchFrom(Supplier<R> source) {
+        execInProgress.set(true);
+
+        CompletableFuture.supplyAsync(source)
+                .thenAccept(ref::set)
+                .whenComplete((v, t) -> {
+                    if (t != null) {
+                        LOG.warn(""Got exception when fetch from source"", t);
+                    }
+                    execInProgress.set(false);
+                });
+    }
+
+    /** Returns null if the fetching in progress or the value from the source. */

Review Comment:
   ```suggestion
       /** Returns {@code null} if the fetching is in progress or the value returned from the source is {@code null}. */
   ```



##########
modules/cli/src/main/java/org/apache/ignite/internal/cli/core/repl/registry/impl/ClusterConfigRegistryImpl.java:
##########
@@ -34,25 +32,23 @@ public class ClusterConfigRegistryImpl implements ClusterConfigRegistry, AsyncSe
 
     private final ClusterConfigShowCall clusterConfigShowCall;
 
-    private final AtomicReference<Config> config = new AtomicReference<>(null);
+    private LazyObjectRef<Config> configRef;
 
     public ClusterConfigRegistryImpl(ClusterConfigShowCall clusterConfigShowCall) {
         this.clusterConfigShowCall = clusterConfigShowCall;
     }
 
     @Override
     public void onConnect(SessionInfo sessionInfo) {
-        CompletableFuture.runAsync(() -> {
-            try {
-                config.set(ConfigFactory.parseString(
-                        clusterConfigShowCall.execute(
-                                ClusterConfigShowCallInput.builder().clusterUrl(sessionInfo.nodeUrl()).build()
-                        ).body().getValue()
-                ));
-            } catch (Exception ignored) {
-                // no-op
-            }
-        });
+        configRef = new LazyObjectRef<>(() -> fetchConfig(sessionInfo));

Review Comment:
   Should we null the reference in `onDisconnect` here and in the `NodeConfigRegistryImpl`?



;03/May/23 10:19;githubbot;600","PakhomovAlexander merged PR #2008:
URL: https://github.com/apache/ignite-3/pull/2008


;03/May/23 12:02;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,IGNITE-19351,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Wed May 03 12:02:49 UTC 2023,,,,,,,,,,"0|z1hdq0:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"03/May/23 12:02;aleksandr.pakhomov;Merged into main: 4da2b8ec5905641a61ecf45a11658939ef2391ca;;;",,,,,
Validate node configuration on node start,IGNITE-19315,13533158,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,ivan.gagarkin,aleksandr.pakhomov,aleksandr.pakhomov,19/Apr/23 08:04,16/May/23 12:29,13/Jul/23 09:11,16/May/23 12:29,,,,,,,,3.0.0-beta2,general,,,0,ignite-3,,,"After the changes made in IGNITE-19152, the configuration validation is no longer performed on node start (see ItSslConfigurationValidationTest).

It's not clear where the validation should be applied, as it could be either in ConfigurationChanger or LocalFileConfigurationStorage. 

Additionally, we need to write more tests to ensure that the validation works as expected.",,aleksandr.pakhomov,,,,,"Flaugh24 opened a new pull request, #2058:
URL: https://github.com/apache/ignite-3/pull/2058

   (no comment)


;10/May/23 19:36;githubbot;600","Flaugh24 commented on PR #2058:
URL: https://github.com/apache/ignite-3/pull/2058#issuecomment-1542880808

   https://issues.apache.org/jira/browse/IGNITE-19315


;10/May/23 22:16;githubbot;600","PakhomovAlexander commented on code in PR #2058:
URL: https://github.com/apache/ignite-3/pull/2058#discussion_r1190873409


##########
modules/configuration/src/main/java/org/apache/ignite/internal/configuration/ConfigurationChanger.java:
##########
@@ -274,11 +274,30 @@ public void start() throws ConfigurationChangeException {
         //Workaround for distributed configuration.
         addDefaults(superRoot);
 
+        // Validate the restored configuration

Review Comment:
   ```suggestion
           // Validate the restored configuration.
   ```



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/ItNodeConfigurationFileTest.java:
##########
@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.configuration;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.assertThrowsWithCause;
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.testNodeName;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.containsString;
+import static org.hamcrest.Matchers.instanceOf;
+import static org.hamcrest.Matchers.is;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.nio.file.Path;
+import java.util.UUID;
+import org.apache.ignite.configuration.validation.ConfigurationValidationException;
+import org.apache.ignite.internal.testframework.TestIgnitionManager;
+import org.apache.ignite.internal.testframework.WorkDirectory;
+import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
+import org.apache.ignite.lang.IgniteException;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+/**
+ * General integration tests for node configuration file.
+ */
+@ExtendWith(WorkDirectoryExtension.class)
+public class ItNodeConfigurationFileTest {
+
+    @Test
+    public void wrongConfigurationFormat(TestInfo testInfo, @WorkDirectory Path workDir) {
+        String config = UUID.randomUUID().toString();
+
+        IgniteException igniteException = assertThrows(
+                IgniteException.class,
+                () -> TestIgnitionManager.start(testNodeName(testInfo, 0), config, workDir)
+        );
+        assertThat(igniteException.getCause(), is(instanceOf(NodeConfigParseException.class)));
+        assertThat(igniteException.getCause().getMessage(), containsString(""Failed to parse config content from file ""));

Review Comment:
   from what file do we fail to parse the config? I don't see any file here.



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/ItNodeConfigurationFileTest.java:
##########
@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.configuration;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.assertThrowsWithCause;
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.testNodeName;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.containsString;
+import static org.hamcrest.Matchers.instanceOf;
+import static org.hamcrest.Matchers.is;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.nio.file.Path;
+import java.util.UUID;
+import org.apache.ignite.configuration.validation.ConfigurationValidationException;
+import org.apache.ignite.internal.testframework.TestIgnitionManager;
+import org.apache.ignite.internal.testframework.WorkDirectory;
+import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
+import org.apache.ignite.lang.IgniteException;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+/**
+ * General integration tests for node configuration file.
+ */
+@ExtendWith(WorkDirectoryExtension.class)
+public class ItNodeConfigurationFileTest {

Review Comment:
   Why is there `File` in the class name? I can find tests without any files. Would you drop this from the class name?



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/ItNodeConfigurationFileTest.java:
##########
@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.configuration;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.assertThrowsWithCause;
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.testNodeName;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.containsString;
+import static org.hamcrest.Matchers.instanceOf;
+import static org.hamcrest.Matchers.is;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.nio.file.Path;
+import java.util.UUID;
+import org.apache.ignite.configuration.validation.ConfigurationValidationException;
+import org.apache.ignite.internal.testframework.TestIgnitionManager;
+import org.apache.ignite.internal.testframework.WorkDirectory;
+import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
+import org.apache.ignite.lang.IgniteException;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+/**
+ * General integration tests for node configuration file.

Review Comment:
   ```suggestion
    * Integration tests for the node configuration file.
   ```



;11/May/23 09:45;githubbot;600","Flaugh24 commented on code in PR #2058:
URL: https://github.com/apache/ignite-3/pull/2058#discussion_r1192080580


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/ItNodeConfigurationFileTest.java:
##########
@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.configuration;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.assertThrowsWithCause;
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.testNodeName;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.containsString;
+import static org.hamcrest.Matchers.instanceOf;
+import static org.hamcrest.Matchers.is;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.nio.file.Path;
+import java.util.UUID;
+import org.apache.ignite.configuration.validation.ConfigurationValidationException;
+import org.apache.ignite.internal.testframework.TestIgnitionManager;
+import org.apache.ignite.internal.testframework.WorkDirectory;
+import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
+import org.apache.ignite.lang.IgniteException;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+/**
+ * General integration tests for node configuration file.
+ */
+@ExtendWith(WorkDirectoryExtension.class)
+public class ItNodeConfigurationFileTest {

Review Comment:
   org.apache.ignite.internal.testframework.TestIgnitionManager#start creates the configuration file in a work directory, which is going to be read by Ignite



;12/May/23 08:36;githubbot;600","Flaugh24 commented on code in PR #2058:
URL: https://github.com/apache/ignite-3/pull/2058#discussion_r1192081020


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/ItNodeConfigurationFileTest.java:
##########
@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.configuration;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.assertThrowsWithCause;
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.testNodeName;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.containsString;
+import static org.hamcrest.Matchers.instanceOf;
+import static org.hamcrest.Matchers.is;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.nio.file.Path;
+import java.util.UUID;
+import org.apache.ignite.configuration.validation.ConfigurationValidationException;
+import org.apache.ignite.internal.testframework.TestIgnitionManager;
+import org.apache.ignite.internal.testframework.WorkDirectory;
+import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
+import org.apache.ignite.lang.IgniteException;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+/**
+ * General integration tests for node configuration file.
+ */
+@ExtendWith(WorkDirectoryExtension.class)
+public class ItNodeConfigurationFileTest {
+
+    @Test
+    public void wrongConfigurationFormat(TestInfo testInfo, @WorkDirectory Path workDir) {
+        String config = UUID.randomUUID().toString();
+
+        IgniteException igniteException = assertThrows(
+                IgniteException.class,
+                () -> TestIgnitionManager.start(testNodeName(testInfo, 0), config, workDir)
+        );
+        assertThat(igniteException.getCause(), is(instanceOf(NodeConfigParseException.class)));
+        assertThat(igniteException.getCause().getMessage(), containsString(""Failed to parse config content from file ""));

Review Comment:
   See my comment above 



;12/May/23 08:37;githubbot;600","PakhomovAlexander commented on PR #2058:
URL: https://github.com/apache/ignite-3/pull/2058#issuecomment-1545542771

   Looks ok to me. I would appreciate it if @ibessonov takes a look.


;12/May/23 10:41;githubbot;600","tkalkirill commented on code in PR #2058:
URL: https://github.com/apache/ignite-3/pull/2058#discussion_r1192266124


##########
modules/configuration/src/main/java/org/apache/ignite/internal/configuration/ConfigurationChanger.java:
##########
@@ -274,11 +274,30 @@ public void start() throws ConfigurationChangeException {
         //Workaround for distributed configuration.
         addDefaults(superRoot);
 
+        // Validate the restored configuration.
+        validateConfiguration(defaultConfiguration(), superRoot);
+
         storageRoots = new StorageRoots(superRoot, data.changeId());
 
         storage.registerConfigurationListener(configurationStorageListener());
     }
 
+    /**
+     * Creates an empty configuration with defaults.
+     *
+     * @return Default configuration.
+     */
+    private SuperRoot defaultConfiguration() {

Review Comment:
   There may be no default values, what happens then?



##########
modules/configuration/src/test/java/org/apache/ignite/internal/configuration/ConfigurationChangerTest.java:
##########
@@ -95,12 +96,12 @@ public static class FirstConfigurationSchema {
      */
     @Config
     public static class SecondConfigurationSchema {
-        @Value
+        @Value(hasDefault = true)
         @Immutable
-        public int intCfg;
+        public int intCfg = 0;
 
-        @Value
-        public String strCfg;
+        @Value(hasDefault = true)
+        public String strCfg = """";
     }

Review Comment:
   I think we can add fields with default values instead of adding default values for the current ones.



##########
modules/configuration/src/test/java/org/apache/ignite/internal/configuration/ConfigurationRegistryTest.java:
##########
@@ -370,16 +370,16 @@ public static class FourthPolymorphicConfigurationSchema {
         @PolymorphicId(hasDefault = true)
         public String typeId = ""fourth0"";
 
-        @Value
-        public String strVal;
+        @Value(hasDefault = true)
+        public String strVal = """";
     }
 
     /**
      * First {@link FourthPolymorphicConfigurationSchema} extension.
      */
     @PolymorphicConfigInstance(""fourth0"")
     public static class Fourth0PolymorphicConfigurationSchema extends FourthPolymorphicConfigurationSchema {
-        @Value
-        public int intVal;
+        @Value(hasDefault = true)

Review Comment:
   Same



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/NodeConfigParseException.java:
##########
@@ -0,0 +1,31 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.configuration;
+
+import org.apache.ignite.lang.ErrorGroups.NodeConfiguration;
+import org.apache.ignite.lang.IgniteException;
+
+/**
+ * Throws when node bootstrap configuration file failed to parse.
+ */
+public class NodeConfigParseException extends IgniteException {

Review Comment:
   ```suggestion
   public class ConfigurationParseException extends IgniteException {
   ```



##########
modules/configuration/src/test/java/org/apache/ignite/internal/configuration/ConfigurationRegistryTest.java:
##########
@@ -370,16 +370,16 @@ public static class FourthPolymorphicConfigurationSchema {
         @PolymorphicId(hasDefault = true)
         public String typeId = ""fourth0"";
 
-        @Value
-        public String strVal;
+        @Value(hasDefault = true)

Review Comment:
   Same



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/NodeConfigParseException.java:
##########
@@ -0,0 +1,31 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.configuration;
+
+import org.apache.ignite.lang.ErrorGroups.NodeConfiguration;
+import org.apache.ignite.lang.IgniteException;
+
+/**
+ * Throws when node bootstrap configuration file failed to parse.
+ */
+public class NodeConfigParseException extends IgniteException {
+
+    public NodeConfigParseException(String msg, Throwable cause) {

Review Comment:
   Missing javadoc



;12/May/23 11:55;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,4200,,,0,4200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Tue May 16 12:29:33 UTC 2023,,,,,,,,,,"0|z1hdls:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"16/May/23 12:29;aleksandr.pakhomov;Thank you, merged into main: 3d2b36504dc6cf76827fbcc926bd7b99ef17f845;;;",,,,,
Drop multiple column if exists without brace,IGNITE-19306,13533061,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Trivial,Fixed,igusev,Berkov,Berkov,18/Apr/23 15:15,04/May/23 12:06,13/Jul/23 09:11,04/May/23 12:06,3.0,,,,,,,3.0.0-beta2,documentation,,,0,ignite-3,,,"Wrong parameter name {{IF NOT EXISTS}}

[https://ignite.apache.org/docs/3.0.0-beta/sql-reference/ddl#alter-table-if-exists-table-drop-column-if-exists-column1-column2-int]

Correct one: IF EXISTS",,aleksandr.pakhomov,Berkov,,,,"PakhomovAlexander merged PR #1984:
URL: https://github.com/apache/ignite-3/pull/1984


;04/May/23 12:05;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Thu May 04 12:06:31 UTC 2023,,,,,,,,,,"0|z1hd08:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"04/May/23 12:06;aleksandr.pakhomov;Merged into main: bf880181518580eb745e9980d2bc0df3f577aec0;;;",,,,,
Index alive after drop indexed column,IGNITE-19305,13533056,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,xtern,Berkov,Berkov,18/Apr/23 14:39,15/May/23 09:14,13/Jul/23 09:11,08/May/23 14:33,3.0,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"In [documentation|https://ignite.apache.org/docs/3.0.0-beta/sql-reference/ddl#alter-table-if-exists-table-drop-column-if-exists-column1-column2-int] I see: ""If the column was indexed, the index has to be dropped manually in advance by using the 'DROP INDEX' command."" But it seems like an alpha version limitation.

Unable to create index with the same name after dropping indexed column:
{noformat}
create table tindex(
id int primary key,
v1 int, 
v2 int);
create index titest on tindex(v1, v2)
alter table tindex drop column v1;
create index titest on tindex(v2);{noformat}
error:
{noformat}
[Code: 0, SQL State: 50000]  Exception while executing query [query=create index titest on tindex(v2)]. Error message:IGN-SQL-17 TraceId:5f61df67-cc61-4eb1-98be-3bbaa25a7c44 IGN-SQL-17 TraceId:5f61df67-cc61-4eb1-98be-3bbaa25a7c44 Index already exists [name=""PUBLIC"".""TITEST""]{noformat}
Expected behaviour:

1) index titest drop while dropping v1 columnd

2) index titest successfully created on the last DDL operation.",,Berkov,xtern,,,,"AMashenkov merged PR #2018:
URL: https://github.com/apache/ignite-3/pull/2018


;08/May/23 14:33;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19456,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu May 04 07:49:43 UTC 2023,,,,,,,,,,"0|z1hcz4:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"04/May/23 07:49;xtern;Since we don't support the ""drop behavior"" feature, we decided to restrict deletion of indexed columns. Proposed behavior is similar to MS SQL Server, but not to Oracle/Postgresql which support the ""drop behavior"" feature.;;;",,,,,
Create index with the same column twice,IGNITE-19304,13533055,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,amashenkov,Berkov,Berkov,18/Apr/23 14:32,12/Jun/23 14:28,13/Jul/23 09:11,12/Jun/23 14:17,3.0,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"Unable to create index with same column twice:
{noformat}
create table tindex(
id int primary key,
v1 int, 
v2 int);
create index titest on tindex(v1,v1){noformat}
error:
{noformat}
[Code: 0, SQL State: 50000]  Exception while executing query [query=create index titest on tindex(v1,v1)]. Error message:IGN-CMN-65535 TraceId:203a2c0c-fbf1-4143-aa47-50c97223ad84 Named List element with key ""V1"" already exists{noformat}
But documentation [https://ignite.apache.org/docs/3.0.0-beta/sql-reference/ddl#create-index] do not block it. Postgres allow to execute such DDL too.",,amashenkov,Berkov,,,,"AMashenkov opened a new pull request, #2174:
URL: https://github.com/apache/ignite-3/pull/2174

   (no comment)


;09/Jun/23 09:20;githubbot;600","AMashenkov merged PR #2174:
URL: https://github.com/apache/ignite-3/pull/2174


;12/Jun/23 14:17;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,IGNITE-19711,,,,IGNITE-19483,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,,,,Mon Jun 12 14:28:18 UTC 2023,,,,,,,,,,"0|z1hcyw:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"12/Jun/23 14:28;amashenkov;Creating index with duplicates columns looks like a typo. 
The second and further mentions of the same column in index definition has no affect on behaviour.
In general case, fixing a type by dropping useless columns may lead to unexpected result.
E.g. for index on (col1, col2, col1) there are 2 possible ways to fix this that lead to completely different results: index on (col1, col2) and index on (col2, col2).;;;",,,,,
Phantom reads protection is broken,IGNITE-19302,13533041,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ibessonov,ibessonov,ibessonov,18/Apr/23 12:30,04/May/23 17:51,13/Jul/23 09:11,02/May/23 09:27,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"{{SortedIndexLocker#acquireLockNextKey}} is poorly implemented and not tested properly. It ignores the documented contract of {{hasNext}} and {{peek}} from {{{}PeekCursor{}}}.

""Has next"" checks must essentially be replaced with {{{}peek() != null{}}}.
Unit tests, that would simulate concurrent operations, or maybe even do concurrent operations, must be implemented.",,ibessonov,rpuch,,,,"ibessonov opened a new pull request, #1992:
URL: https://github.com/apache/ignite-3/pull/1992

   https://issues.apache.org/jira/browse/IGNITE-19302


;27/Apr/23 11:23;githubbot;600","rpuch commented on code in PR #1992:
URL: https://github.com/apache/ignite-3/pull/1992#discussion_r1180319280


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/SortedIndexLocker.java:
##########
@@ -155,15 +154,15 @@ public CompletableFuture<Lock> locksForInsert(UUID txId, BinaryRow tableRow, Row
 
         BinaryTuplePrefix prefix = BinaryTuplePrefix.fromBinaryTuple(key);
 
-        // find next key
-        Cursor<IndexRow> cursor = storage.scan(prefix, null, SortedIndexStorage.GREATER);
+        // Find next key.
+        PeekCursor<IndexRow> cursor = storage.scan(prefix, null, SortedIndexStorage.GREATER);
 
-        BinaryTuple nextKey;
-        if (cursor.hasNext()) {
-            nextKey = cursor.next().indexColumns();
-        } else { // otherwise INF
-            nextKey = POSITIVE_INF;
-        }
+        //noinspection ResultOfMethodCallIgnored
+        cursor.hasNext();
+
+        // ""peek"" works the same as ""next"" when ""hasNext"" is called. The only difference is that it returns null instead of throwing
+        // an exception, if nothing is found.
+        BinaryTuple nextKey = indexKey(cursor.peek());

Review Comment:
   The code 'after' seems to be equivalent to the code 'before', but the code 'before' was arguably more straightforward. Are you sure this actually improves readability?



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/table/ItTableScanTest.java:
##########
@@ -178,9 +181,8 @@ public void testInsertDuringScan() throws Exception {
 
         subscription.request(1);
 
-        waitForCondition(() -> !scannedRows.isEmpty(), 10_000);
+        assertTrue(waitForCondition(() -> !scannedRows.isEmpty(), 10_000));
 
-        assertEquals(1, scannedRows.size());

Review Comment:
   The change is not equivalent: earlier it checked that there is exactly 1 element, now it will allow any non-zero number of elements



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/table/ItTableScanTest.java:
##########
@@ -590,14 +513,71 @@ public void testScanWithUpperBound() throws Exception {
                 null
         );
 
-        ArrayList<BinaryRow> scannedRows2 = scanAllRows(publisher2);
+        List<BinaryRow> scannedRows2 = scanAllRows(publisher2);
 
         assertEquals(5, scannedRows2.size());
 
         log.info(""Result of scanning after insert rows: "" + scannedRows2.stream().map(binaryRow -> rowToString(binaryRow))
                 .collect(Collectors.joining("", "")));
     }
 
+    @Test
+    public void testPhantomReads() throws Exception {
+        int iterations = 10;
+
+        // ""for"" is better at detecting data races than RepeatedTest.
+        for (int i = 0; i < iterations; i++) {
+            KeyValueView<Tuple, Tuple> kvView = table.keyValueView();
+
+            UUID sortedIndexId = getSortedIndexId();
+
+            int partId = 0;
+
+            InternalTransaction tx = startTxWithEnlistedPartition(partId);
+
+            try {
+                IgniteBiTuple<ClusterNode, Long> leaderWithTerm = tx.enlistedNodeAndTerm(new TablePartitionId(table.tableId(), partId));
+
+                PrimaryReplica recipient = new PrimaryReplica(leaderWithTerm.get1(), leaderWithTerm.get2());
+
+                Publisher<BinaryRow> publisher = internalTable.scan(partId, tx.id(), recipient, sortedIndexId, null, null, 0, null);
+
+                // Non-thread-safe collection is fine, HB is guaranteed by ""Thread#join"" inside of ""runRace"".

Review Comment:
   How about just replacing the collection with a thread-safe one, so that the thread-safety question do not even arise? It's a test, performance does not seem to be critical here. Then the comment is not needed at all.



;28/Apr/23 11:58;githubbot;600","ibessonov commented on code in PR #1992:
URL: https://github.com/apache/ignite-3/pull/1992#discussion_r1180342821


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/table/ItTableScanTest.java:
##########
@@ -590,14 +513,71 @@ public void testScanWithUpperBound() throws Exception {
                 null
         );
 
-        ArrayList<BinaryRow> scannedRows2 = scanAllRows(publisher2);
+        List<BinaryRow> scannedRows2 = scanAllRows(publisher2);
 
         assertEquals(5, scannedRows2.size());
 
         log.info(""Result of scanning after insert rows: "" + scannedRows2.stream().map(binaryRow -> rowToString(binaryRow))
                 .collect(Collectors.joining("", "")));
     }
 
+    @Test
+    public void testPhantomReads() throws Exception {
+        int iterations = 10;
+
+        // ""for"" is better at detecting data races than RepeatedTest.
+        for (int i = 0; i < iterations; i++) {
+            KeyValueView<Tuple, Tuple> kvView = table.keyValueView();
+
+            UUID sortedIndexId = getSortedIndexId();
+
+            int partId = 0;
+
+            InternalTransaction tx = startTxWithEnlistedPartition(partId);
+
+            try {
+                IgniteBiTuple<ClusterNode, Long> leaderWithTerm = tx.enlistedNodeAndTerm(new TablePartitionId(table.tableId(), partId));
+
+                PrimaryReplica recipient = new PrimaryReplica(leaderWithTerm.get1(), leaderWithTerm.get2());
+
+                Publisher<BinaryRow> publisher = internalTable.scan(partId, tx.id(), recipient, sortedIndexId, null, null, 0, null);
+
+                // Non-thread-safe collection is fine, HB is guaranteed by ""Thread#join"" inside of ""runRace"".

Review Comment:
   I don't like using thread-safe collections when no one needs them, I consider this a bad practice.



;28/Apr/23 12:26;githubbot;600","ibessonov commented on code in PR #1992:
URL: https://github.com/apache/ignite-3/pull/1992#discussion_r1180344448


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/SortedIndexLocker.java:
##########
@@ -155,15 +154,15 @@ public CompletableFuture<Lock> locksForInsert(UUID txId, BinaryRow tableRow, Row
 
         BinaryTuplePrefix prefix = BinaryTuplePrefix.fromBinaryTuple(key);
 
-        // find next key
-        Cursor<IndexRow> cursor = storage.scan(prefix, null, SortedIndexStorage.GREATER);
+        // Find next key.
+        PeekCursor<IndexRow> cursor = storage.scan(prefix, null, SortedIndexStorage.GREATER);
 
-        BinaryTuple nextKey;
-        if (cursor.hasNext()) {
-            nextKey = cursor.next().indexColumns();
-        } else { // otherwise INF
-            nextKey = POSITIVE_INF;
-        }
+        //noinspection ResultOfMethodCallIgnored
+        cursor.hasNext();
+
+        // ""peek"" works the same as ""next"" when ""hasNext"" is called. The only difference is that it returns null instead of throwing
+        // an exception, if nothing is found.
+        BinaryTuple nextKey = indexKey(cursor.peek());

Review Comment:
   Old code was a scenario copy-pasted twice, I removed the copy-paste.
   What else is equivalent? Replacement of ""hasNext()"" with ""peek() != null"" is not an equivalent change, it's a fix



;28/Apr/23 12:28;githubbot;600","rpuch commented on code in PR #1992:
URL: https://github.com/apache/ignite-3/pull/1992#discussion_r1180485815


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/SortedIndexLocker.java:
##########
@@ -155,15 +154,15 @@ public CompletableFuture<Lock> locksForInsert(UUID txId, BinaryRow tableRow, Row
 
         BinaryTuplePrefix prefix = BinaryTuplePrefix.fromBinaryTuple(key);
 
-        // find next key
-        Cursor<IndexRow> cursor = storage.scan(prefix, null, SortedIndexStorage.GREATER);
+        // Find next key.
+        PeekCursor<IndexRow> cursor = storage.scan(prefix, null, SortedIndexStorage.GREATER);
 
-        BinaryTuple nextKey;
-        if (cursor.hasNext()) {
-            nextKey = cursor.next().indexColumns();
-        } else { // otherwise INF
-            nextKey = POSITIVE_INF;
-        }
+        //noinspection ResultOfMethodCallIgnored
+        cursor.hasNext();
+
+        // ""peek"" works the same as ""next"" when ""hasNext"" is called. The only difference is that it returns null instead of throwing
+        // an exception, if nothing is found.
+        BinaryTuple nextKey = indexKey(cursor.peek());

Review Comment:
   > ""peek"" works the same as ""next"" when ""hasNext"" is called
   
   So I concluded that the code after the change works in the same way as the code before the change. If this is not the case, could you please describe a scenario that would demonstrate a difference?



;02/May/23 08:43;githubbot;600","rpuch commented on code in PR #1992:
URL: https://github.com/apache/ignite-3/pull/1992#discussion_r1182260512


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/SortedIndexLocker.java:
##########
@@ -155,15 +154,15 @@ public CompletableFuture<Lock> locksForInsert(UUID txId, BinaryRow tableRow, Row
 
         BinaryTuplePrefix prefix = BinaryTuplePrefix.fromBinaryTuple(key);
 
-        // find next key
-        Cursor<IndexRow> cursor = storage.scan(prefix, null, SortedIndexStorage.GREATER);
+        // Find next key.
+        PeekCursor<IndexRow> cursor = storage.scan(prefix, null, SortedIndexStorage.GREATER);
 
-        BinaryTuple nextKey;
-        if (cursor.hasNext()) {
-            nextKey = cursor.next().indexColumns();
-        } else { // otherwise INF
-            nextKey = POSITIVE_INF;
-        }
+        //noinspection ResultOfMethodCallIgnored
+        cursor.hasNext();
+
+        // ""peek"" works the same as ""next"" when ""hasNext"" is called. The only difference is that it returns null instead of throwing
+        // an exception, if nothing is found.
+        BinaryTuple nextKey = indexKey(cursor.peek());

Review Comment:
   My comment is not relevant anymore, please ignore it



;02/May/23 08:46;githubbot;600","ibessonov merged PR #1992:
URL: https://github.com/apache/ignite-3/pull/1992


;02/May/23 09:27;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,4200,,,0,4200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17304,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu May 04 17:51:51 UTC 2023,,,,,,,,,,"0|z1hcvs:",9223372036854775807,,,rpuch,,,,,,,,,,,,,,,,,,"04/May/23 17:51;rpuch;Sorry, I forgot to do it timely: LGTM!;;;",,,,,
.NET: Thin 3.0: MetricsTests.TestRequestsActive is flaky,IGNITE-19298,13533028,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,18/Apr/23 10:59,02/May/23 09:15,13/Jul/23 09:11,02/May/23 09:15,3.0.0-beta1,,,,,,,3.0.0-beta2,platforms,thin client,,0,ignite-3,,,"{code}
Expected: 0
  But was:  -1
   at Apache.Ignite.Tests.MetricsTests.TestRequestsActive() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/MetricsTests.cs:line 164
   at NUnit.Framework.Internal.TaskAwaitAdapter.GenericAdapter`1.BlockUntilCompleted()
   at NUnit.Framework.Internal.MessagePumpStrategy.NoMessagePumpStrategy.WaitForCompletion(AwaitAdapter awaiter)
   at NUnit.Framework.Internal.AsyncToSyncAdapter.Await(Func`1 invoke)
   at NUnit.Framework.Internal.Commands.TestMethodCommand.RunTestMethod(TestExecutionContext context)
   at NUnit.Framework.Internal.Commands.TestMethodCommand.Execute(TestExecutionContext context)
   at NUnit.Framework.Internal.Commands.BeforeAndAfterTestCommand.<>c__DisplayClass1_0.<Execute>b__0()
   at NUnit.Framework.Internal.Commands.DelegatingTestCommand.RunTestMethodInThreadAbortSafeZone(TestExecutionContext context, Action action)
1)    at Apache.Ignite.Tests.MetricsTests.TestRequestsActive() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/MetricsTests.cs:line 164
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.ExecutionContextCallback(Object s)
{code}

https://ci.ignite.apache.org/test/4249445999771063462?currentProjectId=ApacheIgnite3xGradle_Test",,isapego,ptupitsyn,,,,"ptupitsyn merged PR #2005:
URL: https://github.com/apache/ignite-3/pull/2005


;02/May/23 09:14;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Tue May 02 09:14:56 UTC 2023,,,,,,,,,,"0|z1hcsw:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"02/May/23 08:56;ptupitsyn;[~isapego] please review.;;;","02/May/23 09:01;isapego;Looks good to me.;;;","02/May/23 09:14;ptupitsyn;Merged to main: 4007b06bfe25df24b8cca57abb134008690a8cc4;;;",,,
NPE in case of simultaneous cache destroy and transaction rollback,IGNITE-19286,13532556,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,NSAmelchev,NSAmelchev,NSAmelchev,13/Apr/23 18:31,17/Apr/23 16:43,13/Jul/23 09:11,17/Apr/23 16:42,,,,,,,,2.15,,,,0,ise,,,"Reproducer attached. NPE in case of simultaneous cache destroy and transaction rollback:

{noformat}
java.lang.NullPointerException: null
	at org.apache.ignite.internal.processors.cache.transactions.IgniteTxManager.notifyEvictions(IgniteTxManager.java:1967) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.transactions.IgniteTxManager.rollbackTx(IgniteTxManager.java:1723) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.transactions.IgniteTxLocalAdapter.userRollback(IgniteTxLocalAdapter.java:1103) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.near.GridNearTxLocal.localFinish(GridNearTxLocal.java:3736) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.near.GridNearTxFinishFuture.doFinish(GridNearTxFinishFuture.java:468) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.near.GridNearTxFinishFuture.finish(GridNearTxFinishFuture.java:417) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.near.GridNearTxLocal$24.apply(GridNearTxLocal.java:4032) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.near.GridNearTxLocal$24.apply(GridNearTxLocal.java:4005) ~[classes/:?]
	at org.apache.ignite.internal.util.future.GridFutureAdapter.notifyListener(GridFutureAdapter.java:464) ~[classes/:?]
	at org.apache.ignite.internal.util.future.GridFutureAdapter.unblock(GridFutureAdapter.java:348) ~[classes/:?]
	at org.apache.ignite.internal.util.future.GridFutureAdapter.unblockAll(GridFutureAdapter.java:336) ~[classes/:?]
	at org.apache.ignite.internal.util.future.GridFutureAdapter.onDone(GridFutureAdapter.java:576) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.GridCacheCompoundFuture.onDone(GridCacheCompoundFuture.java:56) ~[classes/:?]
	at org.apache.ignite.internal.util.future.GridFutureAdapter.onDone(GridFutureAdapter.java:555) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.near.GridNearOptimisticTxPrepareFuture.onComplete(GridNearOptimisticTxPrepareFuture.java:298) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.near.GridNearOptimisticTxPrepareFuture.onDone(GridNearOptimisticTxPrepareFuture.java:274) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.near.GridNearOptimisticTxPrepareFuture.onDone(GridNearOptimisticTxPrepareFuture.java:79) ~[classes/:?]
	at org.apache.ignite.internal.util.future.GridFutureAdapter.onDone(GridFutureAdapter.java:543) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.near.GridNearOptimisticTxPrepareFutureAdapter.prepareOnTopology(GridNearOptimisticTxPrepareFutureAdapter.java:201) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.near.GridNearOptimisticTxPrepareFutureAdapter.lambda$prepareOnTopology$27f50bf2$1(GridNearOptimisticTxPrepareFutureAdapter.java:234) ~[classes/:?]
	at org.apache.ignite.internal.processors.timeout.GridTimeoutProcessor$2.apply(GridTimeoutProcessor.java:181) ~[classes/:?]
	at org.apache.ignite.internal.processors.timeout.GridTimeoutProcessor$2.apply(GridTimeoutProcessor.java:173) ~[classes/:?]
	at org.apache.ignite.internal.util.future.GridFutureAdapter.notifyListener(GridFutureAdapter.java:464) ~[classes/:?]
	at org.apache.ignite.internal.util.future.GridFutureAdapter.unblock(GridFutureAdapter.java:348) ~[classes/:?]
	at org.apache.ignite.internal.util.future.GridFutureAdapter.unblockAll(GridFutureAdapter.java:336) ~[classes/:?]
	at org.apache.ignite.internal.util.future.GridFutureAdapter.onDone(GridFutureAdapter.java:576) ~[classes/:?]
	at org.apache.ignite.internal.util.future.GridFutureAdapter.onDone(GridFutureAdapter.java:555) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPartitionsExchangeFuture.onDone(GridDhtPartitionsExchangeFuture.java:2586) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPartitionsExchangeFuture.finishExchangeOnCoordinator(GridDhtPartitionsExchangeFuture.java:4044) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPartitionsExchangeFuture.onAllReceived(GridDhtPartitionsExchangeFuture.java:3813) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPartitionsExchangeFuture.processSingleMessage(GridDhtPartitionsExchangeFuture.java:3320) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPartitionsExchangeFuture.access$100(GridDhtPartitionsExchangeFuture.java:161) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPartitionsExchangeFuture$2.apply(GridDhtPartitionsExchangeFuture.java:3107) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPartitionsExchangeFuture$2.apply(GridDhtPartitionsExchangeFuture.java:3095) ~[classes/:?]
	at org.apache.ignite.internal.util.future.GridFutureAdapter.notifyListener(GridFutureAdapter.java:464) ~[classes/:?]
	at org.apache.ignite.internal.util.future.GridFutureAdapter.listen(GridFutureAdapter.java:355) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPartitionsExchangeFuture.onReceiveSingleMessage(GridDhtPartitionsExchangeFuture.java:3095) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.GridCachePartitionExchangeManager.processSinglePartitionUpdate(GridCachePartitionExchangeManager.java:2065) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.GridCachePartitionExchangeManager.access$1100(GridCachePartitionExchangeManager.java:197) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.GridCachePartitionExchangeManager$2.onMessage(GridCachePartitionExchangeManager.java:449) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.GridCachePartitionExchangeManager$2.onMessage(GridCachePartitionExchangeManager.java:417) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.GridCachePartitionExchangeManager$MessageHandler.apply(GridCachePartitionExchangeManager.java:3765) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.GridCachePartitionExchangeManager$MessageHandler.apply(GridCachePartitionExchangeManager.java:3744) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.GridCacheIoManager.processMessage(GridCacheIoManager.java:1151) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.GridCacheIoManager.onMessage0(GridCacheIoManager.java:592) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.GridCacheIoManager.handleMessage(GridCacheIoManager.java:393) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.GridCacheIoManager.handleMessage(GridCacheIoManager.java:319) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.GridCacheIoManager.access$100(GridCacheIoManager.java:110) ~[classes/:?]
	at org.apache.ignite.internal.processors.cache.GridCacheIoManager$1.onMessage(GridCacheIoManager.java:309) ~[classes/:?]
	at org.apache.ignite.internal.managers.communication.GridIoManager.invokeListener(GridIoManager.java:1907) ~[classes/:?]
	at org.apache.ignite.internal.managers.communication.GridIoManager.processRegularMessage0(GridIoManager.java:1528) ~[classes/:?]
	at org.apache.ignite.internal.managers.communication.GridIoManager.access$5300(GridIoManager.java:243) ~[classes/:?]
	at org.apache.ignite.internal.managers.communication.GridIoManager$9.execute(GridIoManager.java:1421) ~[classes/:?]
	at org.apache.ignite.internal.managers.communication.TraceRunnable.run(TraceRunnable.java:55) ~[classes/:?]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_352]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_352]
	at java.lang.Thread.run(Thread.java:750) ~[?:1.8.0_352]
{noformat}
",,ignitetcbot,NSAmelchev,,,,"NSAmelchev opened a new pull request, #10647:
URL: https://github.com/apache/ignite/pull/10647

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;13/Apr/23 18:32;githubbot;600","sonarcloud[bot] commented on PR #10647:
URL: https://github.com/apache/ignite/pull/10647#issuecomment-1507447853

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10647)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10647&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10647&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10647&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=CODE_SMELL)
   
   [![No Coverage information](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/NoCoverageInfo-16px.png 'No Coverage information')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10647) No Coverage information  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10647&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10647&metric=new_duplicated_lines_density&view=list)
   
   


;13/Apr/23 18:38;githubbot;600","sonarcloud[bot] commented on PR #10647:
URL: https://github.com/apache/ignite/pull/10647#issuecomment-1507951137

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10647)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10647&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10647&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10647&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=CODE_SMELL) [![E](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/E-16px.png 'E')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=CODE_SMELL) [3 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10647&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10647&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10647&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10647&metric=new_duplicated_lines_density&view=list)
   
   


;14/Apr/23 05:41;githubbot;600","sonarcloud[bot] commented on PR #10647:
URL: https://github.com/apache/ignite/pull/10647#issuecomment-1509003011

   SonarCloud Quality Gate failed.&nbsp; &nbsp; [![Quality Gate failed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/failed-16px.png 'Quality Gate failed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10647)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10647&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10647&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10647&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=CODE_SMELL) [![E](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/E-16px.png 'E')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=CODE_SMELL) [3 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10647&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10647&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10647&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10647&metric=new_duplicated_lines_density&view=list)
   
   


;14/Apr/23 17:34;githubbot;600","alex-plekhanov commented on code in PR #10647:
URL: https://github.com/apache/ignite/pull/10647#discussion_r1168960568


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/transactions/StartImplicitlyTxOnStopCacheTest.java:
##########
@@ -100,4 +126,69 @@ public void test() throws Exception {
 
         assertNull(client.cache(DEFAULT_CACHE_NAME));
     }
+
+    /** @throws Exception If failed. */
+    @Test
+    public void testTxStartAfterGatewayBlockedOnCacheDestroy() throws Exception {
+        IgniteEx crd = (IgniteEx)startGridsMultiThreaded(2);
+        GridCacheSharedContext<Object, Object> cctx = crd.context().cache().context();
+
+        // Cache group with multiple caches are important here, partition topology will not be stopped on cache destroy.
+        crd.createCache(new CacheConfiguration<>(DEFAULT_CACHE_NAME + ""_1"")
+            .setGroupName(GROUP)
+            .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL));
+
+        CountDownLatch txStarted = new CountDownLatch(1);
+        CountDownLatch gatewayStopped = new CountDownLatch(1);
+
+        IgniteTxManager tm = Mockito.spy(cctx.tm());
+        setFieldValue(crd.context().cache().context(), ""txMgr"", tm);

Review Comment:
   `setTxManager`



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/transactions/StartImplicitlyTxOnStopCacheTest.java:
##########
@@ -100,4 +126,69 @@ public void test() throws Exception {
 
         assertNull(client.cache(DEFAULT_CACHE_NAME));
     }
+
+    /** @throws Exception If failed. */
+    @Test
+    public void testTxStartAfterGatewayBlockedOnCacheDestroy() throws Exception {
+        IgniteEx crd = (IgniteEx)startGridsMultiThreaded(2);
+        GridCacheSharedContext<Object, Object> cctx = crd.context().cache().context();
+
+        // Cache group with multiple caches are important here, partition topology will not be stopped on cache destroy.
+        crd.createCache(new CacheConfiguration<>(DEFAULT_CACHE_NAME + ""_1"")
+            .setGroupName(GROUP)
+            .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL));
+
+        CountDownLatch txStarted = new CountDownLatch(1);
+        CountDownLatch gatewayStopped = new CountDownLatch(1);
+
+        IgniteTxManager tm = Mockito.spy(cctx.tm());
+        setFieldValue(crd.context().cache().context(), ""txMgr"", tm);
+
+        Mockito.doAnswer(m -> {
+            // Create tx after gateway was stopped (but not blocked).
+            txStarted.countDown();
+            gatewayStopped.await();
+
+            return m.callRealMethod();
+        }).when(tm).onCreated(Mockito.any(), Mockito.any());
+
+        GridCacheGateway gate = Mockito.spy(cctx.cache().cache(DEFAULT_CACHE_NAME).context().gate());
+        setFieldValue(crd.context().cache().context().cache().cache(DEFAULT_CACHE_NAME).context(), ""gate"", gate);
+
+        Mockito.doAnswer(m -> {
+            // Await tx gateway enter and mark gateway to stop.
+            txStarted.await();
+
+            return m.callRealMethod();
+        }).when(gate).stopped();

Review Comment:
   Looks redundant (`destroyCache` is called only after `txStarted.await()`)



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/transactions/StartImplicitlyTxOnStopCacheTest.java:
##########
@@ -100,4 +126,69 @@ public void test() throws Exception {
 
         assertNull(client.cache(DEFAULT_CACHE_NAME));
     }
+
+    /** @throws Exception If failed. */
+    @Test
+    public void testTxStartAfterGatewayBlockedOnCacheDestroy() throws Exception {
+        IgniteEx crd = (IgniteEx)startGridsMultiThreaded(2);
+        GridCacheSharedContext<Object, Object> cctx = crd.context().cache().context();
+
+        // Cache group with multiple caches are important here, partition topology will not be stopped on cache destroy.
+        crd.createCache(new CacheConfiguration<>(DEFAULT_CACHE_NAME + ""_1"")
+            .setGroupName(GROUP)
+            .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL));
+
+        CountDownLatch txStarted = new CountDownLatch(1);
+        CountDownLatch gatewayStopped = new CountDownLatch(1);
+
+        IgniteTxManager tm = Mockito.spy(cctx.tm());
+        setFieldValue(crd.context().cache().context(), ""txMgr"", tm);
+
+        Mockito.doAnswer(m -> {
+            // Create tx after gateway was stopped (but not blocked).
+            txStarted.countDown();
+            gatewayStopped.await();
+
+            return m.callRealMethod();
+        }).when(tm).onCreated(Mockito.any(), Mockito.any());
+
+        GridCacheGateway gate = Mockito.spy(cctx.cache().cache(DEFAULT_CACHE_NAME).context().gate());
+        setFieldValue(crd.context().cache().context().cache().cache(DEFAULT_CACHE_NAME).context(), ""gate"", gate);

Review Comment:
   Too many `context().cache()`, one can be ommited. Or even `cctx.cacheContext(CU.cacheId(DEFAULT_CACHE_NAME))` can be used.



;17/Apr/23 16:11;githubbot;600","NSAmelchev commented on code in PR #10647:
URL: https://github.com/apache/ignite/pull/10647#discussion_r1168986083


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/transactions/StartImplicitlyTxOnStopCacheTest.java:
##########
@@ -100,4 +126,69 @@ public void test() throws Exception {
 
         assertNull(client.cache(DEFAULT_CACHE_NAME));
     }
+
+    /** @throws Exception If failed. */
+    @Test
+    public void testTxStartAfterGatewayBlockedOnCacheDestroy() throws Exception {
+        IgniteEx crd = (IgniteEx)startGridsMultiThreaded(2);
+        GridCacheSharedContext<Object, Object> cctx = crd.context().cache().context();
+
+        // Cache group with multiple caches are important here, partition topology will not be stopped on cache destroy.
+        crd.createCache(new CacheConfiguration<>(DEFAULT_CACHE_NAME + ""_1"")
+            .setGroupName(GROUP)
+            .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL));
+
+        CountDownLatch txStarted = new CountDownLatch(1);
+        CountDownLatch gatewayStopped = new CountDownLatch(1);
+
+        IgniteTxManager tm = Mockito.spy(cctx.tm());
+        setFieldValue(crd.context().cache().context(), ""txMgr"", tm);
+
+        Mockito.doAnswer(m -> {
+            // Create tx after gateway was stopped (but not blocked).
+            txStarted.countDown();
+            gatewayStopped.await();
+
+            return m.callRealMethod();
+        }).when(tm).onCreated(Mockito.any(), Mockito.any());
+
+        GridCacheGateway gate = Mockito.spy(cctx.cache().cache(DEFAULT_CACHE_NAME).context().gate());
+        setFieldValue(crd.context().cache().context().cache().cache(DEFAULT_CACHE_NAME).context(), ""gate"", gate);
+
+        Mockito.doAnswer(m -> {
+            // Await tx gateway enter and mark gateway to stop.
+            txStarted.await();
+
+            return m.callRealMethod();
+        }).when(gate).stopped();

Review Comment:
   Fixed, thank you.



;17/Apr/23 16:24;githubbot;600","NSAmelchev commented on code in PR #10647:
URL: https://github.com/apache/ignite/pull/10647#discussion_r1168986346


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/transactions/StartImplicitlyTxOnStopCacheTest.java:
##########
@@ -100,4 +126,69 @@ public void test() throws Exception {
 
         assertNull(client.cache(DEFAULT_CACHE_NAME));
     }
+
+    /** @throws Exception If failed. */
+    @Test
+    public void testTxStartAfterGatewayBlockedOnCacheDestroy() throws Exception {
+        IgniteEx crd = (IgniteEx)startGridsMultiThreaded(2);
+        GridCacheSharedContext<Object, Object> cctx = crd.context().cache().context();
+
+        // Cache group with multiple caches are important here, partition topology will not be stopped on cache destroy.
+        crd.createCache(new CacheConfiguration<>(DEFAULT_CACHE_NAME + ""_1"")
+            .setGroupName(GROUP)
+            .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL));
+
+        CountDownLatch txStarted = new CountDownLatch(1);
+        CountDownLatch gatewayStopped = new CountDownLatch(1);
+
+        IgniteTxManager tm = Mockito.spy(cctx.tm());
+        setFieldValue(crd.context().cache().context(), ""txMgr"", tm);
+
+        Mockito.doAnswer(m -> {
+            // Create tx after gateway was stopped (but not blocked).
+            txStarted.countDown();
+            gatewayStopped.await();
+
+            return m.callRealMethod();
+        }).when(tm).onCreated(Mockito.any(), Mockito.any());
+
+        GridCacheGateway gate = Mockito.spy(cctx.cache().cache(DEFAULT_CACHE_NAME).context().gate());
+        setFieldValue(crd.context().cache().context().cache().cache(DEFAULT_CACHE_NAME).context(), ""gate"", gate);

Review Comment:
   Done, thanks.



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/transactions/StartImplicitlyTxOnStopCacheTest.java:
##########
@@ -100,4 +126,69 @@ public void test() throws Exception {
 
         assertNull(client.cache(DEFAULT_CACHE_NAME));
     }
+
+    /** @throws Exception If failed. */
+    @Test
+    public void testTxStartAfterGatewayBlockedOnCacheDestroy() throws Exception {
+        IgniteEx crd = (IgniteEx)startGridsMultiThreaded(2);
+        GridCacheSharedContext<Object, Object> cctx = crd.context().cache().context();
+
+        // Cache group with multiple caches are important here, partition topology will not be stopped on cache destroy.
+        crd.createCache(new CacheConfiguration<>(DEFAULT_CACHE_NAME + ""_1"")
+            .setGroupName(GROUP)
+            .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL));
+
+        CountDownLatch txStarted = new CountDownLatch(1);
+        CountDownLatch gatewayStopped = new CountDownLatch(1);
+
+        IgniteTxManager tm = Mockito.spy(cctx.tm());
+        setFieldValue(crd.context().cache().context(), ""txMgr"", tm);

Review Comment:
   Done, thanks.



;17/Apr/23 16:25;githubbot;600","sonarcloud[bot] commented on PR #10647:
URL: https://github.com/apache/ignite/pull/10647#issuecomment-1511709459

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10647)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10647&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10647&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10647&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10647&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10647&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10647&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10647&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10647&metric=new_duplicated_lines_density&view=list)
   
   


;17/Apr/23 16:32;githubbot;600","NSAmelchev merged PR #10647:
URL: https://github.com/apache/ignite/pull/10647


;17/Apr/23 16:42;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,5400,,,0,5400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Mon Apr 17 16:43:40 UTC 2023,,,,,,,,,,"0|z1h9x4:",9223372036854775807,Fixed NPE in case of simultaneous cache destroy and transaction rollback,,,,,,,,,,,,,,,,,,,,"15/Apr/23 06:24;ignitetcbot;{panel:title=Branch: [pull/10647/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10647/head] Base: [master] : New Tests (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Cache 6{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7137954]]
* {color:#013220}IgniteCacheTestSuite6: StartImplicitlyTxOnStopCacheTest.testTxStartAfterGatewayBlockedOnCacheDestroy - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7137182&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","17/Apr/23 16:43;NSAmelchev;Merged into the master.

[~alexpl], Thank you for the review.;;;",,,,
JDBC URL is not taken from the session,IGNITE-19283,13532458,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,vpakhnushev,vpakhnushev,13/Apr/23 07:50,17/Apr/23 17:27,13/Jul/23 09:11,17/Apr/23 17:27,,,,,,,,3.0.0-beta2,cli,,,0,ignite-3,,,"After connecting to the node with {{connect}} in REPL mode and running {{sql}} command without arguments, JDBC URL is constructed from the default value in config rather than from the connected node.",,aleksandr.pakhomov,vpakhnushev,,,,"valepakh opened a new pull request, #1936:
URL: https://github.com/apache/ignite-3/pull/1936

   https://issues.apache.org/jira/browse/IGNITE-19283


;13/Apr/23 07:59;githubbot;600","PakhomovAlexander merged PR #1936:
URL: https://github.com/apache/ignite-3/pull/1936


;17/Apr/23 17:26;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Apr 17 17:27:04 UTC 2023,,,,,,,,,,"0|z1h9bc:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"17/Apr/23 17:27;aleksandr.pakhomov;Thanks, merged into main: d1841247cee8c62a101b3a0b41b0937f442094fd;;;",,,,,
AssertionError on client request to inactive cluster,IGNITE-19279,13532301,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,timonin.maksim,timoninmaxim,timoninmaxim,12/Apr/23 08:29,14/Apr/23 09:33,13/Jul/23 09:11,13/Apr/23 13:26,,,,,,,,2.15,,,,0,ise,,,"AssertionError is raised for thin client cache operations on inactive cluster. For a such operation clients try to update affinity info. In inactive cluster the topology is not initialized (topVer=-1), and it fails while preparing cache partitions assignment:

 

 
{code:java}
 java.lang.AssertionError: AffinityTopologyVersion [topVer=-1, minorTopVer=0]
    at org.apache.ignite.internal.processors.affinity.GridAffinityAssignmentCache.cachedAffinity(GridAffinityAssignmentCache.java:809) ~[classes/:?]
    at org.apache.ignite.internal.processors.cache.GridCacheAffinityManager.assignment(GridCacheAffinityManager.java:233) ~[classes/:?]
    at org.apache.ignite.internal.processors.cache.GridCacheAffinityManager.assignment(GridCacheAffinityManager.java:218) ~[classes/:?]
    at org.apache.ignite.internal.processors.platform.client.cache.ClientCachePartitionsRequest.getCacheAssignment(ClientCachePartitionsRequest.java:170) ~[classes/:?]
    at org.apache.ignite.internal.processors.platform.client.cache.ClientCachePartitionsRequest.processCache(ClientCachePartitionsRequest.java:144) ~[classes/:?]
    at org.apache.ignite.internal.processors.platform.client.cache.ClientCachePartitionsRequest.process(ClientCachePartitionsRequest.java:103) ~[classes/:?]
    at org.apache.ignite.internal.processors.platform.client.ClientRequestHandler.handle(ClientRequestHandler.java:101) ~[classes/:?]
    at org.apache.ignite.internal.processors.odbc.ClientListenerNioListener.onMessage(ClientListenerNioListener.java:204) ~[classes/:?]
    at org.apache.ignite.internal.processors.odbc.ClientListenerNioListener.onMessage(ClientListenerNioListener.java:55) ~[classes/:?]
    at org.apache.ignite.internal.util.nio.GridNioFilterChain$TailFilter.onMessageReceived(GridNioFilterChain.java:279) ~[classes/:?]
    at org.apache.ignite.internal.util.nio.GridNioFilterAdapter.proceedMessageReceived(GridNioFilterAdapter.java:109) ~[classes/:?]
    at org.apache.ignite.internal.util.nio.GridNioAsyncNotifyFilter$3.body(GridNioAsyncNotifyFilter.java:97) ~[classes/:?]
    at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:125) ~[classes/:?]
    at org.apache.ignite.internal.util.worker.GridWorkerPool$1.run(GridWorkerPool.java:70) ~[classes/:?]
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_322]
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_322]
    at java.lang.Thread.run(Thread.java:750) ~[?:1.8.0_322]
 
{code}
 

Reproducer:

 

 

 
{code:java}
package org.apache.ignite;
import org.apache.ignite.client.IgniteClient;
import org.apache.ignite.cluster.ClusterState;
import org.apache.ignite.configuration.CacheConfiguration;
import org.apache.ignite.configuration.ClientConfiguration;
import org.apache.ignite.configuration.DataRegionConfiguration;
import org.apache.ignite.configuration.DataStorageConfiguration;
import org.apache.ignite.configuration.IgniteConfiguration;
import org.apache.ignite.internal.IgniteEx;
import org.apache.ignite.internal.client.thin.AbstractThinClientTest;
import org.apache.ignite.internal.util.typedef.G;
import org.junit.Test;
/** */
public class Reproducer extends AbstractThinClientTest {
@Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception
{ IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName); cfg.setDataStorageConfiguration(new DataStorageConfiguration() .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setPersistenceEnabled(true))); cfg.setCacheConfiguration(new CacheConfiguration(""default"")); return cfg; }
/** */
@Test
public void test() throws Exception {
IgniteEx ign = startGrids(2);
ign.cluster().state(ClusterState.ACTIVE);
ClientConfiguration ccfg = getClientConfiguration(G.allGrids().toArray(new Ignite[]{}));
stopAllGrids();
startGrid(0);
IgniteClient cln = Ignition.startClient(ccfg);
cln.cache(""default"").get(0);
}
}
 
 
{code}
 ",,alex_pl,aonikolaev,ignitetcbot,timonin.maksim,timoninmaxim,"timoninmaxim opened a new pull request, #10645:
URL: https://github.com/apache/ignite/pull/10645

   …inactive cluster
   
   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;12/Apr/23 13:31;githubbot;600","sonarcloud[bot] commented on PR #10645:
URL: https://github.com/apache/ignite/pull/10645#issuecomment-1505295628

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10645)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10645&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10645&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10645&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10645&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10645&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10645&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10645&metric=new_duplicated_lines_density&view=list)
   
   


;12/Apr/23 13:38;githubbot;600","alex-plekhanov commented on code in PR #10645:
URL: https://github.com/apache/ignite/pull/10645#discussion_r1164150873


##########
modules/indexing/src/test/java/org/apache/ignite/client/ClientTestSuite.java:
##########
@@ -84,6 +85,7 @@
     IgniteClientConnectionEventListenerTest.class,
     IgniteClientRequestEventListenerTest.class,
     ThinClientEnpointsDiscoveryTest.class,
+    InactiveClusterCacheRequestTest.class

Review Comment:
   Add comma at the end please



##########
modules/core/src/main/java/org/apache/ignite/internal/processors/platform/client/cache/ClientCachePartitionsRequest.java:
##########
@@ -82,6 +82,9 @@ public ClientCachePartitionsRequest(BinaryRawReader reader, ClientProtocolContex
 
     /** {@inheritDoc} */
     @Override public ClientResponse process(ClientConnectionContext ctx) {
+        if (!ctx.kernalContext().state().publicApiActiveState(true))
+            return new ClientResponse(requestId(), ""Can not perform cache operation because the cluster is inactive."");

Review Comment:
   `Can not` -> `Cannot`



##########
modules/core/src/test/java/org/apache/ignite/internal/client/thin/InactiveClusterCacheRequestTest.java:
##########
@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.client.thin;
+
+import java.util.List;
+import org.apache.ignite.Ignite;
+import org.apache.ignite.Ignition;
+import org.apache.ignite.client.ClientException;
+import org.apache.ignite.client.IgniteClient;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.ClientConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.F;
+import org.apache.ignite.internal.util.typedef.G;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+/** */
+@RunWith(Parameterized.class)
+public class InactiveClusterCacheRequestTest extends AbstractThinClientTest {
+    /** */
+    @Parameterized.Parameter
+    public boolean partitionAwarenessEnabled;
+
+    /** */
+    @Parameterized.Parameters(name = ""partitionAwareness={0}"")
+    public static List<Boolean> params() {
+        return F.asList(false, true);
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() {
+        stopAllGrids();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);
+
+        cfg.setDataStorageConfiguration(new DataStorageConfiguration()
+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setPersistenceEnabled(true)));
+
+        cfg.setCacheConfiguration(new CacheConfiguration(""default""));
+
+        return cfg;
+    }
+
+    /** */
+    @Test
+    public void testCacheOperationReturnErrorOnInactiveCluster() throws Exception {
+        IgniteEx ign = startGrids(2);
+
+        ign.cluster().state(ClusterState.ACTIVE);
+
+        ClientConfiguration ccfg = getClientConfiguration(G.allGrids().toArray(new Ignite[]{}))
+            .setPartitionAwarenessEnabled(partitionAwarenessEnabled);
+
+        stopAllGrids();
+
+        startGrid(0);
+
+        IgniteClient cln = Ignition.startClient(ccfg);

Review Comment:
   Close client? (try-with-resource perhaps)



##########
modules/core/src/test/java/org/apache/ignite/internal/client/thin/InactiveClusterCacheRequestTest.java:
##########
@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.client.thin;
+
+import java.util.List;
+import org.apache.ignite.Ignite;
+import org.apache.ignite.Ignition;
+import org.apache.ignite.client.ClientException;
+import org.apache.ignite.client.IgniteClient;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.ClientConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.F;
+import org.apache.ignite.internal.util.typedef.G;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+/** */
+@RunWith(Parameterized.class)
+public class InactiveClusterCacheRequestTest extends AbstractThinClientTest {
+    /** */
+    @Parameterized.Parameter
+    public boolean partitionAwarenessEnabled;
+
+    /** */
+    @Parameterized.Parameters(name = ""partitionAwareness={0}"")
+    public static List<Boolean> params() {
+        return F.asList(false, true);
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() {
+        stopAllGrids();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);
+
+        cfg.setDataStorageConfiguration(new DataStorageConfiguration()
+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setPersistenceEnabled(true)));
+
+        cfg.setCacheConfiguration(new CacheConfiguration(""default""));

Review Comment:
   `CacheConfiguration` -> `new CacheConfiguration<>`



##########
modules/core/src/test/java/org/apache/ignite/internal/client/thin/InactiveClusterCacheRequestTest.java:
##########
@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.client.thin;
+
+import java.util.List;
+import org.apache.ignite.Ignite;
+import org.apache.ignite.Ignition;
+import org.apache.ignite.client.ClientException;
+import org.apache.ignite.client.IgniteClient;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.ClientConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.F;
+import org.apache.ignite.internal.util.typedef.G;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+/** */
+@RunWith(Parameterized.class)
+public class InactiveClusterCacheRequestTest extends AbstractThinClientTest {
+    /** */
+    @Parameterized.Parameter
+    public boolean partitionAwarenessEnabled;
+
+    /** */
+    @Parameterized.Parameters(name = ""partitionAwareness={0}"")
+    public static List<Boolean> params() {
+        return F.asList(false, true);
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() {
+        stopAllGrids();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);
+
+        cfg.setDataStorageConfiguration(new DataStorageConfiguration()
+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setPersistenceEnabled(true)));
+
+        cfg.setCacheConfiguration(new CacheConfiguration(""default""));
+
+        return cfg;
+    }
+
+    /** */
+    @Test
+    public void testCacheOperationReturnErrorOnInactiveCluster() throws Exception {
+        IgniteEx ign = startGrids(2);
+
+        ign.cluster().state(ClusterState.ACTIVE);

Review Comment:
   Looks redundant here



##########
modules/core/src/test/java/org/apache/ignite/internal/client/thin/InactiveClusterCacheRequestTest.java:
##########
@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.client.thin;
+
+import java.util.List;
+import org.apache.ignite.Ignite;
+import org.apache.ignite.Ignition;
+import org.apache.ignite.client.ClientException;
+import org.apache.ignite.client.IgniteClient;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.ClientConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.F;
+import org.apache.ignite.internal.util.typedef.G;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+/** */
+@RunWith(Parameterized.class)
+public class InactiveClusterCacheRequestTest extends AbstractThinClientTest {
+    /** */
+    @Parameterized.Parameter
+    public boolean partitionAwarenessEnabled;
+
+    /** */
+    @Parameterized.Parameters(name = ""partitionAwareness={0}"")
+    public static List<Boolean> params() {
+        return F.asList(false, true);
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() {
+        stopAllGrids();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);
+
+        cfg.setDataStorageConfiguration(new DataStorageConfiguration()
+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setPersistenceEnabled(true)));
+
+        cfg.setCacheConfiguration(new CacheConfiguration(""default""));
+
+        return cfg;
+    }
+
+    /** */
+    @Test
+    public void testCacheOperationReturnErrorOnInactiveCluster() throws Exception {
+        IgniteEx ign = startGrids(2);
+
+        ign.cluster().state(ClusterState.ACTIVE);
+
+        ClientConfiguration ccfg = getClientConfiguration(G.allGrids().toArray(new Ignite[]{}))

Review Comment:
   `new Ignite[]{}` -> `new Ignite[2]`, or `getClientConfiguration(grid(0), grid(1))`



;12/Apr/23 14:48;githubbot;600","sonarcloud[bot] commented on PR #10645:
URL: https://github.com/apache/ignite/pull/10645#issuecomment-1506725043

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10645)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10645&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10645&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10645&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10645&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10645&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10645&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10645&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10645&metric=new_duplicated_lines_density&view=list)
   
   


;13/Apr/23 10:26;githubbot;600","timoninmaxim merged PR #10645:
URL: https://github.com/apache/ignite/pull/10645


;13/Apr/23 13:25;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Apr 14 09:33:30 UTC 2023,,,,,,,,,,"0|z1h8cg:",9223372036854775807,,,alex_pl,,,,,,,,,,,,,,,,,,"13/Apr/23 12:14;ignitetcbot;{panel:title=Branch: [pull/10645/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10645/head] Base: [master] : New Tests (2)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Thin Client: Java{color} [[tests 2|https://ci2.ignite.apache.org/viewLog.html?buildId=7136126]]
* {color:#013220}ClientTestSuite: InactiveClusterCacheRequestTest.testCacheOperationReturnErrorOnInactiveCluster[partitionAwareness=false] - PASSED{color}
* {color:#013220}ClientTestSuite: InactiveClusterCacheRequestTest.testCacheOperationReturnErrorOnInactiveCluster[partitionAwareness=true] - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7135072&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","13/Apr/23 13:26;timonin.maksim;[~alex_pl] thanks for review! Merged to master;;;","14/Apr/23 09:33;alex_pl;Cherry-picked to 2.15;;;",,,
Table hang on InternalTableImpl$PartitionScanPublisher$PartitionScanSubscription.lambda$scanBatch,IGNITE-19278,13532285,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,xtern,Berkov,Berkov,12/Apr/23 07:13,19/May/23 06:49,13/Jul/23 09:11,19/May/23 06:49,3.0.0-beta1,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"1) Create table

 
{noformat}
CREATE TABLE order_line (
    ol_w_id        bigint        NOT NULL,
    ol_d_id        bigint        NOT NULL,
    ol_o_id        bigint        NOT NULL,
    ol_number      int           NOT NULL,
    ol_i_id        bigint        NOT NULL,
    ol_delivery_d  bigint,
    ol_amount      double        NOT NULL,
    ol_supply_w_id bigint        NOT NULL,
    ol_quantity    double        NOT NULL,
    ol_dist_info   char(24)      NOT NULL,
    PRIMARY KEY (ol_w_id, ol_d_id, ol_o_id, ol_number)
);{noformat}
 

2) Populate 30k random rows into it

3) Execute query

SELECT OL_I_ID, OL_SUPPLY_W_ID, OL_QUANTITY, OL_AMOUNT, OL_DELIVERY_D   FROM order_line WHERE OL_O_ID = ?   AND OL_D_ID = ?   AND OL_W_ID = ?

Get error:

 
{noformat}
 [Code: 0, SQL State: 50000]  Failed to fetch query results [curId=3]. Error message:java.util.concurrent.CompletionException: org.apache.ignite.lang.IgniteException: IGN-CMN-65535 TraceId:276bc015-a683-4e9d-83c3-c03243d1e0a5 Remote query execution
    at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:314)
    at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:319)
... 
Caused by: java.lang.IllegalStateException: Queue full
    at java.base/java.util.AbstractQueue.add(AbstractQueue.java:98)
    at org.apache.ignite.internal.sql.engine.exec.rel.StorageScanNode$SubscriberImpl.onNext(StorageScanNode.java:278)
    at org.apache.ignite.internal.util.subscription.ConcatenatedPublisher$ConcatenatedSubscriber.onNext(ConcatenatedPublisher.java:96)
    at org.apache.ignite.internal.sql.engine.exec.rel.StorageScanNode$1.onNext(StorageScanNode.java:158)
    at org.apache.ignite.internal.sql.engine.exec.rel.StorageScanNode$1.onNext(StorageScanNode.java:150)
    at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
    at org.apache.ignite.internal.table.distributed.storage.InternalTableImpl$PartitionScanPublisher$PartitionScanSubscription.lambda$scanBatch$2(InternalTableImpl.java:1398)
    at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:714){noformat}
Full error stack trace in attachment

Similar error on any query with this table, queries with the others works well.",,Berkov,xtern,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"12/Apr/23 07:13;Berkov;queueFull.txt;https://issues.apache.org/jira/secure/attachment/13057201/queueFull.txt","12/Apr/23 07:17;Berkov;server.log;https://issues.apache.org/jira/secure/attachment/13057202/server.log",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri May 19 06:49:36 UTC 2023,,,,,,,,,,"0|z1h894:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"17/May/23 15:21;xtern;The main problem is that there is a minor bug in the implementation that causes the following 2 requests to partition scan produce more rows then expected (6 rows instead of 4).

{code}
publisher = internalTable.scan(...)
Subscription subscription = ...subscribe to publisher...

subscription.request(3); // call scanBatch(3)
subscription.request(1); // call scanBatch(3) instead of scanBatch(1)
{code}

;;;","19/May/23 06:49;xtern;[Merged|https://github.com/apache/ignite-3/commit/144ffc4f922b18d8c69a414fb0ce42121569dbff] to the main branch.;;;",,,,
Add authorization of Ignite Cluster Node stop/restart operations.,IGNITE-19277,13532246,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,PetrovMikhail,PetrovMikhail,PetrovMikhail,11/Apr/23 21:32,24/Apr/23 15:46,13/Jul/23 09:11,18/Apr/23 08:59,,,,,,,,2.15,,,,0,security,,,"Before https://issues.apache.org/jira/browse/IGNITE-15322 IgniteCluster#restartNodes()/stopNodes() operations were authorized by the name of the internal tasks that is used during their execution - org.apache.ignite.internal.cluster.IgniteKillTask.

After https://issues.apache.org/jira/browse/IGNITE-15322 has been resolved, authorization of internal tasks is no longer performed. So IgniteCluster#restartNodes()/stopNodes()  operations are not authorized at all.

We must to fix it.",,ignitetcbot,PetrovMikhail,,,,"petrov-mg opened a new pull request, #10644:
URL: https://github.com/apache/ignite/pull/10644

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;11/Apr/23 21:39;githubbot;600","sonarcloud[bot] commented on PR #10644:
URL: https://github.com/apache/ignite/pull/10644#issuecomment-1504155559

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10644)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10644&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10644&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10644&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_duplicated_lines_density&view=list)
   
   


;11/Apr/23 21:53;githubbot;600","sonarcloud[bot] commented on PR #10644:
URL: https://github.com/apache/ignite/pull/10644#issuecomment-1504731192

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10644)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10644&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10644&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10644&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_duplicated_lines_density&view=list)
   
   


;12/Apr/23 06:26;githubbot;600","sonarcloud[bot] commented on PR #10644:
URL: https://github.com/apache/ignite/pull/10644#issuecomment-1509910549

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10644)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10644&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10644&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10644&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_duplicated_lines_density&view=list)
   
   


;15/Apr/23 17:47;githubbot;600","sonarcloud[bot] commented on PR #10644:
URL: https://github.com/apache/ignite/pull/10644#issuecomment-1509993128

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10644)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10644&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10644&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10644&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_duplicated_lines_density&view=list)
   
   


;15/Apr/23 22:54;githubbot;600","sonarcloud[bot] commented on PR #10644:
URL: https://github.com/apache/ignite/pull/10644#issuecomment-1509995658

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10644)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10644&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10644&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10644&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10644&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10644&metric=new_duplicated_lines_density&view=list)
   
   


;15/Apr/23 23:12;githubbot;600","petrov-mg merged PR #10644:
URL: https://github.com/apache/ignite/pull/10644


;18/Apr/23 08:58;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,4200,,,0,4200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Tue Apr 18 08:59:23 UTC 2023,,,,,,,,,,"0|z1h80g:",9223372036854775807,Added authorization of Ignite Cluster Node stop/start/restart operations.,,,,,,,,,,,,,,,,,,,,"18/Apr/23 08:57;ignitetcbot;{panel:title=Branch: [pull/10644/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10644/head] Base: [master] : New Tests (2)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Security{color} [[tests 2|https://ci2.ignite.apache.org/viewLog.html?buildId=7142379]]
* {color:#013220}SecurityTestSuite: ClusterNodeOperationPermissionTest.testStopNodeAuthorization - PASSED{color}
* {color:#013220}SecurityTestSuite: ClusterNodeOperationPermissionTest.testStartNodeAuthorization - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7142402&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","18/Apr/23 08:59;PetrovMikhail;[~alexpl], Thank you for the review.;;;",,,,
Uninformative jdbc exception. The cause is not logged on the server side.,IGNITE-19272,13532190,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,amashenkov,zstan,zstan,11/Apr/23 13:27,08/May/23 12:59,13/Jul/23 09:11,03/May/23 16:56,3.0.0-beta1,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"Steps to reproduce.
{code:java}
try (Statement stmt = conn.createStatement()) {
stmt.executeUpdate(""CREATE TABLE timetest(id INT PRIMARY KEY,""
                    + ""ts TIMESTAMP, ts_tz TIMESTAMP WITH LOCAL TIME ZONE)"");

            stmt.executeUpdate(""INSERT INTO timetest VALUES ""
                    + ""(3, '2011-01-01 01:01:01', TIMESTAMP WITH LOCAL TIME ZONE '2011-01-01 01:01:01')""); // <- ok
            stmt.executeUpdate(""INSERT INTO timetest VALUES ""
                    + ""(1, '2011-01-01 01:01:01', '2011-01-01 01:01:01')""); // <- failed

}
{code}

failed with no reason why:

{noformat}
java.sql.SQLException: Exception while executing query [query=INSERT INTO timetest VALUES (3, '2011-01-01 01:01:01', '2011-01-01 01:01:01')]. Error message:IGN-CMN-65535 TraceId:ba72bbc8-a0e3-414b-a520-6eed739b3f45 Remote query execution

	at org.apache.ignite.internal.jdbc.proto.IgniteQueryErrorCode.createJdbcSqlException(IgniteQueryErrorCode.java:57)
	at org.apache.ignite.internal.jdbc.JdbcStatement.execute0(JdbcStatement.java:148)
	at org.apache.ignite.internal.jdbc.JdbcStatement.executeUpdate(JdbcStatement.java:177)
{noformat}
Also, there is no stacktrace on the server side.
",,zstan,,,,,"AMashenkov opened a new pull request, #1994:
URL: https://github.com/apache/ignite-3/pull/1994

   https://issues.apache.org/jira/browse/IGNITE-19272


;27/Apr/23 14:13;githubbot;600","AMashenkov merged PR #1994:
URL: https://github.com/apache/ignite-3/pull/1994


;03/May/23 16:55;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,IGNITE-19292,IGNITE-19268,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Apr 26 16:30:38 UTC 2023,,,,,,,,,,"0|z1h7o0:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"26/Apr/23 16:30;zstan;probably we need to link them:
https://issues.apache.org/jira/browse/IGNITE-19292;;;",,,,,
Complete future at Checkpointer#syncUpdatedPageStores when Checkpointer shuts down,IGNITE-19263,13532030,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ktkalenko@gridgain.com,ktkalenko@gridgain.com,10/Apr/23 08:13,10/Apr/23 09:04,13/Jul/23 09:11,10/Apr/23 09:04,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"It was found that the future did not complete on the *Checkpointer* shuts down, which can lead to hangs.
*org.apache.ignite.internal.pagememory.persistence.checkpoint.Checkpointer#syncUpdatedPageStores*
{code:java}
for (int i = 0; i < checkpointThreads; i++) {
                int threadIdx = i;

                pageWritePool.execute(() -> {
                    Map.Entry<GroupPartitionId, LongAdder> entry = queue.poll();

                    try {
                        while (entry != null) {
                            if (shutdownNow) {
                                return;
                            }

                            fsyncDeltaFile(currentCheckpointProgress, entry.getKey(), entry.getValue());

                            entry = queue.poll();
                        }

                        futures[threadIdx].complete(null);
                    } catch (Throwable t) {
                        futures[threadIdx].completeExceptionally(t);
                    }
                });
            }

            blockingSectionBegin();

            try {
                // Hangs there.
                CompletableFuture.allOf(futures).join();
            } finally {
                blockingSectionEnd();
            }
{code}
",,ktkalenko@gridgain.com,rpuch,,,,"tkalkirill opened a new pull request, #1923:
URL: https://github.com/apache/ignite-3/pull/1923

   https://issues.apache.org/jira/browse/IGNITE-19263


;10/Apr/23 08:23;githubbot;600","tkalkirill merged PR #1923:
URL: https://github.com/apache/ignite-3/pull/1923


;10/Apr/23 09:04;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17766,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Apr 10 09:02:02 UTC 2023,,,,,,,,,,"0|z1h6oo:",9223372036854775807,,,rpuch,,,,,,,,,,,,,,,,,,"10/Apr/23 09:02;rpuch;LGTM;;;",,,,,
Sql. DDL silently ignores transaction,IGNITE-19262,13532029,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,amashenkov,ptupitsyn,ptupitsyn,10/Apr/23 08:07,19/Apr/23 15:28,13/Jul/23 09:11,19/Apr/23 15:28,3.0.0-beta1,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"In *ItSqlSynchronousApiTest*, update *checkDdl*:

{code:java}
    private static void checkDdl(boolean expectedApplied, Session ses, String sql) {
        Transaction tx = CLUSTER_NODES.get(0).transactions().begin();
        ResultSet res = ses.execute(
                tx,
                sql
        );

        assertEquals(expectedApplied, res.wasApplied());
        assertFalse(res.hasRowSet());
        assertEquals(-1, res.affectedRows());

        res.close();
        tx.rollback();
    }
{code}

All tests pass, even though we call rollback. 

DDL does not support transactions. We should throw an exception when *tx* is not null with a DDL statement to make this clear to the users.",,ptupitsyn,,,,,"AMashenkov opened a new pull request, #1948:
URL: https://github.com/apache/ignite-3/pull/1948

   https://issues.apache.org/jira/browse/IGNITE-19262


;17/Apr/23 15:30;githubbot;600","ygerzhedovich commented on code in PR #1948:
URL: https://github.com/apache/ignite-3/pull/1948#discussion_r1170937702


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/api/ItSqlAsynchronousApiTest.java:
##########
@@ -597,6 +597,19 @@ public void errors() {
             await(ars.closeAsync());
             assertThrowsWithCause(() -> await(ars.fetchNextPage()), CursorClosedException.class);
         }
+
+        // DDL is non-transactional.

Review Comment:
   I would like an additional test when we do a few operations in the transaction and just after it calls DDL in the same TX. Check that transaction is not rolled back or committed 



;19/Apr/23 07:39;githubbot;600","ygerzhedovich commented on code in PR #1948:
URL: https://github.com/apache/ignite-3/pull/1948#discussion_r1170940240


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/api/ItSqlAsynchronousApiTest.java:
##########
@@ -597,6 +597,19 @@ public void errors() {
             await(ars.closeAsync());
             assertThrowsWithCause(() -> await(ars.fetchNextPage()), CursorClosedException.class);
         }
+
+        // DDL is non-transactional.

Review Comment:
   Also, need to check that we have tests with DDL for auto-commit off and on in JDBC



;19/Apr/23 07:41;githubbot;600","ygerzhedovich commented on code in PR #1948:
URL: https://github.com/apache/ignite-3/pull/1948#discussion_r1171424129


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/api/ItSqlAsynchronousApiTest.java:
##########
@@ -597,6 +597,32 @@ public void errors() {
             await(ars.closeAsync());
             assertThrowsWithCause(() -> await(ars.fetchNextPage()), CursorClosedException.class);
         }
+
+        // DDL is non-transactional.
+        {
+            Transaction tx = igniteTx().begin();
+            try {
+                assertThrowsWithCause(() -> await(ses.executeAsync(tx, ""CREATE TABLE TEST2(ID INT PRIMARY KEY, VAL0 INT)"")),
+                        SqlException.class,
+                        ""DDL doesn't support transactions.""
+                );
+            } finally {
+                tx.rollback();
+            }
+        }
+        {

Review Comment:
   it looks as a separate test :)



;19/Apr/23 14:23;githubbot;600","AMashenkov merged PR #1948:
URL: https://github.com/apache/ignite-3/pull/1948


;19/Apr/23 15:28;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,Java,2023-04-10 08:07:01.0,,,,,,,,,,"0|z1h6og:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
The cache is not destroyed if snapshot restore start cache stage failed.,IGNITE-19257,13531893,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,NSAmelchev,NSAmelchev,NSAmelchev,07/Apr/23 15:41,08/May/23 13:28,13/Jul/23 09:11,20/Apr/23 13:03,,,,,,,,2.16,,,,0,ise,,,Add the {{RESTORE_CACHE_GROUP_SNAPSHOT_START}} stage to the {{IncrementalSnapshotTest#testStagesFail}} test to reproduce the fail.,,ignitetcbot,NSAmelchev,,,,"NSAmelchev opened a new pull request, #10654:
URL: https://github.com/apache/ignite/pull/10654

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;19/Apr/23 16:34;githubbot;600","sonarcloud[bot] commented on PR #10654:
URL: https://github.com/apache/ignite/pull/10654#issuecomment-1515049102

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10654)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10654&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10654&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10654&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10654&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10654&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10654&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10654&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10654&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10654&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10654&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10654&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10654&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10654&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10654&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10654&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10654&metric=new_duplicated_lines_density&view=list)
   
   


;19/Apr/23 16:40;githubbot;600","NSAmelchev merged PR #10654:
URL: https://github.com/apache/ignite/pull/10654


;20/Apr/23 13:02;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Mon May 08 13:28:17 UTC 2023,,,,,,,,,,"0|z1h5u8:",9223372036854775807,Fixed snapshot restore rollback if start cache stage failed,,,,,,,,,,,,,,,,,,,,"19/Apr/23 22:34;ignitetcbot;{panel:title=Branch: [pull/10654/head] Base: [master] : Possible Blockers (9)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}
{color:#d04437}Platform .NET (Core Linux){color} [[tests 0 TIMEOUT , Exit Code , TC_SERVICE_MESSAGE |https://ci2.ignite.apache.org/viewLog.html?buildId=7144037]]

{color:#d04437}Snapshots{color} [[tests 3|https://ci2.ignite.apache.org/viewLog.html?buildId=7144050]]
* IgniteSnapshotTestSuite: IgniteSnapshotMXBeanTest.testCreateSnapshot[encryption=false, onlyPrimay=false] - Test has low fail rate in base branch 0,0% and is not flaky
* IgniteSnapshotTestSuite: EncryptedSnapshotTest.testSnapshotRestoringFailsWithOtherMasterKey[encryption=true, onlyPrimay=false] - Test has low fail rate in base branch 0,0% and is not flaky
* IgniteSnapshotTestSuite: IgniteClusterSnapshotStreamerTest.testMetaWarningRestoredByOnlyOneNode[encryption=true, onlyPrimay=true] - Test has low fail rate in base branch 0,0% and is not flaky

{color:#d04437}Queries 2{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7144041]]
* IgniteBinaryCacheQueryTestSuite2: DynamicEnableIndexingBasicSelfTest.testEnableDynamicIndexing[hasNear=false,nodeIdx=3,cacheMode=PARTITIONED,atomicityMode=ATOMIC] - Test has low fail rate in base branch 1,0% and is not flaky

{color:#d04437}Queries 3{color} [[tests 0 TIMEOUT , Exit Code , Failure on metric |https://ci2.ignite.apache.org/viewLog.html?buildId=7144043]]

{color:#d04437}Queries 1 (lazy=true){color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7144040]]
* IgniteBinaryCacheQueryLazyTestSuite: DynamicIndexServerCoordinatorBasicSelfTest.testCreateReplicatedAtomic - Test has low fail rate in base branch 0,0% and is not flaky

{color:#d04437}Index Query API{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7144007]]
* IndexQueryTestSuite: IndexQueryRangeTest.testRangeQueries[qryPar=1 atomicity=TRANSACTIONAL mode=REPLICATED node=CRD backups=2 idxName=PERSON_DESCID_IDX duplicates=10] - Test has low fail rate in base branch 0,0% and is not flaky

{color:#d04437}Snapshots With Indexes{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7144051]]
* IgniteSnapshotWithIndexingTestSuite: IgniteClusterSnapshotRestoreWithIndexingTest.testClusterSnapshotRestoreOnBiggerTopology[encryption=false, onlyPrimay=false] - Test has low fail rate in base branch 0,0% and is not flaky

{panel}
{panel:title=Branch: [pull/10654/head] Base: [master] : No new tests found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7144071&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","20/Apr/23 13:02;ignitetcbot;{panel:title=Branch: [pull/10654/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10654/head] Base: [master] : No new tests found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7144071&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","20/Apr/23 13:03;NSAmelchev;Merged into the master.

[~timonin.maksim], thank you for the review.;;;","22/Apr/23 12:31;ignitetcbot;{panel:title=Branch: [pull/10654/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10654/head] Base: [master] : No new tests found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7144071&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","22/Apr/23 12:33;ignitetcbot;{panel:title=Branch: [pull/10654/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10654/head] Base: [master] : No new tests found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7144071&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","08/May/23 13:28;ignitetcbot;{panel:title=Branch: [pull/10654/head] Base: [master] : Possible Blockers (10)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}
{color:#d04437}Snapshots{color} [[tests 2 Exit Code , Failure on metric |https://ci.ignite.apache.org/viewLog.html?buildId=7195745]]
* IgniteSnapshotTestSuite: IgniteSnapshotMXBeanTest.testCreateSnapshot[encryption=false, onlyPrimay=false] - Test has low fail rate in base branch 0,0% and is not flaky
* IgniteSnapshotTestSuite: IgniteSnapshotMXBeanTest.testCreateSnapshot[encryption=false, onlyPrimay=true] - Test has low fail rate in base branch 0,0% and is not flaky

{color:#d04437}[Check Code Style Ducktests]{color} [[tests 0 Exit Code |https://ci.ignite.apache.org/viewLog.html?buildId=7195687]]

{color:#d04437}Platform .NET (Core Linux){color} [[tests 0 TIMEOUT , Exit Code , TC_SERVICE_MESSAGE |https://ci.ignite.apache.org/viewLog.html?buildId=7195732]]

{color:#d04437}PDS 3{color} [[tests 1|https://ci.ignite.apache.org/viewLog.html?buildId=7195720]]
* IgnitePdsTestSuite3: IgnitePdsContinuousRestartTest.testRebalancingDuringLoad_8000_8000_8_16 - Test has low fail rate in base branch 0,0% and is not flaky

{color:#d04437}ZooKeeper (Discovery) 1{color} [[tests 4|https://ci.ignite.apache.org/viewLog.html?buildId=7195758]]
* ZookeeperDiscoverySpiTestSuite1: ZookeeperDiscoverySegmentationAndConnectionRestoreTest.testStopNodeOnSegmentaion - Test has low fail rate in base branch 0,0% and is not flaky
* ZookeeperDiscoverySpiTestSuite1: ZookeeperDiscoverySegmentationAndConnectionRestoreTest.testSegmentation3 - Test has low fail rate in base branch 0,0% and is not flaky
* ZookeeperDiscoverySpiTestSuite1: ZookeeperDiscoverySegmentationAndConnectionRestoreTest.testSegmentation2 - Test has low fail rate in base branch 0,0% and is not flaky
* ZookeeperDiscoverySpiTestSuite1: ZookeeperDiscoveryClientReconnectTest.testReconnectServersRestart_1 - Test has low fail rate in base branch 0,0% and is not flaky

{panel}
{panel:title=Branch: [pull/10654/head] Base: [master] : No new tests found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci.ignite.apache.org/viewLog.html?buildId=7195766&amp;buildTypeId=IgniteTests24Java8_RunAll];;;"
Fix broken unit tests in distribution-zones module,IGNITE-19255,13531872,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,Sergey Uttsel,apolovtcev,apolovtcev,07/Apr/23 13:30,17/May/23 12:00,13/Jul/23 09:11,17/May/23 12:00,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"In IGNITE-19105 I've changed some internal shenanigans of the MetaStorageManager (without affecting its API in any way). After that, nearly all unit tests in the {{distribution-zones}} module started to fail. Turns out it happened because of extensive mock usages that emulate behavior of the Meta Storage. So I decided to replace it with the {{StandaloneMetaStorageManager}} implementation and all hell broke loose: many tests emulate Meta Storage incorrectly, a lot of races appeared, because many methods became truly asynchronous.

This situation is very frustrating: a different component internals were changed with no API changes and a completely unrelated module is not longer able to pass its tests. Though I fixed most of the failures, some tests are still failing and I'm going to try to describe, what's wrong with them:

*{{DistributionZoneManagerScaleUpTest#testDataNodesPropagationAfterScaleUpTriggeredOnNewCluster}}* - this test tests a scenario when we start a node after logical topology was updated. I don't know how realistic is this scenario, but the problem is that ""data nodes"" don't get populated with the logical topology nodes on {{distributionZoneManager}} start, because {{scheduleTimers}} method, that get's invoked from the Meta Storage Watch, doesn't go inside the {{if (!addedNodes.isEmpty() && autoAdjustScaleUp != INFINITE_TIMER_VALUE)}} branch.

*{{DistributionZoneManagerScaleUpTest#testDataNodesPropagationForDefaultZoneAfterScaleUpTriggered}}* - same issue as above.

*{{DistributionZoneManagerScaleUpTest#testDataNodesPropagationForDefaultZoneAfterScaleDownTriggered}}* - same issue as above.

*{{DistributionZoneManagerScaleUpTest#testUpdateZoneScaleUpTriggersDataNodePropagation}}* - this test fails with the following assertion error: {_}Expected revision that is greater or equal to already seen meta storage events.{_}. This is because TestConfigurationStorage does not use the same revision as the Meta Storage, therefore their revisions can't be compared directly. This should either be converted to an integration test or it should use `DistributedConfigurationStrorage` instead.
(ticket is created https://issues.apache.org/jira/browse/IGNITE-19342)

*{{DistributionZoneManagerScaleUpTest#testUpdateZoneScaleDownTriggersDataNodePropagation}}* - same issue as above. (ticket is created https://issues.apache.org/jira/browse/IGNITE-19342)

*{{DistributionZoneManagerScaleUpTest#testDropZoneDoNotPropagateDataNodesAfterScaleUp}}* - this test is flaky, because notifications from test configuration storage and from Meta Storage Watches are not related to each other (unlike real-life Distributed Configuration Storage which is built on top of Watches), so notifications from the configuration storage and Meta Storage can arrive in a undetermined order. (ticket is created https://issues.apache.org/jira/browse/IGNITE-19342)

*{{DistributionZoneManagerScaleUpTest#testDropZoneDoNotPropagateDataNodesAfterScaleDown}}* - same issue as above.
(ticket is created https://issues.apache.org/jira/browse/IGNITE-19342)

*{{DistributionZoneManagerWatchListenerTest#testDataNodesOfDefaultZoneUpdatedOnWatchListenerEvent}}* - this test is flaky, probably due to some races between Watch and Configuration Listener execution (sometimes a retry on {{invoke}} happens and {{Mockito#verify}} fails). (ticket is created https://issues.apache.org/jira/browse/IGNITE-19342)

 

*New tests* from [https://github.com/gridgain/apache-ignite-3/tree/ignite-18756]

*DistributionZoneAwaitDataNodesTest#testRemoveZoneWhileAwaitingDataNodes* - this test must remove the zone after MetastorageTopologyListener updates the topVerTracker and before 
MetastorageDataNodesListener updates scaleUpRevisionTracker/scaleDownRevisionTracker. Now it's impossible to do it with StandaloneMetaStorageManager. (https://issues.apache.org/jira/browse/IGNITE-19343)
*DistributionZoneAwaitDataNodesTest#testScaleUpScaleDownAreChangedWhileAwaitingDataNodes* - same issue as above but here we need to update scaleUp and scaleDown instead of removing the zone. (https://issues.apache.org/jira/browse/IGNITE-19343)",,alapin,apolovtcev,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19342,IGNITE-19343,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed May 17 12:00:28 UTC 2023,,,,,,,,,,"0|z1h5pk:",9223372036854775807,,,alapin,,,,,,,,,,,,,,,,,,"17/May/23 12:00;alapin;[~Sergey Uttsel] LGTM, thanks!;;;",,,,,
[Missing Tests] check fails on windows agents,IGNITE-19253,13531855,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,av,av,av,07/Apr/23 11:22,20/Apr/23 10:36,13/Jul/23 09:11,07/Apr/23 13:13,,,,,,,,2.15,,,,0,,,,"{noformat}
org.apache.ignite.tools.surefire.testsuites.CheckAllTestsInSuites
12:53:08     check
12:53:08       java.nio.file.InvalidPathException: Illegal char <:> at index 2: /C:/BuildAgent/work/6429fa5c3148cb5c/modules/tools/target/classes/
12:53:08       java.nio.file.InvalidPathException: Illegal char <:> at index 2: /C:/BuildAgent/work/6429fa5c3148cb5c/modules/tools/target/classes/
        at org.apache.ignite.tools.surefire.testsuites.CheckAllTestsInSuites.check(CheckAllTestsInSuites.java:79)
{noformat}",,av,,,,,"anton-vinogradov opened a new pull request, #10634:
URL: https://github.com/apache/ignite/pull/10634

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;07/Apr/23 12:02;githubbot;600","anton-vinogradov merged PR #10634:
URL: https://github.com/apache/ignite/pull/10634


;07/Apr/23 13:13;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,IGNITE-19236,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Apr 07 13:14:29 UTC 2023,,,,,,,,,,"0|z1h5ls:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"07/Apr/23 12:43;av;Fixed according to the hints from https://stackoverflow.com/questions/9834776/java-nio-file-path-issue (to use toURI() instead of getPath());;;","07/Apr/23 13:14;av;Merged to the master.
[~alexpl], thanks for the review!;;;",,,,
The incremental snapshot restore operation fails if there is a node not from the baseline.,IGNITE-19252,13531777,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,NSAmelchev,NSAmelchev,NSAmelchev,06/Apr/23 18:50,07/Apr/23 14:04,13/Jul/23 09:11,07/Apr/23 14:04,,,,,,,,2.15,,,,0,ise,,,"The incremental snapshot restore operation fails if there is a node not from the baseline:


{noformat}
21:20:40.324 [disco-notifier-worker-#147%server-1%] ERROR org.apache.ignite.internal.processors.cache.persistence.snapshot.SnapshotRestoreProcess - Failed to restore snapshot cache groups [reqId=55eead09-4da7-4232-8e98-976dba117d91].
org.apache.ignite.IgniteCheckedException: Snapshot metafile cannot be read due to it doesn't exist: /work/snapshots/snp1/increments/0000000000000001/server_3.smf
	at org.apache.ignite.internal.processors.cache.persistence.snapshot.IgniteSnapshotManager.readFromFile(IgniteSnapshotManager.java:2001) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
	at org.apache.ignite.internal.processors.cache.persistence.snapshot.IgniteSnapshotManager.readIncrementalSnapshotMetadata(IgniteSnapshotManager.java:1098) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
	at org.apache.ignite.internal.processors.cache.persistence.snapshot.IncrementalSnapshotProcessor.process(IncrementalSnapshotProcessor.java:94) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
	at org.apache.ignite.internal.processors.cache.persistence.snapshot.SnapshotRestoreProcess.restoreIncrementalSnapshot(SnapshotRestoreProcess.java:1466) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
	at org.apache.ignite.internal.processors.cache.persistence.snapshot.SnapshotRestoreProcess.lambda$incrementalSnapshotRestore$35(SnapshotRestoreProcess.java:1417) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
	at org.apache.ignite.internal.processors.security.thread.SecurityAwareRunnable.run(SecurityAwareRunnable.java:51) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) ~[?:1.8.0_201]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[?:1.8.0_201]
	at org.apache.ignite.internal.processors.security.thread.SecurityAwareRunnable.run(SecurityAwareRunnable.java:51) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[?:1.8.0_201]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[?:1.8.0_201]
	at java.lang.Thread.run(Thread.java:748) ~[?:1.8.0_201]
{noformat}
",,ignitetcbot,NSAmelchev,,,,"NSAmelchev opened a new pull request, #10630:
URL: https://github.com/apache/ignite/pull/10630

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;06/Apr/23 18:52;githubbot;600","timoninmaxim commented on code in PR #10630:
URL: https://github.com/apache/ignite/pull/10630#discussion_r1160506943


##########
modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/snapshot/SnapshotRestoreProcess.java:
##########
@@ -1395,7 +1395,7 @@ private void finishCacheStop(UUID reqId, Map<UUID, Boolean> res, Map<UUID, Throw
      * @return Result future.
      */
     private IgniteInternalFuture<Boolean> incrementalSnapshotRestore(UUID reqId) {
-        if (ctx.clientNode())
+        if (ctx.clientNode() || !CU.baselineNode(ctx.discovery().localNode(), ctx.state().clusterState()))

Review Comment:
   Nice catch, thanks!
   
   I think we should use another check here. Let's check local node is included into `opCtx0.nodes()`. This collection bases on pre-defined discoCache, so it looks like it's more reliable way to verify node. WDYT?
   
   Also, I think we should check `opCtx0 != null` also. 



;07/Apr/23 07:36;githubbot;600","NSAmelchev commented on code in PR #10630:
URL: https://github.com/apache/ignite/pull/10630#discussion_r1160544499


##########
modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/snapshot/SnapshotRestoreProcess.java:
##########
@@ -1395,7 +1395,7 @@ private void finishCacheStop(UUID reqId, Map<UUID, Boolean> res, Map<UUID, Throw
      * @return Result future.
      */
     private IgniteInternalFuture<Boolean> incrementalSnapshotRestore(UUID reqId) {
-        if (ctx.clientNode())
+        if (ctx.clientNode() || !CU.baselineNode(ctx.discovery().localNode(), ctx.state().clusterState()))

Review Comment:
   Thanks, fixed.



;07/Apr/23 08:37;githubbot;600","NSAmelchev commented on code in PR #10630:
URL: https://github.com/apache/ignite/pull/10630#discussion_r1160544713


##########
modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/snapshot/SnapshotRestoreProcess.java:
##########
@@ -1395,7 +1395,7 @@ private void finishCacheStop(UUID reqId, Map<UUID, Boolean> res, Map<UUID, Throw
      * @return Result future.
      */
     private IgniteInternalFuture<Boolean> incrementalSnapshotRestore(UUID reqId) {
-        if (ctx.clientNode())
+        if (ctx.clientNode() || !CU.baselineNode(ctx.discovery().localNode(), ctx.state().clusterState()))

Review Comment:
   > we should check opCtx0 != null also.
   
   Added.



;07/Apr/23 08:38;githubbot;600","NSAmelchev merged PR #10630:
URL: https://github.com/apache/ignite/pull/10630


;07/Apr/23 14:03;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Apr 07 14:04:26 UTC 2023,,,,,,,,,,"0|z1h54g:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"07/Apr/23 14:02;ignitetcbot;{panel:title=Branch: [pull/10630/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10630/head] Base: [master] : New Tests (2)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Disk Page Compressions 1{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7126467]]
* {color:#013220}IgnitePdsCompressionTestSuite: IncrementalSnapshotRestoreTest.testRecoveryWithNotBaselineNode - PASSED{color}

{color:#00008b}Snapshots{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7127632]]
* {color:#013220}IgniteSnapshotTestSuite: IncrementalSnapshotRestoreTest.testRecoveryWithNotBaselineNode - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7126470&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","07/Apr/23 14:04;NSAmelchev;Merged into the master.

[~timonin.maksim], thank you for the review.;;;",,,,
Fix snapshot restore hanging if the prepare stage fails.,IGNITE-19248,13531748,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,NSAmelchev,NSAmelchev,NSAmelchev,06/Apr/23 13:46,07/Apr/23 15:38,13/Jul/23 09:11,07/Apr/23 15:38,,,,,,,,2.15,,,,0,ise,,,Snapshot restore hangs if the prepare stage fails.,,ignitetcbot,NSAmelchev,,,,"NSAmelchev opened a new pull request, #10629:
URL: https://github.com/apache/ignite/pull/10629

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;06/Apr/23 13:48;githubbot;600","sonarcloud[bot] commented on PR #10629:
URL: https://github.com/apache/ignite/pull/10629#issuecomment-1500393774

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10629)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10629&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10629&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10629&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10629&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10629&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10629&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10629&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10629&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10629&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10629&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10629&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10629&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10629&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10629&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10629&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10629&metric=new_duplicated_lines_density&view=list)
   
   


;07/Apr/23 15:33;githubbot;600","NSAmelchev merged PR #10629:
URL: https://github.com/apache/ignite/pull/10629


;07/Apr/23 15:37;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Fri Apr 07 15:38:05 UTC 2023,,,,,,,,,,"0|z1h4y0:",9223372036854775807,Fixed snapshot restore hanging if the prepare stage fails.,,,,,,,,,,,,,,,,,,,,"07/Apr/23 11:16;ignitetcbot;{panel:title=Branch: [pull/10629/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10629/head] Base: [master] : New Tests (4)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Disk Page Compressions 1{color} [[tests 2|https://ci2.ignite.apache.org/viewLog.html?buildId=7126106]]
* {color:#013220}IgnitePdsCompressionTestSuite: IncrementalSnapshotTest.testStagesFail[encryption=false, onlyPrimay=false] - PASSED{color}
* {color:#013220}IgnitePdsCompressionTestSuite: IncrementalSnapshotTest.testStagesFail[encryption=false, onlyPrimay=true] - PASSED{color}

{color:#00008b}Snapshots{color} [[tests 2|https://ci2.ignite.apache.org/viewLog.html?buildId=7126992]]
* {color:#013220}IgniteSnapshotTestSuite: IncrementalSnapshotTest.testStagesFail[encryption=false, onlyPrimay=false] - PASSED{color}
* {color:#013220}IgniteSnapshotTestSuite: IncrementalSnapshotTest.testStagesFail[encryption=false, onlyPrimay=true] - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7126109&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","07/Apr/23 15:38;NSAmelchev;Merged into the master.

[~PetrovMikhail], Thank you for the review.;;;",,,,
ItDataTypesTest and ItCreateTableDdlTest are flaky,IGNITE-19238,13531654,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,alapin,alapin,alapin,05/Apr/23 20:18,07/Apr/23 10:25,13/Jul/23 09:11,07/Apr/23 09:46,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"h3. Description & Root cause

1. ItDataTypesTest is flaky because previous ItCreateTableDdlTest tests failed to stop replicas on node stop:

!Снимок экрана от 2023-04-06 10-39-32.png!
{code:java}
java.lang.AssertionError: There are replicas alive [replicas=[b86c60a8-4ea3-4592-abef-6438cfc4cdb2_part_21, b86c60a8-4ea3-4592-abef-6438cfc4cdb2_part_6, b86c60a8-4ea3-4592-abef-6438cfc4cdb2_part_13, b86c60a8-4ea3-4592-abef-6438cfc4cdb2_part_8, b86c60a8-4ea3-4592-abef-6438cfc4cdb2_part_9, b86c60a8-4ea3-4592-abef-6438cfc4cdb2_part_11]]
    at org.apache.ignite.internal.replicator.ReplicaManager.stop(ReplicaManager.java:341)
    at org.apache.ignite.internal.app.LifecycleManager.lambda$stopAllComponents$1(LifecycleManager.java:133)
    at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)
    at org.apache.ignite.internal.app.LifecycleManager.stopAllComponents(LifecycleManager.java:131)
    at org.apache.ignite.internal.app.LifecycleManager.stopNode(LifecycleManager.java:115){code}
2. The reason why we failed to stop replicas is the race between tablesToStopInCaseOfError cleanup and adding tables to tablesByIdVv.

On TableManager stop, we stop and cleanup all table resources like replicas and raft nodes
{code:java}
public void stop() {
  ...
  Map<UUID, TableImpl> tables = tablesByIdVv.latest();  // 1*
  cleanUpTablesResources(tables); 
  cleanUpTablesResources(tablesToStopInCaseOfError);
  ...
}{code}
where tablesToStopInCaseOfError is a sort of pending tables list which one is cleared on cfg storage revision update.

tablesByIdVv *listens same storage revision update event* in order to publish tables related to the given revision or in other words make such tables accessible from tablesByIdVv.latest(); that one that is used in order to retrieve tables for cleanup on components stop (see // 1* above)
{code:java}
public TableManager(
  ... 
  tablesByIdVv = new IncrementalVersionedValue<>(registry, HashMap::new);

  registry.accept(token -> {
    tablesToStopInCaseOfError.clear();
    
    return completedFuture(null);
  });
  {code}
However inside IncrementalVersionedValue we have async storageRevision update processing
{code:java}
updaterFuture = updaterFuture.whenComplete((v, t) -> versionedValue.complete(causalityToken, localUpdaterFuture)); {code}
As a result it's possible that we will clear tablesToStopInCaseOfError before publishing same revision tables to tablesByIdVv, so that we will miss that cleared tables in tablesByIdVv.latest() which is used in TableManager#stop.
h3. Implementation Notes

1. First of all I've renamed tablesToStopInCaseOfError to pending tables, because they aren't only ...InCaseOfError.

2. I've also reworked tablesToStopInCaseOfError cleanup by substituting tablesToStopInCaseOfError.clear on revision change with
{code:java}
tablesByIdVv.get(causalityToken).thenAccept(ignored -> inBusyLock(busyLock,  ()-> {      
  pendingTables.remove(tblId);
})); {code}
meaning that we

2.1. remove specific table by id instead of whole map clear.

2.2. do that removal on corresponding table publishing wihtin tablesByIdVv.

3. That means that at some point right after the publishing but before removal it's possible to have same table both within tablesByIdVv and pendingTables thus in order not to stop same table twice (which is safe by the way because of idempotentce) I've substituted
{code:java}
cleanUpTablesResources(tables);
cleanUpTablesResources(tablesToStopInCaseOfError); {code}
with
{code:java}
Map<UUID, TableImpl> tablesToStop = Stream.concat(tablesByIdVv.latest().entrySet().stream(), pendingTables.entrySet().stream()).
        collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (v1, v2) -> v1));

cleanUpTablesResources(tablesToStop); {code}",,alapin,Denis Chudov,,,,"denis-chudov commented on code in PR #1908:
URL: https://github.com/apache/ignite-3/pull/1908#discussion_r1159735496


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -995,13 +988,11 @@ public void stop() {
         metaStorageMgr.unregisterWatch(stableAssignmentsRebalanceListener);
         metaStorageMgr.unregisterWatch(assignmentsSwitchRebalanceListener);
 
-        Map<UUID, TableImpl> tables = tablesByIdVv.latest();
-
-        cleanUpTablesResources(tables);
+        Stream<TableImpl> tablesToStop =
+                Stream.concat(tablesByIdVv.latest().entrySet().stream(), pendingTables.entrySet().stream()).
+                        map(Map.Entry::getValue);

Review Comment:
   seems that `.distinct()` is needed if we want to process every table just once



;06/Apr/23 12:30;githubbot;600","sanpwc commented on code in PR #1908:
URL: https://github.com/apache/ignite-3/pull/1908#discussion_r1159983386


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -995,13 +988,11 @@ public void stop() {
         metaStorageMgr.unregisterWatch(stableAssignmentsRebalanceListener);
         metaStorageMgr.unregisterWatch(assignmentsSwitchRebalanceListener);
 
-        Map<UUID, TableImpl> tables = tablesByIdVv.latest();
-
-        cleanUpTablesResources(tables);
+        Stream<TableImpl> tablesToStop =
+                Stream.concat(tablesByIdVv.latest().entrySet().stream(), pendingTables.entrySet().stream()).
+                        map(Map.Entry::getValue);

Review Comment:
   Yep, you are right. Fixed.



;06/Apr/23 15:53;githubbot;600","sanpwc merged PR #1908:
URL: https://github.com/apache/ignite-3/pull/1908


;07/Apr/23 09:46;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"06/Apr/23 07:40;alapin;Снимок экрана от 2023-04-06 10-39-32.png;https://issues.apache.org/jira/secure/attachment/13057098/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA+%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0+%D0%BE%D1%82+2023-04-06+10-39-32.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Apr 07 09:41:29 UTC 2023,,,,,,,,,,"0|z1h4dc:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"07/Apr/23 09:41;Denis Chudov;[~alapin]  LGTM.;;;",,,,,
Enable ItGeneratedRestClientTest.initCluster(),IGNITE-19235,13531630,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,aleksandr.pakhomov,aleksandr.pakhomov,05/Apr/23 15:47,19/Apr/23 16:16,13/Jul/23 09:11,19/Apr/23 16:16,,,,,,,,3.0.0-beta2,cli,,,0,ignite-3,,,"After optimizing the ItGeneratedRestClientTest by using the BeforeAll and AfterAll methods to start and stop the cluster once for all the tests, it was observed that the ""initCluster"" test breaks the ""logicalTopology"" tests. Specifically, the logical topology changes after the second ""initCluster"" call, which should have no effect on the cluster state.

It seems that this no longer the case and we should enable the test.",,aleksandr.pakhomov,,,,,"valepakh opened a new pull request, #1957:
URL: https://github.com/apache/ignite-3/pull/1957

   https://issues.apache.org/jira/browse/IGNITE-19235


;19/Apr/23 12:22;githubbot;600","PakhomovAlexander merged PR #1957:
URL: https://github.com/apache/ignite-3/pull/1957


;19/Apr/23 16:16;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Apr 19 16:16:58 UTC 2023,,,,,,,,,,"0|z1h480:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"19/Apr/23 16:16;aleksandr.pakhomov;Merged into main: c0e6d5e23ab6d26bda4c588ffd5ce4398f7a5226;;;",,,,,
Change thread pool for metastore raft group,IGNITE-19231,13531553,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ktkalenko@gridgain.com,ktkalenko@gridgain.com,05/Apr/23 09:02,10/Apr/23 08:18,13/Jul/23 09:11,10/Apr/23 08:18,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"It was discovered that the common thread pool is used for raft group the metastorage and partitions, which can lead to deadlocks. The metastorage needs its own thread pool.",,ktkalenko@gridgain.com,rpuch,,,,"tkalkirill opened a new pull request, #1912:
URL: https://github.com/apache/ignite-3/pull/1912

   https://issues.apache.org/jira/browse/IGNITE-19231


;06/Apr/23 08:54;githubbot;600","rpuch commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1160735665


##########
modules/raft/src/integrationTest/java/org/apache/ignite/raft/jraft/core/ItNodeTest.java:
##########
@@ -3976,7 +3976,7 @@ private RaftGroupService createService(String groupId, TestPeer peer, NodeOption
 
         clusterService.start();
 
-        var service = new RaftGroupService(groupId, peer.getPeerId(), nodeOptions, rpcServer, nodeManager) {
+        var service = new RaftGroupService(groupId, peer.getPeerId(), nodeOptions, rpcServer, nodeManager, null) {

Review Comment:
   How about having two constructors in `RaftGroupService`, one identical to the old one (by parameters), another with this new added parameter, to avoid adding this `, null` all over the place?



##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/raft/PartitionListener.java:
##########
@@ -175,6 +176,14 @@ public void onWrite(Iterator<CommandClosure<WriteCommand>> iterator) {
                 clo.result(null);
             } catch (IgniteInternalException e) {
                 clo.result(e);
+            } catch (CompletionException e) {
+                clo.result(e.getCause());
+            } catch (Throwable t) {

Review Comment:
   Shouldn't we rethrow it after logging? For example, after this change it would become a lot more difficult to notice that an `AssertionError` has happened.



##########
modules/raft/src/main/java/org/apache/ignite/internal/raft/server/RaftServer.java:
##########
@@ -76,6 +77,26 @@ boolean startRaftNode(
             RaftGroupOptions groupOptions
     );
 
+    /**
+     * Starts a Raft group bound to this cluster node.
+     *
+     * @param nodeId Raft node ID.
+     * @param configuration Raft configuration.
+     * @param evLsnr Listener for group membership and other events.
+     * @param lsnr Listener for state machine events.
+     * @param groupOptions Options to apply to the group.
+     * @param ownFsmCallerExecutorDisruptorConfig Configuration own (not shared) striped disruptor for FSMCaller service of raft node.

Review Comment:
   ```suggestion
        * @param ownFsmCallerExecutorDisruptorConfig Configuration of own (not shared) striped disruptor for FSMCaller service of raft node.
   ```



##########
modules/raft/src/main/java/org/apache/ignite/raft/jraft/JRaftUtils.java:
##########
@@ -54,7 +54,7 @@ public final class JRaftUtils {
      * @return true if bootstrap success
      */
     public static boolean bootstrap(final BootstrapOptions opts) throws InterruptedException {
-        final NodeImpl node = new NodeImpl(""bootstrap"", new PeerId(""127.0.0.1"", 0));
+        final NodeImpl node = new NodeImpl(""bootstrap"", new PeerId(""127.0.0.1"", 0), null);

Review Comment:
   I suggest adding another constructor to `NodeImpl` to avoid this `, null` all over the place



##########
modules/raft-api/src/main/java/org/apache/ignite/internal/raft/RaftNodeDisruptorConfiguration.java:
##########
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.raft;
+
+/**
+ * Raft node disruptor configuration.
+ */
+public class RaftNodeDisruptorConfiguration {
+    private final String threadPostfix;
+
+    private final int stripes;
+
+    /**
+     * Constructor.
+     *
+     * @param threadPostfix Postfix the name of the disruptor threads.
+     * @param stripes Number of disruptor stripes.
+     */
+    public RaftNodeDisruptorConfiguration(String threadPostfix, int stripes) {
+        this.threadPostfix = threadPostfix;
+        this.stripes = stripes;
+    }
+
+    /**
+     * Return postfix the name of the disruptor threads.

Review Comment:
   ```suggestion
        * Return Disruptor threads' name postfix.
   ```



##########
modules/raft-api/src/main/java/org/apache/ignite/internal/raft/RaftNodeDisruptorConfiguration.java:
##########
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.raft;
+
+/**
+ * Raft node disruptor configuration.
+ */
+public class RaftNodeDisruptorConfiguration {
+    private final String threadPostfix;
+
+    private final int stripes;
+
+    /**
+     * Constructor.
+     *
+     * @param threadPostfix Postfix the name of the disruptor threads.

Review Comment:
   ```suggestion
        * @param threadPostfix Disruptor threads' name postfix.
   ```



##########
modules/raft/src/main/java/org/apache/ignite/internal/raft/Loza.java:
##########
@@ -235,7 +236,36 @@ public <T extends RaftGroupService> CompletableFuture<T> startRaftGroupNode(
         }
 
         try {
-            return startRaftGroupNodeInternal(nodeId, configuration, lsnr, eventsLsnr, groupOptions, raftServiceFactory);
+            return startRaftGroupNodeInternal(nodeId, configuration, lsnr, eventsLsnr, groupOptions, raftServiceFactory, null);
+        } finally {
+            busyLock.leaveBusy();
+        }
+    }
+
+    @Override
+    public CompletableFuture<RaftGroupService> startRaftGroupNode(
+            RaftNodeId nodeId,
+            PeersAndLearners configuration,
+            RaftGroupListener lsnr,
+            RaftGroupEventsListener eventsLsnr,
+            RaftNodeDisruptorConfiguration ownFsmCallerExecutorDisruptorConfig

Review Comment:
   In this class, we have overloads of this method that accept `RaftGroupOptions`. `RaftGroupOptions` was added to aggregate all options that are specific for a group, and it seems that the FSM caller disruptor configuration you are adding can be just added to that class. As a result, we'll not need so many overloads. The new configuration class can be either merged into `RaftGroupOptions`, or included as a sub-structure (as it seems to be passed to `NodeImpl`).
   
   The only catch here is that these overloads (having `RaftGroupOptions` among parameters) are not present on `RaftServer`, but it seems that we can just add them there. By doing this, we'll be able to get rid of that cast to `Loza` in `TableManager` as a by-product.
   
   I consulted @sashapolo on this matter, he seems to support this suggestion. He asked to also add a TODO mentioning https://issues.apache.org/jira/browse/IGNITE-18273 to the new overloads in `RaftService` (if this suggestion gets accepted).



##########
modules/raft/src/main/java/org/apache/ignite/raft/jraft/core/NodeImpl.java:
##########
@@ -225,6 +227,9 @@ public class NodeImpl implements Node, RaftServerService {
      */
     private volatile int electionTimeoutCounter;
 
+    /** Configuration own striped disruptor for FSMCaller service of raft node, {@code null} means use shared disruptor. */

Review Comment:
   ```suggestion
       /** Configuration of own striped disruptor for FSMCaller service of raft node, {@code null} means use shared disruptor. */
   ```



;07/Apr/23 15:00;githubbot;600","tkalkirill commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161432831


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/raft/PartitionListener.java:
##########
@@ -175,6 +176,14 @@ public void onWrite(Iterator<CommandClosure<WriteCommand>> iterator) {
                 clo.result(null);
             } catch (IgniteInternalException e) {
                 clo.result(e);
+            } catch (CompletionException e) {
+                clo.result(e.getCause());
+            } catch (Throwable t) {

Review Comment:
   Of course I forgot to do that, thanks!



;10/Apr/23 04:57;githubbot;600","tkalkirill commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161433003


##########
modules/raft/src/integrationTest/java/org/apache/ignite/raft/jraft/core/ItNodeTest.java:
##########
@@ -3976,7 +3976,7 @@ private RaftGroupService createService(String groupId, TestPeer peer, NodeOption
 
         clusterService.start();
 
-        var service = new RaftGroupService(groupId, peer.getPeerId(), nodeOptions, rpcServer, nodeManager) {
+        var service = new RaftGroupService(groupId, peer.getPeerId(), nodeOptions, rpcServer, nodeManager, null) {

Review Comment:
   Why not.



;10/Apr/23 04:58;githubbot;600","tkalkirill commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161435061


##########
modules/raft/src/main/java/org/apache/ignite/internal/raft/server/RaftServer.java:
##########
@@ -76,6 +77,26 @@ boolean startRaftNode(
             RaftGroupOptions groupOptions
     );
 
+    /**
+     * Starts a Raft group bound to this cluster node.
+     *
+     * @param nodeId Raft node ID.
+     * @param configuration Raft configuration.
+     * @param evLsnr Listener for group membership and other events.
+     * @param lsnr Listener for state machine events.
+     * @param groupOptions Options to apply to the group.
+     * @param ownFsmCallerExecutorDisruptorConfig Configuration own (not shared) striped disruptor for FSMCaller service of raft node.

Review Comment:
   fix it



;10/Apr/23 05:03;githubbot;600","tkalkirill commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161435624


##########
modules/raft/src/main/java/org/apache/ignite/raft/jraft/core/NodeImpl.java:
##########
@@ -225,6 +227,9 @@ public class NodeImpl implements Node, RaftServerService {
      */
     private volatile int electionTimeoutCounter;
 
+    /** Configuration own striped disruptor for FSMCaller service of raft node, {@code null} means use shared disruptor. */

Review Comment:
   fix it



;10/Apr/23 05:05;githubbot;600","tkalkirill commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161437304


##########
modules/raft/src/main/java/org/apache/ignite/raft/jraft/JRaftUtils.java:
##########
@@ -54,7 +54,7 @@ public final class JRaftUtils {
      * @return true if bootstrap success
      */
     public static boolean bootstrap(final BootstrapOptions opts) throws InterruptedException {
-        final NodeImpl node = new NodeImpl(""bootstrap"", new PeerId(""127.0.0.1"", 0));
+        final NodeImpl node = new NodeImpl(""bootstrap"", new PeerId(""127.0.0.1"", 0), null);

Review Comment:
   Why not.



;10/Apr/23 05:09;githubbot;600","tkalkirill commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161437754


##########
modules/raft-api/src/main/java/org/apache/ignite/internal/raft/RaftNodeDisruptorConfiguration.java:
##########
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.raft;
+
+/**
+ * Raft node disruptor configuration.
+ */
+public class RaftNodeDisruptorConfiguration {
+    private final String threadPostfix;
+
+    private final int stripes;
+
+    /**
+     * Constructor.
+     *
+     * @param threadPostfix Postfix the name of the disruptor threads.

Review Comment:
   fix it



##########
modules/raft-api/src/main/java/org/apache/ignite/internal/raft/RaftNodeDisruptorConfiguration.java:
##########
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.raft;
+
+/**
+ * Raft node disruptor configuration.
+ */
+public class RaftNodeDisruptorConfiguration {
+    private final String threadPostfix;
+
+    private final int stripes;
+
+    /**
+     * Constructor.
+     *
+     * @param threadPostfix Postfix the name of the disruptor threads.
+     * @param stripes Number of disruptor stripes.
+     */
+    public RaftNodeDisruptorConfiguration(String threadPostfix, int stripes) {
+        this.threadPostfix = threadPostfix;
+        this.stripes = stripes;
+    }
+
+    /**
+     * Return postfix the name of the disruptor threads.

Review Comment:
   Fix it



;10/Apr/23 05:10;githubbot;600","tkalkirill commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161445416


##########
modules/raft/src/main/java/org/apache/ignite/internal/raft/Loza.java:
##########
@@ -235,7 +236,36 @@ public <T extends RaftGroupService> CompletableFuture<T> startRaftGroupNode(
         }
 
         try {
-            return startRaftGroupNodeInternal(nodeId, configuration, lsnr, eventsLsnr, groupOptions, raftServiceFactory);
+            return startRaftGroupNodeInternal(nodeId, configuration, lsnr, eventsLsnr, groupOptions, raftServiceFactory, null);
+        } finally {
+            busyLock.leaveBusy();
+        }
+    }
+
+    @Override
+    public CompletableFuture<RaftGroupService> startRaftGroupNode(
+            RaftNodeId nodeId,
+            PeersAndLearners configuration,
+            RaftGroupListener lsnr,
+            RaftGroupEventsListener eventsLsnr,
+            RaftNodeDisruptorConfiguration ownFsmCallerExecutorDisruptorConfig

Review Comment:
   Look, `RaftGroupOptions` is in module `ignite-raft` and `RaftManager` (as well as `RaftNodeDisruptorConfiguration`) are in module `ignite-raft-api`, I don't want to inflate the amount of work in this ticket, let's not do it in **IGNITE-18273**. 
   
   IGNITE-18273 already indicates what needs to be done and within it, we will move the configuration, I will mention this in it.



;10/Apr/23 05:30;githubbot;600","rpuch commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161474223


##########
modules/raft/src/main/java/org/apache/ignite/internal/raft/Loza.java:
##########
@@ -235,7 +236,36 @@ public <T extends RaftGroupService> CompletableFuture<T> startRaftGroupNode(
         }
 
         try {
-            return startRaftGroupNodeInternal(nodeId, configuration, lsnr, eventsLsnr, groupOptions, raftServiceFactory);
+            return startRaftGroupNodeInternal(nodeId, configuration, lsnr, eventsLsnr, groupOptions, raftServiceFactory, null);
+        } finally {
+            busyLock.leaveBusy();
+        }
+    }
+
+    @Override
+    public CompletableFuture<RaftGroupService> startRaftGroupNode(
+            RaftNodeId nodeId,
+            PeersAndLearners configuration,
+            RaftGroupListener lsnr,
+            RaftGroupEventsListener eventsLsnr,
+            RaftNodeDisruptorConfiguration ownFsmCallerExecutorDisruptorConfig

Review Comment:
   At least `RaftServer` is in the same module as `RaftGroupOptions`, so it seems that it is possible to pass `RaftNodeDisruptorConfiguration` to `RaftServer` inside of `RaftGroupOptions` easily. Does it take a lot of work? On the other hand, `if this is done, `RaftServer` will become simpler right now.



;10/Apr/23 06:33;githubbot;600","rpuch commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161476054


##########
modules/raft/src/main/java/org/apache/ignite/raft/jraft/core/NodeImpl.java:
##########
@@ -571,9 +570,32 @@ public NodeImpl(
         this.confCtx = new ConfigurationCtx(this);
         this.wakingCandidate = null;
         this.applyCommittedFuture = new CompletableFuture<>();
-        this.ownFsmCallerExecutorDisruptorConfig = ownFsmCallerExecutorDisruptorConfig;
+        this.ownFsmCallerExecutorDisruptorConfig = null;
     }
 
+        public NodeImpl(

Review Comment:
   Same thing: let's reuse one constructor in the other. This seems to be especially important in this class, as the constructor has some non-trivial logic, not just assignments to fields, and it seems scary to duplicate this logic.



##########
modules/raft/src/main/java/org/apache/ignite/raft/jraft/RaftGroupService.java:
##########
@@ -76,26 +76,51 @@ public class RaftGroupService {
      * @param nodeOptions Node options.
      * @param rpcServer RPC server.
      * @param nodeManager Node manager.
-     * @param ownFsmCallerExecutorDisruptorConfig Configuration own striped disruptor for FSMCaller service of raft node, {@code null}
-     *      means use shared disruptor.
      */
     public RaftGroupService(
             final String groupId,
             final PeerId serverId,
             final NodeOptions nodeOptions,
             final RpcServer rpcServer,
-            final NodeManager nodeManager,
-            @Nullable RaftNodeDisruptorConfiguration ownFsmCallerExecutorDisruptorConfig
+            final NodeManager nodeManager
     ) {
         super();
         this.groupId = groupId;
         this.serverId = serverId;
         this.nodeOptions = nodeOptions;
         this.rpcServer = rpcServer;
         this.nodeManager = nodeManager;
-        this.ownFsmCallerExecutorDisruptorConfig = ownFsmCallerExecutorDisruptorConfig;
+        this.ownFsmCallerExecutorDisruptorConfig = null;
     }
 
+        /**
+         * @param groupId Group Id.
+         * @param serverId Server id.
+         * @param nodeOptions Node options.
+         * @param rpcServer RPC server.
+         * @param nodeManager Node manager.
+         * @param ownFsmCallerExecutorDisruptorConfig Configuration own striped disruptor for FSMCaller service of raft node.
+         */
+        public RaftGroupService(
+                final String groupId,
+                final PeerId serverId,
+                final NodeOptions nodeOptions,
+                final RpcServer rpcServer,
+                final NodeManager nodeManager,
+                final RaftNodeDisruptorConfiguration ownFsmCallerExecutorDisruptorConfig
+        ) {
+            super();

Review Comment:
   Sorry, I did not express this clearly: the idea was to reuse one constructor inside another. Looks like the only thing that prevents this is the `assert`, but it doesn't seem to be too important. By removing it, we can remove the duplication. WDYT?



;10/Apr/23 06:37;githubbot;600","tkalkirill commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161478460


##########
modules/raft/src/main/java/org/apache/ignite/raft/jraft/core/NodeImpl.java:
##########
@@ -571,9 +570,32 @@ public NodeImpl(
         this.confCtx = new ConfigurationCtx(this);
         this.wakingCandidate = null;
         this.applyCommittedFuture = new CompletableFuture<>();
-        this.ownFsmCallerExecutorDisruptorConfig = ownFsmCallerExecutorDisruptorConfig;
+        this.ownFsmCallerExecutorDisruptorConfig = null;
     }
 
+        public NodeImpl(

Review Comment:
   Fix it



;10/Apr/23 06:41;githubbot;600","tkalkirill commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161480196


##########
modules/raft/src/main/java/org/apache/ignite/raft/jraft/RaftGroupService.java:
##########
@@ -76,26 +76,51 @@ public class RaftGroupService {
      * @param nodeOptions Node options.
      * @param rpcServer RPC server.
      * @param nodeManager Node manager.
-     * @param ownFsmCallerExecutorDisruptorConfig Configuration own striped disruptor for FSMCaller service of raft node, {@code null}
-     *      means use shared disruptor.
      */
     public RaftGroupService(
             final String groupId,
             final PeerId serverId,
             final NodeOptions nodeOptions,
             final RpcServer rpcServer,
-            final NodeManager nodeManager,
-            @Nullable RaftNodeDisruptorConfiguration ownFsmCallerExecutorDisruptorConfig
+            final NodeManager nodeManager
     ) {
         super();
         this.groupId = groupId;
         this.serverId = serverId;
         this.nodeOptions = nodeOptions;
         this.rpcServer = rpcServer;
         this.nodeManager = nodeManager;
-        this.ownFsmCallerExecutorDisruptorConfig = ownFsmCallerExecutorDisruptorConfig;
+        this.ownFsmCallerExecutorDisruptorConfig = null;
     }
 
+        /**
+         * @param groupId Group Id.
+         * @param serverId Server id.
+         * @param nodeOptions Node options.
+         * @param rpcServer RPC server.
+         * @param nodeManager Node manager.
+         * @param ownFsmCallerExecutorDisruptorConfig Configuration own striped disruptor for FSMCaller service of raft node.
+         */
+        public RaftGroupService(
+                final String groupId,
+                final PeerId serverId,
+                final NodeOptions nodeOptions,
+                final RpcServer rpcServer,
+                final NodeManager nodeManager,
+                final RaftNodeDisruptorConfiguration ownFsmCallerExecutorDisruptorConfig
+        ) {
+            super();

Review Comment:
   Fix it.



;10/Apr/23 06:45;githubbot;600","tkalkirill commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161487364


##########
modules/raft/src/main/java/org/apache/ignite/internal/raft/Loza.java:
##########
@@ -235,7 +236,36 @@ public <T extends RaftGroupService> CompletableFuture<T> startRaftGroupNode(
         }
 
         try {
-            return startRaftGroupNodeInternal(nodeId, configuration, lsnr, eventsLsnr, groupOptions, raftServiceFactory);
+            return startRaftGroupNodeInternal(nodeId, configuration, lsnr, eventsLsnr, groupOptions, raftServiceFactory, null);
+        } finally {
+            busyLock.leaveBusy();
+        }
+    }
+
+    @Override
+    public CompletableFuture<RaftGroupService> startRaftGroupNode(
+            RaftNodeId nodeId,
+            PeersAndLearners configuration,
+            RaftGroupListener lsnr,
+            RaftGroupEventsListener eventsLsnr,
+            RaftNodeDisruptorConfiguration ownFsmCallerExecutorDisruptorConfig

Review Comment:
   I'll try to fix it.



;10/Apr/23 06:58;githubbot;600","rpuch commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161474223


##########
modules/raft/src/main/java/org/apache/ignite/internal/raft/Loza.java:
##########
@@ -235,7 +236,36 @@ public <T extends RaftGroupService> CompletableFuture<T> startRaftGroupNode(
         }
 
         try {
-            return startRaftGroupNodeInternal(nodeId, configuration, lsnr, eventsLsnr, groupOptions, raftServiceFactory);
+            return startRaftGroupNodeInternal(nodeId, configuration, lsnr, eventsLsnr, groupOptions, raftServiceFactory, null);
+        } finally {
+            busyLock.leaveBusy();
+        }
+    }
+
+    @Override
+    public CompletableFuture<RaftGroupService> startRaftGroupNode(
+            RaftNodeId nodeId,
+            PeersAndLearners configuration,
+            RaftGroupListener lsnr,
+            RaftGroupEventsListener eventsLsnr,
+            RaftNodeDisruptorConfiguration ownFsmCallerExecutorDisruptorConfig

Review Comment:
   At least `RaftServer` is in the same module as `RaftGroupOptions`, so it seems that it is possible to pass `RaftNodeDisruptorConfiguration` to `RaftServer` inside of `RaftGroupOptions` easily. Does it take a lot of work? On the other hand, if this is done, `RaftServer` will become simpler right now.



;10/Apr/23 07:00;githubbot;600","rpuch commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161491291


##########
modules/raft/src/main/java/org/apache/ignite/internal/raft/server/RaftGroupOptions.java:
##########
@@ -126,4 +131,20 @@ public RaftGroupOptions raftMetaStorageFactory(RaftMetaStorageFactory raftMetaSt
 
         return this;
     }
+
+    /**
+     * Returns configuration own striped disruptor for FSMCaller service of raft node, {@code null} means use shared disruptor.

Review Comment:
   ```suggestion
        * Returns configuration of own striped disruptor for FSMCaller service of raft node, {@code null} means use shared disruptor.
   ```



##########
modules/raft/src/main/java/org/apache/ignite/internal/raft/server/RaftGroupOptions.java:
##########
@@ -37,6 +39,9 @@ public class RaftGroupOptions {
     /** Raft meta storage factory. */
     private RaftMetaStorageFactory raftMetaStorageFactory;
 
+    /** Configuration own striped disruptor for FSMCaller service of raft node, {@code null} means use shared disruptor. */

Review Comment:
   ```suggestion
       /** Configuration of own striped disruptor for FSMCaller service of raft node, {@code null} means use shared disruptor. */
   ```



##########
modules/raft/src/main/java/org/apache/ignite/internal/raft/server/RaftGroupOptions.java:
##########
@@ -126,4 +131,20 @@ public RaftGroupOptions raftMetaStorageFactory(RaftMetaStorageFactory raftMetaSt
 
         return this;
     }
+
+    /**
+     * Returns configuration own striped disruptor for FSMCaller service of raft node, {@code null} means use shared disruptor.
+     */
+    public @Nullable RaftNodeDisruptorConfiguration ownFsmCallerExecutorDisruptorConfig() {
+        return ownFsmCallerExecutorDisruptorConfig;
+    }
+
+    /**
+     * Sets configuration own striped disruptor for FSMCaller service of raft node.

Review Comment:
   ```suggestion
        * Sets configuration of own striped disruptor for FSMCaller service of raft node.
   ```



;10/Apr/23 07:06;githubbot;600","tkalkirill commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161492668


##########
modules/raft/src/main/java/org/apache/ignite/internal/raft/server/RaftGroupOptions.java:
##########
@@ -37,6 +39,9 @@ public class RaftGroupOptions {
     /** Raft meta storage factory. */
     private RaftMetaStorageFactory raftMetaStorageFactory;
 
+    /** Configuration own striped disruptor for FSMCaller service of raft node, {@code null} means use shared disruptor. */

Review Comment:
   Fix it



;10/Apr/23 07:08;githubbot;600","tkalkirill commented on code in PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912#discussion_r1161493195


##########
modules/raft/src/main/java/org/apache/ignite/internal/raft/server/RaftGroupOptions.java:
##########
@@ -126,4 +131,20 @@ public RaftGroupOptions raftMetaStorageFactory(RaftMetaStorageFactory raftMetaSt
 
         return this;
     }
+
+    /**
+     * Returns configuration own striped disruptor for FSMCaller service of raft node, {@code null} means use shared disruptor.
+     */
+    public @Nullable RaftNodeDisruptorConfiguration ownFsmCallerExecutorDisruptorConfig() {
+        return ownFsmCallerExecutorDisruptorConfig;
+    }
+
+    /**
+     * Sets configuration own striped disruptor for FSMCaller service of raft node.

Review Comment:
   fix it



##########
modules/raft/src/main/java/org/apache/ignite/internal/raft/server/RaftGroupOptions.java:
##########
@@ -126,4 +131,20 @@ public RaftGroupOptions raftMetaStorageFactory(RaftMetaStorageFactory raftMetaSt
 
         return this;
     }
+
+    /**
+     * Returns configuration own striped disruptor for FSMCaller service of raft node, {@code null} means use shared disruptor.

Review Comment:
   fix it



;10/Apr/23 07:09;githubbot;600","tkalkirill merged PR #1912:
URL: https://github.com/apache/ignite-3/pull/1912


;10/Apr/23 08:18;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,0,11400,,,0,11400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17766,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Apr 10 07:27:27 UTC 2023,,,,,,,,,,"0|z1h3qw:",9223372036854775807,,,rpuch,,,,,,,,,,,,,,,,,,"10/Apr/23 07:27;rpuch;The patch looks good to me;;;",,,,,
DistributedQueryManager#close() fails to complete cancellation future,IGNITE-19200,13531421,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,rpuch,rpuch,rpuch,04/Apr/23 09:59,04/Apr/23 13:55,13/Jul/23 09:11,04/Apr/23 13:07,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"var finalStepFut = compoundCancelFut.thenRun(() -> {
    queryManagerMap.remove(ctx.queryId());

    try {
        ctx.cancel().cancel();
    } catch (Exception ex) {
        // NO-OP
    }

    cancelFut.complete(null);
});

The step above must be executed after compoundCancelFut is completed regardless of whether the completion is normal or exceptional; instead, the current code only executes this code on normal completion.",,korlov,rpuch,,,,"rpuch opened a new pull request, #1894:
URL: https://github.com/apache/ignite-3/pull/1894

   https://issues.apache.org/jira/browse/IGNITE-19200


;04/Apr/23 11:25;githubbot;600","korlov42 merged PR #1894:
URL: https://github.com/apache/ignite-3/pull/1894


;04/Apr/23 13:06;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,IGNITE-19201,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Apr 04 13:55:01 UTC 2023,,,,,,,,,,"0|z1h2xk:",9223372036854775807,,,korlov,,,,,,,,,,,,,,,,,,"04/Apr/23 12:09;rpuch;[~korlov] could you please take a look at the attached PR?;;;","04/Apr/23 13:07;korlov;[~rpuch], thanks for the contribution!

Merged to [main|https://github.com/apache/ignite-3/commit/dd2212726254e592a4d35b74b5bbc36200ee0d8d].;;;","04/Apr/23 13:55;rpuch;Thanks!;;;",,,
Fix broken compilation in AbstractMvStorageUpdateHandlerTest,IGNITE-19188,13531229,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ktkalenko@gridgain.com,ktkalenko@gridgain.com,03/Apr/23 09:58,03/Apr/23 10:27,13/Jul/23 09:11,03/Apr/23 10:27,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,I need to fix my broken compilation in *org.apache.ignite.internal.table.distributed.AbstractMvStorageUpdateHandlerTest*.,,ktkalenko@gridgain.com,,,,,"tkalkirill opened a new pull request, #1886:
URL: https://github.com/apache/ignite-3/pull/1886

   https://issues.apache.org/jira/browse/IGNITE-19188


;03/Apr/23 10:03;githubbot;600","tkalkirill merged PR #1886:
URL: https://github.com/apache/ignite-3/pull/1886


;03/Apr/23 10:26;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17766,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-04-03 09:58:21.0,,,,,,,,,,"0|z1h1r4:",9223372036854775807,,,rpuch,,,,,,,,,,,,,,,,,,,,,,,
Sql. Handle StorageRebalanceException during rowsCount estimation,IGNITE-19187,13531227,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,xtern,korlov,korlov,03/Apr/23 09:52,10/Apr/23 14:35,13/Jul/23 09:11,10/Apr/23 14:35,,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"We need to handle StorageRebalanceException which may be thrown from {{org.apache.ignite.internal.storage.MvPartitionStorage#rowsCount}} during row count estimation ({{org.apache.ignite.internal.sql.engine.schema.IgniteTableImpl.StatisticsImpl#getRowCount}}).


{code:java}
Caused by: org.apache.ignite.internal.storage.StorageRebalanceException: IGN-STORAGE-4 TraceId:a943b5f5-8018-4c4b-9e66-cc5060796848 Storage in the process of rebalancing: [table=TEST, partitionId=0]
  at app//org.apache.ignite.internal.storage.util.StorageUtils.throwExceptionDependingOnStorageState(StorageUtils.java:129)
  at app//org.apache.ignite.internal.storage.util.StorageUtils.throwExceptionIfStorageNotInRunnableState(StorageUtils.java:51)
  at app//org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.throwExceptionIfStorageNotInRunnableState(AbstractPageMemoryMvPartitionStorage.java:894)
  at app//org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.lambda$rowsCount$24(AbstractPageMemoryMvPartitionStorage.java:707)
  at app//org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.busy(AbstractPageMemoryMvPartitionStorage.java:785)
  at app//org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.rowsCount(AbstractPageMemoryMvPartitionStorage.java:706)
  at app//org.apache.ignite.internal.sql.engine.schema.IgniteTableImpl$StatisticsImpl.getRowCount(IgniteTableImpl.java:551)
  at app//org.apache.calcite.prepare.RelOptTableImpl.getRowCount(RelOptTableImpl.java:238)
  at app//org.apache.ignite.internal.sql.engine.rel.ProjectableFilterableTableScan.computeSelfCost(ProjectableFilterableTableScan.java:156)
{code}
",,jooger,korlov,xtern,,,"xtern closed pull request #1919: IGNITE-19187 Test for rebalance exception.
URL: https://github.com/apache/ignite-3/pull/1919


;07/Apr/23 11:01;githubbot;600","ygerzhedovich commented on code in PR #1915:
URL: https://github.com/apache/ignite-3/pull/1915#discussion_r1160746068


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -539,20 +540,33 @@ private class StatisticsImpl implements Statistic {
         /** {@inheritDoc} */
         @Override
         public Double getRowCount() {
-            if (statReqCnt.getAndIncrement() % STATS_CLI_UPDATE_THRESHOLD == 0) {
+            int prevCnt = statReqCnt.getAndIncrement();
+
+            if (prevCnt % STATS_CLI_UPDATE_THRESHOLD == 0) {
                 int parts = table.storage().distributionZoneConfiguration().partitions().value();
 
                 long size = 0L;
+                boolean noCache = false;
 
                 for (int p = 0; p < parts; ++p) {
                     @Nullable MvPartitionStorage part = table.storage().getMvPartition(p);
 
-                    if (part != null) {
+                    if (part == null) {
+                        continue;
+                    }
+
+                    try {
                         size += part.rowsCount();
+                    } catch (StorageRebalanceException ignore) {
+                        noCache = true;
                     }
                 }
 
-                localRowCnt = size;
+                if (noCache) {

Review Comment:
   in case the first calculation is fallen we will use zero as the rows counter, I'm not sure but maybe will be better to use incorrectly calculated value for the case



;07/Apr/23 14:37;githubbot;600","xtern commented on code in PR #1915:
URL: https://github.com/apache/ignite-3/pull/1915#discussion_r1160774636


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -539,20 +540,33 @@ private class StatisticsImpl implements Statistic {
         /** {@inheritDoc} */
         @Override
         public Double getRowCount() {
-            if (statReqCnt.getAndIncrement() % STATS_CLI_UPDATE_THRESHOLD == 0) {
+            int prevCnt = statReqCnt.getAndIncrement();
+
+            if (prevCnt % STATS_CLI_UPDATE_THRESHOLD == 0) {
                 int parts = table.storage().distributionZoneConfiguration().partitions().value();
 
                 long size = 0L;
+                boolean noCache = false;
 
                 for (int p = 0; p < parts; ++p) {
                     @Nullable MvPartitionStorage part = table.storage().getMvPartition(p);
 
-                    if (part != null) {
+                    if (part == null) {
+                        continue;
+                    }
+
+                    try {
                         size += part.rowsCount();
+                    } catch (StorageRebalanceException ignore) {
+                        noCache = true;
                     }
                 }
 
-                localRowCnt = size;
+                if (noCache) {

Review Comment:
   Agree, fixed a bit.



;07/Apr/23 15:21;githubbot;600","xtern commented on code in PR #1915:
URL: https://github.com/apache/ignite-3/pull/1915#discussion_r1160782990


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -539,20 +540,33 @@ private class StatisticsImpl implements Statistic {
         /** {@inheritDoc} */
         @Override
         public Double getRowCount() {
-            if (statReqCnt.getAndIncrement() % STATS_CLI_UPDATE_THRESHOLD == 0) {
+            int prevCnt = statReqCnt.getAndIncrement();
+
+            if (prevCnt % STATS_CLI_UPDATE_THRESHOLD == 0) {
                 int parts = table.storage().distributionZoneConfiguration().partitions().value();
 
                 long size = 0L;
+                boolean noCache = false;
 
                 for (int p = 0; p < parts; ++p) {
                     @Nullable MvPartitionStorage part = table.storage().getMvPartition(p);
 
-                    if (part != null) {
+                    if (part == null) {
+                        continue;
+                    }
+
+                    try {
                         size += part.rowsCount();
+                    } catch (StorageRebalanceException ignore) {
+                        noCache = true;
                     }
                 }
 
-                localRowCnt = size;
+                if (noCache) {

Review Comment:
   I decided to revert this change completely... currently any concurrent call can see a zero in localRowCnt (if it is calculated for the first time), but may be it's ok. 



;07/Apr/23 15:34;githubbot;600","xtern commented on code in PR #1915:
URL: https://github.com/apache/ignite-3/pull/1915#discussion_r1160782990


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -539,20 +540,33 @@ private class StatisticsImpl implements Statistic {
         /** {@inheritDoc} */
         @Override
         public Double getRowCount() {
-            if (statReqCnt.getAndIncrement() % STATS_CLI_UPDATE_THRESHOLD == 0) {
+            int prevCnt = statReqCnt.getAndIncrement();
+
+            if (prevCnt % STATS_CLI_UPDATE_THRESHOLD == 0) {
                 int parts = table.storage().distributionZoneConfiguration().partitions().value();
 
                 long size = 0L;
+                boolean noCache = false;
 
                 for (int p = 0; p < parts; ++p) {
                     @Nullable MvPartitionStorage part = table.storage().getMvPartition(p);
 
-                    if (part != null) {
+                    if (part == null) {
+                        continue;
+                    }
+
+                    try {
                         size += part.rowsCount();
+                    } catch (StorageRebalanceException ignore) {
+                        noCache = true;
                     }
                 }
 
-                localRowCnt = size;
+                if (noCache) {

Review Comment:
   I decided to revert this change completely...  since currently any concurrent call can see a zero in localRowCnt (if it is calculated for the first time), but may be it's ok. 



;07/Apr/23 15:35;githubbot;600","xtern commented on code in PR #1915:
URL: https://github.com/apache/ignite-3/pull/1915#discussion_r1160782990


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/schema/IgniteTableImpl.java:
##########
@@ -539,20 +540,33 @@ private class StatisticsImpl implements Statistic {
         /** {@inheritDoc} */
         @Override
         public Double getRowCount() {
-            if (statReqCnt.getAndIncrement() % STATS_CLI_UPDATE_THRESHOLD == 0) {
+            int prevCnt = statReqCnt.getAndIncrement();
+
+            if (prevCnt % STATS_CLI_UPDATE_THRESHOLD == 0) {
                 int parts = table.storage().distributionZoneConfiguration().partitions().value();
 
                 long size = 0L;
+                boolean noCache = false;
 
                 for (int p = 0; p < parts; ++p) {
                     @Nullable MvPartitionStorage part = table.storage().getMvPartition(p);
 
-                    if (part != null) {
+                    if (part == null) {
+                        continue;
+                    }
+
+                    try {
                         size += part.rowsCount();
+                    } catch (StorageRebalanceException ignore) {
+                        noCache = true;
                     }
                 }
 
-                localRowCnt = size;
+                if (noCache) {

Review Comment:
   I decided to revert this change completely...  since currently any concurrent call can see a zero in localRowCnt (if it is calculated for the first time), but may be it's ok. 



;07/Apr/23 15:41;githubbot;600","xtern closed pull request #1924: IGNITE-19187 tc check
URL: https://github.com/apache/ignite-3/pull/1924


;10/Apr/23 12:41;githubbot;600","xtern merged PR #1915:
URL: https://github.com/apache/ignite-3/pull/1915


;10/Apr/23 14:33;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,4800,,,0,4800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Apr 10 14:35:25 UTC 2023,,,,,,,,,,"0|z1h1qo:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"10/Apr/23 12:22;jooger;[~xtern]  LGTM.;;;","10/Apr/23 14:35;xtern;[~jooger], [~korlov],  thanks for the review!

Merged into the main branch.;;;",,,,
Fix index destruction after index creation started,IGNITE-19185,13531202,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ktkalenko@gridgain.com,ktkalenko@gridgain.com,03/Apr/23 08:34,11/Apr/23 10:02,13/Jul/23 09:11,11/Apr/23 10:02,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"It was found that if the destruction of the index occurs immediately after the start of its creation, then errors occur during its building: *org.apache.ignite.internal.sql.api.ItSqlSynchronousApiTest#ddl*
{code:java}
2023-04-02 13:53:16:882 +0300 [INFO][%issat_n_0%build-index-0][IndexBuilder] Start building the index: [table=TEST, tableId=8370aa11-b3ea-4e00-a546-0776ff12fffa, partitionId=14, index=TEST_IDX, indexId=55e899e3-5404-4409-8570-aad4459c2908]
2023-04-02 13:53:16:883 +0300 [INFO][%issat_n_0%build-index-6][IndexBuilder] Start building the index: [table=TEST, tableId=8370aa11-b3ea-4e00-a546-0776ff12fffa, partitionId=8, index=TEST_IDX, indexId=55e899e3-5404-4409-8570-aad4459c2908]
2023-04-02 13:53:16:884 +0300 [INFO][vault0][IndexManager] Index dropped [schema=PUBLIC, index=TEST_IDX]
2023-04-02 13:53:16:885 +0300 [ERROR][%issat_n_0%build-index-6][IndexBuilder] Index build error: [table=TEST, tableId=8370aa11-b3ea-4e00-a546-0776ff12fffa, partitionId=15, index=TEST_IDX, indexId=55e899e3-5404-4409-8570-aad4459c2908]
java.util.concurrent.CompletionException: org.apache.ignite.internal.storage.StorageException: IGN-STORAGE-1 TraceId:f9741480-3eaf-4c32-8220-66e9a9118d48 Index configuration for ""55e899e3-5404-4409-8570-aad4459c2908"" could not be found
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:315)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:320)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1159)
	at java.base/java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:482)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: org.apache.ignite.internal.storage.StorageException: IGN-STORAGE-1 TraceId:f9741480-3eaf-4c32-8220-66e9a9118d48 Index configuration for ""55e899e3-5404-4409-8570-aad4459c2908"" could not be found
	at org.apache.ignite.internal.storage.engine.MvTableStorage.getOrCreateIndex(MvTableStorage.java:94)
	at org.apache.ignite.internal.index.IndexBuilder$BuildIndexTask.collectRowIdBatch(IndexBuilder.java:258)
	at org.apache.ignite.internal.index.IndexBuilder$BuildIndexTask.lambda$run$1(IndexBuilder.java:164)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1150)
	... 4 more
2023-04-02 13:53:16:883 +0300 [INFO][%issat_n_0%build-index-2][IndexBuilder] Start building the index: [table=TEST, tableId=8370aa11-b3ea-4e00-a546-0776ff12fffa, partitionId=1, index=TEST_IDX, indexId=55e899e3-5404-4409-8570-aad4459c2908]
2023-04-02 13:53:16:887 +0300 [ERROR][%issat_n_0%build-index-6][IndexBuilder] Index build error: [table=TEST, tableId=8370aa11-b3ea-4e00-a546-0776ff12fffa, partitionId=18, index=TEST_IDX, indexId=55e899e3-5404-4409-8570-aad4459c2908]

{code}
",,ktkalenko@gridgain.com,sdanilov,,,,"tkalkirill opened a new pull request, #1892:
URL: https://github.com/apache/ignite-3/pull/1892

   https://issues.apache.org/jira/browse/IGNITE-19185


;04/Apr/23 07:58;githubbot;600","SammyVimes commented on code in PR #1892:
URL: https://github.com/apache/ignite-3/pull/1892#discussion_r1161716057


##########
modules/index/src/main/java/org/apache/ignite/internal/index/IndexBuilder.java:
##########
@@ -133,71 +176,77 @@ private BuildIndexTask(
 
         @Override
         public void run() {
-            if (!busyLock.enterBusy()) {
-                return;
-            }
+            completedFuture(null)

Review Comment:
   The first action in the `thenCompose` callback creates a future, do we really need `completedFuture(null)` here? 😰



##########
modules/index/src/main/java/org/apache/ignite/internal/index/BuildIndexTaskId.java:
##########
@@ -0,0 +1,83 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.index;
+
+import java.util.UUID;
+import org.apache.ignite.internal.tostring.S;
+
+/**
+ * ID of the index build task.
+ */
+class BuildIndexTaskId {
+    private final UUID tableId;
+
+    private final UUID indexId;
+
+    private final int partitionId;
+
+    BuildIndexTaskId(UUID tableId, UUID indexId, int partitionId) {
+        this.tableId = tableId;
+        this.indexId = indexId;
+        this.partitionId = partitionId;
+    }
+
+    UUID getTableId() {

Review Comment:
   I though we don't use `get` in getter names



##########
modules/index/src/main/java/org/apache/ignite/internal/index/IndexBuilder.java:
##########
@@ -133,71 +176,77 @@ private BuildIndexTask(
 
         @Override
         public void run() {

Review Comment:
   This future is really hard to read, maybe it can be somehow split into separate methods? I am afraid of it turning out like the TableManager



##########
modules/index/src/main/java/org/apache/ignite/internal/index/IndexBuilder.java:
##########
@@ -133,71 +176,77 @@ private BuildIndexTask(
 
         @Override
         public void run() {
-            if (!busyLock.enterBusy()) {
-                return;
-            }
+            completedFuture(null)
+                    .thenCompose(unused -> inBusyLock(() -> {
+                        // At the time of creating the index, we should have already waited for the table to be created and its raft of
+                        // clients (services) to start for all partitions, so there should be no errors.
+                        RaftGroupService raftGroupService = table.internalTable().partitionRaftGroupService(partitionId);
+
+                        return raftGroupService
+                                // We do not check the presence of nodes in the topology on purpose, so as not to get into races on
+                                // rebalancing, it will be more convenient and reliable for us to wait for a stable topology with a
+                                // chosen leader.

Review Comment:
   I don't get it, maybe you can paraphrase it somehow?



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ClusterPerClassIntegrationTest.java:
##########
@@ -468,4 +475,45 @@ public static void waitForIndex(String indexName) throws InterruptedException {
                 10_000)
         );
     }
+
+    /**
+     * Waits for the index to be built on all nodes.
+     *
+     * @param tableName Table name.
+     * @param indexName Index name.
+     * @throws Exception If failed.
+     */
+    public static void waitForIndexBuild(String tableName, String indexName) throws Exception {
+        // TODO: IGNITE-18733 We are waiting for the synchronization of schemes
+        for (Ignite clusterNode : CLUSTER_NODES) {
+            CompletableFuture<Table> tableFuture = clusterNode.tables().tableAsync(tableName);
+
+            assertThat(tableFuture, willCompleteSuccessfully());
+
+            TableImpl tableImpl = (TableImpl) tableFuture.join();
+
+            InternalTable internalTable = tableImpl.internalTable();
+
+            assertTrue(
+                    waitForCondition(() -> getIndexConfiguration(clusterNode, indexName) != null, 10, 10_000),
+                    String.format(""node=%s, tableName=%s, indexName=%s"", clusterNode.name(), tableName, indexName)
+            );
+
+            UUID indexId = getIndexConfiguration(clusterNode, indexName).id().value();
+
+            for (int partitionId = 0; partitionId < internalTable.partitions(); partitionId++) {
+                RaftGroupService raftGroupService = internalTable.partitionRaftGroupService(partitionId);
+
+                Stream<Peer> allPeers = Stream.concat(Stream.of(raftGroupService.leader()), raftGroupService.peers().stream());
+
+                if (allPeers.map(Peer::consistentId).noneMatch(clusterNode.name()::equals)) {

Review Comment:
   A comment would help here



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ClusterPerClassIntegrationTest.java:
##########
@@ -468,4 +475,45 @@ public static void waitForIndex(String indexName) throws InterruptedException {
                 10_000)
         );
     }
+
+    /**
+     * Waits for the index to be built on all nodes.
+     *
+     * @param tableName Table name.
+     * @param indexName Index name.
+     * @throws Exception If failed.
+     */
+    public static void waitForIndexBuild(String tableName, String indexName) throws Exception {
+        // TODO: IGNITE-18733 We are waiting for the synchronization of schemes
+        for (Ignite clusterNode : CLUSTER_NODES) {
+            CompletableFuture<Table> tableFuture = clusterNode.tables().tableAsync(tableName);
+
+            assertThat(tableFuture, willCompleteSuccessfully());
+
+            TableImpl tableImpl = (TableImpl) tableFuture.join();
+
+            InternalTable internalTable = tableImpl.internalTable();
+
+            assertTrue(
+                    waitForCondition(() -> getIndexConfiguration(clusterNode, indexName) != null, 10, 10_000),
+                    String.format(""node=%s, tableName=%s, indexName=%s"", clusterNode.name(), tableName, indexName)
+            );
+
+            UUID indexId = getIndexConfiguration(clusterNode, indexName).id().value();
+
+            for (int partitionId = 0; partitionId < internalTable.partitions(); partitionId++) {
+                RaftGroupService raftGroupService = internalTable.partitionRaftGroupService(partitionId);
+
+                Stream<Peer> allPeers = Stream.concat(Stream.of(raftGroupService.leader()), raftGroupService.peers().stream());
+
+                if (allPeers.map(Peer::consistentId).noneMatch(clusterNode.name()::equals)) {
+                    continue;
+                }
+
+                IndexStorage index = internalTable.storage().getOrCreateIndex(partitionId, indexId);
+
+                assertTrue(waitForCondition(() -> index.getNextRowIdToBuild() == null, 10, 10_000));

Review Comment:
   ```suggestion
                   assertTrue(waitForCondition(() -> index.getNextRowIdToBuild() == null, 10, TimeUnit.SECONDS.toMillis(10)));
   ```



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ClusterPerClassIntegrationTest.java:
##########
@@ -468,4 +475,45 @@ public static void waitForIndex(String indexName) throws InterruptedException {
                 10_000)
         );
     }
+
+    /**
+     * Waits for the index to be built on all nodes.
+     *
+     * @param tableName Table name.
+     * @param indexName Index name.
+     * @throws Exception If failed.
+     */
+    public static void waitForIndexBuild(String tableName, String indexName) throws Exception {
+        // TODO: IGNITE-18733 We are waiting for the synchronization of schemes
+        for (Ignite clusterNode : CLUSTER_NODES) {
+            CompletableFuture<Table> tableFuture = clusterNode.tables().tableAsync(tableName);
+
+            assertThat(tableFuture, willCompleteSuccessfully());
+
+            TableImpl tableImpl = (TableImpl) tableFuture.join();
+
+            InternalTable internalTable = tableImpl.internalTable();
+
+            assertTrue(
+                    waitForCondition(() -> getIndexConfiguration(clusterNode, indexName) != null, 10, 10_000),

Review Comment:
   ```suggestion
                       waitForCondition(() -> getIndexConfiguration(clusterNode, indexName) != null, 10, TimeUnit.SECONDS.toMillis(10)),
   ```



##########
modules/index/src/main/java/org/apache/ignite/internal/index/IndexBuilder.java:
##########
@@ -272,5 +325,50 @@ private List<RowId> collectRowIdBatch(RowId nextRowIdToBuild) {
 
             return createBatchRowIds(nextRowIdToBuild, BUILD_INDEX_ROW_ID_BATCH_SIZE);
         }
+
+        private boolean enterBusy() {
+            if (!taskBusyLock.enterBusy()) {

Review Comment:
   Can't we use one `busyLock` for tasks?



##########
modules/index/src/main/java/org/apache/ignite/internal/index/IndexBuilder.java:
##########
@@ -133,71 +176,77 @@ private BuildIndexTask(
 
         @Override
         public void run() {
-            if (!busyLock.enterBusy()) {
-                return;
-            }
+            completedFuture(null)
+                    .thenCompose(unused -> inBusyLock(() -> {
+                        // At the time of creating the index, we should have already waited for the table to be created and its raft of
+                        // clients (services) to start for all partitions, so there should be no errors.

Review Comment:
   probably something like
   ```suggestion
                           // At the time of index creation, table and raft services of all partitions 
                           // should be already started, so there should be no errors.
   ```



;10/Apr/23 13:45;githubbot;600","tkalkirill commented on code in PR #1892:
URL: https://github.com/apache/ignite-3/pull/1892#discussion_r1161756453


##########
modules/index/src/main/java/org/apache/ignite/internal/index/BuildIndexTaskId.java:
##########
@@ -0,0 +1,83 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.index;
+
+import java.util.UUID;
+import org.apache.ignite.internal.tostring.S;
+
+/**
+ * ID of the index build task.
+ */
+class BuildIndexTaskId {
+    private final UUID tableId;
+
+    private final UUID indexId;
+
+    private final int partitionId;
+
+    BuildIndexTaskId(UUID tableId, UUID indexId, int partitionId) {
+        this.tableId = tableId;
+        this.indexId = indexId;
+        this.partitionId = partitionId;
+    }
+
+    UUID getTableId() {

Review Comment:
   This rule for 2.0 in 3.0 was not found.



;10/Apr/23 14:15;githubbot;600","tkalkirill commented on code in PR #1892:
URL: https://github.com/apache/ignite-3/pull/1892#discussion_r1161759737


##########
modules/index/src/main/java/org/apache/ignite/internal/index/IndexBuilder.java:
##########
@@ -133,71 +176,77 @@ private BuildIndexTask(
 
         @Override
         public void run() {
-            if (!busyLock.enterBusy()) {
-                return;
-            }
+            completedFuture(null)
+                    .thenCompose(unused -> inBusyLock(() -> {
+                        // At the time of creating the index, we should have already waited for the table to be created and its raft of
+                        // clients (services) to start for all partitions, so there should be no errors.

Review Comment:
   Fix it



;10/Apr/23 14:19;githubbot;600","tkalkirill commented on code in PR #1892:
URL: https://github.com/apache/ignite-3/pull/1892#discussion_r1161761432


##########
modules/index/src/main/java/org/apache/ignite/internal/index/IndexBuilder.java:
##########
@@ -272,5 +325,50 @@ private List<RowId> collectRowIdBatch(RowId nextRowIdToBuild) {
 
             return createBatchRowIds(nextRowIdToBuild, BUILD_INDEX_ROW_ID_BATCH_SIZE);
         }
+
+        private boolean enterBusy() {
+            if (!taskBusyLock.enterBusy()) {

Review Comment:
   Do you think it's right? we want to be able to stop both all tasks and only for a specific index.



;10/Apr/23 14:21;githubbot;600","tkalkirill commented on code in PR #1892:
URL: https://github.com/apache/ignite-3/pull/1892#discussion_r1161762265


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ClusterPerClassIntegrationTest.java:
##########
@@ -468,4 +475,45 @@ public static void waitForIndex(String indexName) throws InterruptedException {
                 10_000)
         );
     }
+
+    /**
+     * Waits for the index to be built on all nodes.
+     *
+     * @param tableName Table name.
+     * @param indexName Index name.
+     * @throws Exception If failed.
+     */
+    public static void waitForIndexBuild(String tableName, String indexName) throws Exception {
+        // TODO: IGNITE-18733 We are waiting for the synchronization of schemes
+        for (Ignite clusterNode : CLUSTER_NODES) {
+            CompletableFuture<Table> tableFuture = clusterNode.tables().tableAsync(tableName);
+
+            assertThat(tableFuture, willCompleteSuccessfully());
+
+            TableImpl tableImpl = (TableImpl) tableFuture.join();
+
+            InternalTable internalTable = tableImpl.internalTable();
+
+            assertTrue(
+                    waitForCondition(() -> getIndexConfiguration(clusterNode, indexName) != null, 10, 10_000),

Review Comment:
   fix it



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ClusterPerClassIntegrationTest.java:
##########
@@ -468,4 +475,45 @@ public static void waitForIndex(String indexName) throws InterruptedException {
                 10_000)
         );
     }
+
+    /**
+     * Waits for the index to be built on all nodes.
+     *
+     * @param tableName Table name.
+     * @param indexName Index name.
+     * @throws Exception If failed.
+     */
+    public static void waitForIndexBuild(String tableName, String indexName) throws Exception {
+        // TODO: IGNITE-18733 We are waiting for the synchronization of schemes
+        for (Ignite clusterNode : CLUSTER_NODES) {
+            CompletableFuture<Table> tableFuture = clusterNode.tables().tableAsync(tableName);
+
+            assertThat(tableFuture, willCompleteSuccessfully());
+
+            TableImpl tableImpl = (TableImpl) tableFuture.join();
+
+            InternalTable internalTable = tableImpl.internalTable();
+
+            assertTrue(
+                    waitForCondition(() -> getIndexConfiguration(clusterNode, indexName) != null, 10, 10_000),
+                    String.format(""node=%s, tableName=%s, indexName=%s"", clusterNode.name(), tableName, indexName)
+            );
+
+            UUID indexId = getIndexConfiguration(clusterNode, indexName).id().value();
+
+            for (int partitionId = 0; partitionId < internalTable.partitions(); partitionId++) {
+                RaftGroupService raftGroupService = internalTable.partitionRaftGroupService(partitionId);
+
+                Stream<Peer> allPeers = Stream.concat(Stream.of(raftGroupService.leader()), raftGroupService.peers().stream());
+
+                if (allPeers.map(Peer::consistentId).noneMatch(clusterNode.name()::equals)) {
+                    continue;
+                }
+
+                IndexStorage index = internalTable.storage().getOrCreateIndex(partitionId, indexId);
+
+                assertTrue(waitForCondition(() -> index.getNextRowIdToBuild() == null, 10, 10_000));

Review Comment:
   fix it



;10/Apr/23 14:22;githubbot;600","tkalkirill commented on code in PR #1892:
URL: https://github.com/apache/ignite-3/pull/1892#discussion_r1161771835


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ClusterPerClassIntegrationTest.java:
##########
@@ -468,4 +475,45 @@ public static void waitForIndex(String indexName) throws InterruptedException {
                 10_000)
         );
     }
+
+    /**
+     * Waits for the index to be built on all nodes.
+     *
+     * @param tableName Table name.
+     * @param indexName Index name.
+     * @throws Exception If failed.
+     */
+    public static void waitForIndexBuild(String tableName, String indexName) throws Exception {
+        // TODO: IGNITE-18733 We are waiting for the synchronization of schemes
+        for (Ignite clusterNode : CLUSTER_NODES) {
+            CompletableFuture<Table> tableFuture = clusterNode.tables().tableAsync(tableName);
+
+            assertThat(tableFuture, willCompleteSuccessfully());
+
+            TableImpl tableImpl = (TableImpl) tableFuture.join();
+
+            InternalTable internalTable = tableImpl.internalTable();
+
+            assertTrue(
+                    waitForCondition(() -> getIndexConfiguration(clusterNode, indexName) != null, 10, 10_000),
+                    String.format(""node=%s, tableName=%s, indexName=%s"", clusterNode.name(), tableName, indexName)
+            );
+
+            UUID indexId = getIndexConfiguration(clusterNode, indexName).id().value();
+
+            for (int partitionId = 0; partitionId < internalTable.partitions(); partitionId++) {
+                RaftGroupService raftGroupService = internalTable.partitionRaftGroupService(partitionId);
+
+                Stream<Peer> allPeers = Stream.concat(Stream.of(raftGroupService.leader()), raftGroupService.peers().stream());
+
+                if (allPeers.map(Peer::consistentId).noneMatch(clusterNode.name()::equals)) {

Review Comment:
   Fix it.



;10/Apr/23 14:33;githubbot;600","tkalkirill commented on code in PR #1892:
URL: https://github.com/apache/ignite-3/pull/1892#discussion_r1161775100


##########
modules/index/src/main/java/org/apache/ignite/internal/index/IndexBuilder.java:
##########
@@ -133,71 +176,77 @@ private BuildIndexTask(
 
         @Override
         public void run() {
-            if (!busyLock.enterBusy()) {
-                return;
-            }
+            completedFuture(null)

Review Comment:
   Conveniently, we will always execute `whenComplete` below (L243), with no additional code in `finally` block to do the same.



;10/Apr/23 14:37;githubbot;600","tkalkirill commented on code in PR #1892:
URL: https://github.com/apache/ignite-3/pull/1892#discussion_r1161779526


##########
modules/index/src/main/java/org/apache/ignite/internal/index/IndexBuilder.java:
##########
@@ -133,71 +176,77 @@ private BuildIndexTask(
 
         @Override
         public void run() {
-            if (!busyLock.enterBusy()) {
-                return;
-            }
+            completedFuture(null)
+                    .thenCompose(unused -> inBusyLock(() -> {
+                        // At the time of creating the index, we should have already waited for the table to be created and its raft of
+                        // clients (services) to start for all partitions, so there should be no errors.
+                        RaftGroupService raftGroupService = table.internalTable().partitionRaftGroupService(partitionId);
+
+                        return raftGroupService
+                                // We do not check the presence of nodes in the topology on purpose, so as not to get into races on
+                                // rebalancing, it will be more convenient and reliable for us to wait for a stable topology with a
+                                // chosen leader.

Review Comment:
   Try fix it.



;10/Apr/23 14:42;githubbot;600","tkalkirill commented on code in PR #1892:
URL: https://github.com/apache/ignite-3/pull/1892#discussion_r1161785543


##########
modules/index/src/main/java/org/apache/ignite/internal/index/IndexBuilder.java:
##########
@@ -133,71 +176,77 @@ private BuildIndexTask(
 
         @Override
         public void run() {

Review Comment:
   It seems that there is not so much code, I tried to add one more method.



;10/Apr/23 14:48;githubbot;600","SammyVimes commented on code in PR #1892:
URL: https://github.com/apache/ignite-3/pull/1892#discussion_r1162018423


##########
modules/index/src/main/java/org/apache/ignite/internal/index/IndexBuilder.java:
##########
@@ -272,5 +325,50 @@ private List<RowId> collectRowIdBatch(RowId nextRowIdToBuild) {
 
             return createBatchRowIds(nextRowIdToBuild, BUILD_INDEX_ROW_ID_BATCH_SIZE);
         }
+
+        private boolean enterBusy() {
+            if (!taskBusyLock.enterBusy()) {

Review Comment:
   Should we use busy lock for cases like this? I thought we only use busy lock to stop the whole node



;10/Apr/23 19:31;githubbot;600","tkalkirill merged PR #1892:
URL: https://github.com/apache/ignite-3/pull/1892


;11/Apr/23 10:02;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,7200,,,0,7200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17766,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Apr 11 10:00:39 UTC 2023,,,,,,,,,,"0|z1h1l4:",9223372036854775807,,,sdanilov,,,,,,,,,,,,,,,,,,"11/Apr/23 10:00;sdanilov;The patch looks awesome to me!;;;",,,,,
"IgniteToStringBuilder#toString(java.lang.Class<T>, T) do not properly print inherited classes",IGNITE-19183,13531173,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,slava.koptilin,maliev,maliev,03/Apr/23 06:53,18/May/23 14:07,13/Jul/23 09:11,18/May/23 14:07,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"{*}Expected behaviour{*}:
{code:java}
class A {
   int f1;
}

class B extend A {
  int f2;
}
{code}
{{S.toString(B.class, this);}} will return ""B [f1 = x, f2 = y]""

{*}Actual behaviour{*}:
{{S.toString(B.class, this);}} returns ""B []""",,maliev,Sergey Uttsel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu May 18 13:53:15 UTC 2023,,,,,,,,,,"0|z1h1eo:",9223372036854775807,,,maliev,,,,,,,,,,,,,,,,,,"08/May/23 07:00;Sergey Uttsel;I see org.apache.ignite.internal.cluster.management.topology.api.LogicalNode#toString is marked with TODO IGNITE-19183
 
We have {{{}LogicalNode extends ClusterNode{}}}.

 
{code:java}
class ClusterNode {
    private final String id;
    private final String name;
    private final NetworkAddress address;
    private final NodeMetadata nodeMetadata;
    public String toString() {
        return S.toString(ClusterNode.class, this);
    }
}
class LogicalNode extends ClusterNode {
    private final Map<String, String> nodeAttributes;
    public String toString() {
        return S.toString(LogicalNode.class, this);
    }
}
{code}
toString on a LogicalNode instance prints:
{noformat}
LogicalNode []{noformat}
It's expected behavior.
 
If I change toString in LogicalNode to:
{code:java}
public String toString() {
    return S.toString(LogicalNode.class, this, super.toString());
}{code}
then toString prints: 
{noformat}
LogicalNode [super=ClusterNode [id=qqq, name=www, address=zzz:111, nodeMetadata=null]]{noformat}
It's expected behavior.
 
If I add annotation _@IgniteToStringInclude_ on
{noformat}
private final Map<String, String> nodeAttributes;{noformat}
then toString prints:
{noformat}
LogicalNode [nodeAttributes=EmptyMap {}, super=ClusterNode [id=qqq, name=www, address=zzz:111, nodeMetadata=null]]{noformat}
It's expected behavior because by default a Map implementation is excluded.
See IgniteToStringBuilder java doc. Ignite2 has the same rules.;;;","18/May/23 13:53;maliev;[~slava.koptilin] Approve, thank you! ;;;",,,,
Fix NPE on building indexes,IGNITE-19182,13531159,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ktkalenko@gridgain.com,ktkalenko@gridgain.com,03/Apr/23 04:44,11/Apr/23 12:13,13/Jul/23 09:11,03/Apr/23 08:38,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"After the implementation of index building, fluky tests appeared:
* *org.apache.ignite.internal.runner.app.ItDataSchemaSyncTest#checkSchemasCorrectUpdate*

Stack traces of errors:
{noformat}
java.util.concurrent.CompletionException: java.lang.NullPointerException: Cannot invoke ""java.util.List.isEmpty()"" because ""batch"" is null
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:315)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:320)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1159)
	at java.base/java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:482)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.NullPointerException: Cannot invoke ""java.util.List.isEmpty()"" because ""batch"" is null
	at org.apache.ignite.internal.index.IndexBuilder$BuildIndexTask.getNextRowIdForNextBatch(IndexBuilder.java:250)
	at org.apache.ignite.internal.index.IndexBuilder$BuildIndexTask.lambda$run$1(IndexBuilder.java:165)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1150)
	... 4 more
{noformat}",,ktkalenko@gridgain.com,,,,,"tkalkirill opened a new pull request, #1884:
URL: https://github.com/apache/ignite-3/pull/1884

   https://issues.apache.org/jira/browse/IGNITE-19182


;03/Apr/23 05:11;githubbot;600","tkalkirill merged PR #1884:
URL: https://github.com/apache/ignite-3/pull/1884


;03/Apr/23 08:38;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17766,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-04-03 04:44:58.0,,,,,,,,,,"0|z1h1bk:",9223372036854775807,,,apolovtcev,,,,,,,,,,,,,,,,,,,,,,,
ItClusterManagerTest#testNodeRestart start to fail after LogicalNode introducing,IGNITE-19179,13530978,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,apolovtcev,maliev,maliev,31/Mar/23 13:32,06/Apr/23 07:49,13/Jul/23 09:11,06/Apr/23 07:48,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"While https://issues.apache.org/jira/browse/IGNITE-18953 was implementing, {{ItClusterManagerTest#testNodeRestart}} started to fail periodically.

 
{noformat}
java.lang.AssertionError: 
Expected: is iterable with items [<ClusterNode [id=ac994fa6-d2d3-42e4-a247-fc437792b617, name=icmt_tnr_10000, address=127.0.0.1:10000, nodeMetadata=null]>, <ClusterNode [id=622f46cb-3f34-4aa7-8332-ce0aa90980e8, name=icmt_tnr_10001, address=127.0.0.1:10001, nodeMetadata=null]>] in any order
     but: was <[ClusterNode [id=ac994fa6-d2d3-42e4-a247-fc437792b617, name=icmt_tnr_10000, address=127.0.0.1:10000, nodeMetadata=null]]>
Expected :is iterable with items [<ClusterNode [id=ac994fa6-d2d3-42e4-a247-fc437792b617, name=icmt_tnr_10000, address=127.0.0.1:10000, nodeMetadata=null]>, <ClusterNode [id=622f46cb-3f34-4aa7-8332-ce0aa90980e8, name=icmt_tnr_10001, address=127.0.0.1:10001, nod ...Actual   :<[ClusterNode [id=ac994fa6-d2d3-42e4-a247-fc437792b617, name=icmt_tnr_10000, address=127.0.0.1:10000, nodeMetadata=null]]>
<Click to see difference>
    at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)
    at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:6)
    at org.apache.ignite.internal.cluster.management.ItClusterManagerTest.testNodeRestart(ItClusterManagerTest.java:174)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.base/java.lang.reflect.Method.invoke(Method.java:566)
    at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:727)
    at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
    at 
{noformat}
 

From the log with additional debug logging we can see, that after we call {{waitForLogicalTopology()}} we still write some new topology to {{{}LogicalTopologyImpl#storage{}}}, moreover we write topology that contains only learner node, or even empty topology, which is definitely wrong. Seems that there is some race and topology in {{waitForLogicalTopology()}} is not a final topology after restart, so after that assertion fails, because topology snapshot changes.",,maliev,,,,,"sashapolo opened a new pull request, #1899:
URL: https://github.com/apache/ignite-3/pull/1899

   https://issues.apache.org/jira/browse/IGNITE-19179


;04/Apr/23 14:54;githubbot;600","ibessonov commented on code in PR #1899:
URL: https://github.com/apache/ignite-3/pull/1899#discussion_r1159395296


##########
modules/cluster-management/src/main/java/org/apache/ignite/internal/cluster/management/topology/api/LogicalNode.java:
##########
@@ -79,10 +78,9 @@ public Map<String, String> nodeAttributes() {
         return nodeAttributes;
     }
 
-    /** {@inheritDoc} */
-    @Override
-    public String toString() {
-        // TODO: S.toString for inherited classes do not work properly https://issues.apache.org/jira/browse/IGNITE-19183
-        return S.toString(LogicalNode.class, this);
-    }
+    // TODO: S.toString for inherited classes do not work properly https://issues.apache.org/jira/browse/IGNITE-19183
+    //    @Override
+    //    public String toString() {
+    //        return S.toString(LogicalNode.class, this);
+    //    }

Review Comment:
   What was the reason for commenting this code? Maybe you forgot to uncomment it, I don't know



##########
modules/raft/src/main/java/org/apache/ignite/raft/jraft/rpc/ActionRequest.java:
##########
@@ -35,7 +34,6 @@ public interface ActionRequest extends Message {
     /**
      * @return Action's command.
      */
-    @Marshallable

Review Comment:
   Thank you very much! :+1: 



##########
modules/cluster-management/src/main/java/org/apache/ignite/internal/cluster/management/topology/LogicalTopologyImpl.java:
##########
@@ -96,6 +96,10 @@ public void putNode(LogicalNode nodeToPut) {
             // This is an update. First simulate disappearance, then appearance will be fired.
             snapshot = new LogicalTopologySnapshot(snapshot.version() + 1, mapByName.values());
 
+            if (LOG.isInfoEnabled()) {

Review Comment:
   I would like to comment the code above.
   ```
               if (oldNode.id().equals(nodeToPut.id())) {
                   // We already have this node, nothing needs to be changed.
                   return;
               }
   ```
   How is it possible?



;06/Apr/23 07:38;githubbot;600","sashapolo commented on code in PR #1899:
URL: https://github.com/apache/ignite-3/pull/1899#discussion_r1159403240


##########
modules/cluster-management/src/main/java/org/apache/ignite/internal/cluster/management/topology/LogicalTopologyImpl.java:
##########
@@ -96,6 +96,10 @@ public void putNode(LogicalNode nodeToPut) {
             // This is an update. First simulate disappearance, then appearance will be fired.
             snapshot = new LogicalTopologySnapshot(snapshot.version() + 1, mapByName.values());
 
+            if (LOG.isInfoEnabled()) {

Review Comment:
   It is possible because a node may try to re-join (e.g. after CMG leader change)



;06/Apr/23 07:41;githubbot;600","sashapolo commented on code in PR #1899:
URL: https://github.com/apache/ignite-3/pull/1899#discussion_r1159404624


##########
modules/cluster-management/src/main/java/org/apache/ignite/internal/cluster/management/topology/api/LogicalNode.java:
##########
@@ -79,10 +78,9 @@ public Map<String, String> nodeAttributes() {
         return nodeAttributes;
     }
 
-    /** {@inheritDoc} */
-    @Override
-    public String toString() {
-        // TODO: S.toString for inherited classes do not work properly https://issues.apache.org/jira/browse/IGNITE-19183
-        return S.toString(LogicalNode.class, this);
-    }
+    // TODO: S.toString for inherited classes do not work properly https://issues.apache.org/jira/browse/IGNITE-19183
+    //    @Override
+    //    public String toString() {
+    //        return S.toString(LogicalNode.class, this);
+    //    }

Review Comment:
   Please have a look at the ticket in the TODO above. Current implementation simply prints `LogicalNode {}` hiding all important information, so I'd like to use `toString` from `ClusterNode` instead.



;06/Apr/23 07:42;githubbot;600","sashapolo commented on code in PR #1899:
URL: https://github.com/apache/ignite-3/pull/1899#discussion_r1159406999


##########
modules/cluster-management/src/main/java/org/apache/ignite/internal/cluster/management/topology/LogicalTopologyImpl.java:
##########
@@ -96,6 +96,10 @@ public void putNode(LogicalNode nodeToPut) {
             // This is an update. First simulate disappearance, then appearance will be fired.
             snapshot = new LogicalTopologySnapshot(snapshot.version() + 1, mapByName.values());
 
+            if (LOG.isInfoEnabled()) {

Review Comment:
   This is to make this Raft command idempotent



;06/Apr/23 07:44;githubbot;600","ibessonov commented on code in PR #1899:
URL: https://github.com/apache/ignite-3/pull/1899#discussion_r1159409014


##########
modules/cluster-management/src/main/java/org/apache/ignite/internal/cluster/management/topology/api/LogicalNode.java:
##########
@@ -79,10 +78,9 @@ public Map<String, String> nodeAttributes() {
         return nodeAttributes;
     }
 
-    /** {@inheritDoc} */
-    @Override
-    public String toString() {
-        // TODO: S.toString for inherited classes do not work properly https://issues.apache.org/jira/browse/IGNITE-19183
-        return S.toString(LogicalNode.class, this);
-    }
+    // TODO: S.toString for inherited classes do not work properly https://issues.apache.org/jira/browse/IGNITE-19183
+    //    @Override
+    //    public String toString() {
+    //        return S.toString(LogicalNode.class, this);
+    //    }

Review Comment:
   This is so weird. In Ignite 2, we constantly used `, ""super"", super.toString()`, right? Why don't we do the same thing? That's a one line fix



;06/Apr/23 07:46;githubbot;600","ibessonov merged PR #1899:
URL: https://github.com/apache/ignite-3/pull/1899


;06/Apr/23 07:48;githubbot;600","sashapolo commented on code in PR #1899:
URL: https://github.com/apache/ignite-3/pull/1899#discussion_r1159412354


##########
modules/cluster-management/src/main/java/org/apache/ignite/internal/cluster/management/topology/api/LogicalNode.java:
##########
@@ -79,10 +78,9 @@ public Map<String, String> nodeAttributes() {
         return nodeAttributes;
     }
 
-    /** {@inheritDoc} */
-    @Override
-    public String toString() {
-        // TODO: S.toString for inherited classes do not work properly https://issues.apache.org/jira/browse/IGNITE-19183
-        return S.toString(LogicalNode.class, this);
-    }
+    // TODO: S.toString for inherited classes do not work properly https://issues.apache.org/jira/browse/IGNITE-19183
+    //    @Override
+    //    public String toString() {
+    //        return S.toString(LogicalNode.class, this);
+    //    }

Review Comment:
   I didn't know what we used in Ignite 2 =(



;06/Apr/23 07:49;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,4800,,,0,4800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-03-31 13:32:23.0,,,,,,,,,,"0|z1h07k:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
Sql. RW transaction skips rows without value.,IGNITE-19176,13530915,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,xtern,xtern,xtern,31/Mar/23 07:56,09/May/23 04:23,13/Jul/23 09:11,09/May/23 04:23,,,,,,,,,sql,,,0,ignite-3,,,"When we try to insert values into a single column  table using RW transaction, those values are not visible in the same transaction.

Example
{code:java}
create table test(id int primary key) // single column table
{code}
{code:java}
// case 1
start RW tx 
  insert into test values (0), (1)
  select count(*) from test // returns 0 instead of 2
finish tx{code}
{code:java}
// case 2
start RW tx
   insert into test values (0), (1)
commit tx

start RW tx
   select count(*) from test // returns 0 instead of 2
finish tx{code}

If we do this using RO transaction - all works fine.
If we add a column to the table, everything will work fine.

Reproducer
{code:java}
@Test
public void test() {
    sql(""CREATE TABLE myTbl (id INT PRIMARY KEY) WITH REPLICAS=2, PARTITIONS=10"");
    Ignite ignite = CLUSTER_NODES.get(0);
    ignite.transactions().runInTransaction(tx -> {
        sql(tx, ""INSERT INTO myTbl VALUES (0), (1)"");
        List<List<Object>> rows = sql(tx, ""SELECT count(*) from myTbl"");
        assertEquals(2L, rows.get(0).get(0));
    });
} {code}
 ",,agura,xtern,,,,"ygerzhedovich commented on code in PR #1933:
URL: https://github.com/apache/ignite-3/pull/1933#discussion_r1172178040


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItDmlTest.java:
##########
@@ -594,4 +605,89 @@ public void testInsertMultipleDefaultsWithImplicitPk() {
                 .returns(5, 2)
                 .check();
     }
+
+    @ParameterizedTest

Review Comment:
   I think the test should be in another place, for example together with antoher *View tests



;20/Apr/23 07:18;githubbot;600","ygerzhedovich commented on code in PR #1933:
URL: https://github.com/apache/ignite-3/pull/1933#discussion_r1172214569


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItDmlTest.java:
##########


Review Comment:
   Need to provide tests for all storages



;20/Apr/23 07:53;githubbot;600","ygerzhedovich commented on code in PR #1933:
URL: https://github.com/apache/ignite-3/pull/1933#discussion_r1173362088


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItSingleColumnTableCrossApiTest.java:
##########
@@ -0,0 +1,269 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.sql.engine;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.function.Consumer;
+import org.apache.ignite.lang.ErrorGroups.Sql;
+import org.apache.ignite.sql.SqlException;
+import org.apache.ignite.table.KeyValueView;
+import org.apache.ignite.table.RecordView;
+import org.apache.ignite.table.Table;
+import org.apache.ignite.table.Tuple;
+import org.apache.ignite.tx.IgniteTransactions;
+import org.apache.ignite.tx.Transaction;
+import org.apache.ignite.tx.TransactionOptions;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Checks basic operations on a single column table.
+ */
+public class ItSingleColumnTableCrossApiTest extends ClusterPerClassIntegrationTest {

Review Comment:
   I want to say that's about all columns belong to  PRIMARY KEY, single column just a special case



;21/Apr/23 06:39;githubbot;600","ygerzhedovich commented on code in PR #1933:
URL: https://github.com/apache/ignite-3/pull/1933#discussion_r1173364382


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItSingleColumnTableCrossApiTest.java:
##########
@@ -0,0 +1,269 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.sql.engine;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.function.Consumer;
+import org.apache.ignite.lang.ErrorGroups.Sql;
+import org.apache.ignite.sql.SqlException;
+import org.apache.ignite.table.KeyValueView;
+import org.apache.ignite.table.RecordView;
+import org.apache.ignite.table.Table;
+import org.apache.ignite.table.Tuple;
+import org.apache.ignite.tx.IgniteTransactions;
+import org.apache.ignite.tx.Transaction;
+import org.apache.ignite.tx.TransactionOptions;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Checks basic operations on a single column table.
+ */
+public class ItSingleColumnTableCrossApiTest extends ClusterPerClassIntegrationTest {
+    private static final String TABLE_NAME = ""test"";
+
+    private static final String[] ENGINES = {""aipersist"", ""aimem"", ""rocksdb""};
+
+    @Override
+    protected int nodes() {
+        return 1;
+    }
+
+    @AfterEach
+    @Override
+    public void tearDown(TestInfo testInfo) throws Exception {
+        for (String engine : ENGINES) {
+            sql(""delete from "" + tableName(engine));
+        }
+
+        tearDownBase(testInfo);
+    }
+
+    @BeforeAll
+    public void beforeAll() {
+        for (String engine : ENGINES) {
+            String testZoneName = (""test_zone_"" + engine).toUpperCase();
+
+            sql(String.format(""create zone %s engine %s with partitions=1, replicas=3;"", testZoneName, engine));
+            sql(String.format(""create table %s (ID int primary key) with primary_zone='%s'"", tableName(engine), testZoneName));

Review Comment:
   We can have tables with the same name for different zones???? Something is wrong...



;21/Apr/23 06:42;githubbot;600","xtern commented on code in PR #1933:
URL: https://github.com/apache/ignite-3/pull/1933#discussion_r1173394415


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItSingleColumnTableCrossApiTest.java:
##########
@@ -0,0 +1,269 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.sql.engine;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.function.Consumer;
+import org.apache.ignite.lang.ErrorGroups.Sql;
+import org.apache.ignite.sql.SqlException;
+import org.apache.ignite.table.KeyValueView;
+import org.apache.ignite.table.RecordView;
+import org.apache.ignite.table.Table;
+import org.apache.ignite.table.Tuple;
+import org.apache.ignite.tx.IgniteTransactions;
+import org.apache.ignite.tx.Transaction;
+import org.apache.ignite.tx.TransactionOptions;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Checks basic operations on a single column table.
+ */
+public class ItSingleColumnTableCrossApiTest extends ClusterPerClassIntegrationTest {

Review Comment:
   Should we cover multi-column PK with tests?



;21/Apr/23 07:16;githubbot;600","xtern merged PR #1933:
URL: https://github.com/apache/ignite-3/pull/1933


;09/May/23 04:20;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3600,,,0,3600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue May 09 04:23:20 UTC 2023,,,,,,,,,,"0|z1gztk:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"04/Apr/23 17:28;xtern;The problem seems to be related only to the SCAN inside the RW transaction.

In IGNITE-17859 a condition (resolvedReadResult.hasValue()) was added to PartitionReplicaListener#processScanRetrieveBatchAction
{code:java}
if (resolvedReadResult != null && resolvedReadResult.hasValue()) {
    batchRows.add(resolvedReadResult);
} {code}
If you remove it, then the above test passes.

 ;;;","28/Apr/23 09:40;xtern;[~agura],
could you take a look at the proposed patch?
Details about the changes are in the PR description.;;;","08/May/23 14:35;agura;[~xtern] The changes look good to me. But I can't understand why the behavior is different for explicit and implicit transactions. The code changes don't answer this question for me.;;;","08/May/23 15:12;xtern;[~agura], thanks!
Sorry, I changed the description, because it was not entirely correct.
Explicit meant an read-write transaction, and implicit read-only.;;;","09/May/23 04:23;xtern;Merged to the main branch ([commit|https://github.com/apache/ignite-3/commit/7abeb9beb251a36436905799d1785724b64fec15]).

[~jooger], [~amashenkov], thanks for the review.;;;",
ItClusterInitTest.testDoubleInit is flaky,IGNITE-19171,13530786,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,apolovtcev,apolovtcev,apolovtcev,30/Mar/23 11:23,31/Mar/23 08:32,13/Jul/23 09:11,31/Mar/23 08:32,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Example failure: https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_IntegrationTests_ModuleRunner/7122199

The problem is that {{IgnitionManager.init}} sends the Init message to all nodes that were passed to it. The first two calls to {{IgnitionManager.init}} in the test only send this message to one node, while the third call sends it to both nodes. So, there's a race between sending {{ClusterState}} message from the CMG leader to the second node (after the CMG group has been created as a result of the first init call) and the third explicit {{init}} call, which may result in a CMG Raft node being started with a different configuration.",,apolovtcev,,,,,"sashapolo opened a new pull request, #1870:
URL: https://github.com/apache/ignite-3/pull/1870

   * Also reduce the number of changePeersAsync calls in CMG manager.
   
   https://issues.apache.org/jira/browse/IGNITE-19171


;30/Mar/23 14:30;githubbot;600","ibessonov merged PR #1870:
URL: https://github.com/apache/ignite-3/pull/1870


;31/Mar/23 08:32;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-03-30 11:23:06.0,,,,,,,,,,"0|z1gz0w:",9223372036854775807,,,rpuch,,,,,,,,,,,,,,,,,,,,,,,
Deadlock detected while calling MvPartitionStorage#pollForVacuum,IGNITE-19169,13530777,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ktkalenko@gridgain.com,ktkalenko@gridgain.com,30/Mar/23 10:10,03/Apr/23 08:00,13/Jul/23 09:11,03/Apr/23 08:00,3.0.0-beta2,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"h2. *Update:*

For now, a possible deadlock fo *MvPartitionStorage#pollForVacuum* inside *MvPartitionStorage#runConsistently* is fine, because we need to maintain consistency when working with indexes.

It is enough for us to fix *StorageUpdateHandler#executeBatchGc* so that it runs outside the general *MvPartitionStorage#runConsistently* and each *StorageUpdateHandler#internalVacuum* is in its own *MvPartitionStorage#runConsistently*.

h2. *Problem:*

Deadlock detected while calling *org.apache.ignite.internal.storage.MvPartitionStorage#pollForVacuum*, reproducer:
{code:java}
@Test
public void testDeadLock() {
    RowId rowId2 = new RowId(PARTITION_ID);
    for (int i = 0; i < REPEATS; i++) {
        addWriteCommitted(ROW_ID, TABLE_ROW, clock.now());
        addWriteCommitted(rowId2, TABLE_ROW2, clock.now());
        addWriteCommitted(ROW_ID, TABLE_ROW, clock.now());
        addWriteCommitted(rowId2, TABLE_ROW2, clock.now());
        addWriteCommitted(ROW_ID, null, clock.now());
        addWriteCommitted(rowId2, null, clock.now());

        RunnableX remove2rowsAction = () -> {
            storage.runConsistently(() -> {
                storage.pollForVacuum(HybridTimestamp.MAX_VALUE);
                storage.pollForVacuum(HybridTimestamp.MAX_VALUE);
                return null;
            });
        };

        runRace(remove2rowsAction, remove2rowsAction);
        assertNull(storage.closestRowId(RowId.lowestRowId(PARTITION_ID)));
    }
}
{code}
",,ktkalenko@gridgain.com,,,,,"tkalkirill opened a new pull request, #1874:
URL: https://github.com/apache/ignite-3/pull/1874

   https://issues.apache.org/jira/browse/IGNITE-19169


;31/Mar/23 05:21;githubbot;600","ibessonov commented on code in PR #1874:
URL: https://github.com/apache/ignite-3/pull/1874#discussion_r1154112874


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/BaseMvStoragesTest.java:
##########
@@ -52,11 +52,15 @@
 import org.apache.ignite.lang.IgniteBiTuple;
 import org.apache.ignite.lang.IgniteException;
 import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.RepeatedTest;
 
 /**
  * Base test for MV storages, contains pojo classes, their descriptor and a marshaller instance.
  */
 public abstract class BaseMvStoragesTest {
+    /** To be used in a loop. {@link RepeatedTest} has a smaller failure rate due to recreating the storage every time. */
+    protected static final int REPEATS = 100;

Review Comment:
   What's the reason for moving this constant here? Are you sure that every subclass should use the same value?
   Maybe new class should have higher repeat value, because deadlock is harder to reproduce



##########
modules/table/src/test/java/org/apache/ignite/internal/table/distributed/AbstractMvStorageUpdateHandlerTest.java:
##########
@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.table.distributed;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.runRace;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertNull;
+
+import java.util.Map;
+import java.util.UUID;
+import org.apache.ignite.distributed.TestPartitionDataStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.configuration.testframework.InjectConfiguration;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZoneConfiguration;
+import org.apache.ignite.internal.hlc.HybridTimestamp;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.schema.configuration.TableConfiguration;
+import org.apache.ignite.internal.schema.configuration.TablesConfiguration;
+import org.apache.ignite.internal.storage.BaseMvStoragesTest;
+import org.apache.ignite.internal.storage.MvPartitionStorage;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.engine.MvTableStorage;
+import org.apache.ignite.internal.storage.engine.StorageEngine;
+import org.apache.ignite.internal.table.distributed.raft.PartitionDataStorage;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+/**
+ * Abstract class for testing {@link StorageUpdateHandler} using different implementations of {@link MvPartitionStorage}.
+ */
+@ExtendWith(ConfigurationExtension.class)
+abstract class AbstractMvStorageUpdateHandlerTest extends BaseMvStoragesTest {
+    private static final int PARTITION_ID = 0;
+
+    private StorageEngine storageEngine;
+
+    private TestPartitionDataStorage partitionDataStorage;
+
+    private StorageUpdateHandler storageUpdateHandler;
+
+    @BeforeEach
+    void setUp(
+            @InjectConfiguration(""mock.tables.foo{}"") TablesConfiguration tablesConfig,
+            @InjectConfiguration DistributionZoneConfiguration distributionZoneConfig
+    ) {
+        storageEngine = createStorageEngine();
+
+        storageEngine.start();
+
+        TableConfiguration tableConfig = tablesConfig.tables().get(""foo"");
+
+        assertThat(
+                tableConfig.dataStorage().change(dataStorageChange -> dataStorageChange.convert(storageEngine.name())),
+                willCompleteSuccessfully()
+        );
+
+        MvTableStorage mvTableStorage = storageEngine.createMvTable(tableConfig, tablesConfig, distributionZoneConfig);
+
+        mvTableStorage.start();
+
+        MvPartitionStorage mvPartitionStorage = getOrCreateMvPartition(mvTableStorage, PARTITION_ID);
+
+        partitionDataStorage = new TestPartitionDataStorage(mvPartitionStorage);
+
+        storageUpdateHandler = new StorageUpdateHandler(PARTITION_ID, partitionDataStorage, Map::of, tableConfig.dataStorage());
+    }
+
+    @AfterEach
+    void tearDown() {
+        if (storageEngine != null) {
+            storageEngine.stop();
+        }

Review Comment:
   You forgot to stop the table, and partition



##########
modules/table/src/test/java/org/apache/ignite/internal/table/distributed/AbstractMvStorageUpdateHandlerTest.java:
##########
@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.table.distributed;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.runRace;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertNull;
+
+import java.util.Map;
+import java.util.UUID;
+import org.apache.ignite.distributed.TestPartitionDataStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.configuration.testframework.InjectConfiguration;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZoneConfiguration;
+import org.apache.ignite.internal.hlc.HybridTimestamp;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.schema.configuration.TableConfiguration;
+import org.apache.ignite.internal.schema.configuration.TablesConfiguration;
+import org.apache.ignite.internal.storage.BaseMvStoragesTest;
+import org.apache.ignite.internal.storage.MvPartitionStorage;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.engine.MvTableStorage;
+import org.apache.ignite.internal.storage.engine.StorageEngine;
+import org.apache.ignite.internal.table.distributed.raft.PartitionDataStorage;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+/**
+ * Abstract class for testing {@link StorageUpdateHandler} using different implementations of {@link MvPartitionStorage}.
+ */
+@ExtendWith(ConfigurationExtension.class)
+abstract class AbstractMvStorageUpdateHandlerTest extends BaseMvStoragesTest {
+    private static final int PARTITION_ID = 0;
+
+    private StorageEngine storageEngine;
+
+    private TestPartitionDataStorage partitionDataStorage;
+
+    private StorageUpdateHandler storageUpdateHandler;
+
+    @BeforeEach
+    void setUp(
+            @InjectConfiguration(""mock.tables.foo{}"") TablesConfiguration tablesConfig,
+            @InjectConfiguration DistributionZoneConfiguration distributionZoneConfig
+    ) {
+        storageEngine = createStorageEngine();
+
+        storageEngine.start();
+
+        TableConfiguration tableConfig = tablesConfig.tables().get(""foo"");
+
+        assertThat(
+                tableConfig.dataStorage().change(dataStorageChange -> dataStorageChange.convert(storageEngine.name())),
+                willCompleteSuccessfully()
+        );
+
+        MvTableStorage mvTableStorage = storageEngine.createMvTable(tableConfig, tablesConfig, distributionZoneConfig);
+
+        mvTableStorage.start();
+
+        MvPartitionStorage mvPartitionStorage = getOrCreateMvPartition(mvTableStorage, PARTITION_ID);
+
+        partitionDataStorage = new TestPartitionDataStorage(mvPartitionStorage);
+
+        storageUpdateHandler = new StorageUpdateHandler(PARTITION_ID, partitionDataStorage, Map::of, tableConfig.dataStorage());
+    }
+
+    @AfterEach
+    void tearDown() {
+        if (storageEngine != null) {
+            storageEngine.stop();
+        }
+    }
+
+    protected abstract StorageEngine createStorageEngine();
+
+    @Test
+    void testConcurrentVacuumBatch() {
+        RowId rowId0 = new RowId(PARTITION_ID);
+        RowId rowId1 = new RowId(PARTITION_ID);
+
+        BinaryRow row0 = binaryRow(new TestKey(0, ""key0""), new TestValue(0, ""value0""));
+        BinaryRow row1 = binaryRow(new TestKey(0, ""key0""), new TestValue(0, ""value0""));
+
+        for (int i = 0; i < REPEATS; i++) {
+            addWriteCommitted(partitionDataStorage, rowId0, row0, clock.now());
+            addWriteCommitted(partitionDataStorage, rowId1, row1, clock.now());
+
+            addWriteCommitted(partitionDataStorage, rowId0, row0, clock.now());
+            addWriteCommitted(partitionDataStorage, rowId1, row1, clock.now());
+
+            addWriteCommitted(partitionDataStorage, rowId0, row0, clock.now());
+            addWriteCommitted(partitionDataStorage, rowId1, row1, clock.now());
+
+            addWriteCommitted(partitionDataStorage, rowId0, row0, clock.now());
+            addWriteCommitted(partitionDataStorage, rowId1, row1, clock.now());
+
+            addWriteCommitted(partitionDataStorage, rowId0, row0, clock.now());
+            addWriteCommitted(partitionDataStorage, rowId1, row1, clock.now());
+
+            addWriteCommitted(partitionDataStorage, rowId0, null, clock.now());
+            addWriteCommitted(partitionDataStorage, rowId1, null, clock.now());
+
+            runRace(
+                    () -> storageUpdateHandler.vacuumBatch(HybridTimestamp.MAX_VALUE, 2),
+                    () -> storageUpdateHandler.vacuumBatch(HybridTimestamp.MAX_VALUE, 2),
+                    () -> storageUpdateHandler.vacuumBatch(HybridTimestamp.MAX_VALUE, 2),
+                    () -> storageUpdateHandler.vacuumBatch(HybridTimestamp.MAX_VALUE, 2),
+                    () -> storageUpdateHandler.vacuumBatch(HybridTimestamp.MAX_VALUE, 2)

Review Comment:
   Having 5 threads is unrealistic, we only have two in real system



;31/Mar/23 07:32;githubbot;600","tkalkirill commented on code in PR #1874:
URL: https://github.com/apache/ignite-3/pull/1874#discussion_r1154201592


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/BaseMvStoragesTest.java:
##########
@@ -52,11 +52,15 @@
 import org.apache.ignite.lang.IgniteBiTuple;
 import org.apache.ignite.lang.IgniteException;
 import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.RepeatedTest;
 
 /**
  * Base test for MV storages, contains pojo classes, their descriptor and a marshaller instance.
  */
 public abstract class BaseMvStoragesTest {
+    /** To be used in a loop. {@link RepeatedTest} has a smaller failure rate due to recreating the storage every time. */
+    protected static final int REPEATS = 100;

Review Comment:
   Fix it



##########
modules/table/src/test/java/org/apache/ignite/internal/table/distributed/AbstractMvStorageUpdateHandlerTest.java:
##########
@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.table.distributed;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.runRace;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertNull;
+
+import java.util.Map;
+import java.util.UUID;
+import org.apache.ignite.distributed.TestPartitionDataStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.configuration.testframework.InjectConfiguration;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZoneConfiguration;
+import org.apache.ignite.internal.hlc.HybridTimestamp;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.schema.configuration.TableConfiguration;
+import org.apache.ignite.internal.schema.configuration.TablesConfiguration;
+import org.apache.ignite.internal.storage.BaseMvStoragesTest;
+import org.apache.ignite.internal.storage.MvPartitionStorage;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.engine.MvTableStorage;
+import org.apache.ignite.internal.storage.engine.StorageEngine;
+import org.apache.ignite.internal.table.distributed.raft.PartitionDataStorage;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+/**
+ * Abstract class for testing {@link StorageUpdateHandler} using different implementations of {@link MvPartitionStorage}.
+ */
+@ExtendWith(ConfigurationExtension.class)
+abstract class AbstractMvStorageUpdateHandlerTest extends BaseMvStoragesTest {
+    private static final int PARTITION_ID = 0;
+
+    private StorageEngine storageEngine;
+
+    private TestPartitionDataStorage partitionDataStorage;
+
+    private StorageUpdateHandler storageUpdateHandler;
+
+    @BeforeEach
+    void setUp(
+            @InjectConfiguration(""mock.tables.foo{}"") TablesConfiguration tablesConfig,
+            @InjectConfiguration DistributionZoneConfiguration distributionZoneConfig
+    ) {
+        storageEngine = createStorageEngine();
+
+        storageEngine.start();
+
+        TableConfiguration tableConfig = tablesConfig.tables().get(""foo"");
+
+        assertThat(
+                tableConfig.dataStorage().change(dataStorageChange -> dataStorageChange.convert(storageEngine.name())),
+                willCompleteSuccessfully()
+        );
+
+        MvTableStorage mvTableStorage = storageEngine.createMvTable(tableConfig, tablesConfig, distributionZoneConfig);
+
+        mvTableStorage.start();
+
+        MvPartitionStorage mvPartitionStorage = getOrCreateMvPartition(mvTableStorage, PARTITION_ID);
+
+        partitionDataStorage = new TestPartitionDataStorage(mvPartitionStorage);
+
+        storageUpdateHandler = new StorageUpdateHandler(PARTITION_ID, partitionDataStorage, Map::of, tableConfig.dataStorage());
+    }
+
+    @AfterEach
+    void tearDown() {
+        if (storageEngine != null) {
+            storageEngine.stop();
+        }

Review Comment:
   Fix it



;31/Mar/23 08:44;githubbot;600","tkalkirill commented on code in PR #1874:
URL: https://github.com/apache/ignite-3/pull/1874#discussion_r1154201781


##########
modules/table/src/test/java/org/apache/ignite/internal/table/distributed/AbstractMvStorageUpdateHandlerTest.java:
##########
@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.table.distributed;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.runRace;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertNull;
+
+import java.util.Map;
+import java.util.UUID;
+import org.apache.ignite.distributed.TestPartitionDataStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.configuration.testframework.InjectConfiguration;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZoneConfiguration;
+import org.apache.ignite.internal.hlc.HybridTimestamp;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.schema.configuration.TableConfiguration;
+import org.apache.ignite.internal.schema.configuration.TablesConfiguration;
+import org.apache.ignite.internal.storage.BaseMvStoragesTest;
+import org.apache.ignite.internal.storage.MvPartitionStorage;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.engine.MvTableStorage;
+import org.apache.ignite.internal.storage.engine.StorageEngine;
+import org.apache.ignite.internal.table.distributed.raft.PartitionDataStorage;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+/**
+ * Abstract class for testing {@link StorageUpdateHandler} using different implementations of {@link MvPartitionStorage}.
+ */
+@ExtendWith(ConfigurationExtension.class)
+abstract class AbstractMvStorageUpdateHandlerTest extends BaseMvStoragesTest {
+    private static final int PARTITION_ID = 0;
+
+    private StorageEngine storageEngine;
+
+    private TestPartitionDataStorage partitionDataStorage;
+
+    private StorageUpdateHandler storageUpdateHandler;
+
+    @BeforeEach
+    void setUp(
+            @InjectConfiguration(""mock.tables.foo{}"") TablesConfiguration tablesConfig,
+            @InjectConfiguration DistributionZoneConfiguration distributionZoneConfig
+    ) {
+        storageEngine = createStorageEngine();
+
+        storageEngine.start();
+
+        TableConfiguration tableConfig = tablesConfig.tables().get(""foo"");
+
+        assertThat(
+                tableConfig.dataStorage().change(dataStorageChange -> dataStorageChange.convert(storageEngine.name())),
+                willCompleteSuccessfully()
+        );
+
+        MvTableStorage mvTableStorage = storageEngine.createMvTable(tableConfig, tablesConfig, distributionZoneConfig);
+
+        mvTableStorage.start();
+
+        MvPartitionStorage mvPartitionStorage = getOrCreateMvPartition(mvTableStorage, PARTITION_ID);
+
+        partitionDataStorage = new TestPartitionDataStorage(mvPartitionStorage);
+
+        storageUpdateHandler = new StorageUpdateHandler(PARTITION_ID, partitionDataStorage, Map::of, tableConfig.dataStorage());
+    }
+
+    @AfterEach
+    void tearDown() {
+        if (storageEngine != null) {
+            storageEngine.stop();
+        }
+    }
+
+    protected abstract StorageEngine createStorageEngine();
+
+    @Test
+    void testConcurrentVacuumBatch() {
+        RowId rowId0 = new RowId(PARTITION_ID);
+        RowId rowId1 = new RowId(PARTITION_ID);
+
+        BinaryRow row0 = binaryRow(new TestKey(0, ""key0""), new TestValue(0, ""value0""));
+        BinaryRow row1 = binaryRow(new TestKey(0, ""key0""), new TestValue(0, ""value0""));
+
+        for (int i = 0; i < REPEATS; i++) {
+            addWriteCommitted(partitionDataStorage, rowId0, row0, clock.now());
+            addWriteCommitted(partitionDataStorage, rowId1, row1, clock.now());
+
+            addWriteCommitted(partitionDataStorage, rowId0, row0, clock.now());
+            addWriteCommitted(partitionDataStorage, rowId1, row1, clock.now());
+
+            addWriteCommitted(partitionDataStorage, rowId0, row0, clock.now());
+            addWriteCommitted(partitionDataStorage, rowId1, row1, clock.now());
+
+            addWriteCommitted(partitionDataStorage, rowId0, row0, clock.now());
+            addWriteCommitted(partitionDataStorage, rowId1, row1, clock.now());
+
+            addWriteCommitted(partitionDataStorage, rowId0, row0, clock.now());
+            addWriteCommitted(partitionDataStorage, rowId1, row1, clock.now());
+
+            addWriteCommitted(partitionDataStorage, rowId0, null, clock.now());
+            addWriteCommitted(partitionDataStorage, rowId1, null, clock.now());
+
+            runRace(
+                    () -> storageUpdateHandler.vacuumBatch(HybridTimestamp.MAX_VALUE, 2),
+                    () -> storageUpdateHandler.vacuumBatch(HybridTimestamp.MAX_VALUE, 2),
+                    () -> storageUpdateHandler.vacuumBatch(HybridTimestamp.MAX_VALUE, 2),
+                    () -> storageUpdateHandler.vacuumBatch(HybridTimestamp.MAX_VALUE, 2),
+                    () -> storageUpdateHandler.vacuumBatch(HybridTimestamp.MAX_VALUE, 2)

Review Comment:
   Fix it



;31/Mar/23 08:44;githubbot;600","tkalkirill merged PR #1874:
URL: https://github.com/apache/ignite-3/pull/1874


;03/Apr/23 08:00;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17571,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,2023-03-30 10:10:19.0,,,,,,,,,,"0|z1gyyw:",9223372036854775807,,,sdanilov,,,,,,,,,,,,,,,,,,,,,,,
Named list support in local file configuration is broken. ,IGNITE-19152,13530567,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,aleksandr.pakhomov,maliev,maliev,29/Mar/23 08:01,26/Apr/23 16:05,13/Jul/23 09:11,26/Apr/23 16:05,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"After IGNITE-18581 we have started to store local configuration in local config file, instead of vault.

The current flow with the saving configuration to a file has a bug. In the method {{LocalFileConfigurationStorage#write}} we call {{LocalFileConfigurationStorage#saveValues}} to save configuration fields to a file, where we call {{{}LocalFileConfigurationStorage#renderHoconString{}}}. Named list value has internal id which is {{{}UUID{}}}, but {{com.typesafe}} do not support {{{}UUID{}}}, so the whole process of saving configuration to a file fails with
{noformat}
Caused by: com.typesafe.config.ConfigException$BugOrBroken: bug in method caller: not valid to create ConfigValue from: 489e16e8-3123-44a3-b27d-6e410863eb24
	at app//com.typesafe.config.impl.ConfigImpl.fromAnyRef(ConfigImpl.java:282)
	at app//com.typesafe.config.impl.PropertiesParser.fromPathMap(PropertiesParser.java:165)
	at app//com.typesafe.config.impl.PropertiesParser.fromPathMap(PropertiesParser.java:95)
	at app//com.typesafe.config.impl.ConfigImpl.fromAnyRef(ConfigImpl.java:265)
	at app//com.typesafe.config.impl.ConfigImpl.fromPathMap(ConfigImpl.java:201)
	at app//com.typesafe.config.ConfigFactory.parseMap(ConfigFactory.java:1225)
	at app//com.typesafe.config.ConfigFactory.parseMap(ConfigFactory.java:1236)
	at app//org.apache.ignite.internal.configuration.storage.LocalFileConfigurationStorage.renderHoconString(LocalFileConfigurationStorage.java:208)
	at app//org.apache.ignite.internal.configuration.storage.LocalFileConfigurationStorage.saveValues(LocalFileConfigurationStorage.java:185)
	at app//org.apache.ignite.internal.configuration.storage.LocalFileConfigurationStorage.write(LocalFileConfigurationStorage.java:138)
	at app//org.apache.ignite.internal.configuration.ConfigurationChanger.changeInternally0(ConfigurationChanger.java:606)
	at app//org.apache.ignite.internal.configuration.ConfigurationChanger.lambda$changeInternally$1(ConfigurationChanger.java:541)
{noformat}
h3. More details

The problem is trickier than it may seem.

Configuration storages receive data in ""flat"" data format, meaning that the entire tree is converted into a list of pairs:
{code:java}
[{ ""dot-separated key string"", ""serializable value"" }]{code}
LocalFileConfigurationStorage interprets keys as literal paths in HOCON representation, which is simply not correct. These keys and values also have meta-information, associated with them, such as:
 * order of elements in named list configuration
 * internal ids for named list elements

To see, what's exactly in there, you may refer to the {{{}org.apache.ignite.internal.configuration.tree.NamedListNodeTest{}}}. It has everything laid out explicitly.
h3. Proposed fix

Well, the ideal approach would be rendering the configuration more or less the same way, as we do it for REST.

It means calling {{ConfigurationUtil#fillFromPrefixMap}} for every local root.

Local roots can be retrieved using {{{}ConfigurationModule{}}}, by reading them all from the class path.

Resulting nodes are converted to maps using {{{}ConverterToMapVisitor{}}}. Then maps are converted to HOCON using its own API.

There are several hidden problems here.
 * {-}we must check, that HOCON preserves order of keys{-}, and that we use linked hash maps in {{fillFromPrefixMap}}
EDIT: HOCON sorts keys alphabetically. Ok
 * {{ConverterToMapVisitor}} does not expect null nodes, because it always works with ""full"" trees. Fixing it would require some fine-tuning, otherwise one may end up with a bunch of empty nodes in the config file, which is bad
 * {{ConverterToMapVisitor}} uses array syntax for named lists. You can see it in action in {{{}HoconConverterTest{}}}.
Yes, there are two ways of representing named lists in the system. We should make rendering mode configurable, because local configuration, at the moment, only needs basic tree representation (for node attributes)

We should also add tests for most of these improvements. First of all, to {{{}HoconConverterTest{}}}.
h3. Misc

Another extremely uncertain thing is the way we handle default values. This may be a topic for another issue, or maybe not.

For example, if user explicitly configure network port to 47500, we will fail to save it into the file, because it matches default and we ignore everything that has default value. We *need* tests for this.",,aleksandr.pakhomov,maliev,,,,"PakhomovAlexander opened a new pull request, #1929:
URL: https://github.com/apache/ignite-3/pull/1929

   https://issues.apache.org/jira/browse/IGNITE-19152


;11/Apr/23 14:07;githubbot;600","Pochatkin commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1165933231


##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -40,114 +53,187 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
-import java.util.stream.Collectors;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import org.apache.ignite.configuration.RootKey;
 import org.apache.ignite.configuration.annotation.ConfigurationType;
 import org.apache.ignite.internal.configuration.NodeConfigCreateException;
 import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.RootInnerNode;
+import org.apache.ignite.internal.configuration.SuperRoot;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
+import org.apache.ignite.internal.configuration.hocon.HoconConverter;
+import org.apache.ignite.internal.configuration.tree.ConverterToMapVisitor;
+import org.apache.ignite.internal.configuration.tree.InnerNode;
 import org.apache.ignite.internal.future.InFlightFutures;
 import org.apache.ignite.internal.logger.IgniteLogger;
 import org.apache.ignite.internal.logger.Loggers;
 import org.apache.ignite.internal.thread.NamedThreadFactory;
 import org.apache.ignite.internal.util.IgniteUtils;
+import org.jetbrains.annotations.NotNull;

Review Comment:
   Please don't use NotNull annotation



##########
modules/configuration/src/main/java/org/apache/ignite/internal/configuration/hocon/HoconConverter.java:
##########
@@ -47,6 +53,26 @@ public static ConfigValue represent(
         return ConfigImpl.fromAnyRef(res, null);
     }
 
+    /**

Review Comment:
   TBD



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -234,4 +339,26 @@ private void checkAndRestoreConfigFile() {
             }
         }
     }
+
+    private <T> CompletableFuture<T> readLockAsync(Supplier<T> supplier) {
+        lock.readLock().lock();
+        try {
+            CompletableFuture<T> future = CompletableFuture.supplyAsync(supplier, workerThreadPool);
+            futureTracker.registerFuture(future);
+            return future;
+        } finally {
+            lock.readLock().unlock();
+        }
+    }
+
+    private <T> CompletableFuture<T> writeLockAsync(Supplier<T> supplier) {
+        lock.writeLock().lock();
+        try {
+            CompletableFuture<T> future = CompletableFuture.supplyAsync(supplier, workerThreadPool);
+            futureTracker.registerFuture(future);
+            return future;
+        } finally {
+            lock.writeLock().unlock();
+        }
+    }

Review Comment:
   As I see all RW operations which you made in supplier has no locking.  So, I think this is not your fault and was previously. I think it would be better to move locking to suppliers implementation 



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -40,114 +53,187 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
-import java.util.stream.Collectors;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import org.apache.ignite.configuration.RootKey;
 import org.apache.ignite.configuration.annotation.ConfigurationType;
 import org.apache.ignite.internal.configuration.NodeConfigCreateException;
 import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.RootInnerNode;
+import org.apache.ignite.internal.configuration.SuperRoot;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
+import org.apache.ignite.internal.configuration.hocon.HoconConverter;
+import org.apache.ignite.internal.configuration.tree.ConverterToMapVisitor;
+import org.apache.ignite.internal.configuration.tree.InnerNode;
 import org.apache.ignite.internal.future.InFlightFutures;
 import org.apache.ignite.internal.logger.IgniteLogger;
 import org.apache.ignite.internal.logger.Loggers;
 import org.apache.ignite.internal.thread.NamedThreadFactory;
 import org.apache.ignite.internal.util.IgniteUtils;
+import org.jetbrains.annotations.NotNull;
 
 /**
  * Implementation of {@link ConfigurationStorage} based on local file configuration storage.
  */
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration nodes generator. */
+    private final ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();
+
+    /** Map of root keys that are needed to generate configuration tree. */
+    private final Map<String, RootKey<?, ?>> rootKeys;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService threadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""loc-cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );

Review Comment:
   What the reason to have two thread pools?



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -234,4 +339,26 @@ private void checkAndRestoreConfigFile() {
             }
         }
     }
+
+    private <T> CompletableFuture<T> readLockAsync(Supplier<T> supplier) {
+        lock.readLock().lock();
+        try {
+            CompletableFuture<T> future = CompletableFuture.supplyAsync(supplier, workerThreadPool);
+            futureTracker.registerFuture(future);
+            return future;
+        } finally {
+            lock.readLock().unlock();
+        }
+    }
+
+    private <T> CompletableFuture<T> writeLockAsync(Supplier<T> supplier) {
+        lock.writeLock().lock();
+        try {
+            CompletableFuture<T> future = CompletableFuture.supplyAsync(supplier, workerThreadPool);
+            futureTracker.registerFuture(future);
+            return future;
+        } finally {
+            lock.writeLock().unlock();
+        }
+    }

Review Comment:
   As I see all RW operations which you made in supplier has no locking.  So, I think this is not your fault and was previously. I think it would be better to move locking to suppliers implementation 



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -40,114 +53,187 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
-import java.util.stream.Collectors;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import org.apache.ignite.configuration.RootKey;
 import org.apache.ignite.configuration.annotation.ConfigurationType;
 import org.apache.ignite.internal.configuration.NodeConfigCreateException;
 import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.RootInnerNode;
+import org.apache.ignite.internal.configuration.SuperRoot;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
+import org.apache.ignite.internal.configuration.hocon.HoconConverter;
+import org.apache.ignite.internal.configuration.tree.ConverterToMapVisitor;
+import org.apache.ignite.internal.configuration.tree.InnerNode;
 import org.apache.ignite.internal.future.InFlightFutures;
 import org.apache.ignite.internal.logger.IgniteLogger;
 import org.apache.ignite.internal.logger.Loggers;
 import org.apache.ignite.internal.thread.NamedThreadFactory;
 import org.apache.ignite.internal.util.IgniteUtils;
+import org.jetbrains.annotations.NotNull;
 
 /**
  * Implementation of {@link ConfigurationStorage} based on local file configuration storage.
  */
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration nodes generator. */
+    private final ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();
+
+    /** Map of root keys that are needed to generate configuration tree. */
+    private final Map<String, RootKey<?, ?>> rootKeys;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService threadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""loc-cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
+    /**
+     * Constructor without configuration extensions.
+     *
+     * @param configPath Path to node bootstrap configuration file.
+     * @param rootKeys Configuration root keys.
+     */
+    public LocalFileConfigurationStorage(Path configPath, Collection<RootKey<?, ?>> rootKeys) {
+        this(configPath, rootKeys, Collections.emptyList(), Collections.emptyList());
+    }
+
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param rootKeys Configuration root keys.
+     * @param internalSchemaExtensions Internal schema extensions.
+     * @param polymorphicSchemaExtensions Polymorphic schema extensions.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, Collection<RootKey<?, ?>> rootKeys,
+            Collection<Class<?>> internalSchemaExtensions, Collection<Class<?>> polymorphicSchemaExtensions) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.rootKeys = rootKeys.stream().collect(toMap(RootKey::key, identity()));
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
+        Map<Class<?>, Set<Class<?>>> internalExtensions = internalSchemaExtensions(internalSchemaExtensions);
+        Map<Class<?>, Set<Class<?>>> polymorphicExtensions = polymorphicSchemaExtensions(polymorphicSchemaExtensions);
+
+        rootKeys.forEach(key -> cgen.compileRootSchema(key.schemaClass(), internalExtensions, polymorphicExtensions));
+
         checkAndRestoreConfigFile();
     }
 
+    private static void setValues(SuperRoot target, Config source) {
+        HoconConverter.hoconSource(source.root()).descend(target);
+    }

Review Comment:
   I think this method may be inlined



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -40,114 +53,187 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
-import java.util.stream.Collectors;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import org.apache.ignite.configuration.RootKey;
 import org.apache.ignite.configuration.annotation.ConfigurationType;
 import org.apache.ignite.internal.configuration.NodeConfigCreateException;
 import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.RootInnerNode;
+import org.apache.ignite.internal.configuration.SuperRoot;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
+import org.apache.ignite.internal.configuration.hocon.HoconConverter;
+import org.apache.ignite.internal.configuration.tree.ConverterToMapVisitor;
+import org.apache.ignite.internal.configuration.tree.InnerNode;
 import org.apache.ignite.internal.future.InFlightFutures;
 import org.apache.ignite.internal.logger.IgniteLogger;
 import org.apache.ignite.internal.logger.Loggers;
 import org.apache.ignite.internal.thread.NamedThreadFactory;
 import org.apache.ignite.internal.util.IgniteUtils;
+import org.jetbrains.annotations.NotNull;
 
 /**
  * Implementation of {@link ConfigurationStorage} based on local file configuration storage.
  */
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration nodes generator. */
+    private final ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();
+
+    /** Map of root keys that are needed to generate configuration tree. */
+    private final Map<String, RootKey<?, ?>> rootKeys;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService threadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""loc-cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
+    /**
+     * Constructor without configuration extensions.
+     *
+     * @param configPath Path to node bootstrap configuration file.
+     * @param rootKeys Configuration root keys.
+     */
+    public LocalFileConfigurationStorage(Path configPath, Collection<RootKey<?, ?>> rootKeys) {
+        this(configPath, rootKeys, Collections.emptyList(), Collections.emptyList());
+    }
+
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param rootKeys Configuration root keys.
+     * @param internalSchemaExtensions Internal schema extensions.
+     * @param polymorphicSchemaExtensions Polymorphic schema extensions.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, Collection<RootKey<?, ?>> rootKeys,
+            Collection<Class<?>> internalSchemaExtensions, Collection<Class<?>> polymorphicSchemaExtensions) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.rootKeys = rootKeys.stream().collect(toMap(RootKey::key, identity()));
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
+        Map<Class<?>, Set<Class<?>>> internalExtensions = internalSchemaExtensions(internalSchemaExtensions);
+        Map<Class<?>, Set<Class<?>>> polymorphicExtensions = polymorphicSchemaExtensions(polymorphicSchemaExtensions);
+
+        rootKeys.forEach(key -> cgen.compileRootSchema(key.schemaClass(), internalExtensions, polymorphicExtensions));
+
         checkAndRestoreConfigFile();
     }

Review Comment:
   I think that you can introduce RootKeysProvider abstraction and encapsulate all logic about root keys. This constructor should have only provider here as parameter



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -175,47 +261,66 @@ public CompletableFuture<Void> writeConfigurationRevision(long prevRevision, lon
 
     @Override
     public void close() {
+        IgniteUtils.shutdownAndAwaitTermination(workerThreadPool, 10, TimeUnit.SECONDS);
         IgniteUtils.shutdownAndAwaitTermination(threadPool, 10, TimeUnit.SECONDS);
 
         futureTracker.cancelInFlightFutures();
     }
 
-    private void saveValues(Map<String, ? extends Serializable> values) {
+    private void saveConfigFile() {
         try {
-            Files.write(tempConfigPath, renderHoconString(values).getBytes(StandardCharsets.UTF_8),
-                    StandardOpenOption.SYNC, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
-            Files.move(tempConfigPath, configPath, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);
+            Files.write(
+                    tempConfigPath,
+                    renderHoconString().getBytes(StandardCharsets.UTF_8),
+                    StandardOpenOption.SYNC, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING
+            );
+
+            Files.move(
+                    tempConfigPath,
+                    configPath,
+                    StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING
+            );
         } catch (IOException e) {
             throw new NodeConfigWriteException(
-                    ""Failed to write values "" + values + "" to config file."", e);
+                    ""Failed to write values to config file."", e);
         }
     }
 
     /**
      * Convert provided map to Hocon String representation.
      *
-     * @param values Values of configuration.
      * @return Configuration file string representation in HOCON format.
      */
-    private String renderHoconString(Map<String, ? extends Serializable> values) {
-        Map<String, Object> map = values.entrySet().stream().collect(Collectors.toMap(Entry::getKey, stringEntry -> {
-            Serializable value = stringEntry.getValue();
-            if (value.getClass().isArray()) {
-                return Arrays.asList((Object[]) value);
-            }
-            return value;
-        }));
-        Config other = ConfigFactory.parseMap(map);
-        Config newConfig = other.withFallback(parseConfigOptions()).resolve();
+    private String renderHoconString() {
+        // Super root that'll be filled from the storage data.
+        SuperRoot rootNode = new SuperRoot(rootCreator());
+
+        fillFromPrefixMap(rootNode, toPrefixMap(latest));
+
+        addDefaults(rootNode);
+
+        ConfigValue conf = ConfigImpl.fromAnyRef(HoconConverter.represent(rootNode, new ConverterToMapVisitor(false)), null);
+
+        Config newConfig = ((ConfigObject) conf).toConfig().resolve();
         return newConfig.isEmpty()
                 ? """"
                 : newConfig.root().render(ConfigRenderOptions.concise().setFormatted(true).setJson(false));
     }
 
+    private Function<String, RootInnerNode> rootCreator() {
+        return key -> {
+            RootKey<?, ?> rootKey = rootKeys.get(key);
+
+            return rootKey == null ? null : new RootInnerNode(rootKey, createRootNode(rootKey));
+        };
+    }
+
+    private InnerNode createRootNode(RootKey<?, ?> rootKey) {
+        return cgen.instantiateNode(rootKey.schemaClass());
+    }

Review Comment:
   As I understood correct this is copypasted code from ConfigurationRegistry. May you extract it to separate abstraction layer and avoid code duplicate?



;13/Apr/23 19:40;githubbot;600","ibessonov commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1166420335


##########
modules/configuration/src/main/java/org/apache/ignite/internal/configuration/hocon/HoconConverter.java:
##########
@@ -47,6 +53,26 @@ public static ConfigValue represent(
         return ConfigImpl.fromAnyRef(res, null);
     }
 
+    /**
+     * TBD.
+     */
+    public static <T> T represent(SuperRoot superRoot, ConfigurationVisitor<T> visitor) throws IllegalArgumentException {
+        Object node;
+        try {
+            node = ConfigurationUtil.find(List.of(), superRoot, false);

Review Comment:
   Finding by an empty path gets you predictable result. It's the parameter that you have passed.
   This entire method could be simplified to `return superRoot.accept(null, visitor);`.
   I propose removing it and calling `accept` directly where you need it.



##########
modules/configuration/src/test/java/org/apache/ignite/internal/configuration/hocon/HoconConverterTest.java:
##########
@@ -352,7 +352,7 @@ public void testHoconArraysSerialization() throws Exception {
     private static String asHoconStr(List<String> basePath, String... path) {
         List<String> fullPath = Stream.concat(basePath.stream(), Arrays.stream(path)).collect(Collectors.toList());
 
-        ConfigValue hoconCfg = HoconConverter.represent(registry, fullPath);
+        ConfigValue hoconCfg = HoconConverter.represent(registry.superRoot(), fullPath);

Review Comment:
   I propose calling the old method with ""registry"" parameter, and remove the getter for ""superRoot"". It's an internal object and it should remain internal



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -40,114 +53,187 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
-import java.util.stream.Collectors;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import org.apache.ignite.configuration.RootKey;
 import org.apache.ignite.configuration.annotation.ConfigurationType;
 import org.apache.ignite.internal.configuration.NodeConfigCreateException;
 import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.RootInnerNode;
+import org.apache.ignite.internal.configuration.SuperRoot;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
+import org.apache.ignite.internal.configuration.hocon.HoconConverter;
+import org.apache.ignite.internal.configuration.tree.ConverterToMapVisitor;
+import org.apache.ignite.internal.configuration.tree.InnerNode;
 import org.apache.ignite.internal.future.InFlightFutures;
 import org.apache.ignite.internal.logger.IgniteLogger;
 import org.apache.ignite.internal.logger.Loggers;
 import org.apache.ignite.internal.thread.NamedThreadFactory;
 import org.apache.ignite.internal.util.IgniteUtils;
+import org.jetbrains.annotations.NotNull;
 
 /**
  * Implementation of {@link ConfigurationStorage} based on local file configuration storage.
  */
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration nodes generator. */
+    private final ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();

Review Comment:
   This is interesting. It would be nice to use the same object that we have in `ConfigurationRegistry`. Can we drill that hole?



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -40,114 +53,187 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
-import java.util.stream.Collectors;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import org.apache.ignite.configuration.RootKey;
 import org.apache.ignite.configuration.annotation.ConfigurationType;
 import org.apache.ignite.internal.configuration.NodeConfigCreateException;
 import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.RootInnerNode;
+import org.apache.ignite.internal.configuration.SuperRoot;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
+import org.apache.ignite.internal.configuration.hocon.HoconConverter;
+import org.apache.ignite.internal.configuration.tree.ConverterToMapVisitor;
+import org.apache.ignite.internal.configuration.tree.InnerNode;
 import org.apache.ignite.internal.future.InFlightFutures;
 import org.apache.ignite.internal.logger.IgniteLogger;
 import org.apache.ignite.internal.logger.Loggers;
 import org.apache.ignite.internal.thread.NamedThreadFactory;
 import org.apache.ignite.internal.util.IgniteUtils;
+import org.jetbrains.annotations.NotNull;
 
 /**
  * Implementation of {@link ConfigurationStorage} based on local file configuration storage.
  */
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration nodes generator. */
+    private final ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();
+
+    /** Map of root keys that are needed to generate configuration tree. */
+    private final Map<String, RootKey<?, ?>> rootKeys;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService threadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""loc-cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
+    /**
+     * Constructor without configuration extensions.
+     *
+     * @param configPath Path to node bootstrap configuration file.
+     * @param rootKeys Configuration root keys.
+     */
+    public LocalFileConfigurationStorage(Path configPath, Collection<RootKey<?, ?>> rootKeys) {
+        this(configPath, rootKeys, Collections.emptyList(), Collections.emptyList());
+    }
+
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param rootKeys Configuration root keys.
+     * @param internalSchemaExtensions Internal schema extensions.
+     * @param polymorphicSchemaExtensions Polymorphic schema extensions.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, Collection<RootKey<?, ?>> rootKeys,
+            Collection<Class<?>> internalSchemaExtensions, Collection<Class<?>> polymorphicSchemaExtensions) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.rootKeys = rootKeys.stream().collect(toMap(RootKey::key, identity()));
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
+        Map<Class<?>, Set<Class<?>>> internalExtensions = internalSchemaExtensions(internalSchemaExtensions);
+        Map<Class<?>, Set<Class<?>>> polymorphicExtensions = polymorphicSchemaExtensions(polymorphicSchemaExtensions);
+
+        rootKeys.forEach(key -> cgen.compileRootSchema(key.schemaClass(), internalExtensions, polymorphicExtensions));
+
         checkAndRestoreConfigFile();
     }
 
+    private static void setValues(SuperRoot target, Config source) {
+        HoconConverter.hoconSource(source.root()).descend(target);
+    }
+
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return writeLockAsync(() -> {
+            SuperRoot superRoot = createSuperRoot();
+            SuperRoot copiedSuperRoot = superRoot.copy();
+
+            Config hocon = readHoconFromFile();
+            setValues(copiedSuperRoot, hocon);
+
+            addDefaults(copiedSuperRoot);

Review Comment:
   Right now I would avoid doing this



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -40,114 +53,187 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
-import java.util.stream.Collectors;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import org.apache.ignite.configuration.RootKey;
 import org.apache.ignite.configuration.annotation.ConfigurationType;
 import org.apache.ignite.internal.configuration.NodeConfigCreateException;
 import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.RootInnerNode;
+import org.apache.ignite.internal.configuration.SuperRoot;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
+import org.apache.ignite.internal.configuration.hocon.HoconConverter;
+import org.apache.ignite.internal.configuration.tree.ConverterToMapVisitor;
+import org.apache.ignite.internal.configuration.tree.InnerNode;
 import org.apache.ignite.internal.future.InFlightFutures;
 import org.apache.ignite.internal.logger.IgniteLogger;
 import org.apache.ignite.internal.logger.Loggers;
 import org.apache.ignite.internal.thread.NamedThreadFactory;
 import org.apache.ignite.internal.util.IgniteUtils;
+import org.jetbrains.annotations.NotNull;
 
 /**
  * Implementation of {@link ConfigurationStorage} based on local file configuration storage.
  */
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration nodes generator. */
+    private final ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();
+
+    /** Map of root keys that are needed to generate configuration tree. */
+    private final Map<String, RootKey<?, ?>> rootKeys;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService threadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""loc-cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
+    /**
+     * Constructor without configuration extensions.
+     *
+     * @param configPath Path to node bootstrap configuration file.
+     * @param rootKeys Configuration root keys.
+     */
+    public LocalFileConfigurationStorage(Path configPath, Collection<RootKey<?, ?>> rootKeys) {
+        this(configPath, rootKeys, Collections.emptyList(), Collections.emptyList());
+    }
+
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param rootKeys Configuration root keys.
+     * @param internalSchemaExtensions Internal schema extensions.
+     * @param polymorphicSchemaExtensions Polymorphic schema extensions.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, Collection<RootKey<?, ?>> rootKeys,
+            Collection<Class<?>> internalSchemaExtensions, Collection<Class<?>> polymorphicSchemaExtensions) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.rootKeys = rootKeys.stream().collect(toMap(RootKey::key, identity()));
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
+        Map<Class<?>, Set<Class<?>>> internalExtensions = internalSchemaExtensions(internalSchemaExtensions);
+        Map<Class<?>, Set<Class<?>>> polymorphicExtensions = polymorphicSchemaExtensions(polymorphicSchemaExtensions);
+
+        rootKeys.forEach(key -> cgen.compileRootSchema(key.schemaClass(), internalExtensions, polymorphicExtensions));
+
         checkAndRestoreConfigFile();
     }
 
+    private static void setValues(SuperRoot target, Config source) {
+        HoconConverter.hoconSource(source.root()).descend(target);
+    }
+
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return writeLockAsync(() -> {
+            SuperRoot superRoot = createSuperRoot();
+            SuperRoot copiedSuperRoot = superRoot.copy();
+
+            Config hocon = readHoconFromFile();
+            setValues(copiedSuperRoot, hocon);
+
+            addDefaults(copiedSuperRoot);
+
+            Map<String, Serializable> flattenedUpdatesMap = createFlattenedUpdatesMap(superRoot, copiedSuperRoot);
+
+            latest.putAll(flattenedUpdatesMap);
+
+            return new Data(flattenedUpdatesMap, lastRevision);
+        });
+    }
+

Review Comment:
   Too many empty lines



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -175,47 +261,66 @@ public CompletableFuture<Void> writeConfigurationRevision(long prevRevision, lon
 
     @Override
     public void close() {
+        IgniteUtils.shutdownAndAwaitTermination(workerThreadPool, 10, TimeUnit.SECONDS);
         IgniteUtils.shutdownAndAwaitTermination(threadPool, 10, TimeUnit.SECONDS);
 
         futureTracker.cancelInFlightFutures();
     }
 
-    private void saveValues(Map<String, ? extends Serializable> values) {
+    private void saveConfigFile() {
         try {
-            Files.write(tempConfigPath, renderHoconString(values).getBytes(StandardCharsets.UTF_8),
-                    StandardOpenOption.SYNC, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
-            Files.move(tempConfigPath, configPath, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);
+            Files.write(
+                    tempConfigPath,
+                    renderHoconString().getBytes(StandardCharsets.UTF_8),
+                    StandardOpenOption.SYNC, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING
+            );
+
+            Files.move(
+                    tempConfigPath,
+                    configPath,
+                    StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING
+            );
         } catch (IOException e) {
             throw new NodeConfigWriteException(
-                    ""Failed to write values "" + values + "" to config file."", e);
+                    ""Failed to write values to config file."", e);
         }
     }
 
     /**
      * Convert provided map to Hocon String representation.
      *
-     * @param values Values of configuration.
      * @return Configuration file string representation in HOCON format.
      */
-    private String renderHoconString(Map<String, ? extends Serializable> values) {
-        Map<String, Object> map = values.entrySet().stream().collect(Collectors.toMap(Entry::getKey, stringEntry -> {
-            Serializable value = stringEntry.getValue();
-            if (value.getClass().isArray()) {
-                return Arrays.asList((Object[]) value);
-            }
-            return value;
-        }));
-        Config other = ConfigFactory.parseMap(map);
-        Config newConfig = other.withFallback(parseConfigOptions()).resolve();
+    private String renderHoconString() {
+        // Super root that'll be filled from the storage data.
+        SuperRoot rootNode = new SuperRoot(rootCreator());
+
+        fillFromPrefixMap(rootNode, toPrefixMap(latest));
+
+        addDefaults(rootNode);

Review Comment:
   Why did you add defaults here? I guess it's a copied code, right? And you didn't tests whether you write default values or not.



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -175,47 +261,66 @@ public CompletableFuture<Void> writeConfigurationRevision(long prevRevision, lon
 
     @Override
     public void close() {
+        IgniteUtils.shutdownAndAwaitTermination(workerThreadPool, 10, TimeUnit.SECONDS);
         IgniteUtils.shutdownAndAwaitTermination(threadPool, 10, TimeUnit.SECONDS);
 
         futureTracker.cancelInFlightFutures();
     }
 
-    private void saveValues(Map<String, ? extends Serializable> values) {
+    private void saveConfigFile() {
         try {
-            Files.write(tempConfigPath, renderHoconString(values).getBytes(StandardCharsets.UTF_8),
-                    StandardOpenOption.SYNC, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
-            Files.move(tempConfigPath, configPath, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);
+            Files.write(
+                    tempConfigPath,
+                    renderHoconString().getBytes(StandardCharsets.UTF_8),
+                    StandardOpenOption.SYNC, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING
+            );
+
+            Files.move(
+                    tempConfigPath,
+                    configPath,
+                    StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING
+            );
         } catch (IOException e) {
             throw new NodeConfigWriteException(
-                    ""Failed to write values "" + values + "" to config file."", e);
+                    ""Failed to write values to config file."", e);
         }
     }
 
     /**
      * Convert provided map to Hocon String representation.
      *
-     * @param values Values of configuration.
      * @return Configuration file string representation in HOCON format.
      */
-    private String renderHoconString(Map<String, ? extends Serializable> values) {
-        Map<String, Object> map = values.entrySet().stream().collect(Collectors.toMap(Entry::getKey, stringEntry -> {
-            Serializable value = stringEntry.getValue();
-            if (value.getClass().isArray()) {
-                return Arrays.asList((Object[]) value);
-            }
-            return value;
-        }));
-        Config other = ConfigFactory.parseMap(map);
-        Config newConfig = other.withFallback(parseConfigOptions()).resolve();
+    private String renderHoconString() {
+        // Super root that'll be filled from the storage data.
+        SuperRoot rootNode = new SuperRoot(rootCreator());
+
+        fillFromPrefixMap(rootNode, toPrefixMap(latest));
+
+        addDefaults(rootNode);
+
+        ConfigValue conf = ConfigImpl.fromAnyRef(HoconConverter.represent(rootNode, new ConverterToMapVisitor(false)), null);
+
+        Config newConfig = ((ConfigObject) conf).toConfig().resolve();
         return newConfig.isEmpty()
                 ? """"
                 : newConfig.root().render(ConfigRenderOptions.concise().setFormatted(true).setJson(false));
     }
 
+    private Function<String, RootInnerNode> rootCreator() {
+        return key -> {
+            RootKey<?, ?> rootKey = rootKeys.get(key);
+
+            return rootKey == null ? null : new RootInnerNode(rootKey, createRootNode(rootKey));
+        };
+    }
+
+    private InnerNode createRootNode(RootKey<?, ?> rootKey) {
+        return cgen.instantiateNode(rootKey.schemaClass());
+    }
+
     private Config parseConfigOptions() {
-        return ConfigFactory.parseFile(
-                configPath.toFile(),
-                ConfigParseOptions.defaults().setAllowMissing(false));
+        return readHoconFromFile();

Review Comment:
   Please inline this method



##########
modules/runner/src/test/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorageTest.java:
##########
@@ -17,75 +17,401 @@
 
 package org.apache.ignite.internal.configuration.storage;
 
-import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willBe;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.aMapWithSize;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.emptyString;
+import static org.hamcrest.Matchers.equalToCompressingWhiteSpace;
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.hasValue;
 import static org.hamcrest.Matchers.is;
 
 import java.io.IOException;
+import java.io.Serializable;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import org.apache.ignite.configuration.annotation.Config;
+import org.apache.ignite.configuration.annotation.ConfigurationRoot;
+import org.apache.ignite.configuration.annotation.NamedConfigValue;
+import org.apache.ignite.configuration.annotation.Value;
+import org.apache.ignite.internal.configuration.TestConfigurationChanger;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
 import org.apache.ignite.internal.testframework.WorkDirectory;
 import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
-import org.junit.jupiter.api.Disabled;
+import org.hamcrest.Matchers;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
 
-/**
- * Tests for the {@link LocalFileConfigurationStorage}.
- */
+/** Test for local file configurations storage. */
 @ExtendWith(WorkDirectoryExtension.class)
-@Disabled(""https://issues.apache.org/jira/browse/IGNITE-19152"")
-public class LocalFileConfigurationStorageTest extends ConfigurationStorageTest {
+public class LocalFileConfigurationStorageTest {
 
     private static final String CONFIG_NAME = ""ignite-config.conf"";
 
+    private static ConfigurationAsmGenerator cgen;
+
     @WorkDirectory
     private Path tmpDir;
 
-    @Override
-    public ConfigurationStorage getStorage() {
-        return new LocalFileConfigurationStorage(getConfigFile());
+    /** Test configuration storage. */
+    private LocalFileConfigurationStorage storage;
+
+    /** Test configuration changer. */
+    private TestConfigurationChanger changer;
+
+    /** Instantiates {@link #cgen}. */
+    @BeforeAll
+    public static void beforeAll() {
+        cgen = new ConfigurationAsmGenerator();
+    }
+
+    /** Nullifies {@link #cgen} to prevent memory leak from having runtime ClassLoader accessible from GC root. */
+    @AfterAll
+    public static void afterAll() {
+        cgen = null;
+    }
+
+    private Path getConfigFile() {
+        return tmpDir.resolve(CONFIG_NAME);
+    }
+
+    @BeforeEach
+    void before() {
+        storage = new LocalFileConfigurationStorage(getConfigFile(), List.of(TopConfiguration.KEY));
+
+        changer = new TestConfigurationChanger(
+                cgen,
+                List.of(TopConfiguration.KEY),
+                Set.of(),
+                storage,
+                List.of(),
+                List.of()
+        );
+
+        changer.start();
+    }
+
+    @AfterEach
+    void after() {
+        changer.stop();
     }
 
     @Test
-    void testHocon() throws IOException {
-        // All of this is needed because write expects serializable values and only concrete classes are serializable
-        HashMap<String, ArrayList<String>> map = new HashMap<>(Map.of(""list"", new ArrayList<>(List.of(""val1"", ""val2""))));
-        var data = Map.of(""foo1"", ""bar1"", ""foo2"", ""bar2"", ""map"", map);
-
-        assertThat(storage.write(data, 0), willBe(true));
-
-        String contents = Files.readString(getConfigFile());
-
-        // \n instead of System.lineSeparator because Config library writes \n only
-        assertThat(contents, is(""foo1=bar1\n""
-                + ""foo2=bar2\n""
-                + ""map {\n""
-                + ""    list=[\n""
-                + ""        val1,\n""
-                + ""        val2\n""
-                + ""    ]\n""
-                + ""}\n""));
+    @DisplayName(""Default values are not added enriched on read when the config file is empty"")
+    void empty() throws IOException {
+        // Given
+        assertThat(configFileContent(), emptyString());
+
+        // When
+        var storageValues = readAllLatest();
+
+        // Then storage data only contains top level defaults
+        assertThat(storageValues.entrySet(), hasSize(1));

Review Comment:
   Can be replaced with `assertThat(storageValues, is(aMapWithSize(1)))`, it would look better.
   By the way, what's a `top level defaults`? Configuration is empty, and we shouldn't store defaults in current implementation (I guess).
   Also, why don't you explicitly assert the content of the map in this test? It's easy to do



##########
modules/runner/src/test/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorageTest.java:
##########
@@ -17,75 +17,401 @@
 
 package org.apache.ignite.internal.configuration.storage;
 
-import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willBe;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.aMapWithSize;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.emptyString;
+import static org.hamcrest.Matchers.equalToCompressingWhiteSpace;
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.hasValue;
 import static org.hamcrest.Matchers.is;
 
 import java.io.IOException;
+import java.io.Serializable;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import org.apache.ignite.configuration.annotation.Config;
+import org.apache.ignite.configuration.annotation.ConfigurationRoot;
+import org.apache.ignite.configuration.annotation.NamedConfigValue;
+import org.apache.ignite.configuration.annotation.Value;
+import org.apache.ignite.internal.configuration.TestConfigurationChanger;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
 import org.apache.ignite.internal.testframework.WorkDirectory;
 import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
-import org.junit.jupiter.api.Disabled;
+import org.hamcrest.Matchers;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
 
-/**
- * Tests for the {@link LocalFileConfigurationStorage}.
- */
+/** Test for local file configurations storage. */
 @ExtendWith(WorkDirectoryExtension.class)
-@Disabled(""https://issues.apache.org/jira/browse/IGNITE-19152"")
-public class LocalFileConfigurationStorageTest extends ConfigurationStorageTest {
+public class LocalFileConfigurationStorageTest {
 
     private static final String CONFIG_NAME = ""ignite-config.conf"";
 
+    private static ConfigurationAsmGenerator cgen;
+
     @WorkDirectory
     private Path tmpDir;
 
-    @Override
-    public ConfigurationStorage getStorage() {
-        return new LocalFileConfigurationStorage(getConfigFile());
+    /** Test configuration storage. */
+    private LocalFileConfigurationStorage storage;
+
+    /** Test configuration changer. */
+    private TestConfigurationChanger changer;
+
+    /** Instantiates {@link #cgen}. */
+    @BeforeAll
+    public static void beforeAll() {
+        cgen = new ConfigurationAsmGenerator();
+    }
+
+    /** Nullifies {@link #cgen} to prevent memory leak from having runtime ClassLoader accessible from GC root. */
+    @AfterAll
+    public static void afterAll() {
+        cgen = null;
+    }
+
+    private Path getConfigFile() {
+        return tmpDir.resolve(CONFIG_NAME);
+    }
+
+    @BeforeEach
+    void before() {
+        storage = new LocalFileConfigurationStorage(getConfigFile(), List.of(TopConfiguration.KEY));
+
+        changer = new TestConfigurationChanger(
+                cgen,
+                List.of(TopConfiguration.KEY),
+                Set.of(),
+                storage,
+                List.of(),
+                List.of()
+        );
+
+        changer.start();
+    }
+
+    @AfterEach
+    void after() {
+        changer.stop();
     }
 
     @Test
-    void testHocon() throws IOException {
-        // All of this is needed because write expects serializable values and only concrete classes are serializable
-        HashMap<String, ArrayList<String>> map = new HashMap<>(Map.of(""list"", new ArrayList<>(List.of(""val1"", ""val2""))));
-        var data = Map.of(""foo1"", ""bar1"", ""foo2"", ""bar2"", ""map"", map);
-
-        assertThat(storage.write(data, 0), willBe(true));
-
-        String contents = Files.readString(getConfigFile());
-
-        // \n instead of System.lineSeparator because Config library writes \n only
-        assertThat(contents, is(""foo1=bar1\n""
-                + ""foo2=bar2\n""
-                + ""map {\n""
-                + ""    list=[\n""
-                + ""        val1,\n""
-                + ""        val2\n""
-                + ""    ]\n""
-                + ""}\n""));
+    @DisplayName(""Default values are not added enriched on read when the config file is empty"")

Review Comment:
   ""not added enriched"" - not added or not enriched?
   Why is it a display name, is that convenient? You better give the method a proper name and move this description into a javadoc, because that's how most of our tests are written



##########
modules/runner/src/test/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorageTest.java:
##########
@@ -17,75 +17,401 @@
 
 package org.apache.ignite.internal.configuration.storage;
 
-import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willBe;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.aMapWithSize;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.emptyString;
+import static org.hamcrest.Matchers.equalToCompressingWhiteSpace;
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.hasValue;
 import static org.hamcrest.Matchers.is;
 
 import java.io.IOException;
+import java.io.Serializable;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import org.apache.ignite.configuration.annotation.Config;
+import org.apache.ignite.configuration.annotation.ConfigurationRoot;
+import org.apache.ignite.configuration.annotation.NamedConfigValue;
+import org.apache.ignite.configuration.annotation.Value;
+import org.apache.ignite.internal.configuration.TestConfigurationChanger;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
 import org.apache.ignite.internal.testframework.WorkDirectory;
 import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
-import org.junit.jupiter.api.Disabled;
+import org.hamcrest.Matchers;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
 
-/**
- * Tests for the {@link LocalFileConfigurationStorage}.
- */
+/** Test for local file configurations storage. */
 @ExtendWith(WorkDirectoryExtension.class)
-@Disabled(""https://issues.apache.org/jira/browse/IGNITE-19152"")
-public class LocalFileConfigurationStorageTest extends ConfigurationStorageTest {
+public class LocalFileConfigurationStorageTest {
 
     private static final String CONFIG_NAME = ""ignite-config.conf"";
 
+    private static ConfigurationAsmGenerator cgen;
+
     @WorkDirectory
     private Path tmpDir;
 
-    @Override
-    public ConfigurationStorage getStorage() {
-        return new LocalFileConfigurationStorage(getConfigFile());
+    /** Test configuration storage. */
+    private LocalFileConfigurationStorage storage;
+
+    /** Test configuration changer. */
+    private TestConfigurationChanger changer;
+
+    /** Instantiates {@link #cgen}. */
+    @BeforeAll
+    public static void beforeAll() {
+        cgen = new ConfigurationAsmGenerator();
+    }
+
+    /** Nullifies {@link #cgen} to prevent memory leak from having runtime ClassLoader accessible from GC root. */
+    @AfterAll
+    public static void afterAll() {
+        cgen = null;
+    }
+
+    private Path getConfigFile() {
+        return tmpDir.resolve(CONFIG_NAME);
+    }
+
+    @BeforeEach
+    void before() {
+        storage = new LocalFileConfigurationStorage(getConfigFile(), List.of(TopConfiguration.KEY));
+
+        changer = new TestConfigurationChanger(
+                cgen,
+                List.of(TopConfiguration.KEY),
+                Set.of(),
+                storage,
+                List.of(),
+                List.of()
+        );
+
+        changer.start();
+    }
+
+    @AfterEach
+    void after() {
+        changer.stop();
     }
 
     @Test
-    void testHocon() throws IOException {
-        // All of this is needed because write expects serializable values and only concrete classes are serializable
-        HashMap<String, ArrayList<String>> map = new HashMap<>(Map.of(""list"", new ArrayList<>(List.of(""val1"", ""val2""))));
-        var data = Map.of(""foo1"", ""bar1"", ""foo2"", ""bar2"", ""map"", map);
-
-        assertThat(storage.write(data, 0), willBe(true));
-
-        String contents = Files.readString(getConfigFile());
-
-        // \n instead of System.lineSeparator because Config library writes \n only
-        assertThat(contents, is(""foo1=bar1\n""
-                + ""foo2=bar2\n""
-                + ""map {\n""
-                + ""    list=[\n""
-                + ""        val1,\n""
-                + ""        val2\n""
-                + ""    ]\n""
-                + ""}\n""));
+    @DisplayName(""Default values are not added enriched on read when the config file is empty"")
+    void empty() throws IOException {
+        // Given
+        assertThat(configFileContent(), emptyString());
+
+        // When
+        var storageValues = readAllLatest();
+
+        // Then storage data only contains top level defaults
+        assertThat(storageValues.entrySet(), hasSize(1));
     }
 
     @Test
-    void testMergeHocon() throws IOException {
-        var data = Map.of(""foo1"", ""bar"");
-        assertThat(storage.write(data, 0), willBe(true));
+    @DisplayName(""Named list entities can be added"")
+    void add() throws Exception {
+        // Given
+        assertThat(configFileContent(), emptyString());
+        // And
+        var topConfiguration = (TopConfiguration) cgen.instantiateCfg(TopConfiguration.KEY, changer);
+        topConfiguration.namedList().change(b -> b.create(""name1"", x -> {
+            x.changeStrVal(""strVal1"");
+            x.changeIntVal(-1);
+        })).get();
+
+        // When
+        var storageValues = readAllLatest();
 
-        var append = Map.of(""foo1"", ""baz"", ""foo2"", ""bar"");
-        assertThat(storage.write(append, 1), willBe(true));
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(-1)));
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(""strVal1"")));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=1\n""
+                        + ""}""
+        ));
 
-        String contents = Files.readString(getConfigFile());
-        assertThat(contents, is(""foo1=baz\n""
-                + ""foo2=bar\n""));
+        // When
+        topConfiguration.namedList().change(b -> b.create(""name2"", x -> {
+            x.changeStrVal(""strVal2"");
+            x.changeIntVal(-2);
+        })).get();
+        // And
+        storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(11), hasValue(-2)));
+        assertThat(storageValues, allOf(aMapWithSize(11), hasValue(""strVal2"")));
+        // And
+        assertThat(storageValues, allOf(aMapWithSize(11), hasValue(-1)));
+        assertThat(storageValues, allOf(aMapWithSize(11), hasValue(""strVal1"")));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        },\n""
+                        + ""        {\n""
+                        + ""            intVal=-2\n""
+                        + ""            name=name2\n""
+                        + ""            strVal=strVal2\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=1\n""
+                        + ""}\n""
+        ));
     }
 
-    private Path getConfigFile() {
-        return tmpDir.resolve(CONFIG_NAME);
+    @DisplayName(""Update values"")
+    @Test
+    void update() throws Exception {
+        // Given
+        assertThat(configFileContent(), emptyString());
+
+        // When
+        var topConfiguration = (TopConfiguration) cgen.instantiateCfg(TopConfiguration.KEY, changer);
+        topConfiguration.shortVal().update((short) 3).get();
+        // And
+        var storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(1), hasValue((short) 3)));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[]\n""
+                        + ""    shortVal=3\n""
+                        + ""}\n""
+        ));
+
+        // When create named list entity with defaults
+        topConfiguration.namedList().change(b -> b.create(""name1"", x -> {
+        })).get();
+        // And
+        storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(1)));
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(""foo"")));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=foo\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=3\n""
+                        + ""}""
+        ));
+
+        // When update named list entity
+        topConfiguration.namedList().change(b -> b.update(""name1"", x -> {
+            x.changeStrVal(""strVal1"");
+            x.changeIntVal(-1);
+        })).get();
+        // And
+        storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(-1)));
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(""strVal1"")));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=3\n""
+                        + ""}""
+        ));
+    }
+
+    @DisplayName(""Remove values"")
+    @Test
+    void remove() throws Exception {
+        // Given
+        var topConfiguration = (TopConfiguration) cgen.instantiateCfg(TopConfiguration.KEY, changer);
+        topConfiguration.namedList().change(b -> {
+            b.create(""name1"", x -> {
+                x.changeStrVal(""strVal1"");
+                x.changeIntVal(-1);
+            });
+            b.create(""name2"", x -> {
+                x.changeStrVal(""strVal2"");
+                x.changeIntVal(-2);
+            });
+        }).get();
+        topConfiguration.shortVal().update((short) 3).get();
+        // And values are saved to file
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        },\n""
+                        + ""        {\n""
+                        + ""            intVal=-2\n""
+                        + ""            name=name2\n""
+                        + ""            strVal=strVal2\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=3\n""
+                        + ""}\n""
+        ));
+
+        // When remove named list entity
+        topConfiguration.namedList().change(b -> b.delete(""name1"")).get();
+        // And
+        var storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(6), Matchers.not(hasValue(""strVal1""))));
+        // And entity removed from file
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-2\n""
+                        + ""            name=name2\n""
+                        + ""            strVal=strVal2\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=3\n""
+                        + ""}\n""
+        ));
+
+        // When remove the last entity
+        topConfiguration.namedList().change(b -> b.delete(""name2"")).get();
+        // And
+        storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(1), hasValue((short) 3)));
+        // And entity removed from file
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[]\n""
+                        + ""    shortVal=3\n""
+                        + ""}\n""
+        ));
+    }
+
+    @DisplayName(""Delete file before read on recovery"")
+    @Test
+    void deleteFileBeforeReadOnRecovery() throws IOException {
+        // Given
+        Files.delete(getConfigFile());
+
+        // When
+        var storageValues = storage.readDataOnRecovery().join().values();
+
+        // Then storage data only contains top level defaults
+        assertThat(storageValues.entrySet(), hasSize(1));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[]\n""

Review Comment:
   Can we avoid rendering empty lists?



##########
modules/runner/src/test/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorageTest.java:
##########
@@ -17,75 +17,401 @@
 
 package org.apache.ignite.internal.configuration.storage;
 
-import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willBe;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.aMapWithSize;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.emptyString;
+import static org.hamcrest.Matchers.equalToCompressingWhiteSpace;
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.hasValue;
 import static org.hamcrest.Matchers.is;
 
 import java.io.IOException;
+import java.io.Serializable;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import org.apache.ignite.configuration.annotation.Config;
+import org.apache.ignite.configuration.annotation.ConfigurationRoot;
+import org.apache.ignite.configuration.annotation.NamedConfigValue;
+import org.apache.ignite.configuration.annotation.Value;
+import org.apache.ignite.internal.configuration.TestConfigurationChanger;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
 import org.apache.ignite.internal.testframework.WorkDirectory;
 import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
-import org.junit.jupiter.api.Disabled;
+import org.hamcrest.Matchers;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
 
-/**
- * Tests for the {@link LocalFileConfigurationStorage}.
- */
+/** Test for local file configurations storage. */
 @ExtendWith(WorkDirectoryExtension.class)
-@Disabled(""https://issues.apache.org/jira/browse/IGNITE-19152"")
-public class LocalFileConfigurationStorageTest extends ConfigurationStorageTest {
+public class LocalFileConfigurationStorageTest {
 
     private static final String CONFIG_NAME = ""ignite-config.conf"";
 
+    private static ConfigurationAsmGenerator cgen;
+
     @WorkDirectory
     private Path tmpDir;
 
-    @Override
-    public ConfigurationStorage getStorage() {
-        return new LocalFileConfigurationStorage(getConfigFile());
+    /** Test configuration storage. */
+    private LocalFileConfigurationStorage storage;
+
+    /** Test configuration changer. */
+    private TestConfigurationChanger changer;
+
+    /** Instantiates {@link #cgen}. */
+    @BeforeAll
+    public static void beforeAll() {
+        cgen = new ConfigurationAsmGenerator();
+    }
+
+    /** Nullifies {@link #cgen} to prevent memory leak from having runtime ClassLoader accessible from GC root. */
+    @AfterAll
+    public static void afterAll() {
+        cgen = null;
+    }
+
+    private Path getConfigFile() {
+        return tmpDir.resolve(CONFIG_NAME);
+    }
+
+    @BeforeEach
+    void before() {
+        storage = new LocalFileConfigurationStorage(getConfigFile(), List.of(TopConfiguration.KEY));
+
+        changer = new TestConfigurationChanger(
+                cgen,
+                List.of(TopConfiguration.KEY),
+                Set.of(),
+                storage,
+                List.of(),
+                List.of()
+        );
+
+        changer.start();
+    }
+
+    @AfterEach
+    void after() {
+        changer.stop();
     }
 
     @Test
-    void testHocon() throws IOException {
-        // All of this is needed because write expects serializable values and only concrete classes are serializable
-        HashMap<String, ArrayList<String>> map = new HashMap<>(Map.of(""list"", new ArrayList<>(List.of(""val1"", ""val2""))));
-        var data = Map.of(""foo1"", ""bar1"", ""foo2"", ""bar2"", ""map"", map);
-
-        assertThat(storage.write(data, 0), willBe(true));
-
-        String contents = Files.readString(getConfigFile());
-
-        // \n instead of System.lineSeparator because Config library writes \n only
-        assertThat(contents, is(""foo1=bar1\n""
-                + ""foo2=bar2\n""
-                + ""map {\n""
-                + ""    list=[\n""
-                + ""        val1,\n""
-                + ""        val2\n""
-                + ""    ]\n""
-                + ""}\n""));
+    @DisplayName(""Default values are not added enriched on read when the config file is empty"")
+    void empty() throws IOException {
+        // Given
+        assertThat(configFileContent(), emptyString());
+
+        // When
+        var storageValues = readAllLatest();
+
+        // Then storage data only contains top level defaults
+        assertThat(storageValues.entrySet(), hasSize(1));
     }
 
     @Test
-    void testMergeHocon() throws IOException {
-        var data = Map.of(""foo1"", ""bar"");
-        assertThat(storage.write(data, 0), willBe(true));
+    @DisplayName(""Named list entities can be added"")
+    void add() throws Exception {
+        // Given
+        assertThat(configFileContent(), emptyString());
+        // And
+        var topConfiguration = (TopConfiguration) cgen.instantiateCfg(TopConfiguration.KEY, changer);
+        topConfiguration.namedList().change(b -> b.create(""name1"", x -> {
+            x.changeStrVal(""strVal1"");
+            x.changeIntVal(-1);
+        })).get();
+
+        // When
+        var storageValues = readAllLatest();
 
-        var append = Map.of(""foo1"", ""baz"", ""foo2"", ""bar"");
-        assertThat(storage.write(append, 1), willBe(true));
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(-1)));
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(""strVal1"")));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=1\n""
+                        + ""}""
+        ));
 
-        String contents = Files.readString(getConfigFile());
-        assertThat(contents, is(""foo1=baz\n""
-                + ""foo2=bar\n""));
+        // When
+        topConfiguration.namedList().change(b -> b.create(""name2"", x -> {
+            x.changeStrVal(""strVal2"");
+            x.changeIntVal(-2);
+        })).get();
+        // And
+        storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(11), hasValue(-2)));
+        assertThat(storageValues, allOf(aMapWithSize(11), hasValue(""strVal2"")));
+        // And
+        assertThat(storageValues, allOf(aMapWithSize(11), hasValue(-1)));
+        assertThat(storageValues, allOf(aMapWithSize(11), hasValue(""strVal1"")));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        },\n""
+                        + ""        {\n""
+                        + ""            intVal=-2\n""
+                        + ""            name=name2\n""
+                        + ""            strVal=strVal2\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=1\n""
+                        + ""}\n""
+        ));
     }
 
-    private Path getConfigFile() {
-        return tmpDir.resolve(CONFIG_NAME);
+    @DisplayName(""Update values"")
+    @Test
+    void update() throws Exception {
+        // Given
+        assertThat(configFileContent(), emptyString());
+
+        // When
+        var topConfiguration = (TopConfiguration) cgen.instantiateCfg(TopConfiguration.KEY, changer);
+        topConfiguration.shortVal().update((short) 3).get();
+        // And
+        var storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(1), hasValue((short) 3)));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[]\n""
+                        + ""    shortVal=3\n""
+                        + ""}\n""
+        ));
+
+        // When create named list entity with defaults
+        topConfiguration.namedList().change(b -> b.create(""name1"", x -> {
+        })).get();
+        // And
+        storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(1)));
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(""foo"")));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=foo\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=3\n""
+                        + ""}""
+        ));
+
+        // When update named list entity
+        topConfiguration.namedList().change(b -> b.update(""name1"", x -> {
+            x.changeStrVal(""strVal1"");
+            x.changeIntVal(-1);
+        })).get();
+        // And
+        storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(-1)));
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(""strVal1"")));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=3\n""
+                        + ""}""
+        ));
+    }
+
+    @DisplayName(""Remove values"")
+    @Test
+    void remove() throws Exception {
+        // Given
+        var topConfiguration = (TopConfiguration) cgen.instantiateCfg(TopConfiguration.KEY, changer);
+        topConfiguration.namedList().change(b -> {
+            b.create(""name1"", x -> {
+                x.changeStrVal(""strVal1"");
+                x.changeIntVal(-1);
+            });
+            b.create(""name2"", x -> {
+                x.changeStrVal(""strVal2"");
+                x.changeIntVal(-2);
+            });
+        }).get();
+        topConfiguration.shortVal().update((short) 3).get();
+        // And values are saved to file
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        },\n""
+                        + ""        {\n""
+                        + ""            intVal=-2\n""
+                        + ""            name=name2\n""
+                        + ""            strVal=strVal2\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=3\n""
+                        + ""}\n""
+        ));
+
+        // When remove named list entity
+        topConfiguration.namedList().change(b -> b.delete(""name1"")).get();
+        // And
+        var storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(6), Matchers.not(hasValue(""strVal1""))));
+        // And entity removed from file
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-2\n""
+                        + ""            name=name2\n""
+                        + ""            strVal=strVal2\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=3\n""
+                        + ""}\n""
+        ));
+
+        // When remove the last entity
+        topConfiguration.namedList().change(b -> b.delete(""name2"")).get();
+        // And
+        storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(1), hasValue((short) 3)));
+        // And entity removed from file
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[]\n""
+                        + ""    shortVal=3\n""
+                        + ""}\n""
+        ));
+    }
+
+    @DisplayName(""Delete file before read on recovery"")
+    @Test
+    void deleteFileBeforeReadOnRecovery() throws IOException {
+        // Given
+        Files.delete(getConfigFile());
+
+        // When
+        var storageValues = storage.readDataOnRecovery().join().values();
+
+        // Then storage data only contains top level defaults
+        assertThat(storageValues.entrySet(), hasSize(1));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[]\n""
+                        + ""    shortVal=1\n""
+                        + ""}\n""
+        ));
+    }
+
+    @DisplayName(""Delete file before read all"")
+    @Test
+    void deleteFileBeforeReadAll() throws Exception {
+        // Given
+        Files.delete(getConfigFile());
+
+        // When
+        var storageValues = readAllLatest();
+
+        // Then storage data only contains top level defaults
+        assertThat(storageValues.entrySet(), hasSize(1));
+        // And there is no file
+        assertThat(Files.exists(getConfigFile()), is(false));
+
+        // When update configuration
+        var topConfiguration = (TopConfiguration) cgen.instantiateCfg(TopConfiguration.KEY, changer);
+        topConfiguration.namedList().change(b -> b.create(""name1"", x -> {
+                x.changeStrVal(""strVal1"");
+                x.changeIntVal(-1);
+            })).get();
+
+        // Then file is created
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=1\n""
+                        + ""}\n""
+        ));
+    }
+
+    private String configFileContent() throws IOException {
+        return Files.readString(getConfigFile());
+    }
+
+    private Map<String, ? extends Serializable> readAllLatest() {
+        return storage.readAllLatest("""").join();
+    }
+
+    // null == remove
+
+    // when read file you can see all values
+    //

Review Comment:
   What's this?



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/storage/ItRebalanceDistributedTest.java:
##########
@@ -606,7 +606,9 @@ private class Node {
                             RestConfiguration.KEY,
                             ClientConnectorConfiguration.KEY),
                     Set.of(),
-                    new LocalFileConfigurationStorage(configPath),
+                    new LocalFileConfigurationStorage(configPath, List.of(NetworkConfiguration.KEY,

Review Comment:
   Why don't you use `ConfigurationModule` inside of the storage? Explicit list is not very flexible.
   I recommend returning back to the old constructor.



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -175,47 +261,66 @@ public CompletableFuture<Void> writeConfigurationRevision(long prevRevision, lon
 
     @Override
     public void close() {
+        IgniteUtils.shutdownAndAwaitTermination(workerThreadPool, 10, TimeUnit.SECONDS);
         IgniteUtils.shutdownAndAwaitTermination(threadPool, 10, TimeUnit.SECONDS);
 
         futureTracker.cancelInFlightFutures();
     }
 
-    private void saveValues(Map<String, ? extends Serializable> values) {
+    private void saveConfigFile() {
         try {
-            Files.write(tempConfigPath, renderHoconString(values).getBytes(StandardCharsets.UTF_8),
-                    StandardOpenOption.SYNC, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
-            Files.move(tempConfigPath, configPath, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);
+            Files.write(
+                    tempConfigPath,
+                    renderHoconString().getBytes(StandardCharsets.UTF_8),
+                    StandardOpenOption.SYNC, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING
+            );
+
+            Files.move(
+                    tempConfigPath,
+                    configPath,
+                    StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING
+            );
         } catch (IOException e) {
             throw new NodeConfigWriteException(
-                    ""Failed to write values "" + values + "" to config file."", e);
+                    ""Failed to write values to config file."", e);
         }
     }
 
     /**
      * Convert provided map to Hocon String representation.
      *
-     * @param values Values of configuration.
      * @return Configuration file string representation in HOCON format.
      */
-    private String renderHoconString(Map<String, ? extends Serializable> values) {
-        Map<String, Object> map = values.entrySet().stream().collect(Collectors.toMap(Entry::getKey, stringEntry -> {
-            Serializable value = stringEntry.getValue();
-            if (value.getClass().isArray()) {
-                return Arrays.asList((Object[]) value);
-            }
-            return value;
-        }));
-        Config other = ConfigFactory.parseMap(map);
-        Config newConfig = other.withFallback(parseConfigOptions()).resolve();
+    private String renderHoconString() {
+        // Super root that'll be filled from the storage data.
+        SuperRoot rootNode = new SuperRoot(rootCreator());

Review Comment:
   I think you should call `createSuperRoot()` instead. Right now this code may not work. Have you tested it?



##########
modules/runner/src/test/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorageTest.java:
##########
@@ -17,75 +17,401 @@
 
 package org.apache.ignite.internal.configuration.storage;
 
-import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willBe;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.aMapWithSize;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.emptyString;
+import static org.hamcrest.Matchers.equalToCompressingWhiteSpace;
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.hasValue;
 import static org.hamcrest.Matchers.is;
 
 import java.io.IOException;
+import java.io.Serializable;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import org.apache.ignite.configuration.annotation.Config;
+import org.apache.ignite.configuration.annotation.ConfigurationRoot;
+import org.apache.ignite.configuration.annotation.NamedConfigValue;
+import org.apache.ignite.configuration.annotation.Value;
+import org.apache.ignite.internal.configuration.TestConfigurationChanger;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
 import org.apache.ignite.internal.testframework.WorkDirectory;
 import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
-import org.junit.jupiter.api.Disabled;
+import org.hamcrest.Matchers;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
 
-/**
- * Tests for the {@link LocalFileConfigurationStorage}.
- */
+/** Test for local file configurations storage. */
 @ExtendWith(WorkDirectoryExtension.class)
-@Disabled(""https://issues.apache.org/jira/browse/IGNITE-19152"")
-public class LocalFileConfigurationStorageTest extends ConfigurationStorageTest {
+public class LocalFileConfigurationStorageTest {
 
     private static final String CONFIG_NAME = ""ignite-config.conf"";
 
+    private static ConfigurationAsmGenerator cgen;
+
     @WorkDirectory
     private Path tmpDir;
 
-    @Override
-    public ConfigurationStorage getStorage() {
-        return new LocalFileConfigurationStorage(getConfigFile());
+    /** Test configuration storage. */
+    private LocalFileConfigurationStorage storage;
+
+    /** Test configuration changer. */
+    private TestConfigurationChanger changer;
+
+    /** Instantiates {@link #cgen}. */
+    @BeforeAll
+    public static void beforeAll() {
+        cgen = new ConfigurationAsmGenerator();
+    }
+
+    /** Nullifies {@link #cgen} to prevent memory leak from having runtime ClassLoader accessible from GC root. */
+    @AfterAll
+    public static void afterAll() {
+        cgen = null;
+    }
+
+    private Path getConfigFile() {
+        return tmpDir.resolve(CONFIG_NAME);
+    }
+
+    @BeforeEach
+    void before() {
+        storage = new LocalFileConfigurationStorage(getConfigFile(), List.of(TopConfiguration.KEY));
+
+        changer = new TestConfigurationChanger(
+                cgen,
+                List.of(TopConfiguration.KEY),
+                Set.of(),
+                storage,
+                List.of(),
+                List.of()
+        );
+
+        changer.start();
+    }
+
+    @AfterEach
+    void after() {
+        changer.stop();
     }
 
     @Test
-    void testHocon() throws IOException {
-        // All of this is needed because write expects serializable values and only concrete classes are serializable
-        HashMap<String, ArrayList<String>> map = new HashMap<>(Map.of(""list"", new ArrayList<>(List.of(""val1"", ""val2""))));
-        var data = Map.of(""foo1"", ""bar1"", ""foo2"", ""bar2"", ""map"", map);
-
-        assertThat(storage.write(data, 0), willBe(true));
-
-        String contents = Files.readString(getConfigFile());
-
-        // \n instead of System.lineSeparator because Config library writes \n only
-        assertThat(contents, is(""foo1=bar1\n""
-                + ""foo2=bar2\n""
-                + ""map {\n""
-                + ""    list=[\n""
-                + ""        val1,\n""
-                + ""        val2\n""
-                + ""    ]\n""
-                + ""}\n""));
+    @DisplayName(""Default values are not added enriched on read when the config file is empty"")
+    void empty() throws IOException {
+        // Given
+        assertThat(configFileContent(), emptyString());
+
+        // When
+        var storageValues = readAllLatest();
+
+        // Then storage data only contains top level defaults
+        assertThat(storageValues.entrySet(), hasSize(1));
     }
 
     @Test
-    void testMergeHocon() throws IOException {
-        var data = Map.of(""foo1"", ""bar"");
-        assertThat(storage.write(data, 0), willBe(true));
+    @DisplayName(""Named list entities can be added"")
+    void add() throws Exception {
+        // Given
+        assertThat(configFileContent(), emptyString());
+        // And

Review Comment:
   Please add empty lines here and there, this code looks too cramped



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -40,114 +53,187 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
-import java.util.stream.Collectors;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import org.apache.ignite.configuration.RootKey;
 import org.apache.ignite.configuration.annotation.ConfigurationType;
 import org.apache.ignite.internal.configuration.NodeConfigCreateException;
 import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.RootInnerNode;
+import org.apache.ignite.internal.configuration.SuperRoot;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
+import org.apache.ignite.internal.configuration.hocon.HoconConverter;
+import org.apache.ignite.internal.configuration.tree.ConverterToMapVisitor;
+import org.apache.ignite.internal.configuration.tree.InnerNode;
 import org.apache.ignite.internal.future.InFlightFutures;
 import org.apache.ignite.internal.logger.IgniteLogger;
 import org.apache.ignite.internal.logger.Loggers;
 import org.apache.ignite.internal.thread.NamedThreadFactory;
 import org.apache.ignite.internal.util.IgniteUtils;
+import org.jetbrains.annotations.NotNull;
 
 /**
  * Implementation of {@link ConfigurationStorage} based on local file configuration storage.
  */
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration nodes generator. */
+    private final ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();
+
+    /** Map of root keys that are needed to generate configuration tree. */
+    private final Map<String, RootKey<?, ?>> rootKeys;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService threadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""loc-cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
+    /**
+     * Constructor without configuration extensions.
+     *
+     * @param configPath Path to node bootstrap configuration file.
+     * @param rootKeys Configuration root keys.
+     */
+    public LocalFileConfigurationStorage(Path configPath, Collection<RootKey<?, ?>> rootKeys) {
+        this(configPath, rootKeys, Collections.emptyList(), Collections.emptyList());
+    }
+
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param rootKeys Configuration root keys.
+     * @param internalSchemaExtensions Internal schema extensions.
+     * @param polymorphicSchemaExtensions Polymorphic schema extensions.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, Collection<RootKey<?, ?>> rootKeys,
+            Collection<Class<?>> internalSchemaExtensions, Collection<Class<?>> polymorphicSchemaExtensions) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.rootKeys = rootKeys.stream().collect(toMap(RootKey::key, identity()));
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
+        Map<Class<?>, Set<Class<?>>> internalExtensions = internalSchemaExtensions(internalSchemaExtensions);
+        Map<Class<?>, Set<Class<?>>> polymorphicExtensions = polymorphicSchemaExtensions(polymorphicSchemaExtensions);
+
+        rootKeys.forEach(key -> cgen.compileRootSchema(key.schemaClass(), internalExtensions, polymorphicExtensions));
+
         checkAndRestoreConfigFile();
     }
 
+    private static void setValues(SuperRoot target, Config source) {
+        HoconConverter.hoconSource(source.root()).descend(target);
+    }
+
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return writeLockAsync(() -> {

Review Comment:
   Considering that now we really read data on recovery, we should remove the step of applying this very configuration file as a change on top of itself. Please fix that part.



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -40,114 +53,187 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
-import java.util.stream.Collectors;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import org.apache.ignite.configuration.RootKey;
 import org.apache.ignite.configuration.annotation.ConfigurationType;
 import org.apache.ignite.internal.configuration.NodeConfigCreateException;
 import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.RootInnerNode;
+import org.apache.ignite.internal.configuration.SuperRoot;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
+import org.apache.ignite.internal.configuration.hocon.HoconConverter;
+import org.apache.ignite.internal.configuration.tree.ConverterToMapVisitor;
+import org.apache.ignite.internal.configuration.tree.InnerNode;
 import org.apache.ignite.internal.future.InFlightFutures;
 import org.apache.ignite.internal.logger.IgniteLogger;
 import org.apache.ignite.internal.logger.Loggers;
 import org.apache.ignite.internal.thread.NamedThreadFactory;
 import org.apache.ignite.internal.util.IgniteUtils;
+import org.jetbrains.annotations.NotNull;
 
 /**
  * Implementation of {@link ConfigurationStorage} based on local file configuration storage.
  */
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration nodes generator. */
+    private final ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();
+
+    /** Map of root keys that are needed to generate configuration tree. */
+    private final Map<String, RootKey<?, ?>> rootKeys;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService threadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""loc-cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
+    /**
+     * Constructor without configuration extensions.
+     *
+     * @param configPath Path to node bootstrap configuration file.
+     * @param rootKeys Configuration root keys.
+     */
+    public LocalFileConfigurationStorage(Path configPath, Collection<RootKey<?, ?>> rootKeys) {
+        this(configPath, rootKeys, Collections.emptyList(), Collections.emptyList());
+    }
+
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param rootKeys Configuration root keys.
+     * @param internalSchemaExtensions Internal schema extensions.
+     * @param polymorphicSchemaExtensions Polymorphic schema extensions.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, Collection<RootKey<?, ?>> rootKeys,
+            Collection<Class<?>> internalSchemaExtensions, Collection<Class<?>> polymorphicSchemaExtensions) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.rootKeys = rootKeys.stream().collect(toMap(RootKey::key, identity()));
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
+        Map<Class<?>, Set<Class<?>>> internalExtensions = internalSchemaExtensions(internalSchemaExtensions);
+        Map<Class<?>, Set<Class<?>>> polymorphicExtensions = polymorphicSchemaExtensions(polymorphicSchemaExtensions);
+
+        rootKeys.forEach(key -> cgen.compileRootSchema(key.schemaClass(), internalExtensions, polymorphicExtensions));
+
         checkAndRestoreConfigFile();
     }
 
+    private static void setValues(SuperRoot target, Config source) {
+        HoconConverter.hoconSource(source.root()).descend(target);
+    }
+
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return writeLockAsync(() -> {
+            SuperRoot superRoot = createSuperRoot();
+            SuperRoot copiedSuperRoot = superRoot.copy();
+
+            Config hocon = readHoconFromFile();
+            setValues(copiedSuperRoot, hocon);
+
+            addDefaults(copiedSuperRoot);
+
+            Map<String, Serializable> flattenedUpdatesMap = createFlattenedUpdatesMap(superRoot, copiedSuperRoot);
+
+            latest.putAll(flattenedUpdatesMap);
+
+            return new Data(flattenedUpdatesMap, lastRevision);
+        });
+    }
+
+
+    private Config readHoconFromFile() {
+        checkAndRestoreConfigFile();
+        return ConfigFactory.parseFile(configPath.toFile(), ConfigParseOptions.defaults().setAllowMissing(false));
+    }
+
+    @NotNull

Review Comment:
   We don't use `@NotNull`



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -40,114 +53,187 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
-import java.util.stream.Collectors;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import org.apache.ignite.configuration.RootKey;
 import org.apache.ignite.configuration.annotation.ConfigurationType;
 import org.apache.ignite.internal.configuration.NodeConfigCreateException;
 import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.RootInnerNode;
+import org.apache.ignite.internal.configuration.SuperRoot;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
+import org.apache.ignite.internal.configuration.hocon.HoconConverter;
+import org.apache.ignite.internal.configuration.tree.ConverterToMapVisitor;
+import org.apache.ignite.internal.configuration.tree.InnerNode;
 import org.apache.ignite.internal.future.InFlightFutures;
 import org.apache.ignite.internal.logger.IgniteLogger;
 import org.apache.ignite.internal.logger.Loggers;
 import org.apache.ignite.internal.thread.NamedThreadFactory;
 import org.apache.ignite.internal.util.IgniteUtils;
+import org.jetbrains.annotations.NotNull;
 
 /**
  * Implementation of {@link ConfigurationStorage} based on local file configuration storage.
  */
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration nodes generator. */
+    private final ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();
+
+    /** Map of root keys that are needed to generate configuration tree. */
+    private final Map<String, RootKey<?, ?>> rootKeys;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService threadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""loc-cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
+    /**
+     * Constructor without configuration extensions.
+     *
+     * @param configPath Path to node bootstrap configuration file.
+     * @param rootKeys Configuration root keys.
+     */
+    public LocalFileConfigurationStorage(Path configPath, Collection<RootKey<?, ?>> rootKeys) {
+        this(configPath, rootKeys, Collections.emptyList(), Collections.emptyList());
+    }
+
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param rootKeys Configuration root keys.
+     * @param internalSchemaExtensions Internal schema extensions.
+     * @param polymorphicSchemaExtensions Polymorphic schema extensions.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, Collection<RootKey<?, ?>> rootKeys,
+            Collection<Class<?>> internalSchemaExtensions, Collection<Class<?>> polymorphicSchemaExtensions) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.rootKeys = rootKeys.stream().collect(toMap(RootKey::key, identity()));
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
+        Map<Class<?>, Set<Class<?>>> internalExtensions = internalSchemaExtensions(internalSchemaExtensions);
+        Map<Class<?>, Set<Class<?>>> polymorphicExtensions = polymorphicSchemaExtensions(polymorphicSchemaExtensions);
+
+        rootKeys.forEach(key -> cgen.compileRootSchema(key.schemaClass(), internalExtensions, polymorphicExtensions));
+
         checkAndRestoreConfigFile();
     }
 
+    private static void setValues(SuperRoot target, Config source) {
+        HoconConverter.hoconSource(source.root()).descend(target);
+    }
+
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return writeLockAsync(() -> {
+            SuperRoot superRoot = createSuperRoot();
+            SuperRoot copiedSuperRoot = superRoot.copy();
+
+            Config hocon = readHoconFromFile();
+            setValues(copiedSuperRoot, hocon);
+
+            addDefaults(copiedSuperRoot);
+
+            Map<String, Serializable> flattenedUpdatesMap = createFlattenedUpdatesMap(superRoot, copiedSuperRoot);
+
+            latest.putAll(flattenedUpdatesMap);
+
+            return new Data(flattenedUpdatesMap, lastRevision);
+        });
+    }
+
+
+    private Config readHoconFromFile() {
+        checkAndRestoreConfigFile();
+        return ConfigFactory.parseFile(configPath.toFile(), ConfigParseOptions.defaults().setAllowMissing(false));
+    }
+
+    @NotNull
+    private SuperRoot createSuperRoot() {
+        SuperRoot superRoot = new SuperRoot(rootCreator());
+        for (RootKey<?, ?> rootKey : rootKeys.values()) {
+            superRoot.addRoot(rootKey, createRootNode(rootKey));
+        }
+
+        return superRoot;
     }
 
     @Override
     public CompletableFuture<Map<String, ? extends Serializable>> readAllLatest(String prefix) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            Map<String, Serializable> map = latest.entrySet()
-                    .stream()
-                    .filter(entry -> entry.getKey().startsWith(prefix))
-                    .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
-            return CompletableFuture.completedFuture(map);
-        } finally {
-            lock.readLock().unlock();
-        }
+        return readLockAsync(() ->
+                latest.entrySet()
+                        .stream()
+                        .filter(entry -> entry.getKey().startsWith(prefix))
+                        .collect(toMap(Entry::getKey, Entry::getValue))
+        );
     }
 
     @Override
     public CompletableFuture<Serializable> readLatest(String key) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            return CompletableFuture.completedFuture(latest.get(key));
-        } finally {
-            lock.readLock().unlock();
-        }
+        return readLockAsync(() -> latest.get(key));
     }
 
     @Override
     public CompletableFuture<Boolean> write(Map<String, ? extends Serializable> newValues, long ver) {
-        lock.writeLock().lock();
-        try {
+        return writeLockAsync(() -> {
             if (ver != lastRevision) {
-                return CompletableFuture.completedFuture(false);
+                return false;
             }
-            checkAndRestoreConfigFile();
-            // TODO: https://issues.apache.org/jira/browse/IGNITE-19152
-            //saveValues(newValues);
-            latest.putAll(newValues);
-            lastRevision++;
+
+            mergeAndSave(newValues);
+
             runAsync(() -> lsnrRef.get().onEntriesChanged(new Data(newValues, lastRevision)));
-            return CompletableFuture.completedFuture(true);
-        } finally {
-            lock.writeLock().unlock();
-        }
+
+            return true;
+        });
+    }
+
+    private void mergeAndSave(Map<String, ? extends Serializable> newValues) {
+        updateLatestState(newValues);
+        saveConfigFile();
+        lastRevision++;
+    }
+
+    private void updateLatestState(Map<String, ? extends Serializable> newValues) {
+        newValues.forEach((key, value) -> {
+            if (value == null) { // null means that we should remove this entry
+                latest.remove(key);
+            } else {
+                latest.put(key, value);
+            }
+        });
     }
 
     private void runAsync(Runnable runnable) {
         CompletableFuture<Void> future = CompletableFuture.runAsync(runnable, threadPool);
-

Review Comment:
   Why did you remove this empty line? What's the reason?
   For longest time we have specific code convention, we use empty lines throughout the code, it gives Ignite's code certain look and feel. I would say that you don't follow it enough, but that's ok.
   What's not ok to me is simply removing such formatting from the code, that has nothing to do with your changes.



##########
modules/runner/src/test/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorageTest.java:
##########
@@ -17,75 +17,401 @@
 
 package org.apache.ignite.internal.configuration.storage;
 
-import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willBe;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.aMapWithSize;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.emptyString;
+import static org.hamcrest.Matchers.equalToCompressingWhiteSpace;
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.hasValue;
 import static org.hamcrest.Matchers.is;
 
 import java.io.IOException;
+import java.io.Serializable;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import org.apache.ignite.configuration.annotation.Config;
+import org.apache.ignite.configuration.annotation.ConfigurationRoot;
+import org.apache.ignite.configuration.annotation.NamedConfigValue;
+import org.apache.ignite.configuration.annotation.Value;
+import org.apache.ignite.internal.configuration.TestConfigurationChanger;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
 import org.apache.ignite.internal.testframework.WorkDirectory;
 import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
-import org.junit.jupiter.api.Disabled;
+import org.hamcrest.Matchers;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
 
-/**
- * Tests for the {@link LocalFileConfigurationStorage}.
- */
+/** Test for local file configurations storage. */
 @ExtendWith(WorkDirectoryExtension.class)
-@Disabled(""https://issues.apache.org/jira/browse/IGNITE-19152"")
-public class LocalFileConfigurationStorageTest extends ConfigurationStorageTest {
+public class LocalFileConfigurationStorageTest {
 
     private static final String CONFIG_NAME = ""ignite-config.conf"";
 
+    private static ConfigurationAsmGenerator cgen;
+
     @WorkDirectory
     private Path tmpDir;
 
-    @Override
-    public ConfigurationStorage getStorage() {
-        return new LocalFileConfigurationStorage(getConfigFile());
+    /** Test configuration storage. */
+    private LocalFileConfigurationStorage storage;
+
+    /** Test configuration changer. */
+    private TestConfigurationChanger changer;
+
+    /** Instantiates {@link #cgen}. */
+    @BeforeAll
+    public static void beforeAll() {
+        cgen = new ConfigurationAsmGenerator();
+    }
+
+    /** Nullifies {@link #cgen} to prevent memory leak from having runtime ClassLoader accessible from GC root. */
+    @AfterAll
+    public static void afterAll() {
+        cgen = null;
+    }
+
+    private Path getConfigFile() {
+        return tmpDir.resolve(CONFIG_NAME);
+    }
+
+    @BeforeEach
+    void before() {
+        storage = new LocalFileConfigurationStorage(getConfigFile(), List.of(TopConfiguration.KEY));
+
+        changer = new TestConfigurationChanger(
+                cgen,
+                List.of(TopConfiguration.KEY),
+                Set.of(),
+                storage,
+                List.of(),
+                List.of()
+        );
+
+        changer.start();
+    }
+
+    @AfterEach
+    void after() {
+        changer.stop();
     }
 
     @Test
-    void testHocon() throws IOException {
-        // All of this is needed because write expects serializable values and only concrete classes are serializable
-        HashMap<String, ArrayList<String>> map = new HashMap<>(Map.of(""list"", new ArrayList<>(List.of(""val1"", ""val2""))));
-        var data = Map.of(""foo1"", ""bar1"", ""foo2"", ""bar2"", ""map"", map);
-
-        assertThat(storage.write(data, 0), willBe(true));
-
-        String contents = Files.readString(getConfigFile());
-
-        // \n instead of System.lineSeparator because Config library writes \n only
-        assertThat(contents, is(""foo1=bar1\n""
-                + ""foo2=bar2\n""
-                + ""map {\n""
-                + ""    list=[\n""
-                + ""        val1,\n""
-                + ""        val2\n""
-                + ""    ]\n""
-                + ""}\n""));
+    @DisplayName(""Default values are not added enriched on read when the config file is empty"")
+    void empty() throws IOException {
+        // Given
+        assertThat(configFileContent(), emptyString());
+
+        // When
+        var storageValues = readAllLatest();
+
+        // Then storage data only contains top level defaults
+        assertThat(storageValues.entrySet(), hasSize(1));
     }
 
     @Test
-    void testMergeHocon() throws IOException {
-        var data = Map.of(""foo1"", ""bar"");
-        assertThat(storage.write(data, 0), willBe(true));
+    @DisplayName(""Named list entities can be added"")
+    void add() throws Exception {
+        // Given
+        assertThat(configFileContent(), emptyString());
+        // And
+        var topConfiguration = (TopConfiguration) cgen.instantiateCfg(TopConfiguration.KEY, changer);
+        topConfiguration.namedList().change(b -> b.create(""name1"", x -> {
+            x.changeStrVal(""strVal1"");
+            x.changeIntVal(-1);
+        })).get();
+
+        // When
+        var storageValues = readAllLatest();
 
-        var append = Map.of(""foo1"", ""baz"", ""foo2"", ""bar"");
-        assertThat(storage.write(append, 1), willBe(true));
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(-1)));

Review Comment:
   Please add a comment, what are the other 4 entries in the map. There are asserts only for 2 of them, this is not trivial



##########
modules/runner/src/test/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorageTest.java:
##########
@@ -17,75 +17,401 @@
 
 package org.apache.ignite.internal.configuration.storage;
 
-import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willBe;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.aMapWithSize;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.emptyString;
+import static org.hamcrest.Matchers.equalToCompressingWhiteSpace;
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.hasValue;
 import static org.hamcrest.Matchers.is;
 
 import java.io.IOException;
+import java.io.Serializable;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import org.apache.ignite.configuration.annotation.Config;
+import org.apache.ignite.configuration.annotation.ConfigurationRoot;
+import org.apache.ignite.configuration.annotation.NamedConfigValue;
+import org.apache.ignite.configuration.annotation.Value;
+import org.apache.ignite.internal.configuration.TestConfigurationChanger;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
 import org.apache.ignite.internal.testframework.WorkDirectory;
 import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
-import org.junit.jupiter.api.Disabled;
+import org.hamcrest.Matchers;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
 
-/**
- * Tests for the {@link LocalFileConfigurationStorage}.
- */
+/** Test for local file configurations storage. */
 @ExtendWith(WorkDirectoryExtension.class)
-@Disabled(""https://issues.apache.org/jira/browse/IGNITE-19152"")
-public class LocalFileConfigurationStorageTest extends ConfigurationStorageTest {
+public class LocalFileConfigurationStorageTest {
 
     private static final String CONFIG_NAME = ""ignite-config.conf"";
 
+    private static ConfigurationAsmGenerator cgen;
+
     @WorkDirectory
     private Path tmpDir;
 
-    @Override
-    public ConfigurationStorage getStorage() {
-        return new LocalFileConfigurationStorage(getConfigFile());
+    /** Test configuration storage. */
+    private LocalFileConfigurationStorage storage;
+
+    /** Test configuration changer. */
+    private TestConfigurationChanger changer;
+
+    /** Instantiates {@link #cgen}. */
+    @BeforeAll
+    public static void beforeAll() {
+        cgen = new ConfigurationAsmGenerator();
+    }
+
+    /** Nullifies {@link #cgen} to prevent memory leak from having runtime ClassLoader accessible from GC root. */
+    @AfterAll
+    public static void afterAll() {
+        cgen = null;
+    }
+
+    private Path getConfigFile() {
+        return tmpDir.resolve(CONFIG_NAME);
+    }
+
+    @BeforeEach
+    void before() {
+        storage = new LocalFileConfigurationStorage(getConfigFile(), List.of(TopConfiguration.KEY));
+
+        changer = new TestConfigurationChanger(
+                cgen,
+                List.of(TopConfiguration.KEY),
+                Set.of(),
+                storage,
+                List.of(),
+                List.of()
+        );
+
+        changer.start();
+    }
+
+    @AfterEach
+    void after() {
+        changer.stop();
     }
 
     @Test
-    void testHocon() throws IOException {
-        // All of this is needed because write expects serializable values and only concrete classes are serializable
-        HashMap<String, ArrayList<String>> map = new HashMap<>(Map.of(""list"", new ArrayList<>(List.of(""val1"", ""val2""))));
-        var data = Map.of(""foo1"", ""bar1"", ""foo2"", ""bar2"", ""map"", map);
-
-        assertThat(storage.write(data, 0), willBe(true));
-
-        String contents = Files.readString(getConfigFile());
-
-        // \n instead of System.lineSeparator because Config library writes \n only
-        assertThat(contents, is(""foo1=bar1\n""
-                + ""foo2=bar2\n""
-                + ""map {\n""
-                + ""    list=[\n""
-                + ""        val1,\n""
-                + ""        val2\n""
-                + ""    ]\n""
-                + ""}\n""));
+    @DisplayName(""Default values are not added enriched on read when the config file is empty"")
+    void empty() throws IOException {
+        // Given
+        assertThat(configFileContent(), emptyString());
+
+        // When
+        var storageValues = readAllLatest();
+
+        // Then storage data only contains top level defaults
+        assertThat(storageValues.entrySet(), hasSize(1));
     }
 
     @Test
-    void testMergeHocon() throws IOException {
-        var data = Map.of(""foo1"", ""bar"");
-        assertThat(storage.write(data, 0), willBe(true));
+    @DisplayName(""Named list entities can be added"")
+    void add() throws Exception {
+        // Given
+        assertThat(configFileContent(), emptyString());
+        // And
+        var topConfiguration = (TopConfiguration) cgen.instantiateCfg(TopConfiguration.KEY, changer);
+        topConfiguration.namedList().change(b -> b.create(""name1"", x -> {
+            x.changeStrVal(""strVal1"");
+            x.changeIntVal(-1);
+        })).get();
+
+        // When
+        var storageValues = readAllLatest();
 
-        var append = Map.of(""foo1"", ""baz"", ""foo2"", ""bar"");
-        assertThat(storage.write(append, 1), willBe(true));
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(-1)));
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(""strVal1"")));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        }\n""

Review Comment:
   Can we have a TODO that would tell us to fix the rendering syntax for named lists?
   Also, I would expect (in the future) the following (when there's only a single property to the list entry):
   ```
   namedList {
       foo.attribute = a
       bar.attribute = b
   }
   ```
   instead of
   ```
   namedList {
       foo {
           attribute = a
       }
       ...
   }
   ```
   Maybe we would require a custom rendering code. This topic must be discussed with somebody. Syntax matters, it's a user-facing part of Ignite.



;14/Apr/23 08:16;githubbot;600","PakhomovAlexander commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1166622351


##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -40,114 +53,187 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
-import java.util.stream.Collectors;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import org.apache.ignite.configuration.RootKey;
 import org.apache.ignite.configuration.annotation.ConfigurationType;
 import org.apache.ignite.internal.configuration.NodeConfigCreateException;
 import org.apache.ignite.internal.configuration.NodeConfigWriteException;
+import org.apache.ignite.internal.configuration.RootInnerNode;
+import org.apache.ignite.internal.configuration.SuperRoot;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
+import org.apache.ignite.internal.configuration.hocon.HoconConverter;
+import org.apache.ignite.internal.configuration.tree.ConverterToMapVisitor;
+import org.apache.ignite.internal.configuration.tree.InnerNode;
 import org.apache.ignite.internal.future.InFlightFutures;
 import org.apache.ignite.internal.logger.IgniteLogger;
 import org.apache.ignite.internal.logger.Loggers;
 import org.apache.ignite.internal.thread.NamedThreadFactory;
 import org.apache.ignite.internal.util.IgniteUtils;
+import org.jetbrains.annotations.NotNull;
 
 /**
  * Implementation of {@link ConfigurationStorage} based on local file configuration storage.
  */
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration nodes generator. */
+    private final ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();
+
+    /** Map of root keys that are needed to generate configuration tree. */
+    private final Map<String, RootKey<?, ?>> rootKeys;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService threadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""loc-cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );

Review Comment:
   Given an implementation of the configuration listener that freezes the thread, we won't stop processing the configuration updates. So, I decided to separate the notification and main executors. WDYT?



;14/Apr/23 09:57;githubbot;600","PakhomovAlexander commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1166648094


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/storage/ItRebalanceDistributedTest.java:
##########
@@ -606,7 +606,9 @@ private class Node {
                             RestConfiguration.KEY,
                             ClientConnectorConfiguration.KEY),
                     Set.of(),
-                    new LocalFileConfigurationStorage(configPath),
+                    new LocalFileConfigurationStorage(configPath, List.of(NetworkConfiguration.KEY,

Review Comment:
   Good point, I've just applied the same approach as we do in `ConfigurationManager`. Do you think we need to use `ConfigurationModule` there as well?



;14/Apr/23 10:17;githubbot;600","PakhomovAlexander commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1166684563


##########
modules/runner/src/test/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorageTest.java:
##########
@@ -17,75 +17,401 @@
 
 package org.apache.ignite.internal.configuration.storage;
 
-import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willBe;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.aMapWithSize;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.emptyString;
+import static org.hamcrest.Matchers.equalToCompressingWhiteSpace;
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.hasValue;
 import static org.hamcrest.Matchers.is;
 
 import java.io.IOException;
+import java.io.Serializable;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import org.apache.ignite.configuration.annotation.Config;
+import org.apache.ignite.configuration.annotation.ConfigurationRoot;
+import org.apache.ignite.configuration.annotation.NamedConfigValue;
+import org.apache.ignite.configuration.annotation.Value;
+import org.apache.ignite.internal.configuration.TestConfigurationChanger;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
 import org.apache.ignite.internal.testframework.WorkDirectory;
 import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
-import org.junit.jupiter.api.Disabled;
+import org.hamcrest.Matchers;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
 
-/**
- * Tests for the {@link LocalFileConfigurationStorage}.
- */
+/** Test for local file configurations storage. */
 @ExtendWith(WorkDirectoryExtension.class)
-@Disabled(""https://issues.apache.org/jira/browse/IGNITE-19152"")
-public class LocalFileConfigurationStorageTest extends ConfigurationStorageTest {
+public class LocalFileConfigurationStorageTest {
 
     private static final String CONFIG_NAME = ""ignite-config.conf"";
 
+    private static ConfigurationAsmGenerator cgen;
+
     @WorkDirectory
     private Path tmpDir;
 
-    @Override
-    public ConfigurationStorage getStorage() {
-        return new LocalFileConfigurationStorage(getConfigFile());
+    /** Test configuration storage. */
+    private LocalFileConfigurationStorage storage;
+
+    /** Test configuration changer. */
+    private TestConfigurationChanger changer;
+
+    /** Instantiates {@link #cgen}. */
+    @BeforeAll
+    public static void beforeAll() {
+        cgen = new ConfigurationAsmGenerator();
+    }
+
+    /** Nullifies {@link #cgen} to prevent memory leak from having runtime ClassLoader accessible from GC root. */
+    @AfterAll
+    public static void afterAll() {
+        cgen = null;
+    }
+
+    private Path getConfigFile() {
+        return tmpDir.resolve(CONFIG_NAME);
+    }
+
+    @BeforeEach
+    void before() {
+        storage = new LocalFileConfigurationStorage(getConfigFile(), List.of(TopConfiguration.KEY));
+
+        changer = new TestConfigurationChanger(
+                cgen,
+                List.of(TopConfiguration.KEY),
+                Set.of(),
+                storage,
+                List.of(),
+                List.of()
+        );
+
+        changer.start();
+    }
+
+    @AfterEach
+    void after() {
+        changer.stop();
     }
 
     @Test
-    void testHocon() throws IOException {
-        // All of this is needed because write expects serializable values and only concrete classes are serializable
-        HashMap<String, ArrayList<String>> map = new HashMap<>(Map.of(""list"", new ArrayList<>(List.of(""val1"", ""val2""))));
-        var data = Map.of(""foo1"", ""bar1"", ""foo2"", ""bar2"", ""map"", map);
-
-        assertThat(storage.write(data, 0), willBe(true));
-
-        String contents = Files.readString(getConfigFile());
-
-        // \n instead of System.lineSeparator because Config library writes \n only
-        assertThat(contents, is(""foo1=bar1\n""
-                + ""foo2=bar2\n""
-                + ""map {\n""
-                + ""    list=[\n""
-                + ""        val1,\n""
-                + ""        val2\n""
-                + ""    ]\n""
-                + ""}\n""));
+    @DisplayName(""Default values are not added enriched on read when the config file is empty"")
+    void empty() throws IOException {
+        // Given
+        assertThat(configFileContent(), emptyString());
+
+        // When
+        var storageValues = readAllLatest();
+
+        // Then storage data only contains top level defaults
+        assertThat(storageValues.entrySet(), hasSize(1));

Review Comment:
   The question with defaults is a good one. I think you are right and we should not store defaults. 



;14/Apr/23 10:51;githubbot;600","PakhomovAlexander commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1168449309


##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -175,47 +261,66 @@ public CompletableFuture<Void> writeConfigurationRevision(long prevRevision, lon
 
     @Override
     public void close() {
+        IgniteUtils.shutdownAndAwaitTermination(workerThreadPool, 10, TimeUnit.SECONDS);
         IgniteUtils.shutdownAndAwaitTermination(threadPool, 10, TimeUnit.SECONDS);
 
         futureTracker.cancelInFlightFutures();
     }
 
-    private void saveValues(Map<String, ? extends Serializable> values) {
+    private void saveConfigFile() {
         try {
-            Files.write(tempConfigPath, renderHoconString(values).getBytes(StandardCharsets.UTF_8),
-                    StandardOpenOption.SYNC, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
-            Files.move(tempConfigPath, configPath, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);
+            Files.write(
+                    tempConfigPath,
+                    renderHoconString().getBytes(StandardCharsets.UTF_8),
+                    StandardOpenOption.SYNC, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING
+            );
+
+            Files.move(
+                    tempConfigPath,
+                    configPath,
+                    StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING
+            );
         } catch (IOException e) {
             throw new NodeConfigWriteException(
-                    ""Failed to write values "" + values + "" to config file."", e);
+                    ""Failed to write values to config file."", e);
         }
     }
 
     /**
      * Convert provided map to Hocon String representation.
      *
-     * @param values Values of configuration.
      * @return Configuration file string representation in HOCON format.
      */
-    private String renderHoconString(Map<String, ? extends Serializable> values) {
-        Map<String, Object> map = values.entrySet().stream().collect(Collectors.toMap(Entry::getKey, stringEntry -> {
-            Serializable value = stringEntry.getValue();
-            if (value.getClass().isArray()) {
-                return Arrays.asList((Object[]) value);
-            }
-            return value;
-        }));
-        Config other = ConfigFactory.parseMap(map);
-        Config newConfig = other.withFallback(parseConfigOptions()).resolve();
+    private String renderHoconString() {
+        // Super root that'll be filled from the storage data.
+        SuperRoot rootNode = new SuperRoot(rootCreator());

Review Comment:
   Sure I did.



;17/Apr/23 09:52;githubbot;600","PakhomovAlexander commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1170024228


##########
modules/runner/src/test/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorageTest.java:
##########
@@ -17,75 +17,401 @@
 
 package org.apache.ignite.internal.configuration.storage;
 
-import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willBe;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.aMapWithSize;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.emptyString;
+import static org.hamcrest.Matchers.equalToCompressingWhiteSpace;
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.hasValue;
 import static org.hamcrest.Matchers.is;
 
 import java.io.IOException;
+import java.io.Serializable;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import org.apache.ignite.configuration.annotation.Config;
+import org.apache.ignite.configuration.annotation.ConfigurationRoot;
+import org.apache.ignite.configuration.annotation.NamedConfigValue;
+import org.apache.ignite.configuration.annotation.Value;
+import org.apache.ignite.internal.configuration.TestConfigurationChanger;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
 import org.apache.ignite.internal.testframework.WorkDirectory;
 import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
-import org.junit.jupiter.api.Disabled;
+import org.hamcrest.Matchers;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
 
-/**
- * Tests for the {@link LocalFileConfigurationStorage}.
- */
+/** Test for local file configurations storage. */
 @ExtendWith(WorkDirectoryExtension.class)
-@Disabled(""https://issues.apache.org/jira/browse/IGNITE-19152"")
-public class LocalFileConfigurationStorageTest extends ConfigurationStorageTest {
+public class LocalFileConfigurationStorageTest {
 
     private static final String CONFIG_NAME = ""ignite-config.conf"";
 
+    private static ConfigurationAsmGenerator cgen;
+
     @WorkDirectory
     private Path tmpDir;
 
-    @Override
-    public ConfigurationStorage getStorage() {
-        return new LocalFileConfigurationStorage(getConfigFile());
+    /** Test configuration storage. */
+    private LocalFileConfigurationStorage storage;
+
+    /** Test configuration changer. */
+    private TestConfigurationChanger changer;
+
+    /** Instantiates {@link #cgen}. */
+    @BeforeAll
+    public static void beforeAll() {
+        cgen = new ConfigurationAsmGenerator();
+    }
+
+    /** Nullifies {@link #cgen} to prevent memory leak from having runtime ClassLoader accessible from GC root. */
+    @AfterAll
+    public static void afterAll() {
+        cgen = null;
+    }
+
+    private Path getConfigFile() {
+        return tmpDir.resolve(CONFIG_NAME);
+    }
+
+    @BeforeEach
+    void before() {
+        storage = new LocalFileConfigurationStorage(getConfigFile(), List.of(TopConfiguration.KEY));
+
+        changer = new TestConfigurationChanger(
+                cgen,
+                List.of(TopConfiguration.KEY),
+                Set.of(),
+                storage,
+                List.of(),
+                List.of()
+        );
+
+        changer.start();
+    }
+
+    @AfterEach
+    void after() {
+        changer.stop();
     }
 
     @Test
-    void testHocon() throws IOException {
-        // All of this is needed because write expects serializable values and only concrete classes are serializable
-        HashMap<String, ArrayList<String>> map = new HashMap<>(Map.of(""list"", new ArrayList<>(List.of(""val1"", ""val2""))));
-        var data = Map.of(""foo1"", ""bar1"", ""foo2"", ""bar2"", ""map"", map);
-
-        assertThat(storage.write(data, 0), willBe(true));
-
-        String contents = Files.readString(getConfigFile());
-
-        // \n instead of System.lineSeparator because Config library writes \n only
-        assertThat(contents, is(""foo1=bar1\n""
-                + ""foo2=bar2\n""
-                + ""map {\n""
-                + ""    list=[\n""
-                + ""        val1,\n""
-                + ""        val2\n""
-                + ""    ]\n""
-                + ""}\n""));
+    @DisplayName(""Default values are not added enriched on read when the config file is empty"")
+    void empty() throws IOException {
+        // Given
+        assertThat(configFileContent(), emptyString());
+
+        // When
+        var storageValues = readAllLatest();
+
+        // Then storage data only contains top level defaults
+        assertThat(storageValues.entrySet(), hasSize(1));
     }
 
     @Test
-    void testMergeHocon() throws IOException {
-        var data = Map.of(""foo1"", ""bar"");
-        assertThat(storage.write(data, 0), willBe(true));
+    @DisplayName(""Named list entities can be added"")
+    void add() throws Exception {
+        // Given
+        assertThat(configFileContent(), emptyString());
+        // And
+        var topConfiguration = (TopConfiguration) cgen.instantiateCfg(TopConfiguration.KEY, changer);
+        topConfiguration.namedList().change(b -> b.create(""name1"", x -> {
+            x.changeStrVal(""strVal1"");
+            x.changeIntVal(-1);
+        })).get();
+
+        // When
+        var storageValues = readAllLatest();
 
-        var append = Map.of(""foo1"", ""baz"", ""foo2"", ""bar"");
-        assertThat(storage.write(append, 1), willBe(true));
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(-1)));
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(""strVal1"")));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        }\n""

Review Comment:
   https://issues.apache.org/jira/browse/IGNITE-19303



;18/Apr/23 13:15;githubbot;600","ibessonov commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1172179670


##########
modules/configuration/src/main/java/org/apache/ignite/internal/configuration/ConfigurationManager.java:
##########
@@ -40,6 +31,30 @@ public class ConfigurationManager implements IgniteComponent {
     /** Configuration registry. */
     private final ConfigurationRegistry registry;
 
+    /**
+     * Constructor.
+     *
+     * @param rootKeys                    Configuration root keys.
+     * @param validators                  Validators.
+     * @param storage                     Configuration storage.
+     * @param generator                   Configuration tree generator.
+     * @throws IllegalArgumentException If the configuration type of the root keys is not equal to the storage type, or if the schema or its
+     *                                  extensions are not valid.
+     */
+    public ConfigurationManager(

Review Comment:
   Is there a reason to leave the old constructor in this class? Seems confusing now, but I don't know some nuances probably



##########
modules/configuration/src/main/java/org/apache/ignite/internal/configuration/ConfigurationTreeGenerator.java:
##########
@@ -0,0 +1,281 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.configuration;
+
+
+import static java.util.function.Function.identity;
+import static java.util.function.Predicate.not;
+import static java.util.stream.Collectors.toList;
+import static java.util.stream.Collectors.toMap;
+import static org.apache.ignite.internal.configuration.util.ConfigurationUtil.collectSchemas;
+import static org.apache.ignite.internal.configuration.util.ConfigurationUtil.internalSchemaExtensions;
+import static org.apache.ignite.internal.configuration.util.ConfigurationUtil.isPolymorphicId;
+import static org.apache.ignite.internal.configuration.util.ConfigurationUtil.polymorphicInstanceId;
+import static org.apache.ignite.internal.configuration.util.ConfigurationUtil.polymorphicSchemaExtensions;
+import static org.apache.ignite.internal.configuration.util.ConfigurationUtil.schemaFields;
+import static org.apache.ignite.internal.util.CollectionUtils.difference;
+import static org.apache.ignite.internal.util.CollectionUtils.viewReadOnly;
+
+import java.lang.reflect.Field;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Function;
+import org.apache.ignite.configuration.RootKey;
+import org.apache.ignite.configuration.annotation.Config;
+import org.apache.ignite.configuration.annotation.ConfigurationRoot;
+import org.apache.ignite.configuration.annotation.InternalConfiguration;
+import org.apache.ignite.configuration.annotation.PolymorphicConfigInstance;
+import org.apache.ignite.configuration.annotation.PolymorphicId;
+import org.apache.ignite.internal.close.ManuallyCloseable;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
+import org.apache.ignite.internal.configuration.tree.InnerNode;
+import org.apache.ignite.internal.configuration.util.ConfigurationUtil;
+import org.jetbrains.annotations.Nullable;
+
+/** Schema-aware configuration generator. */
+public class ConfigurationTreeGenerator implements ManuallyCloseable {
+
+    private final Map<String, RootKey<?, ?>> rootKeys;
+
+    @Nullable
+    private ConfigurationAsmGenerator generator = new ConfigurationAsmGenerator();
+
+    /**
+     * Constructor that takes a collection of root keys. Internal and polymorphic schema extensions are empty by default.
+     *
+     * @param rootKeys Root keys.
+     */
+    public ConfigurationTreeGenerator(Collection<RootKey<?, ?>> rootKeys) {
+        this(rootKeys, Set.of(), Set.of());
+    }

Review Comment:
   Is this for tests? Mark it as `@TestOnly` then



##########
modules/configuration/src/main/java/org/apache/ignite/internal/configuration/util/ConfigurationFlattener.java:
##########
@@ -136,6 +136,10 @@ public Void doVisitInnerNode(String key, InnerNode newNode) {
                 return null;
             }
 
+            if (oldNode == null && newNode == null) {

Review Comment:
   Can you please add a comment, explaining how it's possible?



##########
modules/configuration/src/test/java/org/apache/ignite/internal/configuration/ConfigurationChangerTest.java:
##########
@@ -113,13 +112,13 @@ public static class ThirdConfigurationSchema {
         public String strCfg;
     }
 
-    private static ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();
+    private static ConfigurationTreeGenerator generator = new ConfigurationTreeGenerator(List.of(KEY, DefaultsConfiguration.KEY));
 
     private final TestConfigurationStorage storage = new TestConfigurationStorage(LOCAL);
 
     @AfterAll
-    public static void afterAll() {
-        cgen = null;
+    public static void afterAll() throws Exception {

Review Comment:
   Does it have to throw an exception? This ""close"" method in generator simply nullifies the field, there's no way it ends with exception.



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/ItSslConfigurationValidationTest.java:
##########
@@ -34,6 +35,7 @@
  * Integration test for checking SSL configuration validation.
  */
 @ExtendWith(WorkDirectoryExtension.class)
+@Disabled(""https://issues.apache.org/jira/browse/IGNITE-19315"")

Review Comment:
   Too bad, I expected us to preserve this function.
   Do we prioritize this new feature as the next one that you'll be working on?



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -56,99 +66,146 @@
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration tree generator. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService notificationsThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param generator Configuration tree generator.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, ConfigurationTreeGenerator generator) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.generator = generator;
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
         checkAndRestoreConfigFile();
     }
 
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                SuperRoot superRoot = generator.createSuperRoot();
+                SuperRoot copiedSuperRoot = superRoot.copy();
+
+                Config hocon = readHoconFromFile();
+                HoconConverter.hoconSource(hocon.root()).descend(copiedSuperRoot);
+
+                Map<String, Serializable> flattenedUpdatesMap = createFlattenedUpdatesMap(superRoot, copiedSuperRoot);
+                flattenedUpdatesMap.forEach((key, value) -> {
+                    if (value != null) { // filter defaults
+                        latest.put(key, value);
+                    }
+                });
+
+                return new Data(flattenedUpdatesMap, lastRevision);
+            } finally {
+                lock.writeLock().unlock();
+            }
+        });
+    }
+
+    private Config readHoconFromFile() {
+        checkAndRestoreConfigFile();
+
+        return ConfigFactory.parseFile(configPath.toFile(), ConfigParseOptions.defaults().setAllowMissing(false));
     }
 
     @Override
     public CompletableFuture<Map<String, ? extends Serializable>> readAllLatest(String prefix) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            Map<String, Serializable> map = latest.entrySet()
-                    .stream()
-                    .filter(entry -> entry.getKey().startsWith(prefix))
-                    .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
-            return CompletableFuture.completedFuture(map);
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {

Review Comment:
   Again, I don't get it. We read data from the field. Why do we have to do it in a separate pool? Makes no sense to me, please add a comment or revert this change.



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -56,99 +66,146 @@
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration tree generator. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService notificationsThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param generator Configuration tree generator.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, ConfigurationTreeGenerator generator) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.generator = generator;
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
         checkAndRestoreConfigFile();
     }
 
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                SuperRoot superRoot = generator.createSuperRoot();
+                SuperRoot copiedSuperRoot = superRoot.copy();
+
+                Config hocon = readHoconFromFile();
+                HoconConverter.hoconSource(hocon.root()).descend(copiedSuperRoot);
+
+                Map<String, Serializable> flattenedUpdatesMap = createFlattenedUpdatesMap(superRoot, copiedSuperRoot);
+                flattenedUpdatesMap.forEach((key, value) -> {
+                    if (value != null) { // filter defaults

Review Comment:
   ```suggestion
                       if (value != null) { // Filter defaults.
   ```



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -175,56 +232,65 @@ public CompletableFuture<Void> writeConfigurationRevision(long prevRevision, lon
 
     @Override
     public void close() {
-        IgniteUtils.shutdownAndAwaitTermination(threadPool, 10, TimeUnit.SECONDS);
-
         futureTracker.cancelInFlightFutures();
+
+        IgniteUtils.shutdownAndAwaitTermination(workerThreadPool, 10, TimeUnit.SECONDS);
+        IgniteUtils.shutdownAndAwaitTermination(notificationsThreadPool, 10, TimeUnit.SECONDS);
     }
 
-    private void saveValues(Map<String, ? extends Serializable> values) {
+    private void saveConfigFile() {
         try {
-            Files.write(tempConfigPath, renderHoconString(values).getBytes(StandardCharsets.UTF_8),
-                    StandardOpenOption.SYNC, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
-            Files.move(tempConfigPath, configPath, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);
+            Files.write(
+                    tempConfigPath,
+                    renderHoconString().getBytes(StandardCharsets.UTF_8),
+                    StandardOpenOption.SYNC, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING
+            );
+
+            Files.move(
+                    tempConfigPath,
+                    configPath,
+                    StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING
+            );
         } catch (IOException e) {
             throw new NodeConfigWriteException(
-                    ""Failed to write values "" + values + "" to config file."", e);
+                    ""Failed to write values to config file."", e);
         }
     }
 
     /**
      * Convert provided map to Hocon String representation.
      *
-     * @param values Values of configuration.
      * @return Configuration file string representation in HOCON format.
      */
-    private String renderHoconString(Map<String, ? extends Serializable> values) {
-        Map<String, Object> map = values.entrySet().stream().collect(Collectors.toMap(Entry::getKey, stringEntry -> {
-            Serializable value = stringEntry.getValue();
-            if (value.getClass().isArray()) {
-                return Arrays.asList((Object[]) value);
-            }
-            return value;
-        }));
-        Config other = ConfigFactory.parseMap(map);
-        Config newConfig = other.withFallback(parseConfigOptions()).resolve();
+    private String renderHoconString() {
+        // Super root that'll be filled from the storage data.
+        SuperRoot rootNode = generator.createSuperRoot();
+
+        fillFromPrefixMap(rootNode, toPrefixMap(latest));
+
+        Object transformed = rootNode.accept(null, new ConverterToMapVisitor(false, true));
+
+        ConfigValue conf = ConfigImpl.fromAnyRef(
+                transformed, null
+        );

Review Comment:
   Could be a single line I guess



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -56,99 +66,146 @@
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration tree generator. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService notificationsThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param generator Configuration tree generator.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, ConfigurationTreeGenerator generator) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.generator = generator;
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
         checkAndRestoreConfigFile();
     }
 
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                SuperRoot superRoot = generator.createSuperRoot();
+                SuperRoot copiedSuperRoot = superRoot.copy();
+
+                Config hocon = readHoconFromFile();
+                HoconConverter.hoconSource(hocon.root()).descend(copiedSuperRoot);
+
+                Map<String, Serializable> flattenedUpdatesMap = createFlattenedUpdatesMap(superRoot, copiedSuperRoot);
+                flattenedUpdatesMap.forEach((key, value) -> {
+                    if (value != null) { // filter defaults
+                        latest.put(key, value);
+                    }
+                });
+
+                return new Data(flattenedUpdatesMap, lastRevision);
+            } finally {
+                lock.writeLock().unlock();
+            }
+        });
+    }
+
+    private Config readHoconFromFile() {
+        checkAndRestoreConfigFile();
+
+        return ConfigFactory.parseFile(configPath.toFile(), ConfigParseOptions.defaults().setAllowMissing(false));
     }
 
     @Override
     public CompletableFuture<Map<String, ? extends Serializable>> readAllLatest(String prefix) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            Map<String, Serializable> map = latest.entrySet()
-                    .stream()
-                    .filter(entry -> entry.getKey().startsWith(prefix))
-                    .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
-            return CompletableFuture.completedFuture(map);
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {
+            lock.readLock().lock();
+            try {
+                return latest.entrySet()
+                        .stream()
+                        .filter(entry -> entry.getKey().startsWith(prefix))
+                        .collect(toMap(Entry::getKey, Entry::getValue));
+            } finally {
+                lock.readLock().unlock();
+            }
+        });
     }
 
     @Override
     public CompletableFuture<Serializable> readLatest(String key) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            return CompletableFuture.completedFuture(latest.get(key));
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {

Review Comment:
   Same here. Literally ""Map#get""



##########
modules/runner/src/test/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorageTest.java:
##########
@@ -17,75 +17,401 @@
 
 package org.apache.ignite.internal.configuration.storage;
 
-import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willBe;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.aMapWithSize;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.emptyString;
+import static org.hamcrest.Matchers.equalToCompressingWhiteSpace;
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.hasValue;
 import static org.hamcrest.Matchers.is;
 
 import java.io.IOException;
+import java.io.Serializable;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import org.apache.ignite.configuration.annotation.Config;
+import org.apache.ignite.configuration.annotation.ConfigurationRoot;
+import org.apache.ignite.configuration.annotation.NamedConfigValue;
+import org.apache.ignite.configuration.annotation.Value;
+import org.apache.ignite.internal.configuration.TestConfigurationChanger;
+import org.apache.ignite.internal.configuration.asm.ConfigurationAsmGenerator;
 import org.apache.ignite.internal.testframework.WorkDirectory;
 import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
-import org.junit.jupiter.api.Disabled;
+import org.hamcrest.Matchers;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
 
-/**
- * Tests for the {@link LocalFileConfigurationStorage}.
- */
+/** Test for local file configurations storage. */
 @ExtendWith(WorkDirectoryExtension.class)
-@Disabled(""https://issues.apache.org/jira/browse/IGNITE-19152"")
-public class LocalFileConfigurationStorageTest extends ConfigurationStorageTest {
+public class LocalFileConfigurationStorageTest {
 
     private static final String CONFIG_NAME = ""ignite-config.conf"";
 
+    private static ConfigurationAsmGenerator cgen;
+
     @WorkDirectory
     private Path tmpDir;
 
-    @Override
-    public ConfigurationStorage getStorage() {
-        return new LocalFileConfigurationStorage(getConfigFile());
+    /** Test configuration storage. */
+    private LocalFileConfigurationStorage storage;
+
+    /** Test configuration changer. */
+    private TestConfigurationChanger changer;
+
+    /** Instantiates {@link #cgen}. */
+    @BeforeAll
+    public static void beforeAll() {
+        cgen = new ConfigurationAsmGenerator();
+    }
+
+    /** Nullifies {@link #cgen} to prevent memory leak from having runtime ClassLoader accessible from GC root. */
+    @AfterAll
+    public static void afterAll() {
+        cgen = null;
+    }
+
+    private Path getConfigFile() {
+        return tmpDir.resolve(CONFIG_NAME);
+    }
+
+    @BeforeEach
+    void before() {
+        storage = new LocalFileConfigurationStorage(getConfigFile(), List.of(TopConfiguration.KEY));
+
+        changer = new TestConfigurationChanger(
+                cgen,
+                List.of(TopConfiguration.KEY),
+                Set.of(),
+                storage,
+                List.of(),
+                List.of()
+        );
+
+        changer.start();
+    }
+
+    @AfterEach
+    void after() {
+        changer.stop();
     }
 
     @Test
-    void testHocon() throws IOException {
-        // All of this is needed because write expects serializable values and only concrete classes are serializable
-        HashMap<String, ArrayList<String>> map = new HashMap<>(Map.of(""list"", new ArrayList<>(List.of(""val1"", ""val2""))));
-        var data = Map.of(""foo1"", ""bar1"", ""foo2"", ""bar2"", ""map"", map);
-
-        assertThat(storage.write(data, 0), willBe(true));
-
-        String contents = Files.readString(getConfigFile());
-
-        // \n instead of System.lineSeparator because Config library writes \n only
-        assertThat(contents, is(""foo1=bar1\n""
-                + ""foo2=bar2\n""
-                + ""map {\n""
-                + ""    list=[\n""
-                + ""        val1,\n""
-                + ""        val2\n""
-                + ""    ]\n""
-                + ""}\n""));
+    @DisplayName(""Default values are not added enriched on read when the config file is empty"")
+    void empty() throws IOException {
+        // Given
+        assertThat(configFileContent(), emptyString());
+
+        // When
+        var storageValues = readAllLatest();
+
+        // Then storage data only contains top level defaults
+        assertThat(storageValues.entrySet(), hasSize(1));
     }
 
     @Test
-    void testMergeHocon() throws IOException {
-        var data = Map.of(""foo1"", ""bar"");
-        assertThat(storage.write(data, 0), willBe(true));
+    @DisplayName(""Named list entities can be added"")
+    void add() throws Exception {
+        // Given
+        assertThat(configFileContent(), emptyString());
+        // And
+        var topConfiguration = (TopConfiguration) cgen.instantiateCfg(TopConfiguration.KEY, changer);
+        topConfiguration.namedList().change(b -> b.create(""name1"", x -> {
+            x.changeStrVal(""strVal1"");
+            x.changeIntVal(-1);
+        })).get();
+
+        // When
+        var storageValues = readAllLatest();
 
-        var append = Map.of(""foo1"", ""baz"", ""foo2"", ""bar"");
-        assertThat(storage.write(append, 1), willBe(true));
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(-1)));
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(""strVal1"")));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        }\n""

Review Comment:
   Just in case - I don't mind custom HOCON renderer. This format is kind-of trivial, and converting tree to string would only require a few days of coding, while there are multiple advantages, like the ability to inset comments or to preserve properties order.



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -56,99 +66,146 @@
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration tree generator. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService notificationsThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param generator Configuration tree generator.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, ConfigurationTreeGenerator generator) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.generator = generator;
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
         checkAndRestoreConfigFile();
     }
 
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                SuperRoot superRoot = generator.createSuperRoot();
+                SuperRoot copiedSuperRoot = superRoot.copy();
+
+                Config hocon = readHoconFromFile();
+                HoconConverter.hoconSource(hocon.root()).descend(copiedSuperRoot);
+
+                Map<String, Serializable> flattenedUpdatesMap = createFlattenedUpdatesMap(superRoot, copiedSuperRoot);
+                flattenedUpdatesMap.forEach((key, value) -> {
+                    if (value != null) { // filter defaults
+                        latest.put(key, value);
+                    }
+                });
+
+                return new Data(flattenedUpdatesMap, lastRevision);
+            } finally {
+                lock.writeLock().unlock();
+            }
+        });
+    }
+
+    private Config readHoconFromFile() {
+        checkAndRestoreConfigFile();
+
+        return ConfigFactory.parseFile(configPath.toFile(), ConfigParseOptions.defaults().setAllowMissing(false));
     }
 
     @Override
     public CompletableFuture<Map<String, ? extends Serializable>> readAllLatest(String prefix) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            Map<String, Serializable> map = latest.entrySet()
-                    .stream()
-                    .filter(entry -> entry.getKey().startsWith(prefix))
-                    .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
-            return CompletableFuture.completedFuture(map);
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {
+            lock.readLock().lock();
+            try {
+                return latest.entrySet()
+                        .stream()
+                        .filter(entry -> entry.getKey().startsWith(prefix))
+                        .collect(toMap(Entry::getKey, Entry::getValue));
+            } finally {
+                lock.readLock().unlock();
+            }
+        });
     }
 
     @Override
     public CompletableFuture<Serializable> readLatest(String key) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            return CompletableFuture.completedFuture(latest.get(key));
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {
+            lock.readLock().lock();
+            try {
+                return latest.get(key);
+            } finally {
+                lock.readLock().unlock();
+            }
+        });
     }
 
     @Override
     public CompletableFuture<Boolean> write(Map<String, ? extends Serializable> newValues, long ver) {
-        lock.writeLock().lock();
-        try {
-            if (ver != lastRevision) {
-                return CompletableFuture.completedFuture(false);
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                if (ver != lastRevision) {
+                    return false;
+                }
+
+                mergeAndSave(newValues);
+
+                sendNotificationAsync(new Data(newValues, lastRevision));
+
+                return true;
+            } finally {
+                lock.writeLock().unlock();
             }
-            checkAndRestoreConfigFile();
-            // TODO: https://issues.apache.org/jira/browse/IGNITE-19152
-            //saveValues(newValues);
-            latest.putAll(newValues);
-            lastRevision++;
-            runAsync(() -> lsnrRef.get().onEntriesChanged(new Data(newValues, lastRevision)));
-            return CompletableFuture.completedFuture(true);
-        } finally {
-            lock.writeLock().unlock();
-        }
+        });
     }
 
-    private void runAsync(Runnable runnable) {
-        CompletableFuture<Void> future = CompletableFuture.runAsync(runnable, threadPool);
+    private void mergeAndSave(Map<String, ? extends Serializable> newValues) {
+        updateLatestState(newValues);
+        saveConfigFile();
+        lastRevision++;
+    }
 
-        futureTracker.registerFuture(future);
+    private void updateLatestState(Map<String, ? extends Serializable> newValues) {
+        newValues.forEach((key, value) -> {
+            if (value == null) { // null means that we should remove this entry

Review Comment:
   Please don't ignore coding conventions :)



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -56,99 +66,146 @@
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration tree generator. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService notificationsThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param generator Configuration tree generator.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, ConfigurationTreeGenerator generator) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.generator = generator;
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
         checkAndRestoreConfigFile();
     }
 
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                SuperRoot superRoot = generator.createSuperRoot();
+                SuperRoot copiedSuperRoot = superRoot.copy();
+
+                Config hocon = readHoconFromFile();
+                HoconConverter.hoconSource(hocon.root()).descend(copiedSuperRoot);
+
+                Map<String, Serializable> flattenedUpdatesMap = createFlattenedUpdatesMap(superRoot, copiedSuperRoot);
+                flattenedUpdatesMap.forEach((key, value) -> {
+                    if (value != null) { // filter defaults
+                        latest.put(key, value);
+                    }
+                });
+
+                return new Data(flattenedUpdatesMap, lastRevision);
+            } finally {
+                lock.writeLock().unlock();
+            }
+        });
+    }
+
+    private Config readHoconFromFile() {
+        checkAndRestoreConfigFile();
+
+        return ConfigFactory.parseFile(configPath.toFile(), ConfigParseOptions.defaults().setAllowMissing(false));
     }
 
     @Override
     public CompletableFuture<Map<String, ? extends Serializable>> readAllLatest(String prefix) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            Map<String, Serializable> map = latest.entrySet()
-                    .stream()
-                    .filter(entry -> entry.getKey().startsWith(prefix))
-                    .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
-            return CompletableFuture.completedFuture(map);
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {
+            lock.readLock().lock();
+            try {
+                return latest.entrySet()
+                        .stream()
+                        .filter(entry -> entry.getKey().startsWith(prefix))
+                        .collect(toMap(Entry::getKey, Entry::getValue));
+            } finally {
+                lock.readLock().unlock();
+            }
+        });
     }
 
     @Override
     public CompletableFuture<Serializable> readLatest(String key) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            return CompletableFuture.completedFuture(latest.get(key));
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {
+            lock.readLock().lock();
+            try {
+                return latest.get(key);
+            } finally {
+                lock.readLock().unlock();
+            }
+        });
     }
 
     @Override
     public CompletableFuture<Boolean> write(Map<String, ? extends Serializable> newValues, long ver) {
-        lock.writeLock().lock();
-        try {
-            if (ver != lastRevision) {
-                return CompletableFuture.completedFuture(false);
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                if (ver != lastRevision) {
+                    return false;
+                }
+
+                mergeAndSave(newValues);
+
+                sendNotificationAsync(new Data(newValues, lastRevision));
+
+                return true;
+            } finally {
+                lock.writeLock().unlock();
             }
-            checkAndRestoreConfigFile();
-            // TODO: https://issues.apache.org/jira/browse/IGNITE-19152
-            //saveValues(newValues);
-            latest.putAll(newValues);
-            lastRevision++;
-            runAsync(() -> lsnrRef.get().onEntriesChanged(new Data(newValues, lastRevision)));
-            return CompletableFuture.completedFuture(true);
-        } finally {
-            lock.writeLock().unlock();
-        }
+        });
     }
 
-    private void runAsync(Runnable runnable) {
-        CompletableFuture<Void> future = CompletableFuture.runAsync(runnable, threadPool);
+    private void mergeAndSave(Map<String, ? extends Serializable> newValues) {
+        updateLatestState(newValues);
+        saveConfigFile();
+        lastRevision++;

Review Comment:
   New revision has been given to you as a parameter of ""write"" method. Why do you ignore it and increment the old revision instead? Please don't do that.



##########
modules/configuration/src/main/java/org/apache/ignite/internal/configuration/ConfigurationRegistry.java:
##########
@@ -96,8 +83,11 @@ public class ConfigurationRegistry implements IgniteComponent, ConfigurationStor
     /** Configuration change handler. */
     private final ConfigurationChanger changer;
 
-    /** Configuration generator. */
-    private final ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();
+    /** Runtime implementations generator for node classes. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Flag that indicates if the {@link ConfigurationTreeGenerator} instance is owned by this object or not. */
+    private boolean ownConfigTreeGenerator = false;

Review Comment:
   Why does it matter?
   I believe that generator can always be a constructor parameter, and another component, that instantiated it, should also close it in the end



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -56,99 +66,146 @@
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration tree generator. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService notificationsThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param generator Configuration tree generator.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, ConfigurationTreeGenerator generator) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.generator = generator;
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
         checkAndRestoreConfigFile();
     }
 
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return async(() -> {

Review Comment:
   What's the deal with doing it asynchronously? It's a node start routine, we can do it in current thread I guess?
   Please comment



##########
modules/configuration/src/test/java/org/apache/ignite/internal/configuration/ConfigurationChangerTest.java:
##########
@@ -113,13 +112,13 @@ public static class ThirdConfigurationSchema {
         public String strCfg;
     }
 
-    private static ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();
+    private static ConfigurationTreeGenerator generator = new ConfigurationTreeGenerator(List.of(KEY, DefaultsConfiguration.KEY));

Review Comment:
   Maybe this test-only constructor should use vararg, for convenience



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -56,99 +66,146 @@
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration tree generator. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService notificationsThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param generator Configuration tree generator.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, ConfigurationTreeGenerator generator) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.generator = generator;
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
         checkAndRestoreConfigFile();
     }
 
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                SuperRoot superRoot = generator.createSuperRoot();
+                SuperRoot copiedSuperRoot = superRoot.copy();
+
+                Config hocon = readHoconFromFile();
+                HoconConverter.hoconSource(hocon.root()).descend(copiedSuperRoot);
+
+                Map<String, Serializable> flattenedUpdatesMap = createFlattenedUpdatesMap(superRoot, copiedSuperRoot);
+                flattenedUpdatesMap.forEach((key, value) -> {
+                    if (value != null) { // filter defaults
+                        latest.put(key, value);
+                    }
+                });
+
+                return new Data(flattenedUpdatesMap, lastRevision);
+            } finally {
+                lock.writeLock().unlock();
+            }
+        });
+    }
+
+    private Config readHoconFromFile() {
+        checkAndRestoreConfigFile();
+
+        return ConfigFactory.parseFile(configPath.toFile(), ConfigParseOptions.defaults().setAllowMissing(false));
     }
 
     @Override
     public CompletableFuture<Map<String, ? extends Serializable>> readAllLatest(String prefix) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            Map<String, Serializable> map = latest.entrySet()
-                    .stream()
-                    .filter(entry -> entry.getKey().startsWith(prefix))
-                    .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
-            return CompletableFuture.completedFuture(map);
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {
+            lock.readLock().lock();
+            try {
+                return latest.entrySet()
+                        .stream()
+                        .filter(entry -> entry.getKey().startsWith(prefix))
+                        .collect(toMap(Entry::getKey, Entry::getValue));
+            } finally {
+                lock.readLock().unlock();
+            }
+        });
     }
 
     @Override
     public CompletableFuture<Serializable> readLatest(String key) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            return CompletableFuture.completedFuture(latest.get(key));
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {
+            lock.readLock().lock();
+            try {
+                return latest.get(key);
+            } finally {
+                lock.readLock().unlock();
+            }
+        });
     }
 
     @Override
     public CompletableFuture<Boolean> write(Map<String, ? extends Serializable> newValues, long ver) {
-        lock.writeLock().lock();
-        try {
-            if (ver != lastRevision) {
-                return CompletableFuture.completedFuture(false);
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                if (ver != lastRevision) {
+                    return false;
+                }
+
+                mergeAndSave(newValues);
+
+                sendNotificationAsync(new Data(newValues, lastRevision));
+
+                return true;
+            } finally {
+                lock.writeLock().unlock();
             }
-            checkAndRestoreConfigFile();
-            // TODO: https://issues.apache.org/jira/browse/IGNITE-19152
-            //saveValues(newValues);
-            latest.putAll(newValues);
-            lastRevision++;
-            runAsync(() -> lsnrRef.get().onEntriesChanged(new Data(newValues, lastRevision)));
-            return CompletableFuture.completedFuture(true);
-        } finally {
-            lock.writeLock().unlock();
-        }
+        });
     }
 
-    private void runAsync(Runnable runnable) {
-        CompletableFuture<Void> future = CompletableFuture.runAsync(runnable, threadPool);
+    private void mergeAndSave(Map<String, ? extends Serializable> newValues) {
+        updateLatestState(newValues);
+        saveConfigFile();
+        lastRevision++;
+    }
 
-        futureTracker.registerFuture(future);
+    private void updateLatestState(Map<String, ? extends Serializable> newValues) {
+        newValues.forEach((key, value) -> {
+            if (value == null) { // null means that we should remove this entry

Review Comment:
   ```suggestion
               if (value == null) { // Null means that we should remove this entry.
   ```



##########
modules/runner/src/test/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorageTest.java:
##########
@@ -17,75 +17,457 @@
 
 package org.apache.ignite.internal.configuration.storage;
 
-import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willBe;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.aMapWithSize;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.emptyString;
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.equalToCompressingWhiteSpace;
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.hasValue;
 import static org.hamcrest.Matchers.is;
 
 import java.io.IOException;
+import java.io.Serializable;
+import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import org.apache.ignite.configuration.annotation.Config;
+import org.apache.ignite.configuration.annotation.ConfigValue;
+import org.apache.ignite.configuration.annotation.ConfigurationRoot;
+import org.apache.ignite.configuration.annotation.NamedConfigValue;
+import org.apache.ignite.configuration.annotation.Value;
+import org.apache.ignite.internal.configuration.ConfigurationTreeGenerator;
+import org.apache.ignite.internal.configuration.TestConfigurationChanger;
 import org.apache.ignite.internal.testframework.WorkDirectory;
 import org.apache.ignite.internal.testframework.WorkDirectoryExtension;
-import org.junit.jupiter.api.Disabled;
+import org.hamcrest.Matchers;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
 
-/**
- * Tests for the {@link LocalFileConfigurationStorage}.
- */
+/** Test for local file configurations storage. */
 @ExtendWith(WorkDirectoryExtension.class)
-@Disabled(""https://issues.apache.org/jira/browse/IGNITE-19152"")
-public class LocalFileConfigurationStorageTest extends ConfigurationStorageTest {
+//TODO: https://issues.apache.org/jira/browse/IGNITE-19303
+public class LocalFileConfigurationStorageTest {
 
     private static final String CONFIG_NAME = ""ignite-config.conf"";
 
+    private static ConfigurationTreeGenerator treeGenerator;
+
     @WorkDirectory
     private Path tmpDir;
 
-    @Override
-    public ConfigurationStorage getStorage() {
-        return new LocalFileConfigurationStorage(getConfigFile());
+    private LocalFileConfigurationStorage storage;
+
+    private TestConfigurationChanger changer;
+
+    @BeforeAll
+    public static void beforeAll() {
+        treeGenerator = new ConfigurationTreeGenerator(
+                List.of(TopConfiguration.KEY, TopEmptyConfiguration.KEY)
+        );
+    }
+
+    @AfterAll
+    public static void afterAll() throws Exception {
+        treeGenerator.close();
+    }
+
+    private Path getConfigFile() {
+        return tmpDir.resolve(CONFIG_NAME);
+    }
+
+    @BeforeEach
+    void before() {
+        storage = new LocalFileConfigurationStorage(getConfigFile(), treeGenerator);
+
+        changer = new TestConfigurationChanger(
+                List.of(TopConfiguration.KEY),
+                Set.of(),
+                storage,
+                treeGenerator
+        );
+
+        changer.start();
+    }
+
+    @AfterEach
+    void after() {
+        changer.stop();
+    }
+
+
+    /** Default values are not enriched on read when the config file is empty. */
+    @Test
+    void empty() throws IOException {
+        // Given
+        assertThat(configFileContent(), emptyString());
+
+        // When
+        var storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues.entrySet(), hasSize(0));
+    }
+
+    /** Named list entities can be added. */
+    @Test
+    void add() throws Exception {
+        // Given
+        assertThat(configFileContent(), emptyString());
+
+        // And
+        var topConfiguration = (TopConfiguration) treeGenerator.instantiateCfg(TopConfiguration.KEY, changer);
+
+        topConfiguration.namedList().change(b -> b.create(""name1"", x -> {
+            x.changeStrVal(""strVal1"");
+            x.changeIntVal(-1);
+        })).get();
+
+        // When
+        var storageValues = readAllLatest();
+
+        // Then the map has updated values
+        //
+        // top.namedList.<generatedUUID>.strVal  -> strVal1
+        // top.namedList.<generatedUUID>.intVal  -> -1
+        // top.namedList.<generatedUUID>.<name>  -> name1
+        // top.namedList.<ids>.name1             -> ""<generatedUUID>""
+        // top.namedList.<generatedUUID>.<order> -> 0
+
+        assertThat(storageValues, allOf(aMapWithSize(5), hasValue(-1)));
+        assertThat(storageValues, allOf(aMapWithSize(5), hasValue(""strVal1"")));
+
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""}""
+        ));
+
+        // When
+        topConfiguration.namedList().change(b -> b.create(""name2"", x -> {
+            x.changeStrVal(""strVal2"");
+            x.changeIntVal(-2);
+        })).get();
+        // And
+        storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(10), hasValue(-2)));
+        assertThat(storageValues, allOf(aMapWithSize(10), hasValue(""strVal2"")));
+        // And
+        assertThat(storageValues, allOf(aMapWithSize(10), hasValue(-1)));
+        assertThat(storageValues, allOf(aMapWithSize(10), hasValue(""strVal1"")));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        },\n""
+                        + ""        {\n""
+                        + ""            intVal=-2\n""
+                        + ""            name=name2\n""
+                        + ""            strVal=strVal2\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""}\n""
+        ));
+    }
+
+    /** Update values. */
+    @Test
+    void update() throws Exception {
+        // Given
+        assertThat(configFileContent(), emptyString());
+
+        // When
+        var topConfiguration = (TopConfiguration) treeGenerator.instantiateCfg(TopConfiguration.KEY, changer);
+
+        topConfiguration.shortVal().update((short) 3).get();
+        // And
+        var storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(1), hasValue((short) 3)));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    shortVal=3\n""
+                        + ""}\n""
+        ));
+
+        // When create named list entity with defaults
+        topConfiguration.namedList().change(b -> b.create(""name1"", x -> {
+        })).get();
+        // And
+        storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(1)));
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(""foo"")));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=foo\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=3\n""
+                        + ""}""
+        ));
+
+        // When update named list entity
+        topConfiguration.namedList().change(b -> b.update(""name1"", x -> {
+            x.changeStrVal(""strVal1"");
+            x.changeIntVal(-1);
+        })).get();
+        // And
+        storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(-1)));
+        assertThat(storageValues, allOf(aMapWithSize(6), hasValue(""strVal1"")));
+        // And
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=3\n""
+                        + ""}""
+        ));
     }
 
+    /** Remove values. */
     @Test
-    void testHocon() throws IOException {
-        // All of this is needed because write expects serializable values and only concrete classes are serializable
-        HashMap<String, ArrayList<String>> map = new HashMap<>(Map.of(""list"", new ArrayList<>(List.of(""val1"", ""val2""))));
-        var data = Map.of(""foo1"", ""bar1"", ""foo2"", ""bar2"", ""map"", map);
-
-        assertThat(storage.write(data, 0), willBe(true));
-
-        String contents = Files.readString(getConfigFile());
-
-        // \n instead of System.lineSeparator because Config library writes \n only
-        assertThat(contents, is(""foo1=bar1\n""
-                + ""foo2=bar2\n""
-                + ""map {\n""
-                + ""    list=[\n""
-                + ""        val1,\n""
-                + ""        val2\n""
+    void remove() throws Exception {
+        // Given
+        var topConfiguration = (TopConfiguration) treeGenerator.instantiateCfg(TopConfiguration.KEY, changer);
+
+        topConfiguration.namedList().change(b -> {
+            b.create(""name1"", x -> {
+                x.changeStrVal(""strVal1"");
+                x.changeIntVal(-1);
+            });
+            b.create(""name2"", x -> {
+                x.changeStrVal(""strVal2"");
+                x.changeIntVal(-2);
+            });
+        }).get();
+
+        topConfiguration.shortVal().update((short) 3).get();
+        // And values are saved to file
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        },\n""
+                        + ""        {\n""
+                        + ""            intVal=-2\n""
+                        + ""            name=name2\n""
+                        + ""            strVal=strVal2\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=3\n""
+                        + ""}\n""
+        ));
+
+        // When remove named list entity
+        topConfiguration.namedList().change(b -> b.delete(""name1"")).get();
+        // And
+        var storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(6), Matchers.not(hasValue(""strVal1""))));
+        // And entity removed from file
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-2\n""
+                        + ""            name=name2\n""
+                        + ""            strVal=strVal2\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""    shortVal=3\n""
+                        + ""}\n""
+        ));
+
+        // When remove the last entity
+        topConfiguration.namedList().change(b -> b.delete(""name2"")).get();
+        // And
+        storageValues = readAllLatest();
+
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(1), hasValue((short) 3)));
+        // And entity removed from file
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    shortVal=3\n""
+                        + ""}\n""
+        ));
+    }
+
+    /** Delete file before read on recovery. */
+    @Test
+    void deleteFileBeforeReadOnRecovery() throws IOException {
+        // Given
+        Files.delete(getConfigFile());
+
+        // When
+        var storageValues = storage.readDataOnRecovery().join().values();
+
+        // Then
+        assertThat(storageValues.entrySet(), hasSize(0));
+        // And empty file was created
+        assertThat(configFileContent(), equalTo(""""));
+    }
+
+
+    /** File content is not changed when read data on recovery. */
+    @Test
+    void fileContentIsNotChanged() throws IOException {
+        // Given
+        String fileContent = ""top {\n""
+                + ""    namedList=[\n""
+                + ""        {\n""
+                + ""            intVal=-1\n""
+                + ""            name=name1\n""
+                + ""        }\n""
                 + ""    ]\n""
-                + ""}\n""));
+                + ""}\n"";
+
+        Files.write(getConfigFile(), fileContent.getBytes(StandardCharsets.UTF_8));
+
+        // When
+        var storageValues = storage.readDataOnRecovery().join().values();
+        // Then
+        assertThat(storageValues, allOf(aMapWithSize(5), hasValue(-1)));
+        assertThat(storageValues, allOf(aMapWithSize(5), hasValue(""foo""))); // default value
+        // And file was not changed
+        assertThat(configFileContent(), equalTo(fileContent));
     }
 
+    /** Delete file before read all. */
     @Test
-    void testMergeHocon() throws IOException {
-        var data = Map.of(""foo1"", ""bar"");
-        assertThat(storage.write(data, 0), willBe(true));
+    void deleteFileBeforeReadAll() throws Exception {
+        // Given
+        Files.delete(getConfigFile());
+
+        // When
+        var storageValues = readAllLatest();
 
-        var append = Map.of(""foo1"", ""baz"", ""foo2"", ""bar"");
-        assertThat(storage.write(append, 1), willBe(true));
+        // Then
+        assertThat(storageValues.entrySet(), hasSize(0));
+        // And there is no file
+        assertThat(Files.exists(getConfigFile()), is(false));
 
-        String contents = Files.readString(getConfigFile());
-        assertThat(contents, is(""foo1=baz\n""
-                + ""foo2=bar\n""));
+        // When update configuration
+        var topConfiguration = (TopConfiguration) treeGenerator.instantiateCfg(TopConfiguration.KEY, changer);
+        topConfiguration.namedList().change(b -> b.create(""name1"", x -> {
+            x.changeStrVal(""strVal1"");
+            x.changeIntVal(-1);
+        })).get();
+
+        // Then file is created
+        assertThat(configFileContent(), equalToCompressingWhiteSpace(
+                ""top {\n""
+                        + ""    namedList=[\n""
+                        + ""        {\n""
+                        + ""            intVal=-1\n""
+                        + ""            name=name1\n""
+                        + ""            strVal=strVal1\n""
+                        + ""        }\n""
+                        + ""    ]\n""
+                        + ""}\n""
+        ));
     }
 
-    private Path getConfigFile() {
-        return tmpDir.resolve(CONFIG_NAME);
+    /** Read configuration when inner node configured with partial content (some fields are empty). */
+    @Test
+    void innerNodeWithPartialContent() throws Exception {
+        String content = ""top: { inner.boolVal: true }"";
+        Files.write(getConfigFile(), content.getBytes(StandardCharsets.UTF_8));
+
+        storage.readDataOnRecovery().get();

Review Comment:
   Should we assert the size of the map?



;20/Apr/23 07:56;githubbot;600","PakhomovAlexander commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1172222071


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/configuration/ItSslConfigurationValidationTest.java:
##########
@@ -34,6 +35,7 @@
  * Integration test for checking SSL configuration validation.
  */
 @ExtendWith(WorkDirectoryExtension.class)
+@Disabled(""https://issues.apache.org/jira/browse/IGNITE-19315"")

Review Comment:
   Sure, it has ""Critical"" priority. Will work on it asap.



;20/Apr/23 08:00;githubbot;600","PakhomovAlexander commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1172233823


##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -56,99 +66,146 @@
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration tree generator. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService notificationsThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param generator Configuration tree generator.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, ConfigurationTreeGenerator generator) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.generator = generator;
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
         checkAndRestoreConfigFile();
     }
 
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                SuperRoot superRoot = generator.createSuperRoot();
+                SuperRoot copiedSuperRoot = superRoot.copy();
+
+                Config hocon = readHoconFromFile();
+                HoconConverter.hoconSource(hocon.root()).descend(copiedSuperRoot);
+
+                Map<String, Serializable> flattenedUpdatesMap = createFlattenedUpdatesMap(superRoot, copiedSuperRoot);
+                flattenedUpdatesMap.forEach((key, value) -> {
+                    if (value != null) { // filter defaults
+                        latest.put(key, value);
+                    }
+                });
+
+                return new Data(flattenedUpdatesMap, lastRevision);
+            } finally {
+                lock.writeLock().unlock();
+            }
+        });
+    }
+
+    private Config readHoconFromFile() {
+        checkAndRestoreConfigFile();
+
+        return ConfigFactory.parseFile(configPath.toFile(), ConfigParseOptions.defaults().setAllowMissing(false));
     }
 
     @Override
     public CompletableFuture<Map<String, ? extends Serializable>> readAllLatest(String prefix) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            Map<String, Serializable> map = latest.entrySet()
-                    .stream()
-                    .filter(entry -> entry.getKey().startsWith(prefix))
-                    .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
-            return CompletableFuture.completedFuture(map);
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {
+            lock.readLock().lock();
+            try {
+                return latest.entrySet()
+                        .stream()
+                        .filter(entry -> entry.getKey().startsWith(prefix))
+                        .collect(toMap(Entry::getKey, Entry::getValue));
+            } finally {
+                lock.readLock().unlock();
+            }
+        });
     }
 
     @Override
     public CompletableFuture<Serializable> readLatest(String key) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            return CompletableFuture.completedFuture(latest.get(key));
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {
+            lock.readLock().lock();
+            try {
+                return latest.get(key);
+            } finally {
+                lock.readLock().unlock();
+            }
+        });
     }
 
     @Override
     public CompletableFuture<Boolean> write(Map<String, ? extends Serializable> newValues, long ver) {
-        lock.writeLock().lock();
-        try {
-            if (ver != lastRevision) {
-                return CompletableFuture.completedFuture(false);
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                if (ver != lastRevision) {
+                    return false;
+                }
+
+                mergeAndSave(newValues);
+
+                sendNotificationAsync(new Data(newValues, lastRevision));
+
+                return true;
+            } finally {
+                lock.writeLock().unlock();
             }
-            checkAndRestoreConfigFile();
-            // TODO: https://issues.apache.org/jira/browse/IGNITE-19152
-            //saveValues(newValues);
-            latest.putAll(newValues);
-            lastRevision++;
-            runAsync(() -> lsnrRef.get().onEntriesChanged(new Data(newValues, lastRevision)));
-            return CompletableFuture.completedFuture(true);
-        } finally {
-            lock.writeLock().unlock();
-        }
+        });
     }
 
-    private void runAsync(Runnable runnable) {
-        CompletableFuture<Void> future = CompletableFuture.runAsync(runnable, threadPool);
+    private void mergeAndSave(Map<String, ? extends Serializable> newValues) {
+        updateLatestState(newValues);
+        saveConfigFile();
+        lastRevision++;
+    }
 
-        futureTracker.registerFuture(future);
+    private void updateLatestState(Map<String, ? extends Serializable> newValues) {
+        newValues.forEach((key, value) -> {
+            if (value == null) { // null means that we should remove this entry

Review Comment:
   I don't really get you. Here is what I can see in the [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines#CodingGuidelines-Commentedoutcode)
   
   ""All comments should follow English grammar and punctuation including starting with an upper-case letter and ending with '.'.""
   
   Could you share the link to the coding conventions you are talking about?



;20/Apr/23 08:10;githubbot;600","PakhomovAlexander commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1172363042


##########
modules/configuration/src/main/java/org/apache/ignite/internal/configuration/ConfigurationManager.java:
##########
@@ -40,6 +31,30 @@ public class ConfigurationManager implements IgniteComponent {
     /** Configuration registry. */
     private final ConfigurationRegistry registry;
 
+    /**
+     * Constructor.
+     *
+     * @param rootKeys                    Configuration root keys.
+     * @param validators                  Validators.
+     * @param storage                     Configuration storage.
+     * @param generator                   Configuration tree generator.
+     * @throws IllegalArgumentException If the configuration type of the root keys is not equal to the storage type, or if the schema or its
+     *                                  extensions are not valid.
+     */
+    public ConfigurationManager(

Review Comment:
   Yes, there is a reason for that. `ConfigurationManager` now gives two constructors like:
   
   1) You can provide `ConfigurationTreeGenerator` with `LocalConfigurationStorage` (that is dependent on `ConfigurationTreeGenerator`)
   2) You can provide lists of roots and extensions with `DistributedConfgurationStorage`(that is NOT dependent on `ConfigurationTreeGenerator`) 
   
   Does it make sense? 



;20/Apr/23 09:57;githubbot;600","PakhomovAlexander commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1172368128


##########
modules/configuration/src/main/java/org/apache/ignite/internal/configuration/ConfigurationRegistry.java:
##########
@@ -96,8 +83,11 @@ public class ConfigurationRegistry implements IgniteComponent, ConfigurationStor
     /** Configuration change handler. */
     private final ConfigurationChanger changer;
 
-    /** Configuration generator. */
-    private final ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();
+    /** Runtime implementations generator for node classes. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Flag that indicates if the {@link ConfigurationTreeGenerator} instance is owned by this object or not. */
+    private boolean ownConfigTreeGenerator = false;

Review Comment:
   ""I believe that generator can always be a constructor parameter"" ;20/Apr/23 10:01;githubbot;600","PakhomovAlexander commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1172392160


##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -56,99 +66,146 @@
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration tree generator. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService notificationsThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param generator Configuration tree generator.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, ConfigurationTreeGenerator generator) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.generator = generator;
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
         checkAndRestoreConfigFile();
     }
 
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return async(() -> {

Review Comment:
   I am not a fan of declaring the interface as an async (through CompletableFutures) but running the code in the same thread where the future is returned. What is the reason to use futures then? 
   
   But I can agree with you in this particular case.



;20/Apr/23 10:25;githubbot;600","PakhomovAlexander commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1172396136


##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -56,99 +66,146 @@
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration tree generator. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService notificationsThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param generator Configuration tree generator.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, ConfigurationTreeGenerator generator) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.generator = generator;
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
         checkAndRestoreConfigFile();
     }
 
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                SuperRoot superRoot = generator.createSuperRoot();
+                SuperRoot copiedSuperRoot = superRoot.copy();
+
+                Config hocon = readHoconFromFile();
+                HoconConverter.hoconSource(hocon.root()).descend(copiedSuperRoot);
+
+                Map<String, Serializable> flattenedUpdatesMap = createFlattenedUpdatesMap(superRoot, copiedSuperRoot);
+                flattenedUpdatesMap.forEach((key, value) -> {
+                    if (value != null) { // filter defaults
+                        latest.put(key, value);
+                    }
+                });
+
+                return new Data(flattenedUpdatesMap, lastRevision);
+            } finally {
+                lock.writeLock().unlock();
+            }
+        });
+    }
+
+    private Config readHoconFromFile() {
+        checkAndRestoreConfigFile();
+
+        return ConfigFactory.parseFile(configPath.toFile(), ConfigParseOptions.defaults().setAllowMissing(false));
     }
 
     @Override
     public CompletableFuture<Map<String, ? extends Serializable>> readAllLatest(String prefix) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            Map<String, Serializable> map = latest.entrySet()
-                    .stream()
-                    .filter(entry -> entry.getKey().startsWith(prefix))
-                    .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
-            return CompletableFuture.completedFuture(map);
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {
+            lock.readLock().lock();
+            try {
+                return latest.entrySet()
+                        .stream()
+                        .filter(entry -> entry.getKey().startsWith(prefix))
+                        .collect(toMap(Entry::getKey, Entry::getValue));
+            } finally {
+                lock.readLock().unlock();
+            }
+        });
     }
 
     @Override
     public CompletableFuture<Serializable> readLatest(String key) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            return CompletableFuture.completedFuture(latest.get(key));
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {
+            lock.readLock().lock();
+            try {
+                return latest.get(key);
+            } finally {
+                lock.readLock().unlock();
+            }
+        });
     }
 
     @Override
     public CompletableFuture<Boolean> write(Map<String, ? extends Serializable> newValues, long ver) {
-        lock.writeLock().lock();
-        try {
-            if (ver != lastRevision) {
-                return CompletableFuture.completedFuture(false);
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                if (ver != lastRevision) {
+                    return false;
+                }
+
+                mergeAndSave(newValues);
+
+                sendNotificationAsync(new Data(newValues, lastRevision));
+
+                return true;
+            } finally {
+                lock.writeLock().unlock();
             }
-            checkAndRestoreConfigFile();
-            // TODO: https://issues.apache.org/jira/browse/IGNITE-19152
-            //saveValues(newValues);
-            latest.putAll(newValues);
-            lastRevision++;
-            runAsync(() -> lsnrRef.get().onEntriesChanged(new Data(newValues, lastRevision)));
-            return CompletableFuture.completedFuture(true);
-        } finally {
-            lock.writeLock().unlock();
-        }
+        });
     }
 
-    private void runAsync(Runnable runnable) {
-        CompletableFuture<Void> future = CompletableFuture.runAsync(runnable, threadPool);
+    private void mergeAndSave(Map<String, ? extends Serializable> newValues) {
+        updateLatestState(newValues);
+        saveConfigFile();
+        lastRevision++;
+    }
 
-        futureTracker.registerFuture(future);
+    private void updateLatestState(Map<String, ? extends Serializable> newValues) {
+        newValues.forEach((key, value) -> {
+            if (value == null) { // null means that we should remove this entry

Review Comment:
   Sorry, did not mentioned that it is your suggestion (though it is my code).



;20/Apr/23 10:29;githubbot;600","PakhomovAlexander commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1172404883


##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -56,99 +66,146 @@
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration tree generator. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService notificationsThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param generator Configuration tree generator.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, ConfigurationTreeGenerator generator) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.generator = generator;
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
         checkAndRestoreConfigFile();
     }
 
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                SuperRoot superRoot = generator.createSuperRoot();
+                SuperRoot copiedSuperRoot = superRoot.copy();
+
+                Config hocon = readHoconFromFile();
+                HoconConverter.hoconSource(hocon.root()).descend(copiedSuperRoot);
+
+                Map<String, Serializable> flattenedUpdatesMap = createFlattenedUpdatesMap(superRoot, copiedSuperRoot);
+                flattenedUpdatesMap.forEach((key, value) -> {
+                    if (value != null) { // filter defaults
+                        latest.put(key, value);
+                    }
+                });
+
+                return new Data(flattenedUpdatesMap, lastRevision);
+            } finally {
+                lock.writeLock().unlock();
+            }
+        });
+    }
+
+    private Config readHoconFromFile() {
+        checkAndRestoreConfigFile();
+
+        return ConfigFactory.parseFile(configPath.toFile(), ConfigParseOptions.defaults().setAllowMissing(false));
     }
 
     @Override
     public CompletableFuture<Map<String, ? extends Serializable>> readAllLatest(String prefix) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            Map<String, Serializable> map = latest.entrySet()
-                    .stream()
-                    .filter(entry -> entry.getKey().startsWith(prefix))
-                    .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
-            return CompletableFuture.completedFuture(map);
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {
+            lock.readLock().lock();
+            try {
+                return latest.entrySet()
+                        .stream()
+                        .filter(entry -> entry.getKey().startsWith(prefix))
+                        .collect(toMap(Entry::getKey, Entry::getValue));
+            } finally {
+                lock.readLock().unlock();
+            }
+        });
     }
 
     @Override
     public CompletableFuture<Serializable> readLatest(String key) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            return CompletableFuture.completedFuture(latest.get(key));
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {
+            lock.readLock().lock();
+            try {
+                return latest.get(key);
+            } finally {
+                lock.readLock().unlock();
+            }
+        });
     }
 
     @Override
     public CompletableFuture<Boolean> write(Map<String, ? extends Serializable> newValues, long ver) {
-        lock.writeLock().lock();
-        try {
-            if (ver != lastRevision) {
-                return CompletableFuture.completedFuture(false);
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                if (ver != lastRevision) {
+                    return false;
+                }
+
+                mergeAndSave(newValues);
+
+                sendNotificationAsync(new Data(newValues, lastRevision));
+
+                return true;
+            } finally {
+                lock.writeLock().unlock();
             }
-            checkAndRestoreConfigFile();
-            // TODO: https://issues.apache.org/jira/browse/IGNITE-19152
-            //saveValues(newValues);
-            latest.putAll(newValues);
-            lastRevision++;
-            runAsync(() -> lsnrRef.get().onEntriesChanged(new Data(newValues, lastRevision)));
-            return CompletableFuture.completedFuture(true);
-        } finally {
-            lock.writeLock().unlock();
-        }
+        });
     }
 
-    private void runAsync(Runnable runnable) {
-        CompletableFuture<Void> future = CompletableFuture.runAsync(runnable, threadPool);
+    private void mergeAndSave(Map<String, ? extends Serializable> newValues) {
+        updateLatestState(newValues);
+        saveConfigFile();
+        lastRevision++;

Review Comment:
   I don't get you.  Here is the part of the `write` method that verifies the version is the same. How it can be ""new"" revision?
   
   ```java
               if (ver != lastRevision) {
                   return CompletableFuture.completedFuture(false);
               }
   ```



;20/Apr/23 10:37;githubbot;600","ibessonov commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1173861249


##########
modules/configuration/src/main/java/org/apache/ignite/internal/configuration/ConfigurationManager.java:
##########
@@ -40,6 +31,30 @@ public class ConfigurationManager implements IgniteComponent {
     /** Configuration registry. */
     private final ConfigurationRegistry registry;
 
+    /**
+     * Constructor.
+     *
+     * @param rootKeys                    Configuration root keys.
+     * @param validators                  Validators.
+     * @param storage                     Configuration storage.
+     * @param generator                   Configuration tree generator.
+     * @throws IllegalArgumentException If the configuration type of the root keys is not equal to the storage type, or if the schema or its
+     *                                  extensions are not valid.
+     */
+    public ConfigurationManager(

Review Comment:
   Ok, I don't mind it, but it's always weird to see multiple constructors



;21/Apr/23 14:43;githubbot;600","ibessonov commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1173865056


##########
modules/configuration/src/main/java/org/apache/ignite/internal/configuration/ConfigurationRegistry.java:
##########
@@ -96,8 +83,11 @@ public class ConfigurationRegistry implements IgniteComponent, ConfigurationStor
     /** Configuration change handler. */
     private final ConfigurationChanger changer;
 
-    /** Configuration generator. */
-    private final ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();
+    /** Runtime implementations generator for node classes. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Flag that indicates if the {@link ConfigurationTreeGenerator} instance is owned by this object or not. */
+    private boolean ownConfigTreeGenerator = false;

Review Comment:
   I don't think I understand the answer. Let me rephrase myself.
   Why do you need a flag ""ownConfigTreeGenerator""? It can be removed, right?
   Second question - why do you need a ""close"" method in the generator? I don't see a reason to have it, other than writing `cgen.close()` instead of `cgen = null` in some tests. Can you please explain your decision?



;21/Apr/23 14:46;githubbot;600","ibessonov commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1173868324


##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -56,99 +66,146 @@
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration tree generator. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService notificationsThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param generator Configuration tree generator.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, ConfigurationTreeGenerator generator) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.generator = generator;
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
         checkAndRestoreConfigFile();
     }
 
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return async(() -> {

Review Comment:
   Reason for using the future is that there are multiple implementations. Some of them cannot physically be synchronous, otherwise they would block thread for unknown period of time



;21/Apr/23 14:49;githubbot;600","ibessonov commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1173869063


##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -56,99 +66,146 @@
 public class LocalFileConfigurationStorage implements ConfigurationStorage {
     private static final IgniteLogger LOG = Loggers.forClass(LocalFileConfigurationStorage.class);
 
-    /**
-     * Path to config file.
-     */
+    /** Path to config file. */
     private final Path configPath;
 
-    /**
-     * Path to temporary configuration storage.
-     */
+    /** Path to temporary configuration storage. */
     private final Path tempConfigPath;
 
+    /** R/W lock to guard the latest configuration and config file. */
     private final ReadWriteLock lock = new ReentrantReadWriteLock();
 
-    /**
-     * Latest state of last applied configuration.
-     */
+    /** Latest state of last applied configuration. */
     private final Map<String, Serializable> latest = new ConcurrentHashMap<>();
 
-    /**
-     *  Configuration changes listener.
-     *  */
+    /** Configuration tree generator. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Configuration changes listener. */
     private final AtomicReference<ConfigurationStorageListener> lsnrRef = new AtomicReference<>();
 
-    private final ExecutorService threadPool = Executors.newFixedThreadPool(2, new NamedThreadFactory(""loc-cfg-file"", LOG));
+    /** Thread pool for configuration updates notifications. */
+    private final ExecutorService notificationsThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file"", LOG)
+    );
+
+    /** Thread pool for configuration updates. */
+    private final ExecutorService workerThreadPool = Executors.newFixedThreadPool(
+            2, new NamedThreadFactory(""cfg-file-worker"", LOG)
+    );
 
+    /** Tracks all running futures. */
     private final InFlightFutures futureTracker = new InFlightFutures();
 
+    /** Last revision for configuration. */
     private long lastRevision = 0L;
 
     /**
      * Constructor.
      *
      * @param configPath Path to node bootstrap configuration file.
+     * @param generator Configuration tree generator.
      */
-    public LocalFileConfigurationStorage(Path configPath) {
+    public LocalFileConfigurationStorage(Path configPath, ConfigurationTreeGenerator generator) {
         this.configPath = configPath;
-        tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+        this.generator = generator;
+        this.tempConfigPath = configPath.resolveSibling(configPath.getFileName() + "".tmp"");
+
         checkAndRestoreConfigFile();
     }
 
     @Override
     public CompletableFuture<Data> readDataOnRecovery() {
-        return CompletableFuture.completedFuture(new Data(Collections.emptyMap(), 0));
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                SuperRoot superRoot = generator.createSuperRoot();
+                SuperRoot copiedSuperRoot = superRoot.copy();
+
+                Config hocon = readHoconFromFile();
+                HoconConverter.hoconSource(hocon.root()).descend(copiedSuperRoot);
+
+                Map<String, Serializable> flattenedUpdatesMap = createFlattenedUpdatesMap(superRoot, copiedSuperRoot);
+                flattenedUpdatesMap.forEach((key, value) -> {
+                    if (value != null) { // filter defaults
+                        latest.put(key, value);
+                    }
+                });
+
+                return new Data(flattenedUpdatesMap, lastRevision);
+            } finally {
+                lock.writeLock().unlock();
+            }
+        });
+    }
+
+    private Config readHoconFromFile() {
+        checkAndRestoreConfigFile();
+
+        return ConfigFactory.parseFile(configPath.toFile(), ConfigParseOptions.defaults().setAllowMissing(false));
     }
 
     @Override
     public CompletableFuture<Map<String, ? extends Serializable>> readAllLatest(String prefix) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            Map<String, Serializable> map = latest.entrySet()
-                    .stream()
-                    .filter(entry -> entry.getKey().startsWith(prefix))
-                    .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
-            return CompletableFuture.completedFuture(map);
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {
+            lock.readLock().lock();
+            try {
+                return latest.entrySet()
+                        .stream()
+                        .filter(entry -> entry.getKey().startsWith(prefix))
+                        .collect(toMap(Entry::getKey, Entry::getValue));
+            } finally {
+                lock.readLock().unlock();
+            }
+        });
     }
 
     @Override
     public CompletableFuture<Serializable> readLatest(String key) {
-        lock.readLock().lock();
-        try {
-            checkAndRestoreConfigFile();
-            return CompletableFuture.completedFuture(latest.get(key));
-        } finally {
-            lock.readLock().unlock();
-        }
+        return async(() -> {
+            lock.readLock().lock();
+            try {
+                return latest.get(key);
+            } finally {
+                lock.readLock().unlock();
+            }
+        });
     }
 
     @Override
     public CompletableFuture<Boolean> write(Map<String, ? extends Serializable> newValues, long ver) {
-        lock.writeLock().lock();
-        try {
-            if (ver != lastRevision) {
-                return CompletableFuture.completedFuture(false);
+        return async(() -> {
+            lock.writeLock().lock();
+            try {
+                if (ver != lastRevision) {
+                    return false;
+                }
+
+                mergeAndSave(newValues);
+
+                sendNotificationAsync(new Data(newValues, lastRevision));
+
+                return true;
+            } finally {
+                lock.writeLock().unlock();
             }
-            checkAndRestoreConfigFile();
-            // TODO: https://issues.apache.org/jira/browse/IGNITE-19152
-            //saveValues(newValues);
-            latest.putAll(newValues);
-            lastRevision++;
-            runAsync(() -> lsnrRef.get().onEntriesChanged(new Data(newValues, lastRevision)));
-            return CompletableFuture.completedFuture(true);
-        } finally {
-            lock.writeLock().unlock();
-        }
+        });
     }
 
-    private void runAsync(Runnable runnable) {
-        CompletableFuture<Void> future = CompletableFuture.runAsync(runnable, threadPool);
+    private void mergeAndSave(Map<String, ? extends Serializable> newValues) {
+        updateLatestState(newValues);
+        saveConfigFile();
+        lastRevision++;

Review Comment:
   Ok, thank you, this means that I'm stupid, there are no problems here.



;21/Apr/23 14:50;githubbot;600","ibessonov commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1173870250


##########
modules/configuration/src/main/java/org/apache/ignite/internal/configuration/util/ConfigurationFlattener.java:
##########
@@ -136,6 +136,8 @@ public Void doVisitInnerNode(String key, InnerNode newNode) {
                 return null;
             }
 
+            // in case inner node is null in both trees,

Review Comment:
   I think I mentioned guidelines somewhere, but I'll repeat. First letter is capitalizes, sentence ends with a dot. This is how we should write comments.



##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -147,49 +139,40 @@ private Config readHoconFromFile() {
 
     @Override
     public CompletableFuture<Map<String, ? extends Serializable>> readAllLatest(String prefix) {
-        return async(() -> {
-            lock.readLock().lock();
-            try {
-                return latest.entrySet()
-                        .stream()
-                        .filter(entry -> entry.getKey().startsWith(prefix))
-                        .collect(toMap(Entry::getKey, Entry::getValue));
-            } finally {
-                lock.readLock().unlock();
-            }
-        });
+        lock.readLock().lock();
+        try {
+            return CompletableFuture.completedFuture(
+                    latest.entrySet()
+                            .stream()
+                            .filter(entry -> entry.getKey().startsWith(prefix))
+                            .collect(toMap(Entry::getKey, Entry::getValue))
+            );
+        } finally {
+            lock.readLock().unlock();
+        }
     }
 
     @Override
     public CompletableFuture<Serializable> readLatest(String key) {
-        return async(() -> {
-            lock.readLock().lock();
-            try {
-                return latest.get(key);
-            } finally {
-                lock.readLock().unlock();
-            }
-        });
+        return CompletableFuture.completedFuture(latest.get(key));

Review Comment:
   Why have you removed the read-lock? Technically, you lost the property of the data being ""latest"". By that I mean that two consecutive calls can return newer value first, and older value next, if you ask them not in the order that they are being inserted in ""write"" at the same time. Read lock would save you from such problems.
   Please be careful in such places and don't forget about broader invariants.



##########
modules/runner/src/test/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorageTest.java:
##########
@@ -413,10 +411,12 @@ void deleteFileBeforeReadAll() throws Exception {
     /** Read configuration when inner node configured with partial content (some fields are empty). */
     @Test
     void innerNodeWithPartialContent() throws Exception {
+        // Given
         String content = ""top: { inner.boolVal: true }"";
         Files.write(getConfigFile(), content.getBytes(StandardCharsets.UTF_8));
 
-        storage.readDataOnRecovery().get();
+        // Expect
+        assertThat(storage.readDataOnRecovery().get().values(), allOf(aMapWithSize(1)));

Review Comment:
   Any reason to have ""allOf"" for a single matcher?



;21/Apr/23 15:00;githubbot;600","PakhomovAlexander commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1176136589


##########
modules/configuration/src/main/java/org/apache/ignite/internal/configuration/ConfigurationRegistry.java:
##########
@@ -96,8 +83,11 @@ public class ConfigurationRegistry implements IgniteComponent, ConfigurationStor
     /** Configuration change handler. */
     private final ConfigurationChanger changer;
 
-    /** Configuration generator. */
-    private final ConfigurationAsmGenerator cgen = new ConfigurationAsmGenerator();
+    /** Runtime implementations generator for node classes. */
+    private final ConfigurationTreeGenerator generator;
+
+    /** Flag that indicates if the {@link ConfigurationTreeGenerator} instance is owned by this object or not. */
+    private boolean ownConfigTreeGenerator = false;

Review Comment:
   Technically you are right, we might write `cgen = null`. But this is something hidden. How developers might know that they should nullify the link because we don't want them to hold the link and produce memory leaks? 
   
   I decided to move this contract into the place where contracts are defined – the interface. I think a clear declaration of `close` method helps developers to understand how to work with the object.



;25/Apr/23 07:48;githubbot;600","PakhomovAlexander commented on code in PR #1929:
URL: https://github.com/apache/ignite-3/pull/1929#discussion_r1176140252


##########
modules/runner/src/main/java/org/apache/ignite/internal/configuration/storage/LocalFileConfigurationStorage.java:
##########
@@ -147,49 +139,40 @@ private Config readHoconFromFile() {
 
     @Override
     public CompletableFuture<Map<String, ? extends Serializable>> readAllLatest(String prefix) {
-        return async(() -> {
-            lock.readLock().lock();
-            try {
-                return latest.entrySet()
-                        .stream()
-                        .filter(entry -> entry.getKey().startsWith(prefix))
-                        .collect(toMap(Entry::getKey, Entry::getValue));
-            } finally {
-                lock.readLock().unlock();
-            }
-        });
+        lock.readLock().lock();
+        try {
+            return CompletableFuture.completedFuture(
+                    latest.entrySet()
+                            .stream()
+                            .filter(entry -> entry.getKey().startsWith(prefix))
+                            .collect(toMap(Entry::getKey, Entry::getValue))
+            );
+        } finally {
+            lock.readLock().unlock();
+        }
     }
 
     @Override
     public CompletableFuture<Serializable> readLatest(String key) {
-        return async(() -> {
-            lock.readLock().lock();
-            try {
-                return latest.get(key);
-            } finally {
-                lock.readLock().unlock();
-            }
-        });
+        return CompletableFuture.completedFuture(latest.get(key));

Review Comment:
   Thank you for the clarification, I misunderstood the `latest` meaning. My fault.



;25/Apr/23 07:51;githubbot;600","PakhomovAlexander opened a new pull request, #1988:
URL: https://github.com/apache/ignite-3/pull/1988

   Now the node configuration file is read on node start and updated together with the internal configuration.


;26/Apr/23 14:27;githubbot;600","PakhomovAlexander commented on PR #1988:
URL: https://github.com/apache/ignite-3/pull/1988#issuecomment-1523519147

   Something weird is happening with the GitHub, I've duplicated the PR https://github.com/apache/ignite-3/pull/1929.


;26/Apr/23 14:27;githubbot;600","PakhomovAlexander closed pull request #1929: IGNITE-19152 Use schema information in LocalFileConfigurationStorage
URL: https://github.com/apache/ignite-3/pull/1929


;26/Apr/23 14:28;githubbot;600","PakhomovAlexander merged PR #1988:
URL: https://github.com/apache/ignite-3/pull/1988


;26/Apr/23 16:02;githubbot;600",,,,,,,,,,,,,,,,,,,,0,16200,,,0,16200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-19280,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Apr 26 16:05:45 UTC 2023,,,,,,,,,,"0|z1gxoo:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"26/Apr/23 16:05;aleksandr.pakhomov;Merged into main: b48ddcba7cd2bd3b9a053ae131c25b44a0400e27;;;",,,,,
ClientInboundMessageHandler memory leak,IGNITE-19143,13530419,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,28/Mar/23 12:14,29/Mar/23 07:50,13/Jul/23 09:11,29/Mar/23 04:32,3.0.0-beta1,,,,,,,3.0.0-beta2,thin client,,,0,ignite-3,,,"*AssignmentsChangeListener* is leaked by *ClientInboundMessageHandler*. Each of the following two lines allocate new object implementing Consumer interface, so unsubscribe does not work as expected:

{code:java}
igniteTables.addAssignmentsChangeListener(this::onPartitionAssignmentChanged);
igniteTables.removeAssignmentsChangeListener(this::onPartitionAssignmentChanged);
{code}",,isapego,ptupitsyn,,,,"ptupitsyn merged PR #1852:
URL: https://github.com/apache/ignite-3/pull/1852


;29/Mar/23 04:31;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19151,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Mar 29 04:32:02 UTC 2023,,,,,,,,,,"0|z1gwrs:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"28/Mar/23 12:23;ptupitsyn;[~isapego] please review.;;;","28/Mar/23 14:24;isapego;Looks good.;;;","29/Mar/23 04:32;ptupitsyn;Merged to main: 54b4317d738a1ee7c91b2f128a38d3fdd90ddb14;;;",,,
IncomingSnapshotCopier.cancel() blocks forever if called from multiple threads,IGNITE-19142,13530416,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,rpuch,rpuch,rpuch,28/Mar/23 11:46,28/Mar/23 18:40,13/Jul/23 09:11,28/Mar/23 17:10,,,,,,,,,,,,0,ignite-3,,,"One of the test runs hang forever. Thread dump and process state analysis shown the following:
 # Some thread A invoked IncomingSnapshotCopier.cancel() (twice) on the same copier, which made its busyLock block any operations
 # Another thread B, trying to process an InstallSnapshotRequest, found that the leader has changed (probably, due to the cluster being shut down) and triggered 'interrupt download snapshots'
 # As a result, this thread B called IncomingSnapshotCopier.cancel() on the same copier, but its busyLock.block() (which internally just takes a write lock) blocks this thread forever (as the lock is taken by thread A on step 1)
 # Before trying to cancel the snapshot downloading, thread B took Node.writeLock. As the thread is now blocked forever, it cannot release it, so every operation on the JRaft Node is blocked, including shutdown
 # So the cluster hangs forever on stop, making the tests hang forever as well

We should make IncomingSnapshotCopier.cancel() idempotent even when called from different threads.",,rpuch,sdanilov,,,,"rpuch opened a new pull request, #1851:
URL: https://github.com/apache/ignite-3/pull/1851

   https://issues.apache.org/jira/browse/IGNITE-19142


;28/Mar/23 12:03;githubbot;600","SammyVimes commented on code in PR #1851:
URL: https://github.com/apache/ignite-3/pull/1851#discussion_r1150799805


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/raft/snapshot/incoming/IncomingSnapshotCopier.java:
##########
@@ -151,6 +155,11 @@ public void join() throws InterruptedException {
 
     @Override
     public void cancel() {
+        // Cancellation from one thread must not block cancellations from other threads. hence this check.

Review Comment:
   ```suggestion
           // Cancellation from one thread must not block cancellations from other threads, hence this check.
   ```



;28/Mar/23 15:27;githubbot;600","SammyVimes merged PR #1851:
URL: https://github.com/apache/ignite-3/pull/1851


;28/Mar/23 17:09;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"28/Mar/23 11:47;rpuch;threads_report.txt;https://issues.apache.org/jira/secure/attachment/13056859/threads_report.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Mar 28 18:40:33 UTC 2023,,,,,,,,,,"0|z1gwr4:",9223372036854775807,,,sdanilov,,,,,,,,,,,,,,,,,,"28/Mar/23 15:07;rpuch;[~sdanilov] could you please take a look at the attached PR?;;;","28/Mar/23 17:10;sdanilov;The patch looks good to me. Thank you for the contribution, merged to the main branch.;;;","28/Mar/23 18:40;rpuch;Thanks!;;;",,,
Node failes on rebalance during deactivation,IGNITE-19141,13530411,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,alex_pl,alex_pl,alex_pl,28/Mar/23 11:22,31/Mar/23 07:30,13/Jul/23 09:11,31/Mar/23 07:30,,,,,,,,2.15,,,,0,ise,,,"Failure handler triggered if caches is stopped (for example, due to deactivation) and node is processing partitions supply message. Reproducer:
{code:java}
@Override protected FailureHandler getFailureHandler(String igniteInstanceName) {
    return new StopNodeFailureHandler();
}

@Test
public void testRebalanceOnDeactivate() throws Exception {
    IgniteEx ignite0 = startGrid(0);
    IgniteEx ignite1 = startGrid(1);
    ignite0.cluster().state(ClusterState.ACTIVE);
    ignite0.cluster().baselineAutoAdjustEnabled(false);

    for (int i = 0; i < 10; i++) {
        IgniteCache<Integer, Integer> cache = ignite0.getOrCreateCache(
            new CacheConfiguration<Integer, Integer>(DEFAULT_CACHE_NAME).setBackups(1)
                .setAffinity(new RendezvousAffinityFunction(false, 2)));

        cache.clear();

        stopGrid(0);

        try (IgniteDataStreamer<Integer, Integer> streamer = ignite1.dataStreamer(DEFAULT_CACHE_NAME)) {
            for (int j = 0; j < 100_000; j++)
                streamer.addData(j, j);
        }

        ignite0 = startGrid(0);

        ignite0.cluster().state(ClusterState.INACTIVE);

        ignite0.cluster().state(ClusterState.ACTIVE);
    }
}{code}
 Fails with:
{noformat}
 java.lang.AssertionError: stopping=false, groupName=null, caches=[]
    at org.apache.ignite.internal.processors.cache.CacheGroupContext.singleCacheContext(CacheGroupContext.java:447) ~[classes/:?]
    at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPartitionDemander.handleSupplyMessage(GridDhtPartitionDemander.java:584) ~[classes/:?]
    at org.apache.ignite.internal.processors.cache.distributed.dht.preloader.GridDhtPreloader.lambda$handleSupplyMessage$0(GridDhtPreloader.java:346) ~[classes/:?]{noformat}",,alex_pl,ignitetcbot,slava.koptilin,,,"alex-plekhanov opened a new pull request, #10613:
URL: https://github.com/apache/ignite/pull/10613

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;28/Mar/23 15:25;githubbot;600","asfgit closed pull request #10613: IGNITE-19141 Fix node failure on rebalancing during caches stop
URL: https://github.com/apache/ignite/pull/10613


;31/Mar/23 07:29;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Fri Mar 31 07:30:44 UTC 2023,,,,,,,,,,"0|z1gwq0:",9223372036854775807,Fixed node failure on rebalancing during caches stop,,,,,,,,,,,,,,,,,,,,"31/Mar/23 07:20;ignitetcbot;{panel:title=Branch: [pull/10613/head] Base: [master] : Possible Blockers (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}
{color:#d04437}Thin client: Node.js{color} [[tests 0 Exit Code |https://ci2.ignite.apache.org/viewLog.html?buildId=7117745]]

{panel}
{panel:title=Branch: [pull/10613/head] Base: [master] : New Tests (8)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}PDS 4{color} [[tests 8|https://ci2.ignite.apache.org/viewLog.html?buildId=7113837]]
* {color:#013220}IgnitePdsTestSuite4: IgniteRebalanceRepeatingCacheStopTest.testRebalanceOnCacheStop[sharedGroup=false, persistence=false] - PASSED{color}
* {color:#013220}IgnitePdsTestSuite4: IgniteRebalanceRepeatingCacheStopTest.testRebalanceOnCacheStop[sharedGroup=true, persistence=false] - PASSED{color}
* {color:#013220}IgnitePdsTestSuite4: IgniteRebalanceRepeatingCacheStopTest.testRebalanceOnDeactivate[sharedGroup=false, persistence=true] - PASSED{color}
* {color:#013220}IgnitePdsTestSuite4: IgniteRebalanceRepeatingCacheStopTest.testRebalanceOnCacheStop[sharedGroup=false, persistence=true] - PASSED{color}
* {color:#013220}IgnitePdsTestSuite4: IgniteRebalanceRepeatingCacheStopTest.testRebalanceOnDeactivate[sharedGroup=false, persistence=false] - PASSED{color}
* {color:#013220}IgnitePdsTestSuite4: IgniteRebalanceRepeatingCacheStopTest.testRebalanceOnDeactivate[sharedGroup=true, persistence=true] - PASSED{color}
* {color:#013220}IgnitePdsTestSuite4: IgniteRebalanceRepeatingCacheStopTest.testRebalanceOnCacheStop[sharedGroup=true, persistence=true] - PASSED{color}
* {color:#013220}IgnitePdsTestSuite4: IgniteRebalanceRepeatingCacheStopTest.testRebalanceOnDeactivate[sharedGroup=true, persistence=false] - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7111800&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","31/Mar/23 07:21;alex_pl;Node.js thin client failure related to some type of infrastructure problems (thin clients not affected anyhow by this patch):
{noformat}
Missing write access to /data/tcAgent/work/7a5058913152b6a6/ignite-nodejs-thin-client/node_modules/apache-ignite-client{noformat};;;","31/Mar/23 07:30;alex_pl;[~av], thanks for the review! Merged to master.;;;",,,
Handling timeout on waiting for replica readiness,IGNITE-19136,13530392,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,v.pyatkov,v.pyatkov,v.pyatkov,28/Mar/23 09:55,09/Jun/23 20:46,13/Jul/23 09:11,08/Jun/23 21:26,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"*Motivation*
There are several reasons by the replica can respond _ReplicaNotReadyException_ (storage recovery has not completed yet, indexes have not created). In this case, required sending AwaitReplicaRequest and don't try requesting any more until AwaitReplicaResponse doesn't be received.

But the reason is not obvious when we receive a timeout on waiting for the replica readiness. The result is an exception, which is easy to confuse with that we don't try handling _ReplicaNotReadyException_:
{noformat}
Replica is not ready [replicationGroupId=474283c9-a39e-431a-895f-751003052d7a_part_10, nodeName=irott_n_1]
  at app//org.apache.ignite.internal.replicator.ReplicaManager.sendReplicaUnavailableErrorResponse(ReplicaManager.java:385)
  at app//org.apache.ignite.internal.replicator.ReplicaManager.onReplicaMessageReceived(ReplicaManager.java:167)
  at app//org.apache.ignite.network.DefaultMessagingService.onMessage(DefaultMessagingService.java:358)
  at app//org.apache.ignite.network.DefaultMessagingService.lambda$onMessage$3(DefaultMessagingService.java:314)
  at java.base@11.0.17/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
  at java.base@11.0.17/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
  at java.base@11.0.17/java.lang.Thread.run(Thread.java:834)
{noformat}

*Definition of Done*
A message that describes the situation where we cannot wait for replica for timeout.
{noformat}
Could not wait for the replica become ready for the timeout [replicationGroupId=474283c9-a39e-431a-895f-751003052d7a_part_10, nodeName=irott_n_1, timeout=3000]
{noformat}
",,v.pyatkov,,,,,"vldpyatkov opened a new pull request, #2144:
URL: https://github.com/apache/ignite-3/pull/2144

   (no comment)


;05/Jun/23 12:29;githubbot;600","denis-chudov commented on code in PR #2144:
URL: https://github.com/apache/ignite-3/pull/2144#discussion_r1222598525


##########
modules/replicator/src/main/java/org/apache/ignite/internal/replicator/ReplicaService.java:
##########
@@ -127,17 +127,27 @@ private <R> CompletableFuture<R> sendToReplica(String targetNodeConsistentId, Re
                             pendingInvokes.remove(targetNodeConsistentId, awaitReplicaFut);
 
                             if (throwable0 != null) {
-                                if (throwable0 instanceof CompletionException) {
-                                    throwable0 = throwable0.getCause();
-                                }
+                                throwable0 = unwrapCause(throwable0);
 
                                 if (throwable0 instanceof TimeoutException) {
-                                    res.completeExceptionally(errResp.throwable());
+                                    res.completeExceptionally(withCause(
+                                            ReplicationException::new,
+                                            REPLICA_TIMEOUT_ERR,
+                                            format(
+                                                    ""Could not wait for the replica readiness for the timeout [replicaGroupId={}, req={}]"",

Review Comment:
   ```suggestion
                                                       ""Could not wait for the replica readiness due to timeout [replicaGroupId={}, req={}]"",
   ```



;08/Jun/23 08:29;githubbot;600","vldpyatkov merged PR #2144:
URL: https://github.com/apache/ignite-3/pull/2144


;08/Jun/23 15:22;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jun 08 21:26:10 UTC 2023,,,,,,,,,,"0|z1gwls:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"08/Jun/23 21:26;v.pyatkov;Merged 3f071eb8332864f2b72a2d38a3f16b6cb69a9ed3;;;",,,,,
Sql. Custom data types. IgniteIndexScan has incorrect types in searchBounds. ,IGNITE-19128,13530254,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,mzhuravkov,mzhuravkov,mzhuravkov,27/Mar/23 14:03,01/Jun/23 11:11,13/Jul/23 09:11,03/May/23 10:48,3.0.0-beta2,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"IgniteIndexScanNode has incorrect types in its search bounds although the filter has correct types in it condition.
Example:

{code:java}
 @Test
  public void test() {
        sql(""CREATE TABLE tx (id INTEGER PRIMARY KEY, test_key UUID)"");
        sql(""INSERT INTO tx VALUES(1, ?)"", new UUID(2, 0));
        sql(""CREATE INDEX tx_test_key_idx ON tx (test_key)"");
        String query = format(
                ""SELECT * FROM tx WHERE test_key > '{}'::UUID AND test_key < '{}'::UUID ORDER BY id"",
                new UUID(1, 0), new UUID(3, 0)
        );
        sql(query);
    }
{code}

Error:

{code:java}
Caused by: java.lang.AssertionError: storageType is class java.util.UUID value must also be class java.util.UUID but it was: 00000000-0000-0001-0000-000000000001
	at org.apache.ignite.internal.sql.engine.util.SafeCustomTypeInternalConversion.tryConvertFromInternal(SafeCustomTypeInternalConversion.java:72)
	at org.apache.ignite.internal.sql.engine.util.TypeUtils.fromInternal(TypeUtils.java:330)
	at org.apache.ignite.internal.sql.engine.exec.RowConverter.toByteBuffer(RowConverter.java:141)
	at org.apache.ignite.internal.sql.engine.exec.RowConverter.toBinaryTuplePrefix(RowConverter.java:85)
	at org.apache.ignite.internal.sql.engine.exec.rel.IndexScanNode.toBinaryTuplePrefix(IndexScanNode.java:208)
	at org.apache.ignite.internal.sql.engine.exec.rel.IndexScanNode.partitionPublisher(IndexScanNode.java:146)
{code}

Plan:

{code:java}
IgniteExchange(distribution=[single]), id = 344
  IgniteSort(sort0=[$0], dir0=[ASC]), id = 343
    IgniteIndexScan(table=[[PUBLIC, TX]], index=[TX_TEST_KEY_IDX], type=[SORTED], searchBounds=[[RangeBounds [lowerBound=_UTF-8'00000000-0000-0001-0000-000000000000', upperBound=_UTF-8'00000000-0000-0003-0000-000000000000', lowerInclude=false, upperInclude=false]]], filters=[AND(>($t1, CAST(_UTF-8'00000000-0000-0001-0000-000000000000'):UUID NOT NULL), <($t1, CAST(_UTF-8'00000000-0000-0003-0000-000000000000'):UUID NOT NULL))], requiredColumns=[{0, 1}], collation=[[1]]), id = 326
{code}

But the following works:

{code:java}
 @Test
 public void test2() {
     sql(""CREATE TABLE tx (id INTEGER PRIMARY KEY, test_key UUID)"");
     sql(""INSERT INTO tx VALUES(1, ?)"", new UUID(2, 0));
     sql(""CREATE INDEX tx_test_key_idx ON tx (test_key)"");
     sql(""SELECT * FROM tx WHERE test_key > ? AND test_key < ? ORDER BY id"", new UUID(1, 0), new UUID(3, 0));
 }
{code}

Working Plan:


{code:java}
IgniteExchange(distribution=[single]), id = 291
  IgniteSort(sort0=[$0], dir0=[ASC]), id = 290
    IgniteIndexScan(table=[[PUBLIC, TX]], index=[TX_TEST_KEY_IDX], type=[SORTED], searchBounds=[[RangeBounds [lowerBound=?0, upperBound=?1, lowerInclude=false, upperInclude=false]]], filters=[AND(>($t1, ?0), <($t1, ?1))], requiredColumns=[{0, 1}], collation=[[1]]), id = 273
{code}



",,mzhuravkov,,,,,"AMashenkov merged PR #1981:
URL: https://github.com/apache/ignite-3/pull/1981


;03/May/23 10:47;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,IGNITE-19615,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-03-27 14:03:33.0,,,,,,,,,,"0|z1gvrc:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
Sql. Custom data types. Fix type inference in the presence of nullable types.,IGNITE-19127,13530251,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,mzhuravkov,mzhuravkov,mzhuravkov,27/Mar/23 13:35,03/May/23 08:32,13/Jul/23 09:11,31/Mar/23 12:38,3.0.0-beta2,,,,,,,,sql,,,0,ignite-3,,,"Nullable types are least restrictive than non-nullable types. This is not true for custom data types and should be fixed.
",,mzhuravkov,zstan,,,,"zstan merged PR #1845:
URL: https://github.com/apache/ignite-3/pull/1845


;31/Mar/23 12:38;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Mar 31 12:38:56 UTC 2023,,,,,,,,,,"0|z1gvqo:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"31/Mar/23 12:38;zstan;[~mzhuravkov] thanks for your effort, merged.;;;",,,,,
Make ItTableRaftSnapshotsTest less invasive,IGNITE-19126,13530235,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,rpuch,rpuch,rpuch,27/Mar/23 11:26,10/Apr/23 13:06,13/Jul/23 09:11,10/Apr/23 09:33,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"The current approach to make sure a follower does not get any logs entries from the leader is to drop messages. This approach is too invasive (as some other code might rely on those messages); also, it will stop working after IGNITE-18712.

We should either drop only the vare minimum of the messages, or switch to stopping a node to make sure it does not get log entries.",,rpuch,sdanilov,,,,"rpuch opened a new pull request, #1913:
URL: https://github.com/apache/ignite-3/pull/1913

   https://issues.apache.org/jira/browse/IGNITE-19126


;06/Apr/23 11:18;githubbot;600","SammyVimes merged PR #1913:
URL: https://github.com/apache/ignite-3/pull/1913


;10/Apr/23 09:33;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,IGNITE-18712,,,,,,,,,,,,,,,,,,,IGNITE-19121,IGNITE-19088,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Apr 10 13:06:32 UTC 2023,,,,,,,,,,"0|z1gvn4:",9223372036854775807,,,sdanilov,,,,,,,,,,,,,,,,,,"27/Mar/23 11:32;rpuch;The test suite uses 'drop all messages to a node' to make sure that the node does not receive any RAFT log updates from the leader. This is generally not correct as our network is designed to either deliver a message or make sure that the recipient never receives any messages (if it was detected to have been left).

The correct way would be to only drop ActionRequest messages.;;;","06/Apr/23 12:49;rpuch;[~sdanilov] could you please take a look at the attached PR?;;;","10/Apr/23 09:33;sdanilov;Thank you for the contribution. The patch looks good to me, merged to the main branch.;;;","10/Apr/23 13:06;rpuch;Thanks!;;;",,
Future returned by a dropped message send is never completed,IGNITE-19121,13530196,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,rpuch,rpuch,rpuch,27/Mar/23 07:59,27/Mar/23 13:34,13/Jul/23 09:11,27/Mar/23 12:16,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,This causes problems like IGNITE-19088. We should return a completed future without sending the message.,,rpuch,,,,,"rpuch opened a new pull request, #1841:
URL: https://github.com/apache/ignite-3/pull/1841

   https://issues.apache.org/jira/browse/IGNITE-19121


;27/Mar/23 08:02;githubbot;600","ibessonov merged PR #1841:
URL: https://github.com/apache/ignite-3/pull/1841


;27/Mar/23 13:34;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19088,IGNITE-19126,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-03-27 07:59:36.0,,,,,,,,,,"0|z1gveg:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
Sql. UPDATE statement fails with NPE when table does not exist,IGNITE-19116,13529847,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,xtern,mzhuravkov,mzhuravkov,23/Mar/23 18:05,12/Apr/23 19:55,13/Jul/23 09:11,12/Apr/23 19:55,3.0.0-beta2,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"UPDATE statement fails with NPE when table does not exist.
{code:java}
@Test
public void test() {
   sql(""UPDATE unknown SET j = j + 1"");
}
{code}

Error:
{code:java}
java.lang.NullPointerException
	at org.apache.ignite.internal.sql.engine.prepare.IgniteSqlValidator.createSourceSelectForUpdate(IgniteSqlValidator.java:175)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.performUnconditionalRewrites(SqlValidatorImpl.java:1476)
	at org.apache.ignite.internal.sql.engine.prepare.IgniteSqlValidator.performUnconditionalRewrites(IgniteSqlValidator.java:383)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateScopedExpression(SqlValidatorImpl.java:1046)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validate(SqlValidatorImpl.java:759)
	at org.apache.ignite.internal.sql.engine.prepare.IgniteSqlValidator.validate(IgniteSqlValidator.java:135)
	at org.apache.ignite.internal.sql.engine.prepare.IgnitePlanner.validate(IgnitePlanner.java:189)
{code}

*Expected behavoir*

It should return throw objectNotFound error:

{code:java}
Object 'UNKNOWN' not found
{code}

",,mzhuravkov,xtern,,,,"korlov42 commented on code in PR #1917:
URL: https://github.com/apache/ignite-3/pull/1917#discussion_r1161517225


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteSqlValidator.java:
##########
@@ -210,10 +212,12 @@ protected SqlSelect createSourceSelectForDelete(SqlDelete call) {
         final SqlNodeList selectList = new SqlNodeList(SqlParserPos.ZERO);
         final SqlValidatorTable table = getCatalogReader().getTable(((SqlIdentifier) call.getTargetTable()).names);
 
-        table.unwrap(IgniteTable.class).descriptor().deleteRowType((IgniteTypeFactory) typeFactory)
-                .getFieldNames().stream()
-                .map(name -> new SqlIdentifier(name, SqlParserPos.ZERO))
-                .forEach(selectList::add);
+        if (table != null) {

Review Comment:
   it's unclear why the table may be null at this point. Besides, you're returning incorrect result here



;10/Apr/23 07:50;githubbot;600","xtern commented on code in PR #1917:
URL: https://github.com/apache/ignite-3/pull/1917#discussion_r1162339032


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteSqlValidator.java:
##########
@@ -210,10 +212,12 @@ protected SqlSelect createSourceSelectForDelete(SqlDelete call) {
         final SqlNodeList selectList = new SqlNodeList(SqlParserPos.ZERO);
         final SqlValidatorTable table = getCatalogReader().getTable(((SqlIdentifier) call.getTargetTable()).names);
 
-        table.unwrap(IgniteTable.class).descriptor().deleteRowType((IgniteTypeFactory) typeFactory)
-                .getFieldNames().stream()
-                .map(name -> new SqlIdentifier(name, SqlParserPos.ZERO))
-                .forEach(selectList::add);
+        if (table != null) {

Review Comment:
   Thanks, reworked a bit.



;11/Apr/23 06:06;githubbot;600","zstan commented on code in PR #1917:
URL: https://github.com/apache/ignite-3/pull/1917#discussion_r1162409001


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteSqlValidator.java:
##########
@@ -169,6 +169,10 @@ protected SqlSelect createSourceSelectForUpdate(SqlUpdate call) {
         final SqlIdentifier targetTable = (SqlIdentifier) call.getTargetTable();
         final SqlValidatorTable table = getCatalogReader().getTable(targetTable.names);
 
+        if (table == null) {
+            throw newValidationError(call.getTargetTable(), RESOURCE.objectNotFound(targetTable.toString()));

Review Comment:
   more clear to use : RESOURCE.tableNotFound ? I see that it throws not SqlValidatorException and additional fix possibly required, wdyt ? Also - is it correct to throw not wrapped calcite exception in public api, probably we need to mention some already defined issue here ?



;11/Apr/23 07:31;githubbot;600","xtern commented on code in PR #1917:
URL: https://github.com/apache/ignite-3/pull/1917#discussion_r1162425316


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteSqlValidator.java:
##########
@@ -169,6 +169,10 @@ protected SqlSelect createSourceSelectForUpdate(SqlUpdate call) {
         final SqlIdentifier targetTable = (SqlIdentifier) call.getTargetTable();
         final SqlValidatorTable table = getCatalogReader().getTable(targetTable.names);
 
+        if (table == null) {
+            throw newValidationError(call.getTargetTable(), RESOURCE.objectNotFound(targetTable.toString()));

Review Comment:
   > I see that it throws not SqlValidatorException and additional fix possibly required,
   Thanks, but I'm not fully understand your suggestion.
   
   For example for select * from unknown calcite throws CalciteContextException caused by.SqlValidatorException.
   And the same behavior here:
   ```
   CalciteContextException: From line 1, column 8 to line 1, column 14: Object 'UNKNOWN' not found
   ...
   Caused by: org.apache.calcite.sql.validate.SqlValidatorException: Object 'UNKNOWN' not found
   ```



;11/Apr/23 07:46;githubbot;600","xtern commented on code in PR #1917:
URL: https://github.com/apache/ignite-3/pull/1917#discussion_r1162425316


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteSqlValidator.java:
##########
@@ -169,6 +169,10 @@ protected SqlSelect createSourceSelectForUpdate(SqlUpdate call) {
         final SqlIdentifier targetTable = (SqlIdentifier) call.getTargetTable();
         final SqlValidatorTable table = getCatalogReader().getTable(targetTable.names);
 
+        if (table == null) {
+            throw newValidationError(call.getTargetTable(), RESOURCE.objectNotFound(targetTable.toString()));

Review Comment:
   > I see that it throws not SqlValidatorException and additional fix possibly required,
   
   Thanks, but I'm not fully understand your suggestion.
   
   For example for select * from unknown calcite throws CalciteContextException caused by.SqlValidatorException.
   And the same behavior here:
   ```
   CalciteContextException: From line 1, column 8 to line 1, column 14: Object 'UNKNOWN' not found
   ...
   Caused by: org.apache.calcite.sql.validate.SqlValidatorException: Object 'UNKNOWN' not found
   ```



;11/Apr/23 07:46;githubbot;600","xtern commented on code in PR #1917:
URL: https://github.com/apache/ignite-3/pull/1917#discussion_r1162425316


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteSqlValidator.java:
##########
@@ -169,6 +169,10 @@ protected SqlSelect createSourceSelectForUpdate(SqlUpdate call) {
         final SqlIdentifier targetTable = (SqlIdentifier) call.getTargetTable();
         final SqlValidatorTable table = getCatalogReader().getTable(targetTable.names);
 
+        if (table == null) {
+            throw newValidationError(call.getTargetTable(), RESOURCE.objectNotFound(targetTable.toString()));

Review Comment:
   > I see that it throws not SqlValidatorException and additional fix possibly required,
   
   Thanks, but I'm not fully understand your suggestion.
   
   For example for select * from unknown calcite throws CalciteContextException caused by.SqlValidatorException.
   And the same behavior here:
   ```
   CalciteContextException: From line 1, column 8 to line 1, column 14: Object 'UNKNOWN' not found
   ...
   Caused by: org.apache.calcite.sql.validate.SqlValidatorException: Object 'UNKNOWN' not found
   ```



;11/Apr/23 07:55;githubbot;600","xtern commented on code in PR #1917:
URL: https://github.com/apache/ignite-3/pull/1917#discussion_r1162538282


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteSqlValidator.java:
##########
@@ -169,6 +169,10 @@ protected SqlSelect createSourceSelectForUpdate(SqlUpdate call) {
         final SqlIdentifier targetTable = (SqlIdentifier) call.getTargetTable();
         final SqlValidatorTable table = getCatalogReader().getTable(targetTable.names);
 
+        if (table == null) {
+            throw newValidationError(call.getTargetTable(), RESOURCE.objectNotFound(targetTable.toString()));

Review Comment:
   > more clear to use : RESOURCE.tableNotFound
   Thanks, but I'm not sure about it.
   
   First, as you mentioned it's not a validator exception.
   We can use _RESOURCE.tableNameNotFound_ instead, but still not sure about such a change in this task.
   
   Because we will have inconsistent behavior for MERGE queries for example:
   ```
   MERGE INTO non_existing_table USING existing_table
   ```
   will produce `Table 'NON_EXISTING_TABLE' not found`, but 
   ```
   MERGE INTO existing_table USING non_existing_table
   ```
   will produce `Object 'NON_EXISTING_TABLE' not found`
   
   > probably we need to mention some already defined issue here
   Added TODO https://issues.apache.org/jira/browse/IGNITE-14865
   



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteSqlValidator.java:
##########
@@ -169,6 +169,10 @@ protected SqlSelect createSourceSelectForUpdate(SqlUpdate call) {
         final SqlIdentifier targetTable = (SqlIdentifier) call.getTargetTable();
         final SqlValidatorTable table = getCatalogReader().getTable(targetTable.names);
 
+        if (table == null) {
+            throw newValidationError(call.getTargetTable(), RESOURCE.objectNotFound(targetTable.toString()));

Review Comment:
   > more clear to use : RESOURCE.tableNotFound
   
   Thanks, but I'm not sure about it.
   
   First, as you mentioned it's not a validator exception.
   We can use _RESOURCE.tableNameNotFound_ instead, but still not sure about such a change in this task.
   
   Because we will have inconsistent behavior for MERGE queries for example:
   ```
   MERGE INTO non_existing_table USING existing_table
   ```
   will produce `Table 'NON_EXISTING_TABLE' not found`, but 
   ```
   MERGE INTO existing_table USING non_existing_table
   ```
   will produce `Object 'NON_EXISTING_TABLE' not found`
   
   > probably we need to mention some already defined issue here
   Added TODO https://issues.apache.org/jira/browse/IGNITE-14865
   



;11/Apr/23 09:22;githubbot;600","xtern commented on code in PR #1917:
URL: https://github.com/apache/ignite-3/pull/1917#discussion_r1162538282


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteSqlValidator.java:
##########
@@ -169,6 +169,10 @@ protected SqlSelect createSourceSelectForUpdate(SqlUpdate call) {
         final SqlIdentifier targetTable = (SqlIdentifier) call.getTargetTable();
         final SqlValidatorTable table = getCatalogReader().getTable(targetTable.names);
 
+        if (table == null) {
+            throw newValidationError(call.getTargetTable(), RESOURCE.objectNotFound(targetTable.toString()));

Review Comment:
   > more clear to use : RESOURCE.tableNotFound
   
   Thanks, but I'm not sure about it.
   
   First, as you mentioned it's not a validator exception.
   We can use _RESOURCE.tableNameNotFound_ instead, but still not sure about such a change in this task.
   
   Because we will have inconsistent behavior for MERGE queries for example:
   ```
   MERGE INTO non_existing_table USING existing_table
   ```
   will produce `Table 'NON_EXISTING_TABLE' not found`, but 
   ```
   MERGE INTO existing_table USING non_existing_table
   ```
   will produce `Object 'NON_EXISTING_TABLE' not found`
   
   > probably we need to mention some already defined issue here
   
   Added TODO https://issues.apache.org/jira/browse/IGNITE-14865
   



;11/Apr/23 09:23;githubbot;600","xtern commented on code in PR #1917:
URL: https://github.com/apache/ignite-3/pull/1917#discussion_r1162538282


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteSqlValidator.java:
##########
@@ -169,6 +169,10 @@ protected SqlSelect createSourceSelectForUpdate(SqlUpdate call) {
         final SqlIdentifier targetTable = (SqlIdentifier) call.getTargetTable();
         final SqlValidatorTable table = getCatalogReader().getTable(targetTable.names);
 
+        if (table == null) {
+            throw newValidationError(call.getTargetTable(), RESOURCE.objectNotFound(targetTable.toString()));

Review Comment:
   > more clear to use : RESOURCE.tableNotFound
   
   Thanks, but I'm not sure about it.
   
   First, as you mentioned it's not a validator exception.
   We can use `RESOURCE.tableNameNotFound` instead, but still not sure about such a change in this task.
   
   Because we will have inconsistent behavior for MERGE queries for example:
   ```
   MERGE INTO non_existing_table USING existing_table
   ```
   will produce `Table 'NON_EXISTING_TABLE' not found`, but 
   ```
   MERGE INTO existing_table USING non_existing_table
   ```
   will produce `Object 'NON_EXISTING_TABLE' not found`
   
   > probably we need to mention some already defined issue here
   
   Added TODO https://issues.apache.org/jira/browse/IGNITE-14865
   



;11/Apr/23 09:23;githubbot;600","xtern commented on code in PR #1917:
URL: https://github.com/apache/ignite-3/pull/1917#discussion_r1162538282


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteSqlValidator.java:
##########
@@ -169,6 +169,10 @@ protected SqlSelect createSourceSelectForUpdate(SqlUpdate call) {
         final SqlIdentifier targetTable = (SqlIdentifier) call.getTargetTable();
         final SqlValidatorTable table = getCatalogReader().getTable(targetTable.names);
 
+        if (table == null) {
+            throw newValidationError(call.getTargetTable(), RESOURCE.objectNotFound(targetTable.toString()));

Review Comment:
   > more clear to use : RESOURCE.tableNotFound
   
   Thanks, but I'm not sure about it.
   
   First, as you mentioned it's not a validator exception.
   We can use `RESOURCE.tableNameNotFound` instead, but still not sure about such a change in this task.
   
   Because we will have inconsistent behavior for MERGE queries for example:
   ```
   MERGE INTO non_existing_table USING existing_table
   ```
   will produce `Table 'NON_EXISTING_TABLE' not found`, but 
   ```
   MERGE INTO existing_table USING non_existing_table
   ```
   will produce `Object 'NON_EXISTING_TABLE' not found`
   



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteSqlValidator.java:
##########
@@ -169,6 +169,10 @@ protected SqlSelect createSourceSelectForUpdate(SqlUpdate call) {
         final SqlIdentifier targetTable = (SqlIdentifier) call.getTargetTable();
         final SqlValidatorTable table = getCatalogReader().getTable(targetTable.names);
 
+        if (table == null) {
+            throw newValidationError(call.getTargetTable(), RESOURCE.objectNotFound(targetTable.toString()));

Review Comment:
   > probably we need to mention some already defined issue here
   
   Thanks, added TODO https://issues.apache.org/jira/browse/IGNITE-14865



;11/Apr/23 09:24;githubbot;600","xtern commented on code in PR #1917:
URL: https://github.com/apache/ignite-3/pull/1917#discussion_r1162538282


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteSqlValidator.java:
##########
@@ -169,6 +169,10 @@ protected SqlSelect createSourceSelectForUpdate(SqlUpdate call) {
         final SqlIdentifier targetTable = (SqlIdentifier) call.getTargetTable();
         final SqlValidatorTable table = getCatalogReader().getTable(targetTable.names);
 
+        if (table == null) {
+            throw newValidationError(call.getTargetTable(), RESOURCE.objectNotFound(targetTable.toString()));

Review Comment:
   > more clear to use : RESOURCE.tableNotFound
   
   I'm not sure about it.
   
   First, as you mentioned it's not a validator exception.
   We can use `RESOURCE.tableNameNotFound` instead, but still not sure about such a change in this task.
   
   Because we will have inconsistent behavior for MERGE queries for example:
   ```
   MERGE INTO non_existing_table USING existing_table
   ```
   will produce `Table 'NON_EXISTING_TABLE' not found`, but 
   ```
   MERGE INTO existing_table USING non_existing_table
   ```
   will produce `Object 'NON_EXISTING_TABLE' not found`
   



;11/Apr/23 09:27;githubbot;600","xtern commented on code in PR #1917:
URL: https://github.com/apache/ignite-3/pull/1917#discussion_r1162538282


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteSqlValidator.java:
##########
@@ -169,6 +169,10 @@ protected SqlSelect createSourceSelectForUpdate(SqlUpdate call) {
         final SqlIdentifier targetTable = (SqlIdentifier) call.getTargetTable();
         final SqlValidatorTable table = getCatalogReader().getTable(targetTable.names);
 
+        if (table == null) {
+            throw newValidationError(call.getTargetTable(), RESOURCE.objectNotFound(targetTable.toString()));

Review Comment:
   > more clear to use : RESOURCE.tableNotFound
   
   I'm not sure about this.
   
   First, as you mentioned it's not a validator exception.
   We can use `RESOURCE.tableNameNotFound` instead, but still not sure about such a change in this task.
   
   Because we will have inconsistent behavior for MERGE queries for example:
   ```
   MERGE INTO non_existing_table USING existing_table
   ```
   will produce `Table 'NON_EXISTING_TABLE' not found`, but 
   ```
   MERGE INTO existing_table USING non_existing_table
   ```
   will produce `Object 'NON_EXISTING_TABLE' not found`
   



;11/Apr/23 09:30;githubbot;600","xtern merged PR #1917:
URL: https://github.com/apache/ignite-3/pull/1917


;12/Apr/23 19:50;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,7800,,,0,7800,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-18458,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Apr 12 19:55:14 UTC 2023,,,,,,,,,,"0|z1gt8w:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"12/Apr/23 19:55;xtern;[Merged|https://github.com/apache/ignite-3/commit/d7a6037705f85a66cf086d70316d4d2855da7360] to the main branch.

[~korlov], [~zstan] thanks for the review!;;;",,,,,
Possible deadlock in handling pending cache messages when the cache is recreated,IGNITE-19115,13529814,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,slava.koptilin,slava.koptilin,slava.koptilin,23/Mar/23 15:55,14/Apr/23 20:18,13/Jul/23 09:11,14/Apr/23 08:33,2.14,,,,,,,2.15,,,,0,,,,"Let's consider the following scenario:
  Precondition:
    there is a cluster of two server nodes (node A - coordinator, and node B) and an atomic cache that resides on that nodes.
    current topology version is (x, y)

Node B initiates putting a new key-value pair into the atomic cache. Let's assume the primary partition, which belongs to the key, resides on node A.

The previous step requires acquiring a gateway lock for the corresponding cache (GridCacheGateway read lock) and registering GridNearAtomicSingleUpdateFuture into the MVCC manager. It is important to note, that cache future does not acquire topology lock and so should not block PME

Concurrently, node A initiates destroying the cache. Corresponding PME will be successfully completed on the coordinator node and blocked on node B just because the gateway is already acquired

{noformat}
Thread [name=""sys-#105%dht.IgniteCacheRecreateTest1%"", id=123, state=TIMED_WAITING, blockCnt=0, waitCnt=350]
        at java.lang.Thread.sleep(Native Method)
        at o.a.i.i.util.IgniteUtils.sleep(IgniteUtils.java:8316)
        at o.a.i.i.processors.cache.GridCacheGateway.onStopped(GridCacheGateway.java:324)
        at o.a.i.i.processors.cache.GridCacheProcessor.stopGateway(GridCacheProcessor.java:2582)
        at o.a.i.i.processors.cache.GridCacheProcessor.lambda$processCacheStopRequestOnExchangeDone$1c59e5cf$1(GridCacheProcessor.java:2776)
        at o.a.i.i.processors.cache.GridCacheProcessor$$Lambda$714/770930142.apply(Unknown Source)
        at o.a.i.i.util.IgniteUtils.doInParallel(IgniteUtils.java:11628)
        at o.a.i.i.util.IgniteUtils.doInParallel(IgniteUtils.java:11530)
        at o.a.i.i.processors.cache.GridCacheProcessor.processCacheStopRequestOnExchangeDone(GridCacheProcessor.java:2755)
        at o.a.i.i.processors.cache.GridCacheProcessor.onExchangeDone(GridCacheProcessor.java:2945)
        at o.a.i.i.processors.cache.distributed.dht.preloader.GridDhtPartitionsExchangeFuture.onDone(GridDhtPartitionsExchangeFuture.java:2528)
        at o.a.i.i.processors.cache.distributed.dht.preloader.GridDhtPartitionsExchangeFuture.processFullMessage(GridDhtPartitionsExchangeFuture.java:4785)
        at o.a.i.i.processors.cache.distributed.dht.preloader.GridDhtPartitionsExchangeFuture.access$1500(GridDhtPartitionsExchangeFuture.java:161)
        at o.a.i.i.processors.cache.distributed.dht.preloader.GridDhtPartitionsExchangeFuture$4.apply(GridDhtPartitionsExchangeFuture.java:4453)
        at o.a.i.i.processors.cache.distributed.dht.preloader.GridDhtPartitionsExchangeFuture$4.apply(GridDhtPartitionsExchangeFuture.java:4441)
        at o.a.i.i.util.future.GridFutureAdapter.notifyListener(GridFutureAdapter.java:464)
        at o.a.i.i.util.future.GridFutureAdapter.listen(GridFutureAdapter.java:355)
        at o.a.i.i.processors.cache.distributed.dht.preloader.GridDhtPartitionsExchangeFuture.onReceiveFullMessage(GridDhtPartitionsExchangeFuture.java:4441)
        at o.a.i.i.processors.cache.GridCachePartitionExchangeManager.processFullPartitionUpdate(GridCachePartitionExchangeManager.java:1991)
        at o.a.i.i.processors.cache.GridCachePartitionExchangeManager$3.onMessage(GridCachePartitionExchangeManager.java:469)
        at o.a.i.i.processors.cache.GridCachePartitionExchangeManager$3.onMessage(GridCachePartitionExchangeManager.java:454)
        at o.a.i.i.processors.cache.GridCachePartitionExchangeManager$MessageHandler.apply(GridCachePartitionExchangeManager.java:3765)
        at o.a.i.i.processors.cache.GridCachePartitionExchangeManager$MessageHandler.apply(GridCachePartitionExchangeManager.java:3744)
        at o.a.i.i.processors.cache.GridCacheIoManager.processMessage(GridCacheIoManager.java:1151)
        at o.a.i.i.processors.cache.GridCacheIoManager.onMessage0(GridCacheIoManager.java:592)
        at o.a.i.i.processors.cache.GridCacheIoManager.handleMessage(GridCacheIoManager.java:393)
        at o.a.i.i.processors.cache.GridCacheIoManager.handleMessage(GridCacheIoManager.java:319)
        at o.a.i.i.processors.cache.GridCacheIoManager.access$100(GridCacheIoManager.java:110)
        at o.a.i.i.processors.cache.GridCacheIoManager$1.onMessage(GridCacheIoManager.java:309)
        at o.a.i.i.managers.communication.GridIoManager.invokeListener(GridIoManager.java:1907)
        at o.a.i.i.managers.communication.GridIoManager.processRegularMessage0(GridIoManager.java:1528)
        at o.a.i.i.managers.communication.GridIoManager.access$5300(GridIoManager.java:243)
        at o.a.i.i.managers.communication.GridIoManager$9.execute(GridIoManager.java:1421)
        at o.a.i.i.managers.communication.TraceRunnable.run(TraceRunnable.java:55)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:750)
{noformat}

Node A initiates creating a new cache with the same name as previously destroyed.

Node A received a cache update message but it cannot be processed, because a new cache (cache with the same cacheId) is starting, so, the processing of this message should be postponed until PME is completed (In this case the GridDhtForceKeysFuture is created, and the message will not be processed until PME is completed. So, the near node will not receive a response and it will not be able to complete the previous exchange future. see IGNITE-10251).

new PME on node B cannot proceed further just because of 3.",,alex_pl,ignitetcbot,ivandasch,slava.koptilin,,"sk0x50 opened a new pull request, #10616:
URL: https://github.com/apache/ignite/pull/10616

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;29/Mar/23 12:05;githubbot;600","sk0x50 opened a new pull request, #10618:
URL: https://github.com/apache/ignite/pull/10618

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;30/Mar/23 06:17;githubbot;600","sk0x50 merged PR #10618:
URL: https://github.com/apache/ignite/pull/10618


;14/Apr/23 08:29;githubbot;600","sk0x50 closed pull request #10616: IGNITE-19115 Fixed possible deadlock in handling pending cache messages when the cache is recreated
URL: https://github.com/apache/ignite/pull/10616


;14/Apr/23 20:18;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Apr 14 09:33:53 UTC 2023,,,,,,,,,,"0|z1gt1k:",9223372036854775807,,,ivandasch,,,,,,,,,,,,,,,,,,"03/Apr/23 07:39;slava.koptilin;Hello [~ivandasch],

Could you please take a look at both patches?

The first approach is based on introducing a new field `deploymentId` (which is IgniteUuid. this identifier is cluster-wide and unique) for all cache messages in order to track a generation of a cache.
The second one is trying to achieve the same goal using the `cache start topology version` (this value may vary from node to node, however, it does not seem that this fact can impact the proposed solution).;;;","13/Apr/23 09:35;ivandasch;[~slava.koptilin] The second approach looks good to me;;;","13/Apr/23 15:17;ignitetcbot;{panel:title=Branch: [pull/10618/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10618/head] Base: [master] : New Tests (13)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Cache (Restarts) 2{color} [[tests 13|https://ci2.ignite.apache.org/viewLog.html?buildId=7136041]]
* {color:#013220}IgniteCacheRestartTestSuite2: IgniteCacheRecreateTest.testImplicitTxInvokeAndCacheRecreate - PASSED{color}
* {color:#013220}IgniteCacheRestartTestSuite2: IgniteCacheRecreateTest.testImplicitInvokeAndCacheRecreate - PASSED{color}
* {color:#013220}IgniteCacheRestartTestSuite2: IgniteCacheRecreateTest.testAtomicScanAndCacheRecreate - PASSED{color}
* {color:#013220}IgniteCacheRestartTestSuite2: IgniteCacheRecreateTest.testAtomicPutAndCacheRecreate - PASSED{color}
* {color:#013220}IgniteCacheRestartTestSuite2: IgniteCacheRecreateTest.testPessimisticTxGetAndCacheRecreate - PASSED{color}
* {color:#013220}IgniteCacheRestartTestSuite2: IgniteCacheRecreateTest.testPessimisticTxPutAllAndCacheRecreate - PASSED{color}
* {color:#013220}IgniteCacheRestartTestSuite2: IgniteCacheRecreateTest.testAtomicPutAllAndCacheRecreate - PASSED{color}
* {color:#013220}IgniteCacheRestartTestSuite2: IgniteCacheRecreateTest.testImplicitOptimisticTxPutAllAndCacheRecreate - PASSED{color}
* {color:#013220}IgniteCacheRestartTestSuite2: IgniteCacheRecreateTest.testPessimisticTxPutAndCacheRecreate - PASSED{color}
* {color:#013220}IgniteCacheRestartTestSuite2: IgniteCacheRecreateTest.testAtomicGetAllAndCacheRecreate - PASSED{color}
* {color:#013220}IgniteCacheRestartTestSuite2: IgniteCacheRecreateTest.testAtomicGetAndCacheRecreate - PASSED{color}
... and 2 new tests

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7136124&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","14/Apr/23 09:33;alex_pl;Cherry-picked to 2.15;;;",,
Storage corruption if pages changed after last checkpoint during deactivation,IGNITE-19111,13529782,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,alex_pl,alex_pl,alex_pl,23/Mar/23 13:52,31/Mar/23 07:40,13/Jul/23 09:11,31/Mar/23 07:40,,,,,,,,2.15,,,,0,ise,,,"During cluster deactivation we force checkpoint (with ""caches stop"" reason) and remove checkpoint listeners before actual caches stop. But if there are some activity with data pages on the node after that checkpoint, but before caches stops and next checkpoint is started, the storage can be corrupted.

Reproducer:
{code:java}
    /** {@inheritDoc} */
    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
        return super.getConfiguration(igniteInstanceName)
            .setDataStorageConfiguration(new DataStorageConfiguration()
                .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setPersistenceEnabled(true))
                .setCheckpointFrequency(1_000L))
            .setFailureHandler(new StopNodeFailureHandler());
    }

    /** */
    @Test
    public void testCpAfterClusterDeactivate() throws Exception {
        IgniteEx ignite0 = startGrid(0);
        IgniteEx ignite1 = startGrid(1);

        ignite0.cluster().state(ClusterState.ACTIVE);

        ignite0.getOrCreateCache(new CacheConfiguration<>(DEFAULT_CACHE_NAME).setBackups(1)
            .setAffinity(new RendezvousAffinityFunction(false, 10)));

        try (IgniteDataStreamer<Integer, Integer> streamer = ignite0.dataStreamer(DEFAULT_CACHE_NAME)) {
            for (int i = 0; i < 100_000; i++)
                streamer.addData(i, i);
        }

        stopGrid(0);

        try (IgniteDataStreamer<Integer, Integer> streamer = ignite1.dataStreamer(DEFAULT_CACHE_NAME)) {
            streamer.allowOverwrite(true);
            for (int i = 0; i < 100_000; i++)
                streamer.addData(i, i + 1);
        }

        ignite0 = startGrid(0);
        ((GridCacheDatabaseSharedManager)ignite0.context().cache().context().database()).addCheckpointListener(new CheckpointListener() {
            @Override public void onMarkCheckpointBegin(Context ctx) {
                // No-op.
            }

            @Override public void onCheckpointBegin(Context ctx) {
                if (""caches stop"".equals(ctx.progress().reason()))
                    doSleep(1_000L);
            }

            @Override public void beforeCheckpointBegin(Context ctx) {
                // No-op.
            }
        });

        ignite0.cluster().state(ClusterState.INACTIVE);

        doSleep(2_000L);

        ignite0.cluster().state(ClusterState.ACTIVE);

        IgniteCache<Integer, Integer> cache = ignite0.cache(DEFAULT_CACHE_NAME);

        for (int i = 0; i < 100_000; i++)
            assertEquals((Integer)(i + 1), cache.get(i));
    } {code}
This reproducer shuts down the node with some probability (about 1/5 on my laptop) on activation or on last check with {{{}CorruptedTreeException{}}}.",,alex_pl,ignitetcbot,sergeychugunov,slava.koptilin,,"alex-plekhanov opened a new pull request, #10615:
URL: https://github.com/apache/ignite/pull/10615

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;29/Mar/23 11:34;githubbot;600","asfgit closed pull request #10615: IGNITE-19111 Fix PDS corruption on checkpoint after deactivation
URL: https://github.com/apache/ignite/pull/10615


;31/Mar/23 07:39;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Fri Mar 31 07:40:18 UTC 2023,,,,,,,,,,"0|z1gsug:",9223372036854775807,Fixed PDS corruption on checkpoint after deactivation,,,,,,,,,,,,,,,,,,,,"31/Mar/23 07:18;ignitetcbot;{panel:title=Branch: [pull/10615/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10615/head] Base: [master] : New Tests (2)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Disk Page Compressions 1{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7116301]]
* {color:#013220}IgnitePdsCompressionTestSuite: IgnitePdsCheckpointAfterDeactivateTest.testCpAfterClusterDeactivate - PASSED{color}

{color:#00008b}PDS 1{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7116255]]
* {color:#013220}IgnitePdsTestSuite: IgnitePdsCheckpointAfterDeactivateTest.testCpAfterClusterDeactivate - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7116304&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","31/Mar/23 07:40;alex_pl;[~ivandasch], thanks for the review! Merged to master.;;;",,,,
Fix flaky IgniteWorkerTest#testUpdateHeartbeat,IGNITE-19094,13529599,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ktkalenko@gridgain.com,ktkalenko@gridgain.com,22/Mar/23 11:02,23/Mar/23 05:06,13/Jul/23 09:11,23/Mar/23 05:06,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Fix flaky *org.apache.ignite.internal.util.worker.IgniteWorkerTest#testUpdateHeartbeat*, [Tc link|https://ci.ignite.apache.org/viewLog.html?buildId=7142884&buildTypeId=ApacheIgnite3xGradle_Test_RunUnitTests&fromSakuraUI=true].",,ktkalenko@gridgain.com,,,,,"tkalkirill opened a new pull request, #1834:
URL: https://github.com/apache/ignite-3/pull/1834

   https://issues.apache.org/jira/browse/IGNITE-19094


;22/Mar/23 11:27;githubbot;600","tkalkirill merged PR #1834:
URL: https://github.com/apache/ignite-3/pull/1834


;23/Mar/23 05:06;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-03-22 11:02:49.0,,,,,,,,,,"0|z1grps:",9223372036854775807,,,apolovtcev,,,,,,,,,,,,,,,,,,,,,,,
ItIgniteNodeRestartTest::startPartialNode does not provide configuration of sql-engine component.,IGNITE-19092,13529570,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,alapin,mzhuravkov,mzhuravkov,22/Mar/23 08:29,29/Mar/23 15:36,13/Jul/23 09:11,29/Mar/23 15:36,3.0.0-beta2,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"After https://issues.apache.org/jira/browse/IGNITE-18225 several tests in ItIgniteNodeRestartTest started to fail, because the sql-engine component is not configured for startPartialNode. 
Update startPartialNode to include sql-engine component. If it is possible, include all available components, so adding news components to this method in future won't be necessary.
h3. Implementation Notes

As was suggested I've added sql-engine(qryEngine) along with corresponding dependencies such as catalogManager and distributionZoneManager and that helped.

> If it is possible, include all available components, so adding news components to this method in future won't be necessary.

Well it's by design partial node, so components should be added by demand. We may elaborate proposed solution in a separate ticket, however I'd favor to unmute given tests ASAP so simplest solution of just adding sql-engine is preferable.  ",,maliev,mzhuravkov,,,,"sanpwc opened a new pull request, #1862:
URL: https://github.com/apache/ignite-3/pull/1862

   https://issues.apache.org/jira/browse/IGNITE-19092


;29/Mar/23 12:20;githubbot;600","alievmirza commented on code in PR #1862:
URL: https://github.com/apache/ignite-3/pull/1862#discussion_r1151951540


##########
modules/runner/build.gradle:
##########
@@ -134,6 +135,7 @@ dependencies {
     integrationTestImplementation(testFixtures(project(':ignite-table')))
     integrationTestImplementation(testFixtures(project(':ignite-storage-api')))
     integrationTestImplementation(testFixtures(project(':ignite-transactions')))
+    integrationTestImplementation(testFixtures(project(':ignite-distribution-zones')))

Review Comment:
   Do we really need this? 



;29/Mar/23 13:33;githubbot;600","sanpwc commented on code in PR #1862:
URL: https://github.com/apache/ignite-3/pull/1862#discussion_r1151992597


##########
modules/runner/build.gradle:
##########
@@ -134,6 +135,7 @@ dependencies {
     integrationTestImplementation(testFixtures(project(':ignite-table')))
     integrationTestImplementation(testFixtures(project(':ignite-storage-api')))
     integrationTestImplementation(testFixtures(project(':ignite-transactions')))
+    integrationTestImplementation(testFixtures(project(':ignite-distribution-zones')))

Review Comment:
   Nope. Fixed.



;29/Mar/23 14:00;githubbot;600","sanpwc merged PR #1862:
URL: https://github.com/apache/ignite-3/pull/1862


;29/Mar/23 15:35;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Mar 29 15:22:28 UTC 2023,,,,,,,,,,"0|z1grjc:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"29/Mar/23 15:22;maliev;[~alapin] LGTM;;;",,,,,
Sql. Investigate why severals tests ItTableRaftSnapshotsTest hang/fail.,IGNITE-19088,13529554,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,mzhuravkov,mzhuravkov,mzhuravkov,22/Mar/23 07:30,03/May/23 08:32,13/Jul/23 09:11,31/Mar/23 12:42,3.0.0-beta2,,,,,,,,sql,,,0,ignite-3,,,"After enabling distrubuted execution of DML queries in https://issues.apache.org/jira/browse/IGNITE-18225, performing DML in several test cases in ItTableRaftSnapshotsTest fail to terminate.
Internally the code hangs indefinitely at 

some_node-sql-execution-pool-0
{code:java}
 java.lang.Thread.State: WAITING (parking)
	at jdk.internal.misc.Unsafe.park(java.base@11.0.14.1/Native Method)
	- parking to wait for  <0x00000005daab1fe8> (a java.util.concurrent.CompletableFuture$Signaller)
	at java.util.concurrent.locks.LockSupport.park(java.base@11.0.14.1/LockSupport.java:194)
	at java.util.concurrent.CompletableFuture$Signaller.block(java.base@11.0.14.1/CompletableFuture.java:1796)
	at java.util.concurrent.ForkJoinPool.managedBlock(java.base@11.0.14.1/ForkJoinPool.java:3128)
	at java.util.concurrent.CompletableFuture.waitingGet(java.base@11.0.14.1/CompletableFuture.java:1823)
	at java.util.concurrent.CompletableFuture.join(java.base@11.0.14.1/CompletableFuture.java:2043)
	at org.apache.ignite.internal.sql.engine.message.MessageServiceImpl.send(MessageServiceImpl.java:102)
	at org.apache.ignite.internal.sql.engine.exec.ExchangeServiceImpl.request(ExchangeServiceImpl.java:106)
	at org.apache.ignite.internal.sql.engine.exec.rel.Inbox.requestBatches(Inbox.java:341)
	at org.apache.ignite.internal.sql.engine.exec.rel.Inbox.lambda$new$0(Inbox.java:89)
	at org.apache.ignite.internal.sql.engine.exec.rel.Inbox$$Lambda$2832/0x0000000800e16040.request(Unknown Source)
	at org.apache.ignite.internal.sql.engine.exec.rel.Inbox$RemoteSource.requestNextBatchIfNeeded(Inbox.java:555)
	at org.apache.ignite.internal.sql.engine.exec.rel.Inbox.pushUnordered(Inbox.java:331)
	at org.apache.ignite.internal.sql.engine.exec.rel.Inbox.push(Inbox.java:194)
	at org.apache.ignite.internal.sql.engine.exec.rel.Inbox.doPush(Inbox.java:175)
	at org.apache.ignite.internal.sql.engine.exec.rel.Inbox$$Lambda$2835/0x0000000800e34c40.run(Unknown Source)
	at
{code}
some_node-sql-execution-pool-1:
 
{code:java}
java.lang.Thread.State: WAITING (parking)
	at jdk.internal.misc.Unsafe.park(java.base@11.0.14.1/Native Method)
	- parking to wait for  <0x00000005daabbeb0> (a java.util.concurrent.CompletableFuture$Signaller)
	at java.util.concurrent.locks.LockSupport.park(java.base@11.0.14.1/LockSupport.java:194)
	at java.util.concurrent.CompletableFuture$Signaller.block(java.base@11.0.14.1/CompletableFuture.java:1796)
	at java.util.concurrent.ForkJoinPool.managedBlock(java.base@11.0.14.1/ForkJoinPool.java:3128)
	at java.util.concurrent.CompletableFuture.waitingGet(java.base@11.0.14.1/CompletableFuture.java:1823)
	at java.util.concurrent.CompletableFuture.join(java.base@11.0.14.1/CompletableFuture.java:2043)
	at org.apache.ignite.internal.sql.engine.message.MessageServiceImpl.send(MessageServiceImpl.java:102)
	at org.apache.ignite.internal.sql.engine.exec.ExecutionServiceImpl$DistributedQueryManager.sendFragment(ExecutionServiceImpl.java:495)
	at org.apache.ignite.internal.sql.engine.exec.ExecutionServiceImpl$DistributedQueryManager.lambda$execute$7(ExecutionServiceImpl.java:708)
	at org.apache.ignite.internal.sql.engine.exec.ExecutionServiceImpl$DistributedQueryManager$$Lambda$2790/0x000000080096a040.run(Unknown Source)
	at org.apache.ignite.internal.sql.engine.exec.QueryTaskExecutorImpl.lambda$execute$0(QueryTaskExecutorImpl.java:80)
	at org.a
{code}


",,mzhuravkov,rpuch,,,,"zstan merged PR #1853:
URL: https://github.com/apache/ignite-3/pull/1853


;31/Mar/23 12:41;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-18225,IGNITE-19126,IGNITE-19121,IGNITE-18493,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Mar 29 08:08:58 UTC 2023,,,,,,,,,,"0|z1grfs:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"29/Mar/23 08:08;rpuch;The patch looks good to me;;;",,,,,
Fix NullPointerException on building indexes if the number of replicas is more than one,IGNITE-19086,13529500,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ktkalenko@gridgain.com,ktkalenko@gridgain.com,21/Mar/23 19:07,20/Apr/23 12:02,13/Jul/23 09:11,20/Apr/23 12:02,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Fix NullPointerException on building indexes if the number of replicas is more than one. Fall is not stable.
{noformat}
Caused by: java.lang.NullPointerException
	at org.apache.ignite.internal.sql.engine.schema.IgniteTableImpl.lambda$insertAll$2(IgniteTableImpl.java:417)
	at java.base/java.util.concurrent.CompletableFuture$UniApply.tryFire(CompletableFuture.java:642)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
	at org.apache.ignite.internal.replicator.ReplicaService.lambda$sendToReplica$2(ReplicaService.java:147)
	at java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:930)
	at java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:907)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
	at org.apache.ignite.network.DefaultMessagingService.onInvokeResponse(DefaultMessagingService.java:363)
	at org.apache.ignite.network.DefaultMessagingService.onMessage(DefaultMessagingService.java:328)
	at org.apache.ignite.network.DefaultMessagingService.lambda$onMessage$3(DefaultMessagingService.java:306)
	... 3 more
{noformat}
",,ktkalenko@gridgain.com,,,,,"tkalkirill opened a new pull request, #1963:
URL: https://github.com/apache/ignite-3/pull/1963

   https://issues.apache.org/jira/browse/IGNITE-19086


;20/Apr/23 11:00;githubbot;600","tkalkirill merged PR #1963:
URL: https://github.com/apache/ignite-3/pull/1963


;20/Apr/23 12:02;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17766,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-03-21 19:07:13.0,,,,,,,,,,"0|z1gr3s:",9223372036854775807,,,apolovtcev,,,,,,,,,,,,,,,,,,,,,,,
ExecutionTimeout in ItIgniteNodeRestartTest,IGNITE-19079,13529372,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Denis Chudov,alapin,alapin,21/Mar/23 07:32,14/Jun/23 07:08,13/Jul/23 09:11,14/Jun/23 07:08,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"ItIgniteNodeRestartTest#testTwoNodesRestartDirect fails with ExecutionTimeout
{code:java}
023-03-20 03:52:36:208 +0300 [INFO][%iinrt_ttnrd_0%JRaft-ElectionTimer-17][NodeImpl] Unsuccessful election round number 662
    2023-03-20 03:52:36:209 +0300 [INFO][%iinrt_ttnrd_0%JRaft-ElectionTimer-17][NodeImpl] Node <d73a4612-9277-4061-9331-b3b78b0ee85d_part_0/iinrt_ttnrd_0> term 1 start preVote.
    2023-03-20 03:52:36:601 +0300 [INFO][%iinrt_ttnrd_0%JRaft-ElectionTimer-18][NodeImpl] Unsuccessful election round number 659
    2023-03-20 03:52:36:601 +0300 [INFO][%iinrt_ttnrd_0%JRaft-ElectionTimer-18][NodeImpl] Node <4d8ec640-9e96-4939-86e8-acb0c9460da8_part_1/iinrt_ttnrd_0> term 1 start preVote.
    2023-03-20 03:52:37:992 +0300 [INFO][%iinrt_ttnrd_0%JRaft-ElectionTimer-6][NodeImpl] Unsuccessful election round number 663
    2023-03-20 03:52:37:992 +0300 [INFO][%iinrt_ttnrd_0%JRaft-ElectionTimer-6][NodeImpl] Node <d73a4612-9277-4061-9331-b3b78b0ee85d_part_0/iinrt_ttnrd_0> term 1 start preVote.
    2023-03-20 03:52:38:049 +0300 [INFO][%iinrt_ttnrd_0%JRaft-ElectionTimer-19][NodeImpl] Unsuccessful election round number 660
    2023-03-20 03:52:38:049 +0300 [INFO][%iinrt_ttnrd_0%JRaft-ElectionTimer-19][NodeImpl] Node <4d8ec640-9e96-4939-86e8-acb0c9460da8_part_1/iinrt_ttnrd_0> term 1 start preVote.
    2023-03-20 03:52:38:299 +0300 [INFO][%iinrt_ttnrd_0%JRaft-ElectionTimer-2][NodeImpl] Unsuccessful election round number 659
    2023-03-20 03:52:38:300 +0300 [INFO][%iinrt_ttnrd_0%JRaft-ElectionTimer-2][NodeImpl] Node <4d8ec640-9e96-4939-86e8-acb0c9460da8_part_0/iinrt_ttnrd_0> term 1 start preVote.
    2023-03-20 03:52:42:870 +0300 [INFO][%iinrt_ttnrd_0%JRaft-ElectionTimer-1][NodeImpl] Unsuccessful election round number 662 {code}
https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunAllTests/7138347?expandCode+Inspection=true&expandBuildProblemsSection=true&hideProblemsFromDependencies=false&hideTestsFromDependencies=false",,alapin,Denis Chudov,,,,"sanpwc opened a new pull request, #1822:
URL: https://github.com/apache/ignite-3/pull/1822

   WIP


;21/Mar/23 07:39;githubbot;600","sanpwc merged PR #1822:
URL: https://github.com/apache/ignite-3/pull/1822


;21/Mar/23 13:41;githubbot;600","sanpwc closed pull request #1882: IGNITE-19079
URL: https://github.com/apache/ignite-3/pull/1882


;11/May/23 15:24;githubbot;600","denis-chudov opened a new pull request, #2179:
URL: https://github.com/apache/ignite-3/pull/2179

   (no comment)


;12/Jun/23 09:07;githubbot;600","denis-chudov closed pull request #2179: IGNITE-19079 ExecutionTimeout in ItIgniteNodeRestartTest
URL: https://github.com/apache/ignite-3/pull/2179


;13/Jun/23 15:32;githubbot;600","denis-chudov opened a new pull request, #2187:
URL: https://github.com/apache/ignite-3/pull/2187

   https://issues.apache.org/jira/browse/IGNITE-19079


;13/Jun/23 15:32;githubbot;600","sanpwc merged PR #2187:
URL: https://github.com/apache/ignite-3/pull/2187


;14/Jun/23 07:07;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,4200,,,0,4200,,,,,,,IGNITE-19022,,,,,,,,,,,,,,,,,IGNITE-19089,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jun 14 07:07:38 UTC 2023,,,,,,,,,,"0|z1gqbc:",9223372036854775807,,,sanpwc,,,,,,,,,,,,,,,,,,"13/Jun/23 15:28;Denis Chudov;Could not reproduce the test failure in several hundreds runs of these tests on TeamCity: https://ci.ignite.apache.org/viewType.html?buildTypeId=ApacheIgnite3xGradle_Test_IntegrationTests_ModuleRunner&branch_ApacheIgnite3xGradle_Test_IntegrationTests=pull%2F2179&tab=buildTypeStatusDiv;;;","13/Jun/23 16:29;Denis Chudov;[~sanpwc] could you review pls?;;;","14/Jun/23 07:07;alapin;[~Denis Chudov] LGTM, merged, thanks!;;;",,,
.NET: Thin 3.0: TestReconnectAfterFullClusterRestart is still flaky,IGNITE-19069,13529217,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,20/Mar/23 09:07,23/Mar/23 05:34,13/Jul/23 09:11,23/Mar/23 05:34,3.0.0-beta1,,,,,,,3.0.0-beta2,platforms,thin client,,0,ignite-3,,,"https://ci.ignite.apache.org/test/5088070784193128850?currentProjectId=ApacheIgnite3xGradle_Test&expandTestHistoryChartSection=true

{code}
Expected: No Exception to be thrown
  But was:  <Apache.Ignite.IgniteClientConnectionException: Failed to connect to endpoint: 127.0.0.1:42477
 ---> System.TimeoutException: The operation has timed out.
   at Apache.Ignite.Internal.ClientSocket.ConnectAsync(SocketEndpoint endPoint, IgniteClientConfiguration configuration, Action`1 assignmentChangeCallback) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/ClientSocket.cs:line 195
   --- End of inner exception stack trace ---
   at Apache.Ignite.Internal.ClientSocket.ConnectAsync(SocketEndpoint endPoint, IgniteClientConfiguration configuration, Action`1 assignmentChangeCallback) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/ClientSocket.cs:line 213
   at Apache.Ignite.Internal.ClientFailoverSocket.ConnectAsync(SocketEndpoint endpoint) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/ClientFailoverSocket.cs:line 414
   at Apache.Ignite.Internal.ClientFailoverSocket.GetNextSocketAsync() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/ClientFailoverSocket.cs:line 365
   at Apache.Ignite.Internal.ClientFailoverSocket.GetSocketAsync(PreferredNode preferredNode) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/ClientFailoverSocket.cs:line 285
   at Apache.Ignite.Internal.ClientFailoverSocket.DoOutInOpAndGetSocketAsync(ClientOp clientOp, Transaction tx, PooledArrayBuffer request, PreferredNode preferredNode) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/ClientFailoverSocket.cs:line 183
   at Apache.Ignite.Internal.ClientFailoverSocket.DoOutInOpAsync(ClientOp clientOp, PooledArrayBuffer request, PreferredNode preferredNode) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/ClientFailoverSocket.cs:line 145
   at Apache.Ignite.Internal.Table.Tables.GetTablesAsync() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/Table/Tables.cs:line 64
   at Apache.Ignite.Tests.ReconnectTests.<>c__DisplayClass6_0.<<TestReconnectAfterFullClusterRestart>b__2>d.MoveNext() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/ReconnectTests.cs:line 162
--- End of stack trace from previous location ---
   at NUnit.Framework.Internal.TaskAwaitAdapter.GenericAdapter`1.BlockUntilCompleted()
   at NUnit.Framework.Internal.MessagePumpStrategy.NoMessagePumpStrategy.WaitForCompletion(AwaitAdapter awaiter)
   at NUnit.Framework.Internal.AsyncToSyncAdapter.Await(Func`1 invoke)
   at NUnit.Framework.Internal.ExceptionHelper.RecordException(Delegate parameterlessDelegate, String parameterName)>
   at Apache.Ignite.Tests.ReconnectTests.TestReconnectAfterFullClusterRestart() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/ReconnectTests.cs:line 162
   at NUnit.Framework.Internal.TaskAwaitAdapter.GenericAdapter`1.BlockUntilCompleted()
   at NUnit.Framework.Internal.MessagePumpStrategy.NoMessagePumpStrategy.WaitForCompletion(AwaitAdapter awaiter)
   at NUnit.Framework.Internal.AsyncToSyncAdapter.Await(Func`1 invoke)
   at NUnit.Framework.Internal.Commands.TestMethodCommand.RunTestMethod(TestExecutionContext context)
   at NUnit.Framework.Internal.Commands.TestMethodCommand.Execute(TestExecutionContext context)
   at NUnit.Framework.Internal.Execution.SimpleWorkItem.<>c__DisplayClass4_0.<PerformWork>b__0()
   at NUnit.Framework.Internal.ContextUtils.<>c__DisplayClass1_0`1.<DoIsolated>b__0(Object _)
1)    at Apache.Ignite.Tests.ReconnectTests.TestReconnectAfterFullClusterRestart() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/ReconnectTests.cs:line 162
{code}",,isapego,ptupitsyn,,,,"ptupitsyn merged PR #1828:
URL: https://github.com/apache/ignite-3/pull/1828


;23/Mar/23 05:33;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-18851,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Mar 23 05:34:11 UTC 2023,,,,,,,,,,"0|z1gpcw:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"22/Mar/23 11:43;ptupitsyn;[~isapego] please review.;;;","22/Mar/23 14:22;isapego;Looks good to me.;;;","23/Mar/23 05:34;ptupitsyn;Merged to main: d2a970632927177ffbea49c22d09433c44ef235a;;;",,,
ClassCastException in SQL on certain column combination,IGNITE-19068,13529205,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,zstan,ptupitsyn,ptupitsyn,20/Mar/23 08:11,10/Apr/23 06:38,13/Jul/23 09:11,10/Apr/23 06:38,3.0.0-beta1,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"Place attached *Reproducer.java* to *modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/* and run.

It fails with an exception:
{code}
IGN-CMN-65535 TraceId:0d8e3c54-2e5e-4b46-9c2c-306c11cf4d91 Remote query execution
	at org.apache.ignite.lang.IgniteException.wrap(IgniteException.java:289)
	at org.apache.ignite.internal.sql.engine.AsyncSqlCursorImpl.lambda$requestNextAsync$0(AsyncSqlCursorImpl.java:77)
	at java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:930)
	at java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:907)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
	at org.apache.ignite.internal.sql.engine.exec.rel.AsyncRootNode.lambda$closeAsync$0(AsyncRootNode.java:157)
	at java.base/java.util.concurrent.ConcurrentLinkedQueue.forEachFrom(ConcurrentLinkedQueue.java:1037)
	at java.base/java.util.concurrent.ConcurrentLinkedQueue.forEach(ConcurrentLinkedQueue.java:1054)
	at org.apache.ignite.internal.sql.engine.exec.rel.AsyncRootNode.closeAsync(AsyncRootNode.java:157)
	at org.apache.ignite.internal.sql.engine.exec.rel.AsyncRootNode.onError(AsyncRootNode.java:112)
	at org.apache.ignite.internal.sql.engine.exec.ExecutionServiceImpl$DistributedQueryManager.lambda$onError$2(ExecutionServiceImpl.java:509)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptNow(CompletableFuture.java:753)
	at java.base/java.util.concurrent.CompletableFuture.uniAcceptStage(CompletableFuture.java:731)
	at java.base/java.util.concurrent.CompletableFuture.thenAccept(CompletableFuture.java:2108)
	at org.apache.ignite.internal.sql.engine.exec.ExecutionServiceImpl$DistributedQueryManager.onError(ExecutionServiceImpl.java:508)
	at org.apache.ignite.internal.sql.engine.exec.ExecutionServiceImpl.onMessage(ExecutionServiceImpl.java:357)
	at org.apache.ignite.internal.sql.engine.exec.ExecutionServiceImpl.lambda$start$4(ExecutionServiceImpl.java:216)
	at org.apache.ignite.internal.sql.engine.message.MessageServiceImpl.onMessageInternal(MessageServiceImpl.java:164)
	at org.apache.ignite.internal.sql.engine.message.MessageServiceImpl.lambda$onMessage$1(MessageServiceImpl.java:135)
	at org.apache.ignite.internal.sql.engine.exec.QueryTaskExecutorImpl.lambda$execute$0(QueryTaskExecutorImpl.java:80)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:829)
Caused by: org.apache.ignite.internal.sql.engine.metadata.RemoteException: Remote query execution
	at org.apache.ignite.internal.sql.engine.exec.ExecutionServiceImpl.onMessage(ExecutionServiceImpl.java:355)
	... 7 more
Caused by: java.lang.ClassCastException: class java.time.Instant cannot be cast to class java.lang.Long (java.time.Instant and java.lang.Long are in module java.base of loader 'bootstrap')
	at SC.execute(Unknown Source)
	at org.apache.ignite.internal.sql.engine.exec.exp.ExpressionFactoryImpl$ProjectImpl.apply(ExpressionFactoryImpl.java:654)
	at org.apache.ignite.internal.sql.engine.exec.rel.StorageScanNode.push(StorageScanNode.java:197)
	at org.apache.ignite.internal.sql.engine.exec.rel.StorageScanNode$SubscriberImpl.lambda$onComplete$2(StorageScanNode.java:303)
	at org.apache.ignite.internal.sql.engine.exec.ExecutionContext.lambda$execute$0(ExecutionContext.java:315)
	... 4 more
{code}

Note that is does NOT fail if we exclude either UUID or TIMESTAMP column from the SELECT query.",,ptupitsyn,,,,,"ygerzhedovich commented on code in PR #1867:
URL: https://github.com/apache/ignite-3/pull/1867#discussion_r1158148376


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/api/ItCommonApiTest.java:
##########
@@ -95,4 +108,61 @@ public void testSessionExpiration() throws Exception {
         // second session could start new query
         ses2.execute(null, ""SELECT 2 + 2"").close();
     }
+
+    /** Check timestamp type operations correctness using sql and kv api. */
+    @Test
+    public void checkTimestampOperations() {
+        String kvTblName = ""tbl_all_columns_sql"";
+        String schemaName = ""PUBLIC"";
+        String keyCol = ""key"";
+        int maxTimePrecision = TemporalColumnType.MAX_TIME_PRECISION;
+
+        Ignite node = CLUSTER_NODES.get(0);
+
+        // TODO: https://issues.apache.org/jira/browse/IGNITE-19162 Trim all less than millisecond information from timestamp
+        //String tsStr = ""2023-03-29T08:22:33.005007Z"";

Review Comment:
   in case you use precition 9 it should be ""2023-03-29T08:22:33.005007000Z""



;05/Apr/23 07:50;githubbot;600","ygerzhedovich commented on code in PR #1867:
URL: https://github.com/apache/ignite-3/pull/1867#discussion_r1158150559


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/api/ItCommonApiTest.java:
##########
@@ -95,4 +108,61 @@ public void testSessionExpiration() throws Exception {
         // second session could start new query
         ses2.execute(null, ""SELECT 2 + 2"").close();
     }
+
+    /** Check timestamp type operations correctness using sql and kv api. */
+    @Test
+    public void checkTimestampOperations() {
+        String kvTblName = ""tbl_all_columns_sql"";
+        String schemaName = ""PUBLIC"";
+        String keyCol = ""key"";
+        int maxTimePrecision = TemporalColumnType.MAX_TIME_PRECISION;
+
+        Ignite node = CLUSTER_NODES.get(0);
+
+        // TODO: https://issues.apache.org/jira/browse/IGNITE-19162 Trim all less than millisecond information from timestamp

Review Comment:
   could we mention IGNITE-15622 instead of IGNITE-19162 and close IGNITE-19162 as duplicate?



;05/Apr/23 07:52;githubbot;600","zstan commented on PR #1905:
URL: https://github.com/apache/ignite-3/pull/1905#issuecomment-1497625703

   @korlov42 can u make a review plz ?


;05/Apr/23 14:52;githubbot;600","zstan commented on PR #1905:
URL: https://github.com/apache/ignite-3/pull/1905#issuecomment-1498840646

   @AMashenkov can you make a review plz ?


;06/Apr/23 10:23;githubbot;600","zstan commented on PR #1905:
URL: https://github.com/apache/ignite-3/pull/1905#issuecomment-1499988693

   @korlov42  i append additional integration sqllogic tests, as i understand soon they become unmuted and thus it`s appropriate change, isn`t it ?


;07/Apr/23 06:36;githubbot;600","zstan closed pull request #1905: IGNITE-19068 Sql. Support sql engine representation for kv api timestamp type
URL: https://github.com/apache/ignite-3/pull/1905


;10/Apr/23 06:29;githubbot;600","zstan closed pull request #1877: IGNITE-19068 Sql. ClassCastException in SQL on certain column combination
URL: https://github.com/apache/ignite-3/pull/1877


;10/Apr/23 06:35;githubbot;600","zstan closed pull request #1867: IGNITE-19068 Sql. Introduce timestamp type
URL: https://github.com/apache/ignite-3/pull/1867


;10/Apr/23 06:36;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,4800,,,0,4800,,,,,,,IGNITE-18916,,,,,,,,,,,,,,,,,,,,,,,,"20/Mar/23 08:13;ptupitsyn;Reproducer.java;https://issues.apache.org/jira/secure/attachment/13056503/Reproducer.java",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-03-20 08:11:17.0,,,,,,,,,,"0|z1gpa8:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
Snapshot operation NPE on a client node,IGNITE-19060,13528946,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,NSAmelchev,NSAmelchev,NSAmelchev,17/Mar/23 10:54,19/Mar/23 08:44,13/Jul/23 09:11,19/Mar/23 08:44,,,,,,,,2.15,,,,0,ise,,,"NPE if a client node does not have data storage configuration:
{noformat}
java.lang.NullPointerException: null
   at org.apache.ignite.internal.util.future.GridFinishedFuture.chain(GridFinishedFuture.java:145) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
   at org.apache.ignite.internal.processors.cache.persistence.snapshot.IgniteSnapshotManager.initLocalSnapshotEndStage(IgniteSnapshotManager.java:1350) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
   at org.apache.ignite.internal.util.distributed.DistributedProcess.lambda$new$2(DistributedProcess.java:151) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
   at org.apache.ignite.internal.managers.discovery.GridDiscoveryManager$3.onDiscovery0(GridDiscoveryManager.java:760) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
   at org.apache.ignite.internal.managers.discovery.GridDiscoveryManager$3.access$7300(GridDiscoveryManager.java:547) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
   at org.apache.ignite.internal.managers.discovery.GridDiscoveryManager$3$NotificationTask.run(GridDiscoveryManager.java:980) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
   at org.apache.ignite.internal.managers.discovery.GridDiscoveryManager$3$SecurityAwareNotificationTask.run(GridDiscoveryManager.java:950) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
   at org.apache.ignite.internal.managers.discovery.GridDiscoveryManager$DiscoveryMessageNotifierWorker.body0(GridDiscoveryManager.java:2822) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
   at org.apache.ignite.internal.managers.discovery.GridDiscoveryManager$DiscoveryMessageNotifierWorker.body(GridDiscoveryManager.java:2860) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
   at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:125) ~[ignite-core-15.0.0-SNAPSHOT.jar:15.0.0-SNAPSHOT]
   at java.lang.Thread.run(Thread.java:748) ~[?:1.8.0_201]
{noformat}
",,ignitetcbot,NSAmelchev,,,,"NSAmelchev opened a new pull request, #10601:
URL: https://github.com/apache/ignite/pull/10601

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;17/Mar/23 10:56;githubbot;600","NSAmelchev merged PR #10601:
URL: https://github.com/apache/ignite/pull/10601


;19/Mar/23 08:43;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Sun Mar 19 08:44:25 UTC 2023,,,,,,,,,,"0|z1gnow:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"19/Mar/23 08:43;ignitetcbot;{panel:title=Branch: [pull/10601/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10601/head] Base: [master] : No new tests found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7096411&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","19/Mar/23 08:44;NSAmelchev;Merged into the master.

[~alexpl], Thank you for the review.;;;",,,,
ClientLoggingTest.testBasicLogging is flaky,IGNITE-19058,13528927,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,17/Mar/23 09:14,17/Mar/23 14:49,13/Jul/23 09:11,17/Mar/23 14:49,3.0.0-beta1,,,,,,,3.0.0-beta2,thin client,,,0,ignite-3,,,"1. The test is flaky
2. The assertion is not helpful: ""expected: <true> but was: <false>"" - provide more details
3. First run takes a lot of time?

 !screenshot-1.png! 

https://ci.ignite.apache.org/test/8764679646897676088?currentProjectId=ApacheIgnite3xGradle_Test&expandTestHistoryChartSection=true&branch=


{code}
org.opentest4j.AssertionFailedError: expected: <true> but was: <false>
  at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151)
  at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132)
  at app//org.junit.jupiter.api.AssertTrue.failNotTrue(AssertTrue.java:63)
  at app//org.junit.jupiter.api.AssertTrue.assertTrue(AssertTrue.java:36)
  at app//org.junit.jupiter.api.AssertTrue.assertTrue(AssertTrue.java:31)
  at app//org.junit.jupiter.api.Assertions.assertTrue(Assertions.java:180)
  at app//org.apache.ignite.client.ClientLoggingTest.testBasicLogging(ClientLoggingTest.java:97)
{code}
",,isapego,ptupitsyn,,,,"ptupitsyn merged PR #1806:
URL: https://github.com/apache/ignite-3/pull/1806


;17/Mar/23 14:48;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"17/Mar/23 09:15;ptupitsyn;screenshot-1.png;https://issues.apache.org/jira/secure/attachment/13056445/screenshot-1.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,Java,Fri Mar 17 14:49:03 UTC 2023,,,,,,,,,,"0|z1gnko:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"17/Mar/23 13:37;ptupitsyn;[~isapego] please review.;;;","17/Mar/23 13:39;isapego;[~ptupitsyn] looks good to me.;;;","17/Mar/23 14:49;ptupitsyn;Merged to main: 4d37da0d139056f071d1468ba865c45ae3d9f407;;;",,,
ItIgniteInMemoryNodeRestartTest#inMemoryNodeRestartNotLeader fails,IGNITE-19044,13528667,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,alapin,alapin,alapin,15/Mar/23 16:39,31/Mar/23 15:21,13/Jul/23 09:11,31/Mar/23 15:21,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"{code:java}
org.opentest4j.AssertionFailedError: expected: <true> but was: <false>  at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151)  at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132)  at app//org.junit.jupiter.api.AssertTrue.failNotTrue(AssertTrue.java:63)  at app//org.junit.jupiter.api.AssertTrue.assertTrue(AssertTrue.java:36)  at app//org.junit.jupiter.api.AssertTrue.assertTrue(AssertTrue.java:31)  at app//org.junit.jupiter.api.Assertions.assertTrue(Assertions.java:180)  at app//org.apache.ignite.internal.runner.app.ItIgniteInMemoryNodeRestartTest.inMemoryNodeRestartNotLeader(ItIgniteInMemoryNodeRestartTest.java:224) {code}
h3. Implementation Notes
 * ItIgniteInMemoryNodeRestartTest#inMemoryNodeRestartNotLeader was fixed within https://issues.apache.org/jira/browse/IGNITE-19043

 * And I've also enabled inMemoryNodeFullPartitionRestart(that was disabled with https://issues.apache.org/jira/browse/IGNITE-18822)  because the problem was probably fixed within https://issues.apache.org/jira/browse/IGNITE-19059 and https://issues.apache.org/jira/browse/IGNITE-19022

 ",,alapin,,,,,"sanpwc opened a new pull request, #1879:
URL: https://github.com/apache/ignite-3/pull/1879

   - ItIgniteInMemoryNodeRestartTest#inMemoryNodeRestartNotLeader was fixed within https://issues.apache.org/jira/browse/IGNITE-19043
   - And I've also enabled inMemoryNodeFullPartitionRestart because the problem was probably fixed within https://issues.apache.org/jira/browse/IGNITE-19059 and https://issues.apache.org/jira/browse/IGNITE-19022


;31/Mar/23 13:20;githubbot;600","sanpwc merged PR #1879:
URL: https://github.com/apache/ignite-3/pull/1879


;31/Mar/23 15:20;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,IGNITE-19043,,IGNITE-18822,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-03-15 16:39:55.0,,,,,,,,,,"0|z1glyw:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
ItRaftCommandLeftInLogUntilRestartTest: PageMemoryHashIndexStorage lacks data after cluster restart,IGNITE-19043,13528661,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,alapin,alapin,alapin,15/Mar/23 15:57,31/Mar/23 13:56,13/Jul/23 09:11,29/Mar/23 14:13,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"After enabling ItRaftCommandLeftInLogUntilRestartTest failed with
{code:java}
org.opentest4j.AssertionFailedError: expected: not <null> {code}
while trying to retrieve previously added data after cluster restart. Seems that it's because there's no corresponding data in PK index.

It is worth to mention that originally given test is about about raft log re-application on node restart. So, I've commented all  partitionUpdateInhibitor in order to check whether it's related to re-application or indexes themselves, problem is reproducible without re-application logic.

It might be related to rocks to page memory defaults migration. Further investigation required.
h3. Implementation notes

After the investigation it's occurred that the reason of the failure is that raft log re-appliance is skipped within PartitionListener#handleUpdateCommand and PartitionListener#handleUpdateAllCommand because of following logic
{code:java}
        TxMeta txMeta = txStateStorage.get(cmd.txId());
        if (txMeta != null && (txMeta.txState() == COMMITED || txMeta.txState() == ABORTED)) {
            storage.runConsistently(() -> {
                storage.lastApplied(commandIndex, commandTerm);
                return null;
            });
        } 
 
{code}
Full scenario is following:

1. tx1.put populates raft log and mvPartitionStorage with corresponding log record and data.

2. tx1.commit also populates raft log with raft record and finished the transaction within txnStateStorage along wiht cleanup in mvPartitionStorage.

3. RocksDB based txnStateStorage flushes its state to a disk and page memory based doesn't.

4. After node restart raft replays the log, both put and commit commands, however on commit partition we skip put re-application  because of aforementioned
{code:java}
if (txMeta != null && (txMeta.txState() == COMMITED || txMeta.txState() == ABORTED)){code}
Just in case, transaction is considered to be committed because txnStateStorage flushes its state before stop.

 

So, in order to fix given issue it's enough to just remove the skip logic.",,alapin,Denis Chudov,,,,"sanpwc merged PR #1857:
URL: https://github.com/apache/ignite-3/pull/1857


;29/Mar/23 14:08;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,IGNITE-19044,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Mar 29 13:35:26 UTC 2023,,,,,,,,,,"0|z1glxk:",9223372036854775807,,,Denis Chudov,,,,,,,,,,,,,,,,,,"29/Mar/23 13:35;Denis Chudov;[~alapin]  LGTM;;;",,,,,
NPE on DistributionZoneManager#saveDataNodesToMetaStorageOnScaleUp,IGNITE-19042,13528659,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Sergey Uttsel,Sergey Uttsel,Sergey Uttsel,15/Mar/23 15:39,20/Mar/23 13:58,13/Jul/23 09:11,20/Mar/23 13:58,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"h3. Motivation

NullPointerException in log on start the first node in the cluster if DistributionZoneConfigurationSchema#dataNodesAutoAdjustScaleUp and DistributionZoneConfigurationSchema#dataNodesAutoAdjustScaleDown are 0.

How to reproduce:
 # Set DistributionZoneConfigurationSchema#dataNodesAutoAdjustScaleUp = 0 and DistributionZoneConfigurationSchema#dataNodesAutoAdjustScaleDown = 0.
 # Start the test which starts the node. For example ItTablesApiTest#testAddIndex.
 # See NullPointerException in the log.

{code:java}
Caused by: java.lang.NullPointerException	at java.base/java.io.ByteArrayInputStream.<init>(ByteArrayInputStream.java:108)	at org.apache.ignite.internal.util.ByteUtils.fromBytes(ByteUtils.java:152)	at org.apache.ignite.internal.distributionzones.DistributionZoneManager.lambda$saveDataNodesToMetaStorageOnScaleUp$32(DistributionZoneManager.java:1096)	at org.apache.ignite.internal.util.IgniteUtils.inBusyLock(IgniteUtils.java:870)	at org.apache.ignite.internal.distributionzones.DistributionZoneManager.lambda$saveDataNodesToMetaStorageOnScaleUp$33(DistributionZoneManager.java:1090)	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1072)	... 13 more {code}
The root cause is zoneDataNodesKey, zoneScaleUpChangeTriggerKey, zoneScaleDownChangeTriggerKey of zones are not initialized on node start if vaultMgr.get(zonesLogicalTopologyKey()) is null. It's possible for default distribution zone because custom zone the keys initialized in DistributionZoneManager.ZonesConfigurationListener#onCreate.

*Definition of Done*

Properly handle non-initialized values of zoneDataNodesKey, zoneScaleUpChangeTriggerKey, zoneScaleDownChangeTriggerKey in DistributionZoneManager#saveDataNodesToMetaStorageOnScaleUp and DistributionZoneManager#
saveDataNodesToMetaStorageOnScaleDown",,alapin,Sergey Uttsel,,,,"sergeyuttsel opened a new pull request, #1797:
URL: https://github.com/apache/ignite-3/pull/1797

   https://issues.apache.org/jira/browse/IGNITE-19042


;15/Mar/23 15:43;githubbot;600","sanpwc commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1139044086


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -873,25 +873,25 @@ private void initDataNodesFromVaultManager() {
                         try {
                             if (vaultEntry != null && vaultEntry.value() != null) {
                                 logicalTopology = fromBytes(vaultEntry.value());
+                            }
 
-                                // init keys and data nodes for default zone
-                                saveDataNodesAndUpdateTriggerKeysInMetaStorage(
-                                        DEFAULT_ZONE_ID,
-                                        appliedRevision,
-                                        logicalTopology
-                                );
+                            // init keys and data nodes for default zone
+                            saveDataNodesAndUpdateTriggerKeysInMetaStorage(
+                                    DEFAULT_ZONE_ID,
+                                    appliedRevision,
+                                    logicalTopology

Review Comment:
   Are we going to call saveDataNodesAndUpdateTriggerKeysInMetaStorage if vaultEntry == null or  vaultEntry.value() == null? If true
   a. Why?
   b. What we will use as logicalTopology?



;16/Mar/23 16:49;githubbot;600","sergeyuttsel commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1139065968


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -873,25 +873,25 @@ private void initDataNodesFromVaultManager() {
                         try {
                             if (vaultEntry != null && vaultEntry.value() != null) {
                                 logicalTopology = fromBytes(vaultEntry.value());
+                            }
 
-                                // init keys and data nodes for default zone
-                                saveDataNodesAndUpdateTriggerKeysInMetaStorage(
-                                        DEFAULT_ZONE_ID,
-                                        appliedRevision,
-                                        logicalTopology
-                                );
+                            // init keys and data nodes for default zone
+                            saveDataNodesAndUpdateTriggerKeysInMetaStorage(
+                                    DEFAULT_ZONE_ID,
+                                    appliedRevision,
+                                    logicalTopology

Review Comment:
   a) Yes. Because need to initialize zoneDataNodesKey(zoneId), zoneScaleUpChangeTriggerKey(zoneId), zoneScaleDownChangeTriggerKey(zoneId) in the meta storage.
   b) We will use the value in logicalTopology. By default it emptySet().



;16/Mar/23 17:00;githubbot;600","sanpwc commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1139081607


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -873,25 +873,25 @@ private void initDataNodesFromVaultManager() {
                         try {
                             if (vaultEntry != null && vaultEntry.value() != null) {
                                 logicalTopology = fromBytes(vaultEntry.value());
+                            }
 
-                                // init keys and data nodes for default zone
-                                saveDataNodesAndUpdateTriggerKeysInMetaStorage(
-                                        DEFAULT_ZONE_ID,
-                                        appliedRevision,
-                                        logicalTopology
-                                );
+                            // init keys and data nodes for default zone
+                            saveDataNodesAndUpdateTriggerKeysInMetaStorage(
+                                    DEFAULT_ZONE_ID,
+                                    appliedRevision,
+                                    logicalTopology

Review Comment:
   I don't agree. What's the point in writing empty dataNodes and fake appliedRevision? That should be handled within saveDataNodesToMetaStorageOn...



;16/Mar/23 17:10;githubbot;600","sergeyuttsel commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1139849915


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -873,25 +873,25 @@ private void initDataNodesFromVaultManager() {
                         try {
                             if (vaultEntry != null && vaultEntry.value() != null) {
                                 logicalTopology = fromBytes(vaultEntry.value());
+                            }
 
-                                // init keys and data nodes for default zone
-                                saveDataNodesAndUpdateTriggerKeysInMetaStorage(
-                                        DEFAULT_ZONE_ID,
-                                        appliedRevision,
-                                        logicalTopology
-                                );
+                            // init keys and data nodes for default zone
+                            saveDataNodesAndUpdateTriggerKeysInMetaStorage(
+                                    DEFAULT_ZONE_ID,
+                                    appliedRevision,
+                                    logicalTopology

Review Comment:
   It is easier to initialize it once than to do null checks in saveDataNodesToMetaStorageOnScaleUp and saveDataNodesToMetaStorageOnScaleDown and may be later in other places



;17/Mar/23 07:05;githubbot;600","sanpwc commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1139881721


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -873,25 +873,25 @@ private void initDataNodesFromVaultManager() {
                         try {
                             if (vaultEntry != null && vaultEntry.value() != null) {
                                 logicalTopology = fromBytes(vaultEntry.value());
+                            }
 
-                                // init keys and data nodes for default zone
-                                saveDataNodesAndUpdateTriggerKeysInMetaStorage(
-                                        DEFAULT_ZONE_ID,
-                                        appliedRevision,
-                                        logicalTopology
-                                );
+                            // init keys and data nodes for default zone
+                            saveDataNodesAndUpdateTriggerKeysInMetaStorage(
+                                    DEFAULT_ZONE_ID,
+                                    appliedRevision,
+                                    logicalTopology

Review Comment:
   Well, the easiest way will be to catch NPE and ignore it. What I wan't to say here is that easier doesn't mean better.



;17/Mar/23 07:40;githubbot;600","sanpwc commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1139881721


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -873,25 +873,25 @@ private void initDataNodesFromVaultManager() {
                         try {
                             if (vaultEntry != null && vaultEntry.value() != null) {
                                 logicalTopology = fromBytes(vaultEntry.value());
+                            }
 
-                                // init keys and data nodes for default zone
-                                saveDataNodesAndUpdateTriggerKeysInMetaStorage(
-                                        DEFAULT_ZONE_ID,
-                                        appliedRevision,
-                                        logicalTopology
-                                );
+                            // init keys and data nodes for default zone
+                            saveDataNodesAndUpdateTriggerKeysInMetaStorage(
+                                    DEFAULT_ZONE_ID,
+                                    appliedRevision,
+                                    logicalTopology

Review Comment:
   Well, the easiest way will be to catch NPE and ignore it. What I wan't to say here is that easier doesn't mean better.
   Besides that, we'll need to fix immediate dataNodes recalculation and postpone it according to scaleUp/Down values, so that proposed approach won't work at all.



;17/Mar/23 07:47;githubbot;600","sergeyuttsel commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1140410959


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -873,25 +873,25 @@ private void initDataNodesFromVaultManager() {
                         try {
                             if (vaultEntry != null && vaultEntry.value() != null) {
                                 logicalTopology = fromBytes(vaultEntry.value());
+                            }
 
-                                // init keys and data nodes for default zone
-                                saveDataNodesAndUpdateTriggerKeysInMetaStorage(
-                                        DEFAULT_ZONE_ID,
-                                        appliedRevision,
-                                        logicalTopology
-                                );
+                            // init keys and data nodes for default zone
+                            saveDataNodesAndUpdateTriggerKeysInMetaStorage(
+                                    DEFAULT_ZONE_ID,
+                                    appliedRevision,
+                                    logicalTopology

Review Comment:
   Ok. Fixed.



;17/Mar/23 15:53;githubbot;600","sanpwc commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1141734325


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1093,11 +1094,35 @@ CompletableFuture<Void> saveDataNodesToMetaStorageOnScaleUp(int zoneId, long rev
                     return completedFuture(null);
                 }
 
-                Map<String, Integer> dataNodesFromMetaStorage = fromBytes(values.get(zoneDataNodesKey(zoneId)).value());
+                Entry dataNodesValue = values.get(zoneDataNodesKey(zoneId));

Review Comment:
   What we expect to retrieve from the meta storage if there are no corresponding keys?
   We will get map with three elements, right? 
   The values will be null? or empty? See Entry#empty?
   Is it possible to have null/empty dataNodesValue and non null/empty zoneScaleUpChangeTriggerValue?



;20/Mar/23 07:49;githubbot;600","sanpwc commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1141735080


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1093,11 +1094,35 @@ CompletableFuture<Void> saveDataNodesToMetaStorageOnScaleUp(int zoneId, long rev
                     return completedFuture(null);
                 }
 
-                Map<String, Integer> dataNodesFromMetaStorage = fromBytes(values.get(zoneDataNodesKey(zoneId)).value());
+                Entry dataNodesValue = values.get(zoneDataNodesKey(zoneId));
 
-                long scaleUpTriggerRevision = bytesToLong(values.get(zoneScaleUpChangeTriggerKey(zoneId)).value());
+                Entry zoneScaleUpChangeTriggerValue = values.get(zoneScaleUpChangeTriggerKey(zoneId));
 
-                long scaleDownTriggerRevision = bytesToLong(values.get(zoneScaleDownChangeTriggerKey(zoneId)).value());
+                Entry zoneScaleDownChangeTriggerValue = values.get(zoneScaleDownChangeTriggerKey(zoneId));
+
+                Map<String, Integer> dataNodesFromMetaStorage;

Review Comment:
   It seems that we have very similar or even exact the same code both in scaleUp/Down, am I right?



;20/Mar/23 07:50;githubbot;600","sanpwc commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1141751678


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZonesUtil.java:
##########
@@ -160,10 +161,23 @@ static CompoundCondition triggerKeyConditionForZonesChanges(long revision, int z
      * @return Update condition.
      */
     static CompoundCondition triggerScaleUpScaleDownKeysCondition(long scaleUpTriggerRevision, long scaleDownTriggerRevision,  int zoneId) {
-        return and(
-                value(zoneScaleUpChangeTriggerKey(zoneId)).eq(ByteUtils.longToBytes(scaleUpTriggerRevision)),
-                value(zoneScaleDownChangeTriggerKey(zoneId)).eq(ByteUtils.longToBytes(scaleDownTriggerRevision))
-        );
+        SimpleCondition scaleUpCondition;
+
+        if (scaleUpTriggerRevision != 0) {

Review Comment:
   Why do you need this? I believe that we can explicitly generate notExists condition if there are no corresponding keys is ms. Meaning, that we don't need 0 and/or empty map as a signal for emptiness. 



;20/Mar/23 08:10;githubbot;600","sanpwc commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1141895892


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1447,4 +1448,20 @@ private static class Augmentation {
             this.addition = addition;
         }
     }
+
+    private static Map<String, Integer> extractDataNodes(Entry dataNodesEntry) {
+        if (!dataNodesEntry.empty()) {

Review Comment:
   So, dataNodesEntry won't be null, is that correct?



;20/Mar/23 10:16;githubbot;600","sanpwc commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1141899075


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1447,4 +1448,20 @@ private static class Augmentation {
             this.addition = addition;
         }
     }
+
+    private static Map<String, Integer> extractDataNodes(Entry dataNodesEntry) {
+        if (!dataNodesEntry.empty()) {
+            return fromBytes(dataNodesEntry.value());
+        } else {
+            return emptyMap();
+        }
+    }
+
+    private static long extractChangeTriggerRevision(Entry revisionEntry) {
+        if (!revisionEntry.empty()) {
+            return bytesToLong(revisionEntry.value());
+        } else {
+            return 0;

Review Comment:
   It's not clear, and thus a bit unreliable that zero here is the same zero you use in DistributionZoneUtils
   `if (scaleUpTriggerRevision != 0)` Let's use constant, e.g. INITIAL_TRIGGER_REVISION_VALUE or similar.



;20/Mar/23 10:19;githubbot;600","sanpwc commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1141899829


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1447,4 +1448,20 @@ private static class Augmentation {
             this.addition = addition;
         }
     }
+
+    private static Map<String, Integer> extractDataNodes(Entry dataNodesEntry) {
+        if (!dataNodesEntry.empty()) {
+            return fromBytes(dataNodesEntry.value());
+        } else {
+            return emptyMap();
+        }
+    }
+
+    private static long extractChangeTriggerRevision(Entry revisionEntry) {

Review Comment:
   Let's move both extract methods to DistributionZonesUtil, WDYT?



;20/Mar/23 10:20;githubbot;600","sanpwc commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1141901848


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZonesUtil.java:
##########
@@ -160,10 +161,23 @@ static CompoundCondition triggerKeyConditionForZonesChanges(long revision, int z
      * @return Update condition.
      */
     static CompoundCondition triggerScaleUpScaleDownKeysCondition(long scaleUpTriggerRevision, long scaleDownTriggerRevision,  int zoneId) {
-        return and(
-                value(zoneScaleUpChangeTriggerKey(zoneId)).eq(ByteUtils.longToBytes(scaleUpTriggerRevision)),
-                value(zoneScaleDownChangeTriggerKey(zoneId)).eq(ByteUtils.longToBytes(scaleDownTriggerRevision))
-        );
+        SimpleCondition scaleUpCondition;
+
+        if (scaleUpTriggerRevision != 0) {

Review Comment:
   Discussed in person.



;20/Mar/23 10:21;githubbot;600","sergeyuttsel commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1142035270


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1093,11 +1094,35 @@ CompletableFuture<Void> saveDataNodesToMetaStorageOnScaleUp(int zoneId, long rev
                     return completedFuture(null);
                 }
 
-                Map<String, Integer> dataNodesFromMetaStorage = fromBytes(values.get(zoneDataNodesKey(zoneId)).value());
+                Entry dataNodesValue = values.get(zoneDataNodesKey(zoneId));
 
-                long scaleUpTriggerRevision = bytesToLong(values.get(zoneScaleUpChangeTriggerKey(zoneId)).value());
+                Entry zoneScaleUpChangeTriggerValue = values.get(zoneScaleUpChangeTriggerKey(zoneId));
 
-                long scaleDownTriggerRevision = bytesToLong(values.get(zoneScaleDownChangeTriggerKey(zoneId)).value());
+                Entry zoneScaleDownChangeTriggerValue = values.get(zoneScaleDownChangeTriggerKey(zoneId));
+
+                Map<String, Integer> dataNodesFromMetaStorage;

Review Comment:
   Reduce a duplicated code.



;20/Mar/23 12:24;githubbot;600","sergeyuttsel commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1142035947


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1093,11 +1094,35 @@ CompletableFuture<Void> saveDataNodesToMetaStorageOnScaleUp(int zoneId, long rev
                     return completedFuture(null);
                 }
 
-                Map<String, Integer> dataNodesFromMetaStorage = fromBytes(values.get(zoneDataNodesKey(zoneId)).value());
+                Entry dataNodesValue = values.get(zoneDataNodesKey(zoneId));

Review Comment:
   Fixed. We can use Entry#empty.



;20/Mar/23 12:25;githubbot;600","sergeyuttsel commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1142036190


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1447,4 +1448,20 @@ private static class Augmentation {
             this.addition = addition;
         }
     }
+
+    private static Map<String, Integer> extractDataNodes(Entry dataNodesEntry) {
+        if (!dataNodesEntry.empty()) {

Review Comment:
   Yes.



##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1447,4 +1448,20 @@ private static class Augmentation {
             this.addition = addition;
         }
     }
+
+    private static Map<String, Integer> extractDataNodes(Entry dataNodesEntry) {
+        if (!dataNodesEntry.empty()) {
+            return fromBytes(dataNodesEntry.value());
+        } else {
+            return emptyMap();
+        }
+    }
+
+    private static long extractChangeTriggerRevision(Entry revisionEntry) {
+        if (!revisionEntry.empty()) {
+            return bytesToLong(revisionEntry.value());
+        } else {
+            return 0;

Review Comment:
   Fixed. I created INITIAL_TRIGGER_REVISION_VALUE.



##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -1447,4 +1448,20 @@ private static class Augmentation {
             this.addition = addition;
         }
     }
+
+    private static Map<String, Integer> extractDataNodes(Entry dataNodesEntry) {
+        if (!dataNodesEntry.empty()) {
+            return fromBytes(dataNodesEntry.value());
+        } else {
+            return emptyMap();
+        }
+    }
+
+    private static long extractChangeTriggerRevision(Entry revisionEntry) {

Review Comment:
   OK. Fixed.



;20/Mar/23 12:25;githubbot;600","sanpwc commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1142097387


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZonesUtil.java:
##########
@@ -248,7 +271,7 @@ static Update updateLogicalTopologyAndVersion(Set<String> logicalTopology, long
      * @return Returns a set of data nodes retrieved from data nodes map, which value is more than 0.
      */
     public static Set<String> dataNodes(Map<String, Integer> dataNodesMap) {
-        return dataNodesMap.entrySet().stream().filter(e -> e.getValue() > 0).map(Entry::getKey).collect(Collectors.toSet());
+        return dataNodesMap.entrySet().stream().filter(e -> e.getValue() > 0).map(Map.Entry::getKey).collect(Collectors.toSet());

Review Comment:
   Let's restore the import java.util.Map.Entry;



;20/Mar/23 13:16;githubbot;600","sergeyuttsel commented on code in PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797#discussion_r1142113220


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZonesUtil.java:
##########
@@ -248,7 +271,7 @@ static Update updateLogicalTopologyAndVersion(Set<String> logicalTopology, long
      * @return Returns a set of data nodes retrieved from data nodes map, which value is more than 0.
      */
     public static Set<String> dataNodes(Map<String, Integer> dataNodesMap) {
-        return dataNodesMap.entrySet().stream().filter(e -> e.getValue() > 0).map(Entry::getKey).collect(Collectors.toSet());
+        return dataNodesMap.entrySet().stream().filter(e -> e.getValue() > 0).map(Map.Entry::getKey).collect(Collectors.toSet());

Review Comment:
   Discussed in person.



;20/Mar/23 13:28;githubbot;600","sanpwc merged PR #1797:
URL: https://github.com/apache/ignite-3/pull/1797


;20/Mar/23 13:58;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,0,12600,,,0,12600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Mar 20 13:58:34 UTC 2023,,,,,,,,,,"0|z1glx4:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"20/Mar/23 13:58;alapin;[~Sergey Uttsel] LGTM, thx!;;;",,,,,
Fix PlatformTestNodeRunner SSL config on Windows,IGNITE-19039,13528611,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ademakov,ademakov,ademakov,15/Mar/23 11:11,15/Mar/23 14:56,13/Jul/23 09:11,15/Mar/23 14:56,3.0.0-beta2,,,,,,,3.0.0-beta2,platforms,,,0,ignite-3,,,There are problems on Windows with resolving path of SSL key path.,,ademakov,ptupitsyn,,,,"sashapolo commented on code in PR #1794:
URL: https://github.com/apache/ignite-3/pull/1794#discussion_r1137044484


##########
modules/core/src/testFixtures/java/org/apache/ignite/internal/testframework/IgniteTestUtils.java:
##########
@@ -826,4 +830,41 @@ public static void runRace(long timeoutMillis, RunnableX... actions) {
             throw assertionError;
         }
     }
+
+    /**
+     * Returns a file system path for a resource name.
+     *
+     * @param cls A class.
+     * @param resourceName A resource name.
+     * @return A file system path matching the path component of the resource URL.
+     */
+    public static <T> String getResourcePath(Class<T> cls, String resourceName) {
+        return getResourcePath(cls.getClassLoader().getResource(resourceName));
+    }
+
+    /**
+     * Converts an URL gotten from classloader to proper file system path.

Review Comment:
   ```suggestion
        * Converts a URL to a file system path.
   ```



##########
modules/core/src/testFixtures/java/org/apache/ignite/internal/testframework/IgniteTestUtils.java:
##########
@@ -826,4 +830,41 @@ public static void runRace(long timeoutMillis, RunnableX... actions) {
             throw assertionError;
         }
     }
+
+    /**
+     * Returns a file system path for a resource name.
+     *
+     * @param cls A class.
+     * @param resourceName A resource name.
+     * @return A file system path matching the path component of the resource URL.
+     */
+    public static <T> String getResourcePath(Class<T> cls, String resourceName) {
+        return getResourcePath(cls.getClassLoader().getResource(resourceName));
+    }
+
+    /**
+     * Converts an URL gotten from classloader to proper file system path.
+     *
+     * @param url A resource URL.
+     * @return A file system path matching the path component of the resource URL.
+     */
+    public static String getResourcePath(URL url) {
+        try {
+            Objects.requireNonNull(url);

Review Comment:
   I think this check is redundant



##########
modules/core/src/testFixtures/java/org/apache/ignite/internal/testframework/IgniteTestUtils.java:
##########
@@ -826,4 +830,41 @@ public static void runRace(long timeoutMillis, RunnableX... actions) {
             throw assertionError;
         }
     }
+
+    /**
+     * Returns a file system path for a resource name.
+     *
+     * @param cls A class.
+     * @param resourceName A resource name.
+     * @return A file system path matching the path component of the resource URL.
+     */
+    public static <T> String getResourcePath(Class<T> cls, String resourceName) {

Review Comment:
   ```suggestion
       public static String getResourcePath(Class<?> cls, String resourceName) {
   ```



##########
modules/core/src/testFixtures/java/org/apache/ignite/internal/testframework/IgniteTestUtils.java:
##########
@@ -826,4 +830,41 @@ public static void runRace(long timeoutMillis, RunnableX... actions) {
             throw assertionError;
         }
     }
+
+    /**
+     * Returns a file system path for a resource name.
+     *
+     * @param cls A class.
+     * @param resourceName A resource name.
+     * @return A file system path matching the path component of the resource URL.
+     */
+    public static <T> String getResourcePath(Class<T> cls, String resourceName) {
+        return getResourcePath(cls.getClassLoader().getResource(resourceName));
+    }
+
+    /**
+     * Converts an URL gotten from classloader to proper file system path.
+     *
+     * @param url A resource URL.
+     * @return A file system path matching the path component of the resource URL.
+     */
+    public static String getResourcePath(URL url) {
+        try {
+            Objects.requireNonNull(url);
+            // Properly extract file system path from the ""file:"" URL
+            return Path.of(url.toURI()).toString();
+        } catch (URISyntaxException e) {
+            throw new RuntimeException(e); // Shouldn't happen since URL is obtained from the class loader
+        }
+    }
+
+    /**
+     * Adds escape characters before backslashes in a path (on Windows), e.g. for the HOCON config parser.

Review Comment:
   Can you please provide an example, how this method will transform a given string?



;15/Mar/23 13:16;githubbot;600","ptupitsyn merged PR #1794:
URL: https://github.com/apache/ignite-3/pull/1794


;15/Mar/23 14:56;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Mar 15 14:56:35 UTC 2023,,,,,,,,,,"0|z1glmg:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"15/Mar/23 14:56;ptupitsyn;Merged to main: bf6aac866ea0c8a7f2c7af445038978ac9e072ad;;;",,,,,
sql command does not enter repl,IGNITE-19038,13528601,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,aleksandr.pakhomov,aleksandr.pakhomov,15/Mar/23 09:55,17/Apr/23 17:16,13/Jul/23 09:11,17/Apr/23 17:16,,,,,,,,3.0.0-beta2,cli,,,0,ignite-3,,,"{code:bash}
[defaultNode]> sql ""create table test(i int primary key)""
SQL query execution error
Exception while executing query [query=""create table test(i int primary key)""]. Error message:IGN-SQL-3 TraceId:9f1d43d1-5f6d-4319-94a1-2225e931a80d IGN-SQL-3 TraceId:9f1d43d1-5f6d-4319-94a1-2225e931a80d Failed to parse query: Non-query expression encountered in illegal context <--- Why I get this error?
[defaultNode]> SQL    <---- here type exactly 3 letters and hit enter
SQL query execution error
Exception while executing query [query=""create table test(i int primary key)""]. Error message:IGN-SQL-3 TraceId:801a965d-3adf-443c-8028-d080fa894fb8 IGN-SQL-3 TraceId:801a965d-3adf-443c-8028-d080fa894fb8 Failed to parse query: Non-query expression encountered in illegal context
{code}

I would expect to enter the repl, but I get the same error message that I've got before. 

Also, the first error I've got seems strange, exactly the same query works in the repl.

Note: if I type ""sql "" with the space after -- it enters the repl. ",,aleksandr.pakhomov,,,,,"valepakh opened a new pull request, #1940:
URL: https://github.com/apache/ignite-3/pull/1940

   https://issues.apache.org/jira/browse/IGNITE-19038
   
   defaultValue is required in order to reset `@Parameters`-annotated field to null.


;13/Apr/23 17:28;githubbot;600","PakhomovAlexander merged PR #1940:
URL: https://github.com/apache/ignite-3/pull/1940


;17/Apr/23 17:15;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Mon Apr 17 17:16:35 UTC 2023,,,,,,,,,,"0|z1glk8:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"17/Apr/23 17:16;aleksandr.pakhomov;Thank you for the contribution, merged into main: fedb9267f522de5c8a96ab2bbde450ff6d1139d5;;;",,,,,
Ignite extensions fail to compile after TcpClientCache#putAllConflict method signature has changed.,IGNITE-19026,13528454,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,,PetrovMikhail,PetrovMikhail,14/Mar/23 14:44,20/Apr/23 10:46,13/Jul/23 09:11,15/Mar/23 16:40,,,,,,,,2.15,,,,0,,,,"https://issues.apache.org/jira/browse/IGNITE-17449 caused the signature of the TcpClientCache#putAllConflict method to change, which in turn caused the compilation of the CDC extension to fail.

TC Build example:
https://ci.ignite.apache.org/viewLog.html?buildId=7129807&tab=buildResultsDiv&buildTypeId=IgniteExtensions_Tests_Cdc",,nizhikov,PetrovMikhail,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-17449,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Mar 15 16:40:00 UTC 2023,,,,,,,,,,"0|z1gknk:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"15/Mar/23 16:40;nizhikov;Fixed by https://github.com/apache/ignite-extensions/commit/f6ee5b316fa1307dea2e8c8f96d1072bae875b22;;;",,,,,
Specify expire time during conflict resolution,IGNITE-19020,13528388,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,nizhikov,nizhikov,nizhikov,14/Mar/23 09:35,24/Apr/23 14:47,13/Jul/23 09:11,15/Mar/23 16:24,,,,,,,,2.15,,,,0,IEP-59,ise,,"In case usage of putAllConflict, expireTime behaviour differs from standart cache operations.
We must allow to the plugin providers to specify expiryTime when resolving entries conflicts.",,ignitetcbot,nizhikov,,,,"nizhikov opened a new pull request, #10594:
URL: https://github.com/apache/ignite/pull/10594

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;14/Mar/23 16:17;githubbot;600","nizhikov merged PR #10594:
URL: https://github.com/apache/ignite/pull/10594


;15/Mar/23 16:24;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-17449,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Wed Mar 15 16:24:30 UTC 2023,,,,,,,,,,"0|z1gk8w:",9223372036854775807,Added ability to provide expireTime during CDC conflict resolution,,,,,,,,,,,,,,,,,,,,"15/Mar/23 16:24;ignitetcbot;{panel:title=Branch: [pull/10594/head] Base: [master] : Possible Blockers (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}
{color:#d04437}Snapshots{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7094256]]
* IgniteSnapshotTestSuite: EncryptedSnapshotTest.testSnapshotRestoringFailsWithOtherMasterKey[Encryption is enabled.] - Test has low fail rate in base branch 0,0% and is not flaky

{panel}
{panel:title=Branch: [pull/10594/head] Base: [master] : New Tests (12)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Cache (Expiry Policy){color} [[tests 12|https://ci2.ignite.apache.org/viewLog.html?buildId=7094185]]
* {color:#013220}IgniteCacheExpiryPolicyTestSuite: IgniteCacheAtomicExpiryPolicyTest.testTtlUpdateOrder - PASSED{color}
* {color:#013220}IgniteCacheExpiryPolicyTestSuite: IgniteCacheAtomicReplicatedExpiryPolicyTest.testTtlUpdateOrder - PASSED{color}
* {color:#013220}IgniteCacheExpiryPolicyTestSuite: IgniteCacheAtomicWithStoreExpiryPolicyTest.testPutAllConflictWithResolverPluginTtlUpdateOrder - PASSED{color}
* {color:#013220}IgniteCacheExpiryPolicyTestSuite: IgniteCacheAtomicWithStoreExpiryPolicyTest.testTtlUpdateOrder - PASSED{color}
* {color:#013220}IgniteCacheExpiryPolicyTestSuite: IgniteCacheAtomicExpiryPolicyTest.testPutAllConflictWithResolverPluginTtlUpdateOrder - PASSED{color}
* {color:#013220}IgniteCacheExpiryPolicyTestSuite: IgniteCacheTxWithStoreExpiryPolicyTest.testTtlUpdateOrder - PASSED{color}
* {color:#013220}IgniteCacheExpiryPolicyTestSuite: IgniteCacheTxExpiryPolicyTest.testPutAllConflictWithResolverPluginTtlUpdateOrder - PASSED{color}
* {color:#013220}IgniteCacheExpiryPolicyTestSuite: IgniteCacheTxExpiryPolicyTest.testTtlUpdateOrder - PASSED{color}
* {color:#013220}IgniteCacheExpiryPolicyTestSuite: IgniteCacheAtomicReplicatedExpiryPolicyTest.testPutAllConflictWithResolverPluginTtlUpdateOrder - PASSED{color}
* {color:#013220}IgniteCacheExpiryPolicyTestSuite: IgniteCacheTxReplicatedExpiryPolicyTest.testPutAllConflictWithResolverPluginTtlUpdateOrder - PASSED{color}
* {color:#013220}IgniteCacheExpiryPolicyTestSuite: IgniteCacheTxReplicatedExpiryPolicyTest.testTtlUpdateOrder - PASSED{color}
... and 1 new tests

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7094278&amp;buildTypeId=IgniteTests24Java8_RunAll];;;",,,,,
Sql. Investigate AssertionError in ScanNode. ItCorrelatesTest fails when distribution of VALUES is changed from Broadcast to Single.,IGNITE-19018,13528345,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,amashenkov,mzhuravkov,mzhuravkov,14/Mar/23 06:30,03/May/23 08:33,13/Jul/23 09:11,18/Apr/23 14:13,3.0.0-beta2,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"The query in ItCorrelatesTest triggers AssertionError in ScanNode. This behaviour is observed in after modification operations were changed in https://issues.apache.org/jira/browse/IGNITE-18225 is implemented. 

{code:java}
 assertQuery(""SELECT * FROM test1 WHERE ""
                + ""EXISTS(SELECT * FROM test2 WHERE (SELECT test1.a)=test2.a AND (SELECT test1.b)<>test2.c) ""
                + ""AND NOT EXISTS(SELECT * FROM test2 WHERE (SELECT test1.a)=test2.a AND (SELECT test1.b)<test2.c)"")
                .returns(12, 2)
                .check();
{code}

AssertionError:

{code:java}
Caused by: java.lang.AssertionError: rowsCnt=512, requested=512
	at org.apache.ignite.internal.sql.engine.exec.rel.ScanNode.request(ScanNode.java:53)
	at org.apache.ignite.internal.sql.engine.exec.rel.ProjectNode.request(ProjectNode.java:59)
	at org.apache.ignite.internal.sql.engine.exec.rel.HashAggregateNode.request(HashAggregateNode.java:110)
	at org.apache.ignite.internal.sql.engine.exec.rel.Outbox.flush(Outbox.java:267)
	at org.apache.ignite.internal.sql.engine.exec.rel.Outbox.onRequest(Outbox.java:108)
	at org.apache.ignite.internal.sql.engine.exec.ExchangeServiceImpl.lambda$onMessage$3(ExchangeServiceImpl.java:178)
	at org.apache.ignite.internal.sql.engine.exec.ExchangeServiceImpl.onMessage(ExchangeServiceImpl.java:187)
	at org.apache.ignite.internal.sql.engine.exec.ExchangeServiceImpl.lambda$start$1(ExchangeServiceImpl.java:73)
	at org.apache.ignite.internal.sql.engine.message.MessageServiceImpl.onMessageInternal(MessageServiceImpl.java:164)
	at org.
{code}

",,amashenkov,mzhuravkov,,,,"AMashenkov opened a new pull request, #1856:
URL: https://github.com/apache/ignite-3/pull/1856

   https://issues.apache.org/jira/browse/IGNITE-19018


;28/Mar/23 15:54;githubbot;600","korlov42 commented on code in PR #1856:
URL: https://github.com/apache/ignite-3/pull/1856#discussion_r1165294381


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/rel/Inbox.java:
##########
@@ -542,6 +542,9 @@ void requestNextBatchIfNeeded() throws IgniteInternalCheckedException {
             // IO_BATCH_CNT should never be less than 1, but we don't have validation
             if (IO_BATCH_CNT <= 1 && inFlightCount == 0) {
                 batchRequester.request(1, sharedStateHolder);
+
+                lastRequested++;

Review Comment:
   that was a stupid bug =(
   
   Does it make sense to refactor the whole method like 
   
   ```
           void requestNextBatchIfNeeded() throws IgniteInternalCheckedException {
               int maxInFlightCount = Math.max(IO_BATCH_CNT, 1);
               int currentInFlightCount = lastRequested - lastEnqueued;
   
               if (maxInFlightCount / 2 >= currentInFlightCount) {
                   int countOfBatches = maxInFlightCount - currentInFlightCount;
   
                   lastRequested += countOfBatches;
   
                   batchRequester.request(countOfBatches, sharedStateHolder);
                   // shared state should be send only once until next rewind
                   sharedStateHolder = null;
               }
           }
   ```



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/rel/Outbox.java:
##########
@@ -282,7 +301,49 @@ public void onNodeLeft(String nodeName) {
         }
     }
 
-    private static final class RemoteDownstream<RowT> {
+    /**
+     * Enqueue current rewind request, the tries to process rewind queue requests (in order) if possible.

Review Comment:
   did you mean `then tries`? 



##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/planner/DmlPlannerTest.java:
##########
@@ -38,48 +41,107 @@
  * Tests to verify DML plans.
  */
 public class DmlPlannerTest extends AbstractPlannerTest {
-
     /**
-     * Test for INSERT .. VALUES when table has a single distribution.
+     * Test for INSERT .. FROM SELECT when a both tables has a single distribution.
+     * TODO: IGNITE-19018 split into 2 cases: colocated and non-colocated.

Review Comment:
   TODO is referring to current issue



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/rel/Outbox.java:
##########
@@ -282,7 +301,49 @@ public void onNodeLeft(String nodeName) {
         }
     }
 
-    private static final class RemoteDownstream<RowT> {
+    /**
+     * Enqueue current rewind request, the tries to process rewind queue requests (in order) if possible.
+     *
+     * @param nodeName Requester node name.
+     * @param state Shared state.
+     * @param amountOfBatches Amount of batches requested.
+     * @throws Exception If failed.
+     */
+    public void onRewindRequest(String nodeName, SharedState state, int amountOfBatches) throws Exception {
+        checkState();
+
+        if (rewindQueue == null) {
+            rewindQueue = new ArrayDeque<>(nodeBuffers.size());
+        }
+
+        rewindQueue.offer(new RewindRequest(nodeName, state, amountOfBatches));
+
+        if (currentNode == null || currentNode.equals(nodeName)) {
+            processRewindQueue();
+        }
+    }
+
+    /**
+     * Takes the next delayed request from the queue if available, then applies the state, rewinds source and proceeds with the request.
+     *
+     * @throws Exception If failed to send the request.
+     */
+    private void processRewindQueue() throws Exception {
+        RewindRequest rewind = rewindQueue.poll();
+
+        if (rewind == null) {
+            return;
+        }
+
+        currentNode = rewind.nodeName;
+
+        context().sharedState(rewind.state);
+        rewind();
+
+        onRequest(currentNode, rewind.amountOfBatches);
+    }
+
+    static final class RemoteDownstream<RowT> {

Review Comment:
   why `package private`? The same question about `RewindRequest`



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/rel/Outbox.java:
##########
@@ -266,8 +278,15 @@ private void flush() throws Exception {
         if (waiting == 0) {
             source().request(waiting = inBufSize);
         } else if (waiting == -1) {
-            for (RemoteDownstream<RowT> buffer : nodeBuffers.values()) {
-                buffer.end();
+            if (currentNode != null) {
+                nodeBuffers.get(currentNode).end();
+                currentNode = null; // Allow incoming rewind request from next node.

Review Comment:
   should we add `assert currentNode == null` to processRewindQueue to make sure that current request is accidentally not screwed up by call to `processRewindQueue()`?



##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/planner/DmlPlannerTest.java:
##########


Review Comment:
   I see no changes to the optimisation phase, so why do we need to change planner tests? 



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/rel/Outbox.java:
##########
@@ -383,7 +444,7 @@ void reset() {
         void onBatchRequested(int amountOfBatches) throws Exception {
             assert amountOfBatches > 0 : amountOfBatches;
 
-            this.pendingCount = amountOfBatches;
+            this.pendingCount += amountOfBatches;

Review Comment:
   let's add test case for this to ExchangeExecutionTest



;13/Apr/23 11:31;githubbot;600","AMashenkov merged PR #1856:
URL: https://github.com/apache/ignite-3/pull/1856


;18/Apr/23 14:14;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,IGNITE-18225,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Thu Mar 30 16:29:30 UTC 2023,,,,,,,,,,"0|z1gjzc:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"28/Mar/23 10:56;amashenkov;This ticket was created in May 15.
I see no failures in main brach at all, the available historical data starts from Feb 22.
Is it actual issue? What are the steps to reproduce?;;;","28/Mar/23 11:03;mzhuravkov;Updated the description. This behaviour is observed after https://issues.apache.org/jira/browse/IGNITE-18225 (but the changes in the ticket should not have caused that error). ;;;","30/Mar/23 16:29;amashenkov;The query logical plan:
{code:java}
LogicalTableModify(table=[[PUBLIC, T]], operation=[INSERT], flattened=[false])
  LogicalProject(__p_key=[GEN_RANDOM_UUID()], VAL=[$0])
    LogicalValues(tuples=[[{ 1 }, { 2 }, { 3 }]])
{code}

As of now, in physical plan we get Values with broadcast distribution and TableModify with hash distribution. So, Calcite will add an Exchange in between. Actually, it is TrimExchange to make broadcast-distribution fits hash-distribution, which looks ok in general.

But here is a trick with Project that contains non-idemponent function, which produces UUID values.
So, we must either void requesting data from project more than once or make it deterministic and rewindable.

Also there are another similar queries:
1. INSERT INTO t VALUES (1), (2), (3)
2. INSERT INTO t (key, val) VALUES (1, 1), (2, 2), (3, 3)
3. INSERT INTO t (SELECT (val) FROM T2)
4. INSERT INTO t (SELECT (key, val) FROM VALUES() WHERE ...)

All these queries have similar logical plans, 3 and 4 have table scans at the very bottom.
The 4 has an additional filter, just as an example, that we may got different subtrees.
{code:java}
LogicalTableModify(table=[[PUBLIC, T]], operation=[INSERT], flattened=[false])
  LogicalProject(__p_key=[GEN_RANDOM_UUID()], VAL=[$0])
    LogicalTableScan(T2)
{code}

Seems, for p.1 and p3. single-distribution is mandatory because we need materialize Project values first, then send rows to other nodes.
For p.2 any distribution is acceptable. Single may be preffered for large Values set.
In p4, TableModify with  hash-distribution allows to pushdown TableModify and avoid pulling data to a single node.

Summarizing, we need to allow TableModify nodes satisfy single-distribution and hash-distribution in different cases. This can be achieved by having 2 rules like TableModifyConverterRule.
But how to forbid TableModify with hash-distribution when there is Values underneath ??
;;;",,,
Topology aware Raft client creates its own message handler which is not aware of Raft group,IGNITE-19014,13528222,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Denis Chudov,Denis Chudov,Denis Chudov,13/Mar/23 10:58,16/Mar/23 16:57,13/Jul/23 09:11,16/Mar/23 16:57,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Topology aware client creates its own message handler for leader change notifications. These notifications does not contain group ids, which is a problem for adding such clients for partition replication groups. Moreover, having same message handlers for one type of messages in number that is equal to the count of topology aware clients seems not to be a good decision and leads to weird problems after adding topology aware clients for partition Raft groups, which appear as random integration tests fails. 

We should get rid of this handler in topology aware client and create dedicated message processor in RPC.",,Denis Chudov,v.pyatkov,,,,"denis-chudov opened a new pull request, #1796:
URL: https://github.com/apache/ignite-3/pull/1796

   https://issues.apache.org/jira/browse/IGNITE-19014


;15/Mar/23 14:55;githubbot;600","vldpyatkov commented on code in PR #1796:
URL: https://github.com/apache/ignite-3/pull/1796#discussion_r1138309573


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/raft/PartitionListener.java:
##########
@@ -173,6 +165,14 @@ public void onWrite(Iterator<CommandClosure<WriteCommand>> iterator) {
                     assert false : ""Command was not found [cmd="" + command + ']';
                 }
 
+                if (command instanceof SafeTimePropagatingCommand) {

Review Comment:
   Shouldn't handle safe time in the snapshot lock. At lest until it is not stored in the storage.



##########
modules/placement-driver/src/main/java/org/apache/ignite/internal/raft/client/TopologyAwareRaftGroupService.java:
##########
@@ -72,6 +71,10 @@ public class TopologyAwareRaftGroupService implements RaftGroupService {
     /** Leader election handler. */
     private final ServerEventHandler serverEventHandler;
 
+    private final BiConsumer<ClusterNode, Long> leaderElectionListener;

Review Comment:
   This property is excess.



##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -342,12 +343,15 @@ public class IgniteImpl implements Ignite {
                 )
         );
 
+        RaftGroupEventsClientListener raftGroupEventsClientListener = new RaftGroupEventsClientListener();

Review Comment:
   As we discussed before, TODO here is required, to move the property to a factory for various types of clients.



;16/Mar/23 15:24;githubbot;600","vldpyatkov merged PR #1796:
URL: https://github.com/apache/ignite-3/pull/1796


;16/Mar/23 16:56;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,IGNITE-18744,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Mar 16 16:56:45 UTC 2023,,,,,,,,,,"0|z1gj80:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"16/Mar/23 15:29;v.pyatkov;[~Denis Chudov] I reviewed your patch. Look at comments in PR.

Also, do not forget reset (ServerEventHandler#term) when the client unsubscribes of the leader update event.;;;","16/Mar/23 16:56;v.pyatkov;LGTM;;;",,,,
Fix current metric names from prefix.prefix.metric to prefix.prefix.Metric,IGNITE-19005,13527986,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,slava.koptilin,kgusakov,kgusakov,10/Mar/23 14:24,08/Jun/23 07:43,13/Jul/23 09:11,08/Jun/23 07:43,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"JvmMetricSource has the metric names, which violates metric naming conventions: 
memory.heap.init must be replaced by memory.heap.Init and etc.",,kgusakov,,,,,"sk0x50 opened a new pull request, #2132:
URL: https://github.com/apache/ignite-3/pull/2132

   (no comment)


;01/Jun/23 10:50;githubbot;600","sk0x50 merged PR #2132:
URL: https://github.com/apache/ignite-3/pull/2132


;08/Jun/23 07:43;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jun 07 13:15:39 UTC 2023,,,,,,,,,,"0|z1ghrk:",9223372036854775807,,,kgusakov,,,,,,,,,,,,,,,,,,"07/Jun/23 13:15;kgusakov;LGTM;;;",,,,,
ignite config show is broken on connected state,IGNITE-19004,13527984,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,aleksandr.pakhomov,aleksandr.pakhomov,10/Mar/23 14:23,20/Mar/23 09:13,13/Jul/23 09:11,20/Mar/23 09:13,,,,,,,,3.0.0-beta2,cli,,,0,ignite-3,,,"Steps to reproduce:

* connect to an initialized cluster
* {{node config show}} (ok)
* {{node config show \-\-node-name}}     <---- without node name
* {{node config show}} (broken)
",,aleksandr.pakhomov,,,,,"valepakh opened a new pull request, #1811:
URL: https://github.com/apache/ignite-3/pull/1811

   https://issues.apache.org/jira/browse/IGNITE-19004


;17/Mar/23 15:29;githubbot;600","PakhomovAlexander merged PR #1811:
URL: https://github.com/apache/ignite-3/pull/1811


;20/Mar/23 09:09;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Mon Mar 20 09:13:03 UTC 2023,,,,,,,,,,"0|z1ghr4:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"20/Mar/23 09:13;aleksandr.pakhomov;Merged into main: 14ec8884935ab631f2f0fab0c096a944b76666a6;;;",,,,,
ODBC: Regression. Missed handling of single quotes,IGNITE-18993,13527874,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ivandasch,ivandasch,ivandasch,09/Mar/23 20:35,24/Apr/23 14:52,13/Jul/23 09:11,10/Mar/23 11:10,2.10,2.11,2.12,2.13,2.14,2.8,2.9,2.15,platforms,,,0,c++,odbc,,"When {{SQLTables}} is called with param 'table type' {{'TABLES'}} (with single comma), it returns an empty table list.
It is a quite common way of calling this procedure (i.e. by INFORMATICA)",,ignitetcbot,isapego,ivandasch,,,"ivandasch opened a new pull request, #10593:
URL: https://github.com/apache/ignite/pull/10593

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;09/Mar/23 20:41;githubbot;600","ivandasch merged PR #10593:
URL: https://github.com/apache/ignite/pull/10593


;10/Mar/23 11:09;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-10009,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Fri Mar 10 11:10:07 UTC 2023,,,,,,,,,,"0|z1gh2o:",9223372036854775807,ODBC: Fixed handling of single quotes,,,,,,,,,,,,,,,,,,,,"10/Mar/23 08:02;ignitetcbot;{panel:title=Branch: [pull/10593/head] Base: [master] : Possible Blockers (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}
{color:#d04437}Platform C++ CMake (Win x64 / Debug){color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7086523]]
* IgniteThinClientTest: ContinuousQueryTestSuite: TestLongEventsProcessingDisconnect - History for base branch is absent.

{panel}
{panel:title=Branch: [pull/10593/head] Base: [master] : New Tests (1063)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Platform C++ CMake (Win x64 / Debug){color} [[tests 1063|https://ci2.ignite.apache.org/viewLog.html?buildId=7086523]]
* {color:#013220}IgniteThinClientTest: CacheClientTestSuite: CacheClientGetAndPutIfAbsentComplexKey - PASSED{color}
* {color:#013220}IgniteThinClientTest: ComputeClientTestSuite: EchoTaskNull - PASSED{color}
* {color:#013220}IgniteThinClientTest: ComputeClientTestSuite: EchoTaskPrimitives - PASSED{color}
* {color:#013220}IgniteThinClientTest: ComputeClientTestSuite: EchoTaskObject - PASSED{color}
* {color:#013220}IgniteThinClientTest: ComputeClientTestSuite: EchoTaskGuid - PASSED{color}
* {color:#013220}IgniteThinClientTest: ComputeClientTestSuite: TaskWithTimeout - PASSED{color}
* {color:#013220}IgniteThinClientTest: ComputeClientTestSuite: TaskWithNoFailover - PASSED{color}
* {color:#013220}IgniteThinClientTest: ComputeClientTestSuite: TaskWithNoResultCache - PASSED{color}
* {color:#013220}IgniteThinClientTest: IgniteClientTestSuite: IgniteClientConnection - PASSED{color}
* {color:#013220}IgniteThinClientTest: IgniteClientTestSuite: IgniteClientConnectionFailover - PASSED{color}
* {color:#013220}IgniteThinClientTest: IgniteClientTestSuite: IgniteClientConnectionLimit - PASSED{color}
... and 1052 new tests

{panel}
[TeamCity *-&gt; Run :: CPP* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7086034&amp;buildTypeId=IgniteTests24Java8_RunCpp];;;","10/Mar/23 08:03;ivandasch;[~isapego] Could you review this patch, please?;;;","10/Mar/23 10:50;isapego;Looks good to me.;;;","10/Mar/23 11:10;ivandasch;[~isapego] Thanks for review, merged;;;",,
Problem with SslContextProviderTest on Windows,IGNITE-18987,13527723,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ademakov,ademakov,ademakov,09/Mar/23 00:48,09/Mar/23 07:41,13/Jul/23 09:11,09/Mar/23 07:41,3.0.0-beta2,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"The following unit tests fail for me on Windows:

SslContextProviderTest > throwsIgniteExceptionWhenWrongTruststorePathConfigured() FAILED
java.lang.AssertionError at SslContextProviderTest.java:162

SslContextProviderTest > throwsIgniteExceptionWhenWrongKeystorePathConfigured() FAILED
java.lang.AssertionError at SslContextProviderTest.java:145

More specifically such assert fails:

assertThat(thrown.getMessage(){color:#cc7832}, {color}containsString({color:#6a8759}""File /no/such/file.pfx not found""{color}));

The real message contains the path with backslashes: \no\such\file.pfx.",,ademakov,ptupitsyn,,,,"ptupitsyn merged PR #1768:
URL: https://github.com/apache/ignite-3/pull/1768


;09/Mar/23 07:40;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Mar 09 07:40:54 UTC 2023,,,,,,,,,,"0|z1gg54:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"09/Mar/23 07:40;ptupitsyn;Merged to main: 6d1fc54cc7c7564fe420f36866b7483c94e9a78b;;;",,,,,
Fix build issues after merge of the ticket,IGNITE-18981,13527635,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,maliev,maliev,maliev,08/Mar/23 12:15,08/Mar/23 12:46,13/Jul/23 09:11,08/Mar/23 12:46,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"After https://issues.apache.org/jira/browse/IGNITE-18835 was merged without updating with main, several build issues have been occurred. 

# {{AbstractBasicIntegrationTest}} was renamed to {{ClusterPerClassIntegrationTest}}, so appropriate class should be used in {{ItReadOnlyTransactionTest}} as a base class
# {{IgnitionManager#init}} method parameters were changed, so {{InitParameters}} should be used in {{ItRoReadsTest}}",,korlov,maliev,,,,"alievmirza opened a new pull request, #1764:
URL: https://github.com/apache/ignite-3/pull/1764

   https://issues.apache.org/jira/browse/IGNITE-18981


;08/Mar/23 12:23;githubbot;600","alievmirza closed pull request #1763: IGNITE-18981 fix build issues after https://issues.apache.org/jira/browse/IGNITE-18835 was merged to main
URL: https://github.com/apache/ignite-3/pull/1763


;08/Mar/23 12:24;githubbot;600","korlov42 merged PR #1764:
URL: https://github.com/apache/ignite-3/pull/1764


;08/Mar/23 12:45;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Mar 08 12:46:24 UTC 2023,,,,,,,,,,"0|z1gflk:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"08/Mar/23 12:46;korlov;[~maliev], thanks of the contribution!

Merged to [main|https://github.com/apache/ignite-3/commit/be1628db0ea69cb35d22c861e899d294cc2c9e1d].;;;",,,,,
Affinity broken on thick client after reconnection,IGNITE-18976,13527395,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ivandasch,macrergate,macrergate,07/Mar/23 08:11,24/Apr/23 14:50,13/Jul/23 09:11,10/Mar/23 15:37,2.14,,,,,,,2.15,binary,,,0,ise,,,"1 Using AffinyKey +BynaryTypeconfiguration 
2 Client is reconnected
3 Affinity is Broken and Binary marshalling is broken:

on Affinity.partition wrong value is returning:
{noformat}
	at org.junit.Assert.failNotEquals(Assert.java:834)
	at org.junit.Assert.assertEquals(Assert.java:645)
	at org.junit.Assert.assertEquals(Assert.java:631)
	at org.apache.ignite.testframework.junits.JUnitAssertAware.assertEquals(JUnitAssertAware.java:95)
	at org.apache.ignite.internal.IgniteClientReconnectAffinityTest.doReconnectClientAffinityKeyPartition(IgniteClientReconnectAffinityTest.java:213)
	at org.apache.ignite.internal.IgniteClientReconnectAffinityTest.testReconnectClientAnnotatedAffinityKeyWithBinaryConfigPartition(IgniteClientReconnectAffinityTest.java:123)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.apache.ignite.testframework.junits.GridAbstractTest$6.run(GridAbstractTest.java:2504)
	at java.lang.Thread.run(Thread.java:748)
{noformat} [^IgniteClientReconnectAffinityTest.java] 

Exception on cache.get :
{noformat}
class org.apache.ignite.binary.BinaryObjectException: Failed to serialize object [typeName=org.apache.ignite.internal.IgniteClientReconnectAffinityTest$TestAnnotatedKey]

	at org.apache.ignite.internal.binary.BinaryClassDescriptor.write(BinaryClassDescriptor.java:916)
	at org.apache.ignite.internal.binary.BinaryWriterExImpl.marshal0(BinaryWriterExImpl.java:232)
	at org.apache.ignite.internal.binary.BinaryWriterExImpl.marshal(BinaryWriterExImpl.java:165)
	at org.apache.ignite.internal.binary.BinaryWriterExImpl.marshal(BinaryWriterExImpl.java:152)
	at org.apache.ignite.internal.binary.GridBinaryMarshaller.marshal(GridBinaryMarshaller.java:251)
	at org.apache.ignite.internal.processors.cache.binary.CacheObjectBinaryProcessorImpl.marshalToBinary(CacheObjectBinaryProcessorImpl.java:583)
	at org.apache.ignite.internal.processors.cache.binary.CacheObjectBinaryProcessorImpl.toBinary(CacheObjectBinaryProcessorImpl.java:1492)
	at org.apache.ignite.internal.processors.cache.binary.CacheObjectBinaryProcessorImpl.toCacheKeyObject(CacheObjectBinaryProcessorImpl.java:1287)
	at org.apache.ignite.internal.processors.cache.GridCacheContext.toCacheKeyObject(GridCacheContext.java:1818)
	at org.apache.ignite.internal.processors.cache.distributed.dht.colocated.GridDhtColocatedCache.getAsync(GridDhtColocatedCache.java:279)
	at org.apache.ignite.internal.processors.cache.GridCacheAdapter.get(GridCacheAdapter.java:4759)
	at org.apache.ignite.internal.processors.cache.GridCacheAdapter.repairableGet(GridCacheAdapter.java:4725)
	at org.apache.ignite.internal.processors.cache.GridCacheAdapter.get(GridCacheAdapter.java:1373)
	at org.apache.ignite.internal.processors.cache.IgniteCacheProxyImpl.get(IgniteCacheProxyImpl.java:1108)
	at org.apache.ignite.internal.processors.cache.GatewayProtectedCacheProxy.get(GatewayProtectedCacheProxy.java:686)
	at org.apache.ignite.internal.IgniteClientReconnectAffinityTest.doReconnectClientAffinityKeyGet(IgniteClientReconnectAffinityTest.java:180)
	at org.apache.ignite.internal.IgniteClientReconnectAffinityTest.testReconnectClientAnnotatedAffinityKeyWithBinaryConfigGet(IgniteClientReconnectAffinityTest.java:118)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.apache.ignite.testframework.junits.GridAbstractTest$6.run(GridAbstractTest.java:2504)
	at java.lang.Thread.run(Thread.java:748)
Caused by: class org.apache.ignite.binary.BinaryObjectException: Binary type has different affinity key fields [typeName=org.apache.ignite.internal.IgniteClientReconnectAffinityTest$TestAnnotatedKey, affKeyFieldName1=null, affKeyFieldName2=annotatedAffinityKey]
	at org.apache.ignite.internal.binary.BinaryUtils.mergeMetadata(BinaryUtils.java:1026)
	at org.apache.ignite.internal.processors.cache.binary.BinaryMetadataTransport.requestMetadataUpdate(BinaryMetadataTransport.java:210)
	at org.apache.ignite.internal.processors.cache.binary.CacheObjectBinaryProcessorImpl.addMeta(CacheObjectBinaryProcessorImpl.java:638)
	at org.apache.ignite.internal.processors.cache.binary.CacheObjectBinaryProcessorImpl$1.addMeta(CacheObjectBinaryProcessorImpl.java:292)
	at org.apache.ignite.internal.binary.BinaryContext.updateMetadata(BinaryContext.java:1342)
	at org.apache.ignite.internal.binary.BinaryClassDescriptor.write(BinaryClassDescriptor.java:875)
	... 26 more

{noformat}",,ignitetcbot,ivandasch,macrergate,,,"ivandasch opened a new pull request, #10584:
URL: https://github.com/apache/ignite/pull/10584

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;07/Mar/23 14:43;githubbot;600","ivandasch merged PR #10584:
URL: https://github.com/apache/ignite/pull/10584


;10/Mar/23 15:37;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"07/Mar/23 09:34;macrergate;IgniteClientReconnectAffinityTest.java;https://issues.apache.org/jira/secure/attachment/13056103/IgniteClientReconnectAffinityTest.java",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Sat Mar 11 10:08:50 UTC 2023,,,,,,,,,,"0|z1ge48:",9223372036854775807,Fixed broken affinity after thick client reconnection,,,,,,,,,,,,,,,,,,,,"07/Mar/23 12:48;ivandasch;[~macrergate] Many thanks for your reproducer, found the reason. Trying to fix it ASAP;;;","07/Mar/23 13:20;macrergate;[~ivandasch], Thank you for prompt response.;;;","08/Mar/23 15:28;ignitetcbot;{panel:title=Branch: [pull/10584/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10584/head] Base: [master] : New Tests (8)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Binary Objects{color} [[tests 8|https://ci2.ignite.apache.org/viewLog.html?buildId=7084072]]
* {color:#013220}IgniteBinaryObjectsTestSuite: GridCacheBinaryConfigurationWithAffinityKeyClientReconnectTest.testReconnectClientAffinityKeyPartition[with binary config = true, key = TestNotAnnotatedKey{notAnnotatedAffinityKey=1, nonAffinityInfo=1}] - PASSED{color}
* {color:#013220}IgniteBinaryObjectsTestSuite: GridCacheBinaryConfigurationWithAffinityKeyClientReconnectTest.testReconnectClientAffinityKeyGet[with binary config = true, key = TestNotAnnotatedKey{notAnnotatedAffinityKey=1, nonAffinityInfo=1}] - PASSED{color}
* {color:#013220}IgniteBinaryObjectsTestSuite: GridCacheBinaryConfigurationWithAffinityKeyClientReconnectTest.testReconnectClientAffinityKeyPartition[with binary config = false, key = TestNotAnnotatedKey{notAnnotatedAffinityKey=1, nonAffinityInfo=1}] - PASSED{color}
* {color:#013220}IgniteBinaryObjectsTestSuite: GridCacheBinaryConfigurationWithAffinityKeyClientReconnectTest.testReconnectClientAffinityKeyGet[with binary config = false, key = TestNotAnnotatedKey{notAnnotatedAffinityKey=1, nonAffinityInfo=1}] - PASSED{color}
* {color:#013220}IgniteBinaryObjectsTestSuite: GridCacheBinaryConfigurationWithAffinityKeyClientReconnectTest.testReconnectClientAffinityKeyPartition[with binary config = true, key = TestAnnotatedKey{annotatedAffinityKey=1, nonAffinityInfo=1}] - PASSED{color}
* {color:#013220}IgniteBinaryObjectsTestSuite: GridCacheBinaryConfigurationWithAffinityKeyClientReconnectTest.testReconnectClientAffinityKeyGet[with binary config = true, key = TestAnnotatedKey{annotatedAffinityKey=1, nonAffinityInfo=1}] - PASSED{color}
* {color:#013220}IgniteBinaryObjectsTestSuite: GridCacheBinaryConfigurationWithAffinityKeyClientReconnectTest.testReconnectClientAffinityKeyPartition[with binary config = false, key = TestAnnotatedKey{annotatedAffinityKey=1, nonAffinityInfo=1}] - PASSED{color}
* {color:#013220}IgniteBinaryObjectsTestSuite: GridCacheBinaryConfigurationWithAffinityKeyClientReconnectTest.testReconnectClientAffinityKeyGet[with binary config = false, key = TestAnnotatedKey{annotatedAffinityKey=1, nonAffinityInfo=1}] - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7083622&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","10/Mar/23 15:37;ivandasch;[~amashenkov] [~sk0x50] Many thanks for reviews, merged;;;","11/Mar/23 10:08;macrergate;[~ivandasch], appreciate your efforts! Thanks a  lot!;;;",
SSL configuration validation doesn't work,IGNITE-18972,13527292,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,vpakhnushev,vpakhnushev,06/Mar/23 14:38,07/Mar/23 09:37,13/Jul/23 09:11,07/Mar/23 09:37,,,,,,,,3.0.0-beta2,security,,,0,ignite-3,,,IGNITE-18850 doesn't properly define configuration validation. Proper annotation types should be used and tests should be added to test that validation actually works.,,aleksandr.pakhomov,vpakhnushev,,,,"valepakh opened a new pull request, #1755:
URL: https://github.com/apache/ignite-3/pull/1755

   https://issues.apache.org/jira/browse/IGNITE-18972


;06/Mar/23 14:39;githubbot;600","ibessonov commented on code in PR #1755:
URL: https://github.com/apache/ignite-3/pull/1755#discussion_r1127475331


##########
modules/rest/src/main/java/org/apache/ignite/internal/rest/configuration/RestSslConfigurationValidatorImpl.java:
##########
@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.rest.configuration;
+
+import org.apache.ignite.configuration.validation.ValidationContext;
+import org.apache.ignite.configuration.validation.Validator;
+import org.apache.ignite.internal.network.configuration.AbstractSslConfigurationValidator;
+
+/**
+ * REST SSL configuration validator implementation.
+ */
+public class RestSslConfigurationValidatorImpl implements Validator<RestSslConfigurationValidator, RestSslView> {

Review Comment:
   Why do you need two classes that perform the same validation?



##########
modules/client-handler/src/main/java/org/apache/ignite/client/handler/configuration/ClientHandlerConfigurationModule.java:
##########
@@ -38,4 +41,9 @@ public ConfigurationType type() {
     public Collection<RootKey<?, ?>> rootKeys() {
         return Collections.singleton(ClientConnectorConfiguration.KEY);
     }
+
+    @Override
+    public Set<Validator<?, ?>> validators() {
+        return Set.of(SslConfigurationValidatorImpl.INSTANCE);

Review Comment:
   This validator is repeated in two modules, you shouldn't do that, please remove one of them



;07/Mar/23 07:51;githubbot;600","PakhomovAlexander merged PR #1755:
URL: https://github.com/apache/ignite-3/pull/1755


;07/Mar/23 09:36;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-18575,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Mar 07 09:37:47 UTC 2023,,,,,,,,,,"0|z1gdhk:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"07/Mar/23 09:37;aleksandr.pakhomov;Thanks, merged into main: 411261841bf8b7080ae3d44634df6e87fb52476e;;;",,,,,
Possible race between updating a low watermark and processing the last batch for storage in a background GC,IGNITE-18968,13527217,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ktkalenko@gridgain.com,ktkalenko@gridgain.com,06/Mar/23 09:21,07/Mar/23 08:40,13/Jul/23 09:11,07/Mar/23 08:40,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"After some analysis of the background garbage collector code, a possible race was found between updating the low watermark and processing the last batch of storage.
Needs to be fixed.",,ktkalenko@gridgain.com,sdanilov,,,,"tkalkirill opened a new pull request, #1760:
URL: https://github.com/apache/ignite-3/pull/1760

   https://issues.apache.org/jira/browse/IGNITE-18968


;07/Mar/23 05:54;githubbot;600","tkalkirill merged PR #1760:
URL: https://github.com/apache/ignite-3/pull/1760


;07/Mar/23 08:40;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17571,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Mar 07 08:27:40 UTC 2023,,,,,,,,,,"0|z1gd0w:",9223372036854775807,,,sdanilov,,,,,,,,,,,,,,,,,,"07/Mar/23 08:27;sdanilov;LGTM;;;",,,,,
Sql. Custom data types. Fix least restrictive type and nullability.,IGNITE-18966,13527208,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,mzhuravkov,mzhuravkov,mzhuravkov,06/Mar/23 08:57,16/Mar/23 07:35,13/Jul/23 09:11,16/Mar/23 07:35,,,,,,,,3.0.0-beta2,sql,,,0,calcite2-required,ignite-3,,"1. Calcite uses ANY type for the DEFAULT operator and introduction of custom data types caused a regression that broke that rule.
  
2. Nullable attribute is not correctly set for custom data types - it creates a custom data type with nullability = true when it should be false.

3. Update commonTypeForBinaryComparison to convert to/from custom data type in binary comparison operators.
",,korlov,mzhuravkov,,,,"korlov42 commented on code in PR #1777:
URL: https://github.com/apache/ignite-3/pull/1777#discussion_r1136655075


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteTypeCoercion.java:
##########
@@ -291,6 +291,33 @@ private RelDataType syncAttributes(
         return syncedType;
     }
 
+    /** {@inheritDoc} **/
+    @Override
+    public @Nullable RelDataType commonTypeForBinaryComparison(@Nullable RelDataType type1, @Nullable RelDataType type2) {
+        if (type1 == null || type2 == null) {
+            return null;
+        }
+
+        if (type1 instanceof IgniteCustomType) {
+            return tryCustomTypeCoercionRules(type1, type2);
+        } else if (type2 instanceof IgniteCustomType) {
+            return tryCustomTypeCoercionRules(type2, type1);
+        } else {
+            return super.commonTypeForBinaryComparison(type1, type2);
+        }
+    }
+
+    private @Nullable RelDataType tryCustomTypeCoercionRules(RelDataType type1, RelDataType type2) {
+        IgniteCustomType to = (IgniteCustomType) type1;

Review Comment:
   this is potential ClassCastException. Let's change the signature in a way to make it clear that only CustomType should be passed as first argument. You have already done all necessary verifications on a caller site to make type casting safe



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/type/IgniteTypeFactory.java:
##########
@@ -375,28 +373,31 @@ public Type getResultClass(RelDataType type) {
             assert resultType instanceof BasicSqlType : ""leastRestrictive is expected to return a new instance of a type: "" + resultType;
 
             IgniteCustomType firstCustomType = null;
-            SqlTypeFamily sqlTypeFamily = null;
+            boolean hasAnyType = false;
 
             for (var type : types) {
                 if (type instanceof IgniteCustomType) {
-                    var customType = (IgniteCustomType) type;
-
                     if (firstCustomType == null) {
                         firstCustomType = (IgniteCustomType) type;
-                    } else if (!Objects.equals(firstCustomType.getCustomTypeName(), customType.getCustomTypeName())) {
-                        // IgniteCustomType: Conversion between custom data types is not supported.
-                        return null;
+                    } else {
+                        IgniteCustomType customType = (IgniteCustomType) type;
+                        if (!Objects.equals(firstCustomType.getCustomTypeName(), customType.getCustomTypeName())) {
+                            // IgniteCustomType: Conversion between custom data types is not supported.
+                            return null;
+                        } else {
+                            return firstCustomType;

Review Comment:
   you stop analysing types as soon as you found another matching custom type, ignoring the rest of the types. This doesn't look correct to me. Please take a look on the test below:
   
   ```
       // LeastRestrictiveTypesTest.java
       @Test
       public void test() {
           RelDataType uuidType = TYPE_FACTORY.createCustomType(UuidType.NAME);
           RelDataType intType = TYPE_FACTORY.createSqlType(SqlTypeName.INTEGER);
   
           RelDataType resultType = TYPE_FACTORY.leastRestrictive(List.of(uuidType, uuidType, intType));
   
           assertNull(resultType);
       }
   ```
   
   I would expect there is no least restrictive type between UUID and Integer, but currently UUID is returned



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteTypeCoercion.java:
##########
@@ -291,6 +291,33 @@ private RelDataType syncAttributes(
         return syncedType;
     }
 
+    /** {@inheritDoc} **/
+    @Override
+    public @Nullable RelDataType commonTypeForBinaryComparison(@Nullable RelDataType type1, @Nullable RelDataType type2) {
+        if (type1 == null || type2 == null) {
+            return null;
+        }
+
+        if (type1 instanceof IgniteCustomType) {
+            return tryCustomTypeCoercionRules(type1, type2);
+        } else if (type2 instanceof IgniteCustomType) {
+            return tryCustomTypeCoercionRules(type2, type1);
+        } else {
+            return super.commonTypeForBinaryComparison(type1, type2);
+        }
+    }
+
+    private @Nullable RelDataType tryCustomTypeCoercionRules(RelDataType type1, RelDataType type2) {
+        IgniteCustomType to = (IgniteCustomType) type1;
+        // IgniteCustomType: If type1 is a custom data type that can be converted to type2,

Review Comment:
   > If type1 is a custom data type that can be converted to type2,
   
   this sounds like we need to verify that type1 is can be converted to type2. In fact, we are going to make conversion vice versa (type2 -> type1)



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItImplicitCastsTest.java:
##########
@@ -46,7 +54,10 @@ public void dropTables() {
     public void testFilter(ColumnPair columnPair) {
         prepareTables(columnPair);
 
-        assertQuery(""SELECT T11.c2 FROM T11 WHERE T11.c2 > 1.0"").check();
+        String value = columnPair.lhsLiteral(0);
+        String query = format(""SELECT T11.c2 FROM T11 WHERE T11.c2 > CAST({} AS {})"", value, columnPair.rhs);

Review Comment:
   `CAST({} AS {})` ;15/Mar/23 10:05;githubbot;600","lowka commented on code in PR #1777:
URL: https://github.com/apache/ignite-3/pull/1777#discussion_r1137091576


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItImplicitCastsTest.java:
##########
@@ -46,7 +54,10 @@ public void dropTables() {
     public void testFilter(ColumnPair columnPair) {
         prepareTables(columnPair);
 
-        assertQuery(""SELECT T11.c2 FROM T11 WHERE T11.c2 > 1.0"").check();
+        String value = columnPair.lhsLiteral(0);
+        String query = format(""SELECT T11.c2 FROM T11 WHERE T11.c2 > CAST({} AS {})"", value, columnPair.rhs);

Review Comment:
   An implicit cast is added to the left side of an expression ( T11.c2.)



;15/Mar/23 13:41;githubbot;600","lowka commented on code in PR #1777:
URL: https://github.com/apache/ignite-3/pull/1777#discussion_r1137093197


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteTypeCoercion.java:
##########
@@ -291,6 +291,33 @@ private RelDataType syncAttributes(
         return syncedType;
     }
 
+    /** {@inheritDoc} **/
+    @Override
+    public @Nullable RelDataType commonTypeForBinaryComparison(@Nullable RelDataType type1, @Nullable RelDataType type2) {
+        if (type1 == null || type2 == null) {
+            return null;
+        }
+
+        if (type1 instanceof IgniteCustomType) {
+            return tryCustomTypeCoercionRules(type1, type2);
+        } else if (type2 instanceof IgniteCustomType) {
+            return tryCustomTypeCoercionRules(type2, type1);
+        } else {
+            return super.commonTypeForBinaryComparison(type1, type2);
+        }
+    }
+
+    private @Nullable RelDataType tryCustomTypeCoercionRules(RelDataType type1, RelDataType type2) {
+        IgniteCustomType to = (IgniteCustomType) type1;

Review Comment:
   Yep. I also didn't like the way I wrote but I was not sure.



;15/Mar/23 13:42;githubbot;600","lowka commented on code in PR #1777:
URL: https://github.com/apache/ignite-3/pull/1777#discussion_r1137095158


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/type/IgniteTypeFactory.java:
##########
@@ -375,28 +373,31 @@ public Type getResultClass(RelDataType type) {
             assert resultType instanceof BasicSqlType : ""leastRestrictive is expected to return a new instance of a type: "" + resultType;
 
             IgniteCustomType firstCustomType = null;
-            SqlTypeFamily sqlTypeFamily = null;
+            boolean hasAnyType = false;
 
             for (var type : types) {
                 if (type instanceof IgniteCustomType) {
-                    var customType = (IgniteCustomType) type;
-
                     if (firstCustomType == null) {
                         firstCustomType = (IgniteCustomType) type;
-                    } else if (!Objects.equals(firstCustomType.getCustomTypeName(), customType.getCustomTypeName())) {
-                        // IgniteCustomType: Conversion between custom data types is not supported.
-                        return null;
+                    } else {
+                        IgniteCustomType customType = (IgniteCustomType) type;
+                        if (!Objects.equals(firstCustomType.getCustomTypeName(), customType.getCustomTypeName())) {
+                            // IgniteCustomType: Conversion between custom data types is not supported.
+                            return null;
+                        } else {
+                            return firstCustomType;

Review Comment:
   Thanks. 



;15/Mar/23 13:43;githubbot;600","lowka commented on code in PR #1777:
URL: https://github.com/apache/ignite-3/pull/1777#discussion_r1137099256


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteTypeCoercion.java:
##########
@@ -291,6 +291,33 @@ private RelDataType syncAttributes(
         return syncedType;
     }
 
+    /** {@inheritDoc} **/
+    @Override
+    public @Nullable RelDataType commonTypeForBinaryComparison(@Nullable RelDataType type1, @Nullable RelDataType type2) {
+        if (type1 == null || type2 == null) {
+            return null;
+        }
+
+        if (type1 instanceof IgniteCustomType) {
+            return tryCustomTypeCoercionRules(type1, type2);
+        } else if (type2 instanceof IgniteCustomType) {
+            return tryCustomTypeCoercionRules(type2, type1);
+        } else {
+            return super.commonTypeForBinaryComparison(type1, type2);
+        }
+    }
+
+    private @Nullable RelDataType tryCustomTypeCoercionRules(RelDataType type1, RelDataType type2) {
+        IgniteCustomType to = (IgniteCustomType) type1;
+        // IgniteCustomType: If type1 is a custom data type that can be converted to type2,

Review Comment:
   Thanks. I would rewrite this comment and this method.



;15/Mar/23 13:46;githubbot;600","lowka commented on code in PR #1777:
URL: https://github.com/apache/ignite-3/pull/1777#discussion_r1137093197


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/prepare/IgniteTypeCoercion.java:
##########
@@ -291,6 +291,33 @@ private RelDataType syncAttributes(
         return syncedType;
     }
 
+    /** {@inheritDoc} **/
+    @Override
+    public @Nullable RelDataType commonTypeForBinaryComparison(@Nullable RelDataType type1, @Nullable RelDataType type2) {
+        if (type1 == null || type2 == null) {
+            return null;
+        }
+
+        if (type1 instanceof IgniteCustomType) {
+            return tryCustomTypeCoercionRules(type1, type2);
+        } else if (type2 instanceof IgniteCustomType) {
+            return tryCustomTypeCoercionRules(type2, type1);
+        } else {
+            return super.commonTypeForBinaryComparison(type1, type2);
+        }
+    }
+
+    private @Nullable RelDataType tryCustomTypeCoercionRules(RelDataType type1, RelDataType type2) {
+        IgniteCustomType to = (IgniteCustomType) type1;

Review Comment:
   Yep. I also didn't like the way I wrote it but I was not sure.



;15/Mar/23 13:59;githubbot;600","lowka commented on code in PR #1777:
URL: https://github.com/apache/ignite-3/pull/1777#discussion_r1137091576


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItImplicitCastsTest.java:
##########
@@ -46,7 +54,10 @@ public void dropTables() {
     public void testFilter(ColumnPair columnPair) {
         prepareTables(columnPair);
 
-        assertQuery(""SELECT T11.c2 FROM T11 WHERE T11.c2 > 1.0"").check();
+        String value = columnPair.lhsLiteral(0);
+        String query = format(""SELECT T11.c2 FROM T11 WHERE T11.c2 > CAST({} AS {})"", value, columnPair.rhs);

Review Comment:
   An implicit cast is added to the left side of the expression ( T11.c2.)



;15/Mar/23 19:14;githubbot;600","lowka commented on code in PR #1777:
URL: https://github.com/apache/ignite-3/pull/1777#discussion_r1137632714


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/planner/ImplicitCastsTest.java:
##########
@@ -82,62 +82,30 @@ public void testNestedLoop(RelDataType lhs, RelDataType rhs, ExpectedTypes expec
     /** Filter clause - casts are added to condition operands. **/
     @ParameterizedTest
     @MethodSource(""filterTypes"")
-    public void testFilter(RelDataType lhs, ExpectedTypes expected) throws Exception {
+    public void testFilter(RelDataType lhs, RelDataType rhs, ExpectedTypes expected) throws Exception {
         IgniteSchema igniteSchema = new IgniteSchema(""PUBLIC"");
 
         addTable(igniteSchema, ""A1"", ""COL1"", lhs);
 
-        assertPlan(""SELECT * FROM A1 WHERE COL1 > 1"", igniteSchema, isInstanceOf(IgniteTableScan.class)
+        // Parameter types are not checked during the validation phase.
+        List<Object> params = List.of(""anything"");
+
+        assertPlan(""SELECT * FROM A1 WHERE COL1 > CAST(? AS "" + rhs + "")"", igniteSchema, isInstanceOf(IgniteTableScan.class)

Review Comment:
   Implicit cast is added to the left side of the expression.



;15/Mar/23 19:16;githubbot;600","korlov42 merged PR #1777:
URL: https://github.com/apache/ignite-3/pull/1777


;16/Mar/23 07:32;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,5400,,,0,5400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-18971,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Mar 16 07:35:05 UTC 2023,,,,,,,,,,"0|z1gcyw:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"16/Mar/23 07:35;korlov;[~mzhuravkov] , thanks for the contribution!

 

Merged to [main|https://github.com/apache/ignite-3/commit/871915f54b403afe221fda5c1e1775d98ff8b2ea];;;",,,,,
Fix 'REFRESH' command about statistics in the ddl doc,IGNITE-18946,13526940,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Trivial,Fixed,chenjian2664,chenjian2664,chenjian2664,03/Mar/23 04:50,03/Mar/23 06:09,13/Jul/23 09:11,03/Mar/23 06:04,,,,,,,,2.15,,,,0,,,,"Fix doc about the 'REFRESH' command about the STATISTICS, 

see [https://ignite.apache.org/docs/2.14.0/sql-reference/ddl#refresh]

the command should be 'REFRESH STATISTICS'",,alex_pl,chenjian2664,,,,"chenjian2664 opened a new pull request, #10578:
URL: https://github.com/apache/ignite/pull/10578

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [x] There is a single JIRA ticket related to the pull request. 
   - [x] The web-link to the pull request is attached to the JIRA ticket.
   - [x] The JIRA ticket has the _Patch Available_ state.
   - [x] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [x] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [x] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;03/Mar/23 04:57;githubbot;600","asfgit closed pull request #10578: IGNITE-18946 Fix refresh command about the statistic in the ddl doc
URL: https://github.com/apache/ignite/pull/10578


;03/Mar/23 06:03;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Mar 03 06:09:00 UTC 2023,,,,,,,,,,"0|z1gbbc:",9223372036854775807,,,jooger,,,,,,,,,,,,,,,,,,"03/Mar/23 06:04;alex_pl;[~chenjian2664], looks good to me. Merged to master. Thanks for the contribution!;;;","03/Mar/23 06:09;chenjian2664;noted,thanks

Aleksey Plekhanov (Jira) <jira@apache.org>于2023年3月3日 周五下午2:05写道：

;;;",,,,
SSL integration tests fail on Windows,IGNITE-18938,13526822,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,vpakhnushev,vpakhnushev,02/Mar/23 09:25,06/Mar/23 11:22,13/Jul/23 09:11,06/Mar/23 08:59,,,,,,,,3.0.0-beta2,rest,,,0,ignite-3,,,"Integration tests using {{org.apache.ignite.internal.rest.ssl.RestNode#bootstrapCfg}} fail on Windows.

Micronaut file path properties like {{micronaut.server.ssl.key-store.path}} expect the ""file:"" prefix, but they don't use proper handling and simply cut the prefix, so on Windows the property should look like {{file:C:\tmp}} instead of {{file:/C:/tmp}}.
Also the config file parser expect escaped strings, so the backslashes should be escaped and the whole string should be quoted.",,aleksandr.pakhomov,vpakhnushev,,,,"valepakh opened a new pull request, #1742:
URL: https://github.com/apache/ignite-3/pull/1742

   https://issues.apache.org/jira/browse/IGNITE-18938


;02/Mar/23 09:26;githubbot;600","PakhomovAlexander merged PR #1742:
URL: https://github.com/apache/ignite-3/pull/1742


;06/Mar/23 08:56;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Mar 06 08:59:26 UTC 2023,,,,,,,,,,"0|z1galc:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"06/Mar/23 08:59;aleksandr.pakhomov;merged into main: 10a58e67a2551f8421d9603ccc97d0f6581ec1b2;;;",,,,,
Late stopping of TTL workers during deactivation leads to corrupted PDS,IGNITE-18935,13526714,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ivandasch,ivandasch,ivandasch,01/Mar/23 16:13,24/Apr/23 14:53,13/Jul/23 09:11,07/Mar/23 08:04,2.14,,,,,,,2.15,,,,0,ise,,,"Step to reproduce
1. Reduce wal history size and wal segment size to 16MB and 8MB respectively, set checkpoint frequency to 10000
2. Perform heavy load with a lot of entries with TTL 5000 and with eager ttl enabled
3. Perform deactivation of cluster, stop grid and restart, provided that an expiration process is active during the process of restart.

{code}
[15:11:58,022][SEVERE][ttl-cleanup-worker-#52%None%][] Critical system error detected. Will be handled accordingly to configured handler [hnd=StopNodeOrHaltFailureHandler [tryStop=false, timeout=0, super=AbstractFailureHandler [ignoredFailureTypes=UnmodifiableSet [SYSTEM_WORKER_BLOCKED, SYSTEM_CRITICAL_OPERATION_TIMEOUT]]], failureCtx=FailureContext [type=CRITICAL_ERROR, err=class o.a.i.i.processors.cache.persistence.tree.CorruptedTreeException: B+Tree is corrupted [groupId=-459905951, pageIds=[], msg=Runtime failure on bounds: [lower=null, upper=PendingRow []]]]]
class org.apache.ignite.internal.processors.cache.persistence.tree.CorruptedTreeException: B+Tree is corrupted [groupId=-459905951, pageIds=[], msg=Runtime failure on bounds: [lower=null, upper=PendingRow []]]
	at org.apache.ignite.internal.processors.cache.persistence.tree.BPlusTree.corruptedTreeException(BPlusTree.java:6434)
	at org.apache.ignite.internal.processors.cache.persistence.tree.BPlusTree.find(BPlusTree.java:1294)
	at org.apache.ignite.internal.processors.cache.persistence.tree.BPlusTree.find(BPlusTree.java:1249)
	at org.apache.ignite.internal.processors.cache.persistence.tree.BPlusTree.find(BPlusTree.java:1237)
	at org.apache.ignite.internal.processors.cache.persistence.tree.BPlusTree.find(BPlusTree.java:1232)
	at org.apache.ignite.internal.processors.cache.persistence.GridCacheOffheapManager$GridCacheDataStore.purgeExpiredInternal(GridCacheOffheapManager.java:3061)
	at org.apache.ignite.internal.processors.cache.persistence.GridCacheOffheapManager$GridCacheDataStore.purgeExpired(GridCacheOffheapManager.java:3010)
	at org.apache.ignite.internal.processors.cache.persistence.GridCacheOffheapManager.expire(GridCacheOffheapManager.java:1213)
	at org.apache.ignite.internal.processors.cache.GridCacheTtlManager.expire(GridCacheTtlManager.java:246)
	at org.apache.ignite.internal.processors.cache.GridCacheSharedTtlCleanupManager$CleanupWorker.lambda$body$0(GridCacheSharedTtlCleanupManager.java:199)
	at java.util.concurrent.ConcurrentHashMap.computeIfPresent(ConcurrentHashMap.java:1769)
	at org.apache.ignite.internal.processors.cache.GridCacheSharedTtlCleanupManager$CleanupWorker.body(GridCacheSharedTtlCleanupManager.java:198)
	at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:125)
	at java.lang.Thread.run(Thread.java:750)
Caused by: org.apache.ignite.internal.processors.cache.persistence.tree.BPlusTreeRuntimeException: org.apache.ignite.internal.processors.cache.persistence.tree.BPlusTreeRuntimeException: java.lang.IllegalStateException: Item not found: 24
	at org.apache.ignite.internal.processors.cache.persistence.tree.BPlusTree.findLowerUnbounded(BPlusTree.java:1216)
	at org.apache.ignite.internal.processors.cache.persistence.tree.BPlusTree.find(BPlusTree.java:1276)
	... 12 more
Caused by: org.apache.ignite.internal.processors.cache.persistence.tree.BPlusTreeRuntimeException: java.lang.IllegalStateException: Item not found: 24
	at org.apache.ignite.internal.processors.cache.persistence.CacheDataRowAdapter.doInitFromLink(CacheDataRowAdapter.java:345)
	at org.apache.ignite.internal.processors.cache.persistence.CacheDataRowAdapter.initFromLink(CacheDataRowAdapter.java:165)
	at org.apache.ignite.internal.processors.cache.persistence.CacheDataRowAdapter.initFromLink(CacheDataRowAdapter.java:136)
	at org.apache.ignite.internal.processors.cache.persistence.CacheDataRowAdapter.initFromLink(CacheDataRowAdapter.java:123)
	at org.apache.ignite.internal.processors.cache.tree.PendingRow.initKey(PendingRow.java:73)
	at org.apache.ignite.internal.processors.cache.tree.PendingEntriesTree.getRow(PendingEntriesTree.java:128)
	at org.apache.ignite.internal.processors.cache.tree.PendingEntriesTree.getRow(PendingEntriesTree.java:32)
	at org.apache.ignite.internal.processors.cache.persistence.tree.BPlusTree$ForwardCursor.fillFromBuffer0(BPlusTree.java:6115)
	at org.apache.ignite.internal.processors.cache.persistence.tree.BPlusTree$AbstractForwardCursor.fillFromBuffer(BPlusTree.java:5864)
	at org.apache.ignite.internal.processors.cache.persistence.tree.BPlusTree$AbstractForwardCursor.init(BPlusTree.java:5790)
	at org.apache.ignite.internal.processors.cache.persistence.tree.BPlusTree.findLowerUnbounded(BPlusTree.java:1205)
	... 13 more
Caused by: java.lang.IllegalStateException: Item not found: 24
	at org.apache.ignite.internal.processors.cache.persistence.tree.io.AbstractDataPageIO.findIndirectItemIndex(AbstractDataPageIO.java:488)
	at org.apache.ignite.internal.processors.cache.persistence.tree.io.AbstractDataPageIO.getDataOffset(AbstractDataPageIO.java:596)
	at org.apache.ignite.internal.processors.cache.persistence.tree.io.AbstractDataPageIO.readPayload(AbstractDataPageIO.java:638)
	at org.apache.ignite.internal.processors.cache.persistence.CacheDataRowAdapter.readIncomplete(CacheDataRowAdapter.java:380)
	at org.apache.ignite.internal.processors.cache.persistence.CacheDataRowAdapter.doInitFromLink(CacheDataRowAdapter.java:316)
	... 23 more
{code}",,ignitetcbot,ivandasch,slava.koptilin,,,"ivandasch opened a new pull request, #10570:
URL: https://github.com/apache/ignite/pull/10570

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;01/Mar/23 16:15;githubbot;600","sk0x50 commented on code in PR #10570:
URL: https://github.com/apache/ignite/pull/10570#discussion_r1126010662


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/IgnitePdsWithTtlExpirationOnDeactivateTest.java:
##########
@@ -0,0 +1,178 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache.persistence.db;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.cache.expiry.AccessedExpiryPolicy;
+import javax.cache.expiry.Duration;
+import org.apache.commons.lang3.RandomStringUtils;
+import org.apache.ignite.Ignite;
+import org.apache.ignite.IgniteCache;
+import org.apache.ignite.IgniteSystemProperties;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.failure.FailureContext;
+import org.apache.ignite.failure.FailureHandler;
+import org.apache.ignite.failure.NoOpFailureHandler;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.IgniteInternalFuture;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.apache.ignite.testframework.MvccFeatureChecker;
+import org.apache.ignite.testframework.junits.WithSystemProperty;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+
+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;
+import static org.apache.ignite.cluster.ClusterState.INACTIVE;
+import static org.apache.ignite.testframework.GridTestUtils.runMultiThreadedAsync;
+
+/**
+ * Tests if TTL worker is correctly stopped on deactivation and PDS is not corrupted after restart.
+ */
+@WithSystemProperty(key = IgniteSystemProperties.IGNITE_UNWIND_THROTTLING_TIMEOUT, value = ""5"")
+public class IgnitePdsWithTtlExpirationOnDeactivateTest extends GridCommonAbstractTest {
+    /** */
+    private static final String CACHE_NAME_ATOMIC = ""expirable-cache-atomic"";
+
+    /** */
+    private static final int EXPIRATION_TIMEOUT = 5_000;
+
+    /** */
+    public static final int ENTRIES = 50_000;
+
+    /** */
+    private static final int WORKLOAD_THREADS_CNT = 8;
+
+    /** Failure handler triggered flag. */
+    private volatile boolean failureHndTriggered;
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        MvccFeatureChecker.skipIfNotSupported(MvccFeatureChecker.Feature.EXPIRATION);
+
+        super.beforeTest();
+
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() throws Exception {
+        super.afterTest();
+
+        stopAllGrids();
+
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        final IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);
+
+        DataRegionConfiguration dfltRegion = new DataRegionConfiguration()
+                .setMaxSize(100 * 1024 * 1024)
+                .setPersistenceEnabled(true);
+
+        // Setting MaxWalArchiveSize to a relatively small value leads to frequent checkpoints (too many WAL segments).
+        cfg.setDataStorageConfiguration(
+            new DataStorageConfiguration()
+                    .setWalSegmentSize(8 * 1024 * 1024)
+                    .setMaxWalArchiveSize(16 * 1024 * 1024)
+                    .setCheckpointFrequency(10_000)
+                    .setDefaultDataRegionConfiguration(dfltRegion)
+                    .setWalMode(WALMode.LOG_ONLY));
+
+        cfg.setCacheConfiguration(
+            getCacheConfiguration(CACHE_NAME_ATOMIC).setAtomicityMode(ATOMIC)
+        );
+
+        return cfg;
+    }
+
+    /** {@inheritDoc} */
+    @Override protected FailureHandler getFailureHandler(String igniteInstanceName) {
+        return new NoOpFailureHandler() {
+            @Override protected boolean handle(Ignite ignite, FailureContext failureCtx) {
+                failureHndTriggered = true;
+
+                return super.handle(ignite, failureCtx);
+            }
+        };
+    }
+
+    /**
+     * Returns a new cache configuration with the given name and {@code GROUP_NAME} group.
+     *
+     * @param name Cache name.
+     * @return Cache configuration.
+     */
+    private CacheConfiguration<?, ?> getCacheConfiguration(String name) {
+        CacheConfiguration<?, ?> ccfg = new CacheConfiguration<>();
+
+        ccfg.setName(name);
+        ccfg.setExpiryPolicyFactory(AccessedExpiryPolicy.factoryOf(new Duration(TimeUnit.MILLISECONDS, EXPIRATION_TIMEOUT)));
+        ccfg.setEagerTtl(true);
+
+        return ccfg;
+    }
+
+    /** */
+    @Test
+    public void testStartAfterDeactivateWithTtlExpiring() throws Exception {
+        IgniteEx srv = startGrid(0);
+
+        srv.cluster().state(ClusterState.ACTIVE);
+
+        IgniteCache<Integer, String> cache = srv.cache(CACHE_NAME_ATOMIC);
+
+        AtomicBoolean timeoutReached = new AtomicBoolean(false);
+
+        AtomicInteger threadId = new AtomicInteger(0);
+
+        IgniteInternalFuture<?> ldrFut = runMultiThreadedAsync(() -> {
+            int id = threadId.getAndIncrement();
+
+            int i = 0;
+            while (!timeoutReached.get()) {
+                cache.put(id * 1_000_000 + i, RandomStringUtils.randomAlphanumeric(1000));
+                i++;
+            }
+        }, WORKLOAD_THREADS_CNT, ""loader"");
+
+        doSleep(EXPIRATION_TIMEOUT * 2);
+        timeoutReached.set(true);
+        ldrFut.get();
+
+        srv.cluster().state(INACTIVE);
+
+        stopGrid(0);
+
+        startGrid(0);
+
+        awaitPartitionMapExchange();

Review Comment:
   It is not obvious why we need this call for a cluster of 1 node.



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/IgnitePdsWithTtlExpirationOnDeactivateTest.java:
##########
@@ -0,0 +1,178 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache.persistence.db;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.cache.expiry.AccessedExpiryPolicy;
+import javax.cache.expiry.Duration;
+import org.apache.commons.lang3.RandomStringUtils;
+import org.apache.ignite.Ignite;
+import org.apache.ignite.IgniteCache;
+import org.apache.ignite.IgniteSystemProperties;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.failure.FailureContext;
+import org.apache.ignite.failure.FailureHandler;
+import org.apache.ignite.failure.NoOpFailureHandler;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.IgniteInternalFuture;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.apache.ignite.testframework.MvccFeatureChecker;
+import org.apache.ignite.testframework.junits.WithSystemProperty;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+
+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;
+import static org.apache.ignite.cluster.ClusterState.INACTIVE;
+import static org.apache.ignite.testframework.GridTestUtils.runMultiThreadedAsync;
+
+/**
+ * Tests if TTL worker is correctly stopped on deactivation and PDS is not corrupted after restart.
+ */
+@WithSystemProperty(key = IgniteSystemProperties.IGNITE_UNWIND_THROTTLING_TIMEOUT, value = ""5"")
+public class IgnitePdsWithTtlExpirationOnDeactivateTest extends GridCommonAbstractTest {
+    /** */
+    private static final String CACHE_NAME_ATOMIC = ""expirable-cache-atomic"";
+
+    /** */
+    private static final int EXPIRATION_TIMEOUT = 5_000;

Review Comment:
   Is it possible to reduce the expiration timeout? I mean that this test takes ~40 sec on my laptop.
   Perhaps, reducing the expiration timeout and the number of partitions can provide better timing.



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/IgnitePdsWithTtlExpirationOnDeactivateTest.java:
##########
@@ -0,0 +1,178 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache.persistence.db;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.cache.expiry.AccessedExpiryPolicy;
+import javax.cache.expiry.Duration;
+import org.apache.commons.lang3.RandomStringUtils;
+import org.apache.ignite.Ignite;
+import org.apache.ignite.IgniteCache;
+import org.apache.ignite.IgniteSystemProperties;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.failure.FailureContext;
+import org.apache.ignite.failure.FailureHandler;
+import org.apache.ignite.failure.NoOpFailureHandler;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.IgniteInternalFuture;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.apache.ignite.testframework.MvccFeatureChecker;
+import org.apache.ignite.testframework.junits.WithSystemProperty;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+
+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;
+import static org.apache.ignite.cluster.ClusterState.INACTIVE;
+import static org.apache.ignite.testframework.GridTestUtils.runMultiThreadedAsync;
+
+/**
+ * Tests if TTL worker is correctly stopped on deactivation and PDS is not corrupted after restart.
+ */
+@WithSystemProperty(key = IgniteSystemProperties.IGNITE_UNWIND_THROTTLING_TIMEOUT, value = ""5"")
+public class IgnitePdsWithTtlExpirationOnDeactivateTest extends GridCommonAbstractTest {
+    /** */
+    private static final String CACHE_NAME_ATOMIC = ""expirable-cache-atomic"";
+
+    /** */
+    private static final int EXPIRATION_TIMEOUT = 5_000;
+
+    /** */
+    public static final int ENTRIES = 50_000;

Review Comment:
   It looks like this field is unused. Please remove it.



;06/Mar/23 07:11;githubbot;600","ivandasch commented on code in PR #10570:
URL: https://github.com/apache/ignite/pull/10570#discussion_r1126026453


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/IgnitePdsWithTtlExpirationOnDeactivateTest.java:
##########
@@ -0,0 +1,178 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache.persistence.db;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.cache.expiry.AccessedExpiryPolicy;
+import javax.cache.expiry.Duration;
+import org.apache.commons.lang3.RandomStringUtils;
+import org.apache.ignite.Ignite;
+import org.apache.ignite.IgniteCache;
+import org.apache.ignite.IgniteSystemProperties;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.failure.FailureContext;
+import org.apache.ignite.failure.FailureHandler;
+import org.apache.ignite.failure.NoOpFailureHandler;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.IgniteInternalFuture;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.apache.ignite.testframework.MvccFeatureChecker;
+import org.apache.ignite.testframework.junits.WithSystemProperty;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+
+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;
+import static org.apache.ignite.cluster.ClusterState.INACTIVE;
+import static org.apache.ignite.testframework.GridTestUtils.runMultiThreadedAsync;
+
+/**
+ * Tests if TTL worker is correctly stopped on deactivation and PDS is not corrupted after restart.
+ */
+@WithSystemProperty(key = IgniteSystemProperties.IGNITE_UNWIND_THROTTLING_TIMEOUT, value = ""5"")
+public class IgnitePdsWithTtlExpirationOnDeactivateTest extends GridCommonAbstractTest {
+    /** */
+    private static final String CACHE_NAME_ATOMIC = ""expirable-cache-atomic"";
+
+    /** */
+    private static final int EXPIRATION_TIMEOUT = 5_000;
+
+    /** */
+    public static final int ENTRIES = 50_000;
+
+    /** */
+    private static final int WORKLOAD_THREADS_CNT = 8;
+
+    /** Failure handler triggered flag. */
+    private volatile boolean failureHndTriggered;
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        MvccFeatureChecker.skipIfNotSupported(MvccFeatureChecker.Feature.EXPIRATION);
+
+        super.beforeTest();
+
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() throws Exception {
+        super.afterTest();
+
+        stopAllGrids();
+
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        final IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);
+
+        DataRegionConfiguration dfltRegion = new DataRegionConfiguration()
+                .setMaxSize(100 * 1024 * 1024)
+                .setPersistenceEnabled(true);
+
+        // Setting MaxWalArchiveSize to a relatively small value leads to frequent checkpoints (too many WAL segments).
+        cfg.setDataStorageConfiguration(
+            new DataStorageConfiguration()
+                    .setWalSegmentSize(8 * 1024 * 1024)
+                    .setMaxWalArchiveSize(16 * 1024 * 1024)
+                    .setCheckpointFrequency(10_000)
+                    .setDefaultDataRegionConfiguration(dfltRegion)
+                    .setWalMode(WALMode.LOG_ONLY));
+
+        cfg.setCacheConfiguration(
+            getCacheConfiguration(CACHE_NAME_ATOMIC).setAtomicityMode(ATOMIC)
+        );
+
+        return cfg;
+    }
+
+    /** {@inheritDoc} */
+    @Override protected FailureHandler getFailureHandler(String igniteInstanceName) {
+        return new NoOpFailureHandler() {
+            @Override protected boolean handle(Ignite ignite, FailureContext failureCtx) {
+                failureHndTriggered = true;
+
+                return super.handle(ignite, failureCtx);
+            }
+        };
+    }
+
+    /**
+     * Returns a new cache configuration with the given name and {@code GROUP_NAME} group.
+     *
+     * @param name Cache name.
+     * @return Cache configuration.
+     */
+    private CacheConfiguration<?, ?> getCacheConfiguration(String name) {
+        CacheConfiguration<?, ?> ccfg = new CacheConfiguration<>();
+
+        ccfg.setName(name);
+        ccfg.setExpiryPolicyFactory(AccessedExpiryPolicy.factoryOf(new Duration(TimeUnit.MILLISECONDS, EXPIRATION_TIMEOUT)));
+        ccfg.setEagerTtl(true);
+
+        return ccfg;
+    }
+
+    /** */
+    @Test
+    public void testStartAfterDeactivateWithTtlExpiring() throws Exception {
+        IgniteEx srv = startGrid(0);
+
+        srv.cluster().state(ClusterState.ACTIVE);
+
+        IgniteCache<Integer, String> cache = srv.cache(CACHE_NAME_ATOMIC);
+
+        AtomicBoolean timeoutReached = new AtomicBoolean(false);
+
+        AtomicInteger threadId = new AtomicInteger(0);
+
+        IgniteInternalFuture<?> ldrFut = runMultiThreadedAsync(() -> {
+            int id = threadId.getAndIncrement();
+
+            int i = 0;
+            while (!timeoutReached.get()) {
+                cache.put(id * 1_000_000 + i, RandomStringUtils.randomAlphanumeric(1000));
+                i++;
+            }
+        }, WORKLOAD_THREADS_CNT, ""loader"");
+
+        doSleep(EXPIRATION_TIMEOUT * 2);
+        timeoutReached.set(true);
+        ldrFut.get();
+
+        srv.cluster().state(INACTIVE);
+
+        stopGrid(0);
+
+        startGrid(0);
+
+        awaitPartitionMapExchange();

Review Comment:
   Great, thank you, forgot to remove this (remains of experiments, you know :))



;06/Mar/23 07:24;githubbot;600","ivandasch commented on code in PR #10570:
URL: https://github.com/apache/ignite/pull/10570#discussion_r1126028192


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/IgnitePdsWithTtlExpirationOnDeactivateTest.java:
##########
@@ -0,0 +1,178 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache.persistence.db;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.cache.expiry.AccessedExpiryPolicy;
+import javax.cache.expiry.Duration;
+import org.apache.commons.lang3.RandomStringUtils;
+import org.apache.ignite.Ignite;
+import org.apache.ignite.IgniteCache;
+import org.apache.ignite.IgniteSystemProperties;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.failure.FailureContext;
+import org.apache.ignite.failure.FailureHandler;
+import org.apache.ignite.failure.NoOpFailureHandler;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.IgniteInternalFuture;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.apache.ignite.testframework.MvccFeatureChecker;
+import org.apache.ignite.testframework.junits.WithSystemProperty;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+
+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;
+import static org.apache.ignite.cluster.ClusterState.INACTIVE;
+import static org.apache.ignite.testframework.GridTestUtils.runMultiThreadedAsync;
+
+/**
+ * Tests if TTL worker is correctly stopped on deactivation and PDS is not corrupted after restart.
+ */
+@WithSystemProperty(key = IgniteSystemProperties.IGNITE_UNWIND_THROTTLING_TIMEOUT, value = ""5"")
+public class IgnitePdsWithTtlExpirationOnDeactivateTest extends GridCommonAbstractTest {
+    /** */
+    private static final String CACHE_NAME_ATOMIC = ""expirable-cache-atomic"";
+
+    /** */
+    private static final int EXPIRATION_TIMEOUT = 5_000;

Review Comment:
   40 secs? My gosh, on my laptop it takes just 17



;06/Mar/23 07:26;githubbot;600","ivandasch commented on code in PR #10570:
URL: https://github.com/apache/ignite/pull/10570#discussion_r1126028192


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/IgnitePdsWithTtlExpirationOnDeactivateTest.java:
##########
@@ -0,0 +1,178 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache.persistence.db;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.cache.expiry.AccessedExpiryPolicy;
+import javax.cache.expiry.Duration;
+import org.apache.commons.lang3.RandomStringUtils;
+import org.apache.ignite.Ignite;
+import org.apache.ignite.IgniteCache;
+import org.apache.ignite.IgniteSystemProperties;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.failure.FailureContext;
+import org.apache.ignite.failure.FailureHandler;
+import org.apache.ignite.failure.NoOpFailureHandler;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.IgniteInternalFuture;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.apache.ignite.testframework.MvccFeatureChecker;
+import org.apache.ignite.testframework.junits.WithSystemProperty;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+
+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;
+import static org.apache.ignite.cluster.ClusterState.INACTIVE;
+import static org.apache.ignite.testframework.GridTestUtils.runMultiThreadedAsync;
+
+/**
+ * Tests if TTL worker is correctly stopped on deactivation and PDS is not corrupted after restart.
+ */
+@WithSystemProperty(key = IgniteSystemProperties.IGNITE_UNWIND_THROTTLING_TIMEOUT, value = ""5"")
+public class IgnitePdsWithTtlExpirationOnDeactivateTest extends GridCommonAbstractTest {
+    /** */
+    private static final String CACHE_NAME_ATOMIC = ""expirable-cache-atomic"";
+
+    /** */
+    private static final int EXPIRATION_TIMEOUT = 5_000;

Review Comment:
   40 secs? My gosh, on my laptop it takes just 17. I suppose it takes so long because of a quite slow ssd. It generates a lot of WAL segments, actually



;06/Mar/23 07:27;githubbot;600","ivandasch commented on code in PR #10570:
URL: https://github.com/apache/ignite/pull/10570#discussion_r1126273676


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/IgnitePdsWithTtlExpirationOnDeactivateTest.java:
##########
@@ -0,0 +1,178 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache.persistence.db;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.cache.expiry.AccessedExpiryPolicy;
+import javax.cache.expiry.Duration;
+import org.apache.commons.lang3.RandomStringUtils;
+import org.apache.ignite.Ignite;
+import org.apache.ignite.IgniteCache;
+import org.apache.ignite.IgniteSystemProperties;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.failure.FailureContext;
+import org.apache.ignite.failure.FailureHandler;
+import org.apache.ignite.failure.NoOpFailureHandler;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.IgniteInternalFuture;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.apache.ignite.testframework.MvccFeatureChecker;
+import org.apache.ignite.testframework.junits.WithSystemProperty;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+
+import static org.apache.ignite.cache.CacheAtomicityMode.ATOMIC;
+import static org.apache.ignite.cluster.ClusterState.INACTIVE;
+import static org.apache.ignite.testframework.GridTestUtils.runMultiThreadedAsync;
+
+/**
+ * Tests if TTL worker is correctly stopped on deactivation and PDS is not corrupted after restart.
+ */
+@WithSystemProperty(key = IgniteSystemProperties.IGNITE_UNWIND_THROTTLING_TIMEOUT, value = ""5"")
+public class IgnitePdsWithTtlExpirationOnDeactivateTest extends GridCommonAbstractTest {
+    /** */
+    private static final String CACHE_NAME_ATOMIC = ""expirable-cache-atomic"";
+
+    /** */
+    private static final int EXPIRATION_TIMEOUT = 5_000;

Review Comment:
   Oh, the main reason of this ;06/Mar/23 11:24;githubbot;600","ivandasch merged PR #10570:
URL: https://github.com/apache/ignite/pull/10570


;07/Mar/23 08:03;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,4200,,,0,4200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Tue Mar 07 08:04:04 UTC 2023,,,,,,,,,,"0|z1g9xc:",9223372036854775807,Fixed PDS corruption on deactivation during entries expire,,,,,,,,,,,,,,,,,,,,"01/Mar/23 21:10;ignitetcbot;{panel:title=Branch: [pull/10570/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10570/head] Base: [master] : New Tests (2)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Disk Page Compressions 1{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7072358]]
* {color:#013220}IgnitePdsCompressionTestSuite: IgnitePdsWithTtlExpirationOnDeactivateTest.testStartAfterDeactivateWithTtlExpiring - PASSED{color}

{color:#00008b}PDS 1{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7072305]]
* {color:#013220}IgnitePdsTestSuite: IgnitePdsWithTtlExpirationOnDeactivateTest.testStartAfterDeactivateWithTtlExpiring - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7072354&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","02/Mar/23 07:17;ivandasch;[~sk0x50] Slava, could you please review this patch?;;;","06/Mar/23 07:13;slava.koptilin;Hello [~ivandasch],

In general, the proposed patch looks good to me. I left a few minor comments in your PR, please take a look.;;;","06/Mar/23 16:48;ignitetcbot;{panel:title=Branch: [pull/10570/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10570/head] Base: [master] : New Tests (2)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Disk Page Compressions 1{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7081286]]
* {color:#013220}IgnitePdsCompressionTestSuite: IgnitePdsWithTtlExpirationOnDeactivateTest.testStartAfterDeactivateWithTtlExpiring - PASSED{color}

{color:#00008b}PDS 1{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7081282]]
* {color:#013220}IgnitePdsTestSuite: IgnitePdsWithTtlExpirationOnDeactivateTest.testStartAfterDeactivateWithTtlExpiring - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7072354&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","07/Mar/23 07:33;slava.koptilin;LGTM;;;","07/Mar/23 08:04;ivandasch;[~slava.koptilin] Many thanks for review!;;;"
Open API spec falidation fails,IGNITE-18926,13526571,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,aleksandr.pakhomov,aleksandr.pakhomov,28/Feb/23 19:12,06/Mar/23 11:22,13/Jul/23 09:11,06/Mar/23 08:49,,,,,,,,3.0.0-beta2,rest,,,0,ignite-3,,,"IGNITE-18881 introduced a regression in terms of openapi spec validation. It has duplicates in some parts. To reproduce the issue just pull the latest main branch and run ./gradlew check -x test -x integrationTest.

The reason for this is javadoc which adds parameter descriptions. From them the duplicated info is generated.",,aleksandr.pakhomov,,,,,"valepakh opened a new pull request, #1744:
URL: https://github.com/apache/ignite-3/pull/1744

   https://issues.apache.org/jira/browse/IGNITE-18926


;02/Mar/23 14:06;githubbot;600","PakhomovAlexander merged PR #1744:
URL: https://github.com/apache/ignite-3/pull/1744


;06/Mar/23 08:47;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Mar 06 08:49:44 UTC 2023,,,,,,,,,,"0|z1g91k:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"06/Mar/23 08:49;aleksandr.pakhomov;Thanks for the contribution, merged into main: 2013940f1e8fc89553648ab09b156613c6eb3483 ;;;",,,,,
Disable ItIgniteNodeRestartTest#testMetastorageStop,IGNITE-18918,13526509,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,ivan.gagarkin,ivan.gagarkin,ivan.gagarkin,28/Feb/23 11:30,28/Feb/23 15:07,13/Jul/23 09:11,28/Feb/23 14:51,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"The test depends on the count of the config changes. 

The condition is never met and the test always passes.  
{code:java}
if (rev == cfgGap / 2) {
    log.info(""Stopping METASTORAGE"");

    stopNode(0);

    log.info(""Starting METASTORAGE"");

    startNode(0);

    log.info(""Restarted METASTORAGE"");
} {code}
But if change the condition to be true (e.g., rev == 5), the test fails.  

The test should be disabled. ",,ivan.gagarkin,,,,,"Flaugh24 commented on PR #1727:
URL: https://github.com/apache/ignite-3/pull/1727#issuecomment-1448316414

   https://issues.apache.org/jira/browse/IGNITE-18918


;28/Feb/23 14:49;githubbot;600","ibessonov merged PR #1727:
URL: https://github.com/apache/ignite-3/pull/1727


;28/Feb/23 14:51;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,IGNITE-18576,,,,,,,,,,,,,,,IGNITE-18919,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-02-28 11:30:58.0,,,,,,,,,,"0|z1g8ns:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
Distributed configuration doesn't generate events when the configuration property is updated with the same value,IGNITE-18908,13526325,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,ivan.gagarkin,ivan.gagarkin,ivan.gagarkin,27/Feb/23 11:46,12/Apr/23 12:20,13/Jul/23 09:11,28/Feb/23 14:50,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Steps to reproduce:

Add the following code to org.apache.ignite.internal.runner.app.ItIgniteNodeRestartTest#testCfgGapWithoutData

 
{code:java}
IgniteImpl ignite = startNode(0);
Integer value = ignite.clusterConfiguration()
        .getConfiguration(RocksDbStorageEngineConfiguration.KEY)
        .flushDelayMillis().value();

ignite.clusterConfiguration()
        .getConfiguration(RocksDbStorageEngineConfiguration.KEY)
        .flushDelayMillis().update(value).join();

stopNode(0); {code}
Revision of the cluster configuration will be changed, but events will not be generated. So nodes joining the cluster will be unable to update their version of the configuration and the recovery will not be completed. 
{code:java}
// Recovery future must be created before configuration listeners are triggered.
CompletableFuture<?> recoveryFuture = RecoveryCompletionFutureFactory.create(
        clusterCfgMgr,
        fut -> new ConfigurationCatchUpListener(cfgStorage, fut, LOG)
)  {code}
 ",,ivan.gagarkin,,,,,"Flaugh24 commented on PR #1722:
URL: https://github.com/apache/ignite-3/pull/1722#issuecomment-1447749772

   https://issues.apache.org/jira/browse/IGNITE-18908


;28/Feb/23 08:13;githubbot;600","ibessonov commented on code in PR #1722:
URL: https://github.com/apache/ignite-3/pull/1722#discussion_r1119765747


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -974,6 +975,24 @@ public void testCfgGap() throws InterruptedException {
         checkTableWithData(newNode, ""t2"");
     }
 
+    /**
+     * The test for updating cluster configuration with the default value.
+     * Check that new nodes will be able to synchronize the local cluster configuration.
+     */
+    @Test
+    public void updateClusterCfgWithDefaultValue() {
+        IgniteImpl ignite = startNode(0);
+
+        RocksDbStorageEngineConfiguration dbStorageEngineConfiguration = ignite.clusterConfiguration()
+                .getConfiguration(RocksDbStorageEngineConfiguration.KEY);
+        int defaultValue = dbStorageEngineConfiguration.flushDelayMillis().value();
+        dbStorageEngineConfiguration.flushDelayMillis().update(defaultValue);

Review Comment:
   Please ""join"" this future before stopping the node



;28/Feb/23 09:13;githubbot;600","ibessonov commented on code in PR #1722:
URL: https://github.com/apache/ignite-3/pull/1722#discussion_r1119766622


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -974,6 +975,24 @@ public void testCfgGap() throws InterruptedException {
         checkTableWithData(newNode, ""t2"");
     }
 
+    /**
+     * The test for updating cluster configuration with the default value.
+     * Check that new nodes will be able to synchronize the local cluster configuration.
+     */
+    @Test
+    public void updateClusterCfgWithDefaultValue() {
+        IgniteImpl ignite = startNode(0);
+
+        RocksDbStorageEngineConfiguration dbStorageEngineConfiguration = ignite.clusterConfiguration()
+                .getConfiguration(RocksDbStorageEngineConfiguration.KEY);
+        int defaultValue = dbStorageEngineConfiguration.flushDelayMillis().value();
+        dbStorageEngineConfiguration.flushDelayMillis().update(defaultValue);

Review Comment:
   But, please either do it with a timeout, or use ""assertThar(fut, willCompleteSuccessfully())""



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -974,6 +975,24 @@ public void testCfgGap() throws InterruptedException {
         checkTableWithData(newNode, ""t2"");
     }
 
+    /**
+     * The test for updating cluster configuration with the default value.
+     * Check that new nodes will be able to synchronize the local cluster configuration.
+     */
+    @Test
+    public void updateClusterCfgWithDefaultValue() {
+        IgniteImpl ignite = startNode(0);
+
+        RocksDbStorageEngineConfiguration dbStorageEngineConfiguration = ignite.clusterConfiguration()
+                .getConfiguration(RocksDbStorageEngineConfiguration.KEY);
+        int defaultValue = dbStorageEngineConfiguration.flushDelayMillis().value();
+        dbStorageEngineConfiguration.flushDelayMillis().update(defaultValue);

Review Comment:
   But, please either do it with a timeout, or use `assertThat(fut, willCompleteSuccessfully())`



;28/Feb/23 09:14;githubbot;600","ibessonov commented on PR #1722:
URL: https://github.com/apache/ignite-3/pull/1722#issuecomment-1447840378

   @Flaugh24 Please do not force-push your branches once review has already started, thank you


;28/Feb/23 09:22;githubbot;600","ibessonov commented on code in PR #1722:
URL: https://github.com/apache/ignite-3/pull/1722#discussion_r1119780530


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItIgniteNodeRestartTest.java:
##########
@@ -974,6 +975,24 @@ public void testCfgGap() throws InterruptedException {
         checkTableWithData(newNode, ""t2"");
     }
 
+    /**
+     * The test for updating cluster configuration with the default value.
+     * Check that new nodes will be able to synchronize the local cluster configuration.
+     */
+    @Test
+    public void updateClusterCfgWithDefaultValue() {
+        IgniteImpl ignite = startNode(0);
+
+        RocksDbStorageEngineConfiguration dbStorageEngineConfiguration = ignite.clusterConfiguration()
+                .getConfiguration(RocksDbStorageEngineConfiguration.KEY);
+        int defaultValue = dbStorageEngineConfiguration.flushDelayMillis().value();
+        dbStorageEngineConfiguration.flushDelayMillis().update(defaultValue).join();

Review Comment:
   Can you please add timeout to the join?
   Another question - why have you decided to write an integration test instead of the unit test?



;28/Feb/23 09:25;githubbot;600","ibessonov merged PR #1722:
URL: https://github.com/apache/ignite-3/pull/1722


;28/Feb/23 14:50;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3600,,,0,3600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-19280,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-02-27 11:46:29.0,,,,,,,,,,"0|z1g7j4:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
Fix tombstone is stored if it is the first entry of version chain,IGNITE-18882,13525840,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,sdanilov,sdanilov,sdanilov,23/Feb/23 08:00,02/Mar/23 16:05,13/Jul/23 09:11,02/Mar/23 16:05,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"This test in AbstractMvPartitionStorageGcTest should pass   


{code:java}
void testTombstoneFirst() {
        addAndCommit(null);

        addAndCommit(TABLE_ROW);

        addAndCommit(TABLE_ROW2);

        BinaryRowAndRowId row = pollForVacuum(HybridTimestamp.MAX_VALUE);

        assertRowMatches(row.binaryRow(), TABLE_ROW);
    }
{code}


At this moment, storages will store the tombstone if it is the first committed value which disrupts the GC flow.

addWrite with null argument as a first version of row is valid, for example: 


{code:sql}
CREATE TABLE test (
  id INT
);
BEGIN;
INSERT INTO test VALUES(1);
DELETE from test where id = 1;
COMMIT;
{code}


is ok, but tombstone should not be stored (so the operation should be no-op)",,ktkalenko@gridgain.com,sdanilov,,,,"SammyVimes opened a new pull request, #1739:
URL: https://github.com/apache/ignite-3/pull/1739

   https://issues.apache.org/jira/browse/IGNITE-18882


;01/Mar/23 16:30;githubbot;600","tkalkirill commented on code in PR #1739:
URL: https://github.com/apache/ignite-3/pull/1739#discussion_r1123022879


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AddWriteCommittedInvokeClosure.java:
##########
@@ -81,6 +81,14 @@ public void call(@Nullable VersionChain oldRow) throws IgniteInternalCheckedExce
             throw new StorageException(""Write intent exists: [rowId={}, {}]"", oldRow.rowId(), storage.createStorageInfo());
         }
 
+        if (row == null && oldRow == null) {
+            // If previous version doesn't exist and current version is a tombstone,

Review Comment:
   I would paraphrase in:
   `If only one version, and it is a tombstone, then we will not save such a chain.`



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/CommitWriteInvokeClosure.java:
##########
@@ -80,6 +80,13 @@ public void call(@Nullable VersionChain oldRow) throws IgniteInternalCheckedExce
         RowVersion current = storage.readRowVersion(oldRow.headLink(), DONT_LOAD_VALUE);
         RowVersion next = oldRow.hasNextLink() ? storage.readRowVersion(oldRow.nextLink(), DONT_LOAD_VALUE) : null;
 
+        if (next == null && current.isTombstone()) {
+            // Previous version doesn't exist and current version is a tombstone, delete current version.

Review Comment:
   I would paraphrase in:
   `If only one version, and it is a tombstone, then we will remove such a chain.`



##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/impl/TestMvPartitionStorage.java:
##########
@@ -271,6 +271,12 @@ private VersionChain resolveCommittedVersionChain(VersionChain committedVersionC
             // Calling it from the compute is fine. Concurrent writes of the same row are impossible, and if we call the compute closure
             // several times, the same tuple will be inserted into the GC queue (timestamp and rowId don't change in this case).
             gcQueue.add(committedVersionChain);
+        } else {
+            if (committedVersionChain.row == null) {
+                // If previous version doesn't exist and current version is a tombstone,

Review Comment:
   I would paraphrase in: 
   `if only one version, and it is a tombstone, then we will remove such a chain.`



;02/Mar/23 12:32;githubbot;600","SammyVimes merged PR #1739:
URL: https://github.com/apache/ignite-3/pull/1739


;02/Mar/23 16:04;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17571,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Mar 02 16:05:09 UTC 2023,,,,,,,,,,"0|z1g4js:",9223372036854775807,,,ktkalenko@gridgain.com,,,,,,,,,,,,,,,,,,"02/Mar/23 12:33;ktkalenko@gridgain.com;Looks good!;;;","02/Mar/23 16:05;sdanilov;Thank you for the review. Merged to the main branch.;;;",,,,
Recursive update of pendingInvokes in ReplicaService,IGNITE-18868,13525689,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,v.pyatkov,korlov,korlov,22/Feb/23 07:21,28/Mar/23 10:35,13/Jul/23 09:11,28/Mar/23 10:35,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"h3. Motivation

Take a look at the code below:
{code:java}
// ReplicaService#sendToReplica
           if (errResp.throwable() instanceof ReplicaUnavailableException) {
                        pendingInvokes.compute(targetNodeConsistentId, (clusterNode, fut) -> {
                            if (fut == null) {
                                AwaitReplicaRequest awaitReplicaReq = ...

                                fut = messagingService.invoke(...)
                                        .whenComplete((response0, throwable0) -> {
                                            pendingInvokes.remove(targetNodeConsistentId);
                                        });
                            }
{code}
In case {{messagingService}} respond immediately, {{whenComplete}} callback will be executed in the same thread causing recursive update ({{{}remove{}}} inside of {{{}compute{}}}) which is not allowed.
{code:java}
Caused by: java.lang.IllegalStateException: Recursive update
	at java.base/java.util.concurrent.ConcurrentHashMap.replaceNode(ConcurrentHashMap.java:1167)
	at java.base/java.util.concurrent.ConcurrentHashMap.remove(ConcurrentHashMap.java:1102)
	at org.apache.ignite.internal.replicator.ReplicaService.lambda$sendToReplica$0(ReplicaService.java:125)
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859)
	at java.base/java.util.concurrent.CompletableFuture.uniWhenCompleteStage(CompletableFuture.java:883)
	at java.base/java.util.concurrent.CompletableFuture.whenComplete(CompletableFuture.java:2251)
	at org.apache.ignite.internal.replicator.ReplicaService.lambda$sendToReplica$3(ReplicaService.java:124)

{code}
a
h3. Definition of Done

Need to move 
{code:java}
.whenComplete(
    (response0, throwable0) -> { pendingInvokes.remove(targetNodeConsistentId); }
);
{code}
from the _compute_ block and add it to the future which is returned from the {_}compute{_}.",,alapin,korlov,v.pyatkov,,,"vldpyatkov merged PR #1773:
URL: https://github.com/apache/ignite-3/pull/1773


;28/Mar/23 10:34;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,IGNITE-19022,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Mar 28 10:35:00 UTC 2023,,,,,,,,,,"0|z1g3m8:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"28/Feb/23 11:01;korlov;The test {{ReplicaUnavailableTest#testWithReplicaStartedAfterRequestSending}} was disabled with link to this issue;;;","27/Mar/23 17:34;v.pyatkov;I had already fixed the issue in IGNITE-19022, here I unmuted test and sightly modify it.;;;","28/Mar/23 10:31;alapin;[~v.pyatkov] LGTM;;;","28/Mar/23 10:35;v.pyatkov;Merged 27be2182c7515f81c9d4e828c4ad8570ad2b7a9c;;;",,
JdbcUrlRegistryImpl should stop fetching URLs after disconnect,IGNITE-18866,13525593,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,vpakhnushev,vpakhnushev,21/Feb/23 14:28,22/Feb/23 15:02,13/Jul/23 09:11,22/Feb/23 15:02,,,,,,,,3.0.0-beta2,cli,,,0,ignite-3,,,"{{org.apache.ignite.internal.cli.core.repl.registry.impl.JdbcUrlRegistryImpl}} starts a thread executor on connect which starts polling the JDBC URLs from the node and doesn't stop doing this leading to the logs pollution especially in integration tests where a test connects to the node and even if it disonnects, the it continue to fetch URLs.",,aleksandr.pakhomov,vpakhnushev,,,,"valepakh opened a new pull request, #1702:
URL: https://github.com/apache/ignite-3/pull/1702

   https://issues.apache.org/jira/browse/IGNITE-18866


;21/Feb/23 14:51;githubbot;600","PakhomovAlexander merged PR #1702:
URL: https://github.com/apache/ignite-3/pull/1702


;22/Feb/23 14:59;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Feb 22 15:02:46 UTC 2023,,,,,,,,,,"0|z1g30w:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"22/Feb/23 14:48;aleksandr.pakhomov;LGTM;;;","22/Feb/23 15:02;aleksandr.pakhomov;merged into main: eeb8b898ec1008a47406fe73778c5b862aab6160;;;",,,,
NPE in DumpThreadsOnTimeout breaking resource cleanup,IGNITE-18861,13525583,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,rpuch,Mikhail Pochatkin,Mikhail Pochatkin,21/Feb/23 14:04,23/Feb/23 04:23,13/Jul/23 09:11,23/Feb/23 04:23,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"In test runs from CI founded follow stacktrace:
{code:java}
java.lang.NullPointerException
	at org.apache.ignite.internal.testframework.junit.DumpThreadsOnTimeout.isJunitMethodTimeout(DumpThreadsOnTimeout.java:68)
	at org.apache.ignite.internal.testframework.junit.DumpThreadsOnTimeout.handleThrowable(DumpThreadsOnTimeout.java:53)
	at org.apache.ignite.internal.testframework.junit.DumpThreadsOnTimeout.handleTestExecutionException(DumpThreadsOnTimeout.java:49)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestExecutionExceptionHandlers$8(TestMethodTestDescriptor.java:228)
	at org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.invokeExecutionExceptionHandlers(JupiterTestDescriptor.java:123)
	at org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.invokeExecutionExceptionHandlers(JupiterTestDescriptor.java:110)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestExecutionExceptionHandlers(TestMethodTestDescriptor.java:227)
	...
	at org.gradle.api.internal.tasks.testing.worker.TestWorker$3.run(TestWorker.java:193)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.executeAndMaintainThreadName(TestWorker.java:129)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:100)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:60)
	at org.gradle.process.internal.worker.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:56)
	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:133)
	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:71)
	at worker.org.gradle.process.internal.worker.GradleWorkerMain.run(GradleWorkerMain.java:69)
	at worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74)
{code}

In case any tests failed with TimeoutException *org.apache.ignite.internal.testframework.junit.DumpThreadsOnTimeout*  tried to produce readable message but fail with *NPE * in case when Exception message is null. After this NPE JUnit thread die and *BeforeAll\BeforeEach* methods are not called. As result, we have unkilled AI3 live nodes which holded ports and next tests on the CI Agent where it failed cannot run correctly with reason *Caused by: java.lang.IllegalStateException: No available port in range [3344-3344]*",,Mikhail Pochatkin,rpuch,,,,"rpuch opened a new pull request, #1705:
URL: https://github.com/apache/ignite-3/pull/1705

   https://issues.apache.org/jira/browse/IGNITE-18861


;22/Feb/23 07:07;githubbot;600","Pochatkin commented on PR #1705:
URL: https://github.com/apache/ignite-3/pull/1705#issuecomment-1440147969

   LGTM


;22/Feb/23 14:38;githubbot;600","tkalkirill merged PR #1705:
URL: https://github.com/apache/ignite-3/pull/1705


;23/Feb/23 04:22;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-18874,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Feb 22 14:39:04 UTC 2023,,,,,,,,,,"0|z1g2yo:",9223372036854775807,,,krokpop,,,,,,,,,,,,,,,,,,"22/Feb/23 07:39;rpuch;Looks ilke an NPE in a JUnit extension cannot prevent other life-cycle methods (after-all/after-each) execution, so it is not the cause of some node being alive after our tests. Anyway, the NPE must be fixed to reduce the noise and avoid false leads.;;;","22/Feb/23 11:17;rpuch;[~Mikhail Pochatkin] could you please take a look?;;;","22/Feb/23 14:39;Mikhail Pochatkin;LGTM;;;",,,
.NET: Thin 3.0: TestReconnectAfterFullClusterRestart is flaky,IGNITE-18851,13525445,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,20/Feb/23 15:26,20/Mar/23 09:07,13/Jul/23 09:11,02/Mar/23 12:02,3.0.0-beta1,,,,,,,3.0.0-beta2,platforms,thin client,,0,.NET,ignite-3,,"{code}
Condition not reached after 00:00:03.0086244
   at Apache.Ignite.Tests.TestUtils.WaitForCondition(Func`1 condition, Int32 timeoutMs, Func`1 messageFactory) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/TestUtils.cs:line 62
   at Apache.Ignite.Tests.ReconnectTests.TestReconnectAfterFullClusterRestart() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/ReconnectTests.cs:line 156
   at NUnit.Framework.Internal.TaskAwaitAdapter.GenericAdapter`1.BlockUntilCompleted()
   at NUnit.Framework.Internal.MessagePumpStrategy.NoMessagePumpStrategy.WaitForCompletion(AwaitAdapter awaiter)
   at NUnit.Framework.Internal.AsyncToSyncAdapter.Await(Func`1 invoke)
   at NUnit.Framework.Internal.Commands.TestMethodCommand.RunTestMethod(TestExecutionContext context)
   at NUnit.Framework.Internal.Commands.TestMethodCommand.Execute(TestExecutionContext context)
   at NUnit.Framework.Internal.Execution.SimpleWorkItem.<>c__DisplayClass4_0.<PerformWork>b__0()
   at NUnit.Framework.Internal.ContextUtils.<>c__DisplayClass1_0`1.<DoIsolated>b__0(Object _)
1)    at Apache.Ignite.Tests.TestUtils.WaitForCondition(Func`1 condition, Int32 timeoutMs, Func`1 messageFactory) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/TestUtils.cs:line 62
   at Apache.Ignite.Tests.ReconnectTests.TestReconnectAfterFullClusterRestart() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/ReconnectTests.cs:line 156
{code}

https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunNetTests/7088557?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&pluginCoverage=true&expandBuildTestsSection=true",,isapego,ptupitsyn,,,,"ptupitsyn opened a new pull request, #1741:
URL: https://github.com/apache/ignite-3/pull/1741

   * Use volatile flag.
   * Increase timeout.
   * Improve assertion message.


;02/Mar/23 07:27;githubbot;600","ptupitsyn merged PR #1741:
URL: https://github.com/apache/ignite-3/pull/1741


;02/Mar/23 12:01;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-19069,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Mar 02 12:02:15 UTC 2023,,,,,,,,,,"0|z1g240:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"02/Mar/23 11:25;ptupitsyn;[~isapego] please review. 

100+ TC runs without failures in this test: https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunNetTests?branch=pull%2F1741&buildTypeTab=overview&mode=builds;;;","02/Mar/23 12:00;isapego;[~ptupitsyn] Looks good to me.;;;","02/Mar/23 12:02;ptupitsyn;Merged to main: 3f9f532e8f6e2a59b98e58bac62def51904b51bf;;;",,,
Fix the behavior of MvPartitionStorage#pollForVacuum when trying to delete the same row in parallel,IGNITE-18843,13525373,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ktkalenko@gridgain.com,ktkalenko@gridgain.com,20/Feb/23 06:24,23/Feb/23 07:41,13/Jul/23 09:11,23/Feb/23 07:41,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"It is necessary to slightly correct the behavior of the *org.apache.ignite.internal.storage.MvPartitionStorage#pollForVacuum* when we are trying to delete the same *RowVersion* in parallel.

At the moment, when trying to delete 2 *RowVersion* in parallel, we will actually delete the first *RowVersion* for one thread, and the second thread will notice this and simply return *null*, and as a result, we will have one *RowVersion* that needs to be deleted.

We need to try to get *RowVersion*s until the queue is empty.

It needs to be fixed for all implementations.",,ktkalenko@gridgain.com,,,,,"tkalkirill opened a new pull request, #1697:
URL: https://github.com/apache/ignite-3/pull/1697

   https://issues.apache.org/jira/browse/IGNITE-18843


;21/Feb/23 07:51;githubbot;600","ibessonov commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1114124187


##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowId.java:
##########
@@ -0,0 +1,175 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Supplier;
+import org.apache.ignite.internal.storage.RowId;
+
+/**
+ * {@link ReentrantLock} by row ID.
+ *
+ * <p>Allows synchronization of version chain update operations.
+ */
+public class ReentrantLockByRowId {
+    private final ThreadLocal<Object> lockedRowIds = new ThreadLocal<>();
+
+    private final ConcurrentMap<RowId, LockHolder<ReentrantLock>> lockHolderByRowId = new ConcurrentHashMap<>();
+
+    /**
+     * Executes the supplier under lock by row ID.
+     *
+     * @param <T> Return type.
+     * @param rowId Row ID.
+     * @param supplier Supplier to execute under the lock.
+     * @return Value.
+     */
+    public <T> T inLock(RowId rowId, Supplier<T> supplier) {
+        acquireLock0(rowId);
+
+        try {
+            return supplier.get();
+        } finally {
+            releaseLock0(rowId, false);
+        }
+    }
+
+    /**
+     * Acquires the lock by row ID.
+     *
+     * @param rowId Row ID.
+     */
+    public void acquireLock(RowId rowId) {
+        acquireLock0(rowId);
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        if (lockedRowIds == null) {
+            this.lockedRowIds.set(rowId);
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            if (!lockedRowId.equals(rowId)) {
+                Set<RowId> rowIds = new HashSet<>();
+
+                rowIds.add(lockedRowId);
+                rowIds.add(rowId);
+
+                this.lockedRowIds.set(rowIds);
+            }
+        } else {
+            ((Set<RowId>) lockedRowIds).add(rowId);
+        }
+    }
+
+    /**
+     * Releases the lock by row ID.
+     *
+     * @param rowId Row ID.
+     * @throws IllegalStateException If the lock could not be found by row ID.
+     * @throws IllegalMonitorStateException If the current thread does not hold this lock.
+     */
+    public void releaseLock(RowId rowId) {
+        releaseLock0(rowId, false);
+
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder != null && lockHolder.getLock().isHeldByCurrentThread()) {
+            return;
+        }
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        assert lockedRowIds != null : rowId;
+
+        if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            assert lockedRowId.equals(rowId) : ""rowId="" + rowId + "", lockedRowId="" + lockedRowId;
+
+            this.lockedRowIds.remove();
+        } else {
+            Set<RowId> rowIds = ((Set<RowId>) lockedRowIds);
+
+            boolean remove = rowIds.remove(rowId);
+
+            assert remove : ""rowId="" + rowId + "", lockedRowIds="" + rowIds;
+
+            if (rowIds.isEmpty()) {
+                this.lockedRowIds.remove();
+            }
+        }
+    }
+
+    /**
+     * Releases all locks {@link #acquireLock(RowId) acquired} by the current thread if exists.
+     *
+     * <p>Order of releasing the locks is not defined, each lock will be released with all re-entries.
+     */
+    public void releaseAllLockByCurrentThread() {
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        this.lockedRowIds.remove();
+
+        if (lockedRowIds == null) {
+            return;
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            releaseLock0(((RowId) lockedRowIds), true);
+        } else {
+            ((Set<RowId>) lockedRowIds).forEach(rowId -> releaseLock0(rowId, true));

Review Comment:
   Why ""forEach"" and not a loop? I thought that we don't use such constructions in hot code



##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowId.java:
##########
@@ -0,0 +1,175 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Supplier;
+import org.apache.ignite.internal.storage.RowId;
+
+/**
+ * {@link ReentrantLock} by row ID.
+ *
+ * <p>Allows synchronization of version chain update operations.
+ */
+public class ReentrantLockByRowId {
+    private final ThreadLocal<Object> lockedRowIds = new ThreadLocal<>();
+
+    private final ConcurrentMap<RowId, LockHolder<ReentrantLock>> lockHolderByRowId = new ConcurrentHashMap<>();
+
+    /**
+     * Executes the supplier under lock by row ID.
+     *
+     * @param <T> Return type.
+     * @param rowId Row ID.
+     * @param supplier Supplier to execute under the lock.
+     * @return Value.
+     */
+    public <T> T inLock(RowId rowId, Supplier<T> supplier) {
+        acquireLock0(rowId);
+
+        try {
+            return supplier.get();
+        } finally {
+            releaseLock0(rowId, false);
+        }
+    }
+
+    /**
+     * Acquires the lock by row ID.
+     *
+     * @param rowId Row ID.
+     */
+    public void acquireLock(RowId rowId) {
+        acquireLock0(rowId);
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        if (lockedRowIds == null) {
+            this.lockedRowIds.set(rowId);
+        } else if (lockedRowIds.getClass() == RowId.class) {

Review Comment:
   Please replace it with `lockedRowIds instanceof RowId`. Please do the same in other method that uses similar construction



##########
modules/storage-api/src/test/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowIdTest.java:
##########
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.runAsync;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willFailFast;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeoutException;
+import org.apache.ignite.internal.storage.RowId;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Class for testing {@link ReentrantLockByRowId}.
+ */
+public class ReentrantLockByRowIdTest {
+    @Test
+    void testSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.releaseLock(rowId);
+
+        assertEquals(1, lockByRowId.inLock(rowId, () -> 1));
+    }
+
+    @Test
+    void testSimpleReEnter() {

Review Comment:
   I see no assertions in this test



##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowId.java:
##########
@@ -0,0 +1,175 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Supplier;
+import org.apache.ignite.internal.storage.RowId;
+
+/**
+ * {@link ReentrantLock} by row ID.
+ *
+ * <p>Allows synchronization of version chain update operations.
+ */
+public class ReentrantLockByRowId {
+    private final ThreadLocal<Object> lockedRowIds = new ThreadLocal<>();
+
+    private final ConcurrentMap<RowId, LockHolder<ReentrantLock>> lockHolderByRowId = new ConcurrentHashMap<>();
+
+    /**
+     * Executes the supplier under lock by row ID.
+     *
+     * @param <T> Return type.
+     * @param rowId Row ID.
+     * @param supplier Supplier to execute under the lock.
+     * @return Value.
+     */
+    public <T> T inLock(RowId rowId, Supplier<T> supplier) {
+        acquireLock0(rowId);
+
+        try {
+            return supplier.get();
+        } finally {
+            releaseLock0(rowId, false);
+        }
+    }
+
+    /**
+     * Acquires the lock by row ID.
+     *
+     * @param rowId Row ID.
+     */
+    public void acquireLock(RowId rowId) {
+        acquireLock0(rowId);
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        if (lockedRowIds == null) {
+            this.lockedRowIds.set(rowId);
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            if (!lockedRowId.equals(rowId)) {
+                Set<RowId> rowIds = new HashSet<>();
+
+                rowIds.add(lockedRowId);
+                rowIds.add(rowId);
+
+                this.lockedRowIds.set(rowIds);
+            }
+        } else {
+            ((Set<RowId>) lockedRowIds).add(rowId);
+        }
+    }
+
+    /**
+     * Releases the lock by row ID.
+     *
+     * @param rowId Row ID.
+     * @throws IllegalStateException If the lock could not be found by row ID.
+     * @throws IllegalMonitorStateException If the current thread does not hold this lock.
+     */
+    public void releaseLock(RowId rowId) {
+        releaseLock0(rowId, false);
+
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder != null && lockHolder.getLock().isHeldByCurrentThread()) {
+            return;
+        }
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        assert lockedRowIds != null : rowId;
+
+        if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            assert lockedRowId.equals(rowId) : ""rowId="" + rowId + "", lockedRowId="" + lockedRowId;
+
+            this.lockedRowIds.remove();
+        } else {
+            Set<RowId> rowIds = ((Set<RowId>) lockedRowIds);
+
+            boolean remove = rowIds.remove(rowId);
+
+            assert remove : ""rowId="" + rowId + "", lockedRowIds="" + rowIds;
+
+            if (rowIds.isEmpty()) {
+                this.lockedRowIds.remove();

Review Comment:
   Would it be better to use `set(null)` instead of `remove`? The latter might be noticeably slower



##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowId.java:
##########
@@ -0,0 +1,175 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Supplier;
+import org.apache.ignite.internal.storage.RowId;
+
+/**
+ * {@link ReentrantLock} by row ID.
+ *
+ * <p>Allows synchronization of version chain update operations.
+ */
+public class ReentrantLockByRowId {
+    private final ThreadLocal<Object> lockedRowIds = new ThreadLocal<>();
+
+    private final ConcurrentMap<RowId, LockHolder<ReentrantLock>> lockHolderByRowId = new ConcurrentHashMap<>();
+
+    /**
+     * Executes the supplier under lock by row ID.
+     *
+     * @param <T> Return type.
+     * @param rowId Row ID.
+     * @param supplier Supplier to execute under the lock.
+     * @return Value.
+     */
+    public <T> T inLock(RowId rowId, Supplier<T> supplier) {
+        acquireLock0(rowId);
+
+        try {
+            return supplier.get();
+        } finally {
+            releaseLock0(rowId, false);
+        }
+    }
+
+    /**
+     * Acquires the lock by row ID.
+     *
+     * @param rowId Row ID.
+     */
+    public void acquireLock(RowId rowId) {
+        acquireLock0(rowId);
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        if (lockedRowIds == null) {
+            this.lockedRowIds.set(rowId);
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            if (!lockedRowId.equals(rowId)) {
+                Set<RowId> rowIds = new HashSet<>();
+
+                rowIds.add(lockedRowId);
+                rowIds.add(rowId);
+
+                this.lockedRowIds.set(rowIds);
+            }
+        } else {
+            ((Set<RowId>) lockedRowIds).add(rowId);
+        }
+    }
+
+    /**
+     * Releases the lock by row ID.
+     *
+     * @param rowId Row ID.
+     * @throws IllegalStateException If the lock could not be found by row ID.
+     * @throws IllegalMonitorStateException If the current thread does not hold this lock.
+     */
+    public void releaseLock(RowId rowId) {
+        releaseLock0(rowId, false);
+
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder != null && lockHolder.getLock().isHeldByCurrentThread()) {
+            return;
+        }
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        assert lockedRowIds != null : rowId;
+
+        if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            assert lockedRowId.equals(rowId) : ""rowId="" + rowId + "", lockedRowId="" + lockedRowId;
+
+            this.lockedRowIds.remove();
+        } else {
+            Set<RowId> rowIds = ((Set<RowId>) lockedRowIds);
+
+            boolean remove = rowIds.remove(rowId);
+
+            assert remove : ""rowId="" + rowId + "", lockedRowIds="" + rowIds;
+
+            if (rowIds.isEmpty()) {
+                this.lockedRowIds.remove();
+            }
+        }
+    }
+
+    /**
+     * Releases all locks {@link #acquireLock(RowId) acquired} by the current thread if exists.
+     *
+     * <p>Order of releasing the locks is not defined, each lock will be released with all re-entries.
+     */
+    public void releaseAllLockByCurrentThread() {
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        this.lockedRowIds.remove();
+
+        if (lockedRowIds == null) {
+            return;
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            releaseLock0(((RowId) lockedRowIds), true);
+        } else {
+            ((Set<RowId>) lockedRowIds).forEach(rowId -> releaseLock0(rowId, true));
+        }
+    }
+
+    private void acquireLock0(RowId rowId) {
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {
+            if (reentrantLockLockHolder == null) {
+                reentrantLockLockHolder = new LockHolder<>(new ReentrantLock());
+            }
+
+            reentrantLockLockHolder.incrementHolders();
+
+            return reentrantLockLockHolder;
+        });
+
+        lockHolder.getLock().lock();
+    }
+
+    private void releaseLock0(RowId rowId, boolean untilHoldByCurrentThread) {
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder == null) {
+            throw new IllegalStateException(""Could not find lock by row ID: "" + rowId);
+        }
+
+        ReentrantLock lock = lockHolder.getLock();
+
+        do {
+            lock.unlock();
+
+            lockHolderByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {
+                assert reentrantLockLockHolder != null;
+
+                return reentrantLockLockHolder.decrementHolders() ? null : reentrantLockLockHolder;
+            });
+        } while (untilHoldByCurrentThread && lock.getHoldCount() > 0);

Review Comment:
   You don't remove the holder from the map, is this intentional?



##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowId.java:
##########
@@ -0,0 +1,175 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Supplier;
+import org.apache.ignite.internal.storage.RowId;
+
+/**
+ * {@link ReentrantLock} by row ID.
+ *
+ * <p>Allows synchronization of version chain update operations.
+ */
+public class ReentrantLockByRowId {
+    private final ThreadLocal<Object> lockedRowIds = new ThreadLocal<>();
+
+    private final ConcurrentMap<RowId, LockHolder<ReentrantLock>> lockHolderByRowId = new ConcurrentHashMap<>();
+
+    /**
+     * Executes the supplier under lock by row ID.
+     *
+     * @param <T> Return type.
+     * @param rowId Row ID.
+     * @param supplier Supplier to execute under the lock.
+     * @return Value.
+     */
+    public <T> T inLock(RowId rowId, Supplier<T> supplier) {
+        acquireLock0(rowId);
+
+        try {
+            return supplier.get();
+        } finally {
+            releaseLock0(rowId, false);
+        }
+    }
+
+    /**
+     * Acquires the lock by row ID.
+     *
+     * @param rowId Row ID.
+     */
+    public void acquireLock(RowId rowId) {
+        acquireLock0(rowId);
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        if (lockedRowIds == null) {
+            this.lockedRowIds.set(rowId);
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            if (!lockedRowId.equals(rowId)) {
+                Set<RowId> rowIds = new HashSet<>();
+
+                rowIds.add(lockedRowId);
+                rowIds.add(rowId);
+
+                this.lockedRowIds.set(rowIds);
+            }
+        } else {
+            ((Set<RowId>) lockedRowIds).add(rowId);
+        }
+    }
+
+    /**
+     * Releases the lock by row ID.
+     *
+     * @param rowId Row ID.
+     * @throws IllegalStateException If the lock could not be found by row ID.
+     * @throws IllegalMonitorStateException If the current thread does not hold this lock.
+     */
+    public void releaseLock(RowId rowId) {
+        releaseLock0(rowId, false);
+
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder != null && lockHolder.getLock().isHeldByCurrentThread()) {
+            return;
+        }
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        assert lockedRowIds != null : rowId;
+
+        if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            assert lockedRowId.equals(rowId) : ""rowId="" + rowId + "", lockedRowId="" + lockedRowId;
+
+            this.lockedRowIds.remove();
+        } else {
+            Set<RowId> rowIds = ((Set<RowId>) lockedRowIds);
+
+            boolean remove = rowIds.remove(rowId);
+
+            assert remove : ""rowId="" + rowId + "", lockedRowIds="" + rowIds;
+
+            if (rowIds.isEmpty()) {
+                this.lockedRowIds.remove();
+            }
+        }
+    }
+
+    /**
+     * Releases all locks {@link #acquireLock(RowId) acquired} by the current thread if exists.
+     *
+     * <p>Order of releasing the locks is not defined, each lock will be released with all re-entries.
+     */
+    public void releaseAllLockByCurrentThread() {
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        this.lockedRowIds.remove();
+
+        if (lockedRowIds == null) {
+            return;
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            releaseLock0(((RowId) lockedRowIds), true);
+        } else {
+            ((Set<RowId>) lockedRowIds).forEach(rowId -> releaseLock0(rowId, true));
+        }
+    }
+
+    private void acquireLock0(RowId rowId) {
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {
+            if (reentrantLockLockHolder == null) {
+                reentrantLockLockHolder = new LockHolder<>(new ReentrantLock());
+            }
+
+            reentrantLockLockHolder.incrementHolders();
+
+            return reentrantLockLockHolder;
+        });
+
+        lockHolder.getLock().lock();
+    }
+
+    private void releaseLock0(RowId rowId, boolean untilHoldByCurrentThread) {

Review Comment:
   Name `untilHoldByCurrentThread` feels complicated, maybe there's another name that you could give to this parameter.



##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/AbstractMvPartitionStorageConcurrencyTest.java:
##########
@@ -193,19 +202,39 @@ void testConcurrentGc(AddAndCommit addAndCommit) {
         for (int i = 0; i < REPEATS; i++) {
             addAndCommit.perform(this, TABLE_ROW);
 
+            addAndCommit.perform(this, TABLE_ROW2);
+
             addAndCommit.perform(this, null);
 
+            Collection<byte[]> rows = toRowBytes(TABLE_ROW, TABLE_ROW2);
+
             runRace(
-                    () -> pollForVacuum(HybridTimestamp.MAX_VALUE),
-                    () -> pollForVacuum(HybridTimestamp.MAX_VALUE),
-                    () -> pollForVacuum(HybridTimestamp.MAX_VALUE),
-                    () -> pollForVacuum(HybridTimestamp.MAX_VALUE)
+                    () -> assertRemoveRow(pollForVacuum(HybridTimestamp.MAX_VALUE).binaryRow().bytes(), rows),
+                    () -> assertRemoveRow(pollForVacuum(HybridTimestamp.MAX_VALUE).binaryRow().bytes(), rows)
             );
 
+            assertNull(pollForVacuum(HybridTimestamp.MAX_VALUE));
+
             assertNull(storage.closestRowId(ROW_ID));
+
+            assertThat(rows, empty());
         }
     }
 
+    private void assertRemoveRow(byte[] rowBytes, Collection<byte[]> rows) {
+        assertNotNull(rowBytes);
+
+        byte[] found = rows.stream().filter(bytes -> Arrays.equals(bytes, rowBytes)).findFirst().orElseGet(null);

Review Comment:
   You could have used byte buffers instead, they provide the default ""equals"" implementation



##########
modules/storage-api/src/test/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowIdTest.java:
##########
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.runAsync;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willFailFast;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeoutException;
+import org.apache.ignite.internal.storage.RowId;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Class for testing {@link ReentrantLockByRowId}.
+ */
+public class ReentrantLockByRowIdTest {
+    @Test
+    void testSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.releaseLock(rowId);
+
+        assertEquals(1, lockByRowId.inLock(rowId, () -> 1));
+    }
+
+    @Test
+    void testSimpleReEnter() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.acquireLock(rowId);
+
+        lockByRowId.inLock(rowId, () -> {
+            lockByRowId.acquireLock(rowId);
+
+            lockByRowId.releaseLock(rowId);
+
+            return null;
+        });
+
+        lockByRowId.releaseLock(rowId);
+        lockByRowId.releaseLock(rowId);
+    }
+
+    @Test
+    void testReleaseError() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        assertThrows(IllegalStateException.class, () -> lockByRowId.releaseLock(new RowId(0)));
+
+        RowId rowId = new RowId(0);
+
+        assertThat(runAsync(() -> lockByRowId.acquireLock(rowId)), willCompleteSuccessfully());
+
+        assertThrows(IllegalMonitorStateException.class, () -> lockByRowId.releaseLock(rowId));
+    }
+
+    @Test
+    void testBlockSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.acquireLock(rowId);
+
+        CompletableFuture<?> acquireLockFuture = runAsync(() -> {
+            lockByRowId.acquireLock(rowId);
+            lockByRowId.releaseLock(rowId);
+        });
+
+        assertThat(acquireLockFuture, willFailFast(TimeoutException.class));
+
+        lockByRowId.releaseLock(rowId);
+
+        assertThat(acquireLockFuture, willFailFast(TimeoutException.class));
+
+        lockByRowId.releaseLock(rowId);
+
+        assertThat(acquireLockFuture, willCompleteSuccessfully());
+
+        lockByRowId.acquireLock(rowId);

Review Comment:
   Why do you re-acquire the lock?
   Also, why don't you use try/finally blocks in your tests?



##########
modules/storage-api/src/test/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowIdTest.java:
##########
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.runAsync;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willFailFast;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeoutException;
+import org.apache.ignite.internal.storage.RowId;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Class for testing {@link ReentrantLockByRowId}.
+ */
+public class ReentrantLockByRowIdTest {
+    @Test
+    void testSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.releaseLock(rowId);
+
+        assertEquals(1, lockByRowId.inLock(rowId, () -> 1));
+    }
+
+    @Test
+    void testSimpleReEnter() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.acquireLock(rowId);
+
+        lockByRowId.inLock(rowId, () -> {
+            lockByRowId.acquireLock(rowId);
+
+            lockByRowId.releaseLock(rowId);
+
+            return null;
+        });
+
+        lockByRowId.releaseLock(rowId);
+        lockByRowId.releaseLock(rowId);
+    }
+
+    @Test
+    void testReleaseError() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        assertThrows(IllegalStateException.class, () -> lockByRowId.releaseLock(new RowId(0)));
+
+        RowId rowId = new RowId(0);
+
+        assertThat(runAsync(() -> lockByRowId.acquireLock(rowId)), willCompleteSuccessfully());
+
+        assertThrows(IllegalMonitorStateException.class, () -> lockByRowId.releaseLock(rowId));
+    }
+
+    @Test
+    void testBlockSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.acquireLock(rowId);
+
+        CompletableFuture<?> acquireLockFuture = runAsync(() -> {
+            lockByRowId.acquireLock(rowId);
+            lockByRowId.releaseLock(rowId);
+        });
+
+        assertThat(acquireLockFuture, willFailFast(TimeoutException.class));
+
+        lockByRowId.releaseLock(rowId);
+
+        assertThat(acquireLockFuture, willFailFast(TimeoutException.class));

Review Comment:
   It's not ""willFailFast"", it's ""wontCompleteWithinShortTimeout"" (but I'd prefer something shorter)



;22/Feb/23 13:46;githubbot;600","tkalkirill commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115224671


##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowId.java:
##########
@@ -0,0 +1,175 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Supplier;
+import org.apache.ignite.internal.storage.RowId;
+
+/**
+ * {@link ReentrantLock} by row ID.
+ *
+ * <p>Allows synchronization of version chain update operations.
+ */
+public class ReentrantLockByRowId {
+    private final ThreadLocal<Object> lockedRowIds = new ThreadLocal<>();
+
+    private final ConcurrentMap<RowId, LockHolder<ReentrantLock>> lockHolderByRowId = new ConcurrentHashMap<>();
+
+    /**
+     * Executes the supplier under lock by row ID.
+     *
+     * @param <T> Return type.
+     * @param rowId Row ID.
+     * @param supplier Supplier to execute under the lock.
+     * @return Value.
+     */
+    public <T> T inLock(RowId rowId, Supplier<T> supplier) {
+        acquireLock0(rowId);
+
+        try {
+            return supplier.get();
+        } finally {
+            releaseLock0(rowId, false);
+        }
+    }
+
+    /**
+     * Acquires the lock by row ID.
+     *
+     * @param rowId Row ID.
+     */
+    public void acquireLock(RowId rowId) {
+        acquireLock0(rowId);
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        if (lockedRowIds == null) {
+            this.lockedRowIds.set(rowId);
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            if (!lockedRowId.equals(rowId)) {
+                Set<RowId> rowIds = new HashSet<>();
+
+                rowIds.add(lockedRowId);
+                rowIds.add(rowId);
+
+                this.lockedRowIds.set(rowIds);
+            }
+        } else {
+            ((Set<RowId>) lockedRowIds).add(rowId);
+        }
+    }
+
+    /**
+     * Releases the lock by row ID.
+     *
+     * @param rowId Row ID.
+     * @throws IllegalStateException If the lock could not be found by row ID.
+     * @throws IllegalMonitorStateException If the current thread does not hold this lock.
+     */
+    public void releaseLock(RowId rowId) {
+        releaseLock0(rowId, false);
+
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder != null && lockHolder.getLock().isHeldByCurrentThread()) {
+            return;
+        }
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        assert lockedRowIds != null : rowId;
+
+        if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            assert lockedRowId.equals(rowId) : ""rowId="" + rowId + "", lockedRowId="" + lockedRowId;
+
+            this.lockedRowIds.remove();
+        } else {
+            Set<RowId> rowIds = ((Set<RowId>) lockedRowIds);
+
+            boolean remove = rowIds.remove(rowId);
+
+            assert remove : ""rowId="" + rowId + "", lockedRowIds="" + rowIds;
+
+            if (rowIds.isEmpty()) {
+                this.lockedRowIds.remove();
+            }
+        }
+    }
+
+    /**
+     * Releases all locks {@link #acquireLock(RowId) acquired} by the current thread if exists.
+     *
+     * <p>Order of releasing the locks is not defined, each lock will be released with all re-entries.
+     */
+    public void releaseAllLockByCurrentThread() {
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        this.lockedRowIds.remove();
+
+        if (lockedRowIds == null) {
+            return;
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            releaseLock0(((RowId) lockedRowIds), true);
+        } else {
+            ((Set<RowId>) lockedRowIds).forEach(rowId -> releaseLock0(rowId, true));

Review Comment:
   Fix it



;23/Feb/23 04:26;githubbot;600","tkalkirill commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115225017


##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowId.java:
##########
@@ -0,0 +1,175 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Supplier;
+import org.apache.ignite.internal.storage.RowId;
+
+/**
+ * {@link ReentrantLock} by row ID.
+ *
+ * <p>Allows synchronization of version chain update operations.
+ */
+public class ReentrantLockByRowId {
+    private final ThreadLocal<Object> lockedRowIds = new ThreadLocal<>();
+
+    private final ConcurrentMap<RowId, LockHolder<ReentrantLock>> lockHolderByRowId = new ConcurrentHashMap<>();
+
+    /**
+     * Executes the supplier under lock by row ID.
+     *
+     * @param <T> Return type.
+     * @param rowId Row ID.
+     * @param supplier Supplier to execute under the lock.
+     * @return Value.
+     */
+    public <T> T inLock(RowId rowId, Supplier<T> supplier) {
+        acquireLock0(rowId);
+
+        try {
+            return supplier.get();
+        } finally {
+            releaseLock0(rowId, false);
+        }
+    }
+
+    /**
+     * Acquires the lock by row ID.
+     *
+     * @param rowId Row ID.
+     */
+    public void acquireLock(RowId rowId) {
+        acquireLock0(rowId);
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        if (lockedRowIds == null) {
+            this.lockedRowIds.set(rowId);
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            if (!lockedRowId.equals(rowId)) {
+                Set<RowId> rowIds = new HashSet<>();
+
+                rowIds.add(lockedRowId);
+                rowIds.add(rowId);
+
+                this.lockedRowIds.set(rowIds);
+            }
+        } else {
+            ((Set<RowId>) lockedRowIds).add(rowId);
+        }
+    }
+
+    /**
+     * Releases the lock by row ID.
+     *
+     * @param rowId Row ID.
+     * @throws IllegalStateException If the lock could not be found by row ID.
+     * @throws IllegalMonitorStateException If the current thread does not hold this lock.
+     */
+    public void releaseLock(RowId rowId) {
+        releaseLock0(rowId, false);
+
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder != null && lockHolder.getLock().isHeldByCurrentThread()) {
+            return;
+        }
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        assert lockedRowIds != null : rowId;
+
+        if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            assert lockedRowId.equals(rowId) : ""rowId="" + rowId + "", lockedRowId="" + lockedRowId;
+
+            this.lockedRowIds.remove();
+        } else {
+            Set<RowId> rowIds = ((Set<RowId>) lockedRowIds);
+
+            boolean remove = rowIds.remove(rowId);
+
+            assert remove : ""rowId="" + rowId + "", lockedRowIds="" + rowIds;
+
+            if (rowIds.isEmpty()) {
+                this.lockedRowIds.remove();

Review Comment:
   fix it



;23/Feb/23 04:27;githubbot;600","tkalkirill commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115225325


##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowId.java:
##########
@@ -0,0 +1,175 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Supplier;
+import org.apache.ignite.internal.storage.RowId;
+
+/**
+ * {@link ReentrantLock} by row ID.
+ *
+ * <p>Allows synchronization of version chain update operations.
+ */
+public class ReentrantLockByRowId {
+    private final ThreadLocal<Object> lockedRowIds = new ThreadLocal<>();
+
+    private final ConcurrentMap<RowId, LockHolder<ReentrantLock>> lockHolderByRowId = new ConcurrentHashMap<>();
+
+    /**
+     * Executes the supplier under lock by row ID.
+     *
+     * @param <T> Return type.
+     * @param rowId Row ID.
+     * @param supplier Supplier to execute under the lock.
+     * @return Value.
+     */
+    public <T> T inLock(RowId rowId, Supplier<T> supplier) {
+        acquireLock0(rowId);
+
+        try {
+            return supplier.get();
+        } finally {
+            releaseLock0(rowId, false);
+        }
+    }
+
+    /**
+     * Acquires the lock by row ID.
+     *
+     * @param rowId Row ID.
+     */
+    public void acquireLock(RowId rowId) {
+        acquireLock0(rowId);
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        if (lockedRowIds == null) {
+            this.lockedRowIds.set(rowId);
+        } else if (lockedRowIds.getClass() == RowId.class) {

Review Comment:
   fix it



;23/Feb/23 04:28;githubbot;600","tkalkirill commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115227955


##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowId.java:
##########
@@ -0,0 +1,175 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Supplier;
+import org.apache.ignite.internal.storage.RowId;
+
+/**
+ * {@link ReentrantLock} by row ID.
+ *
+ * <p>Allows synchronization of version chain update operations.
+ */
+public class ReentrantLockByRowId {
+    private final ThreadLocal<Object> lockedRowIds = new ThreadLocal<>();
+
+    private final ConcurrentMap<RowId, LockHolder<ReentrantLock>> lockHolderByRowId = new ConcurrentHashMap<>();
+
+    /**
+     * Executes the supplier under lock by row ID.
+     *
+     * @param <T> Return type.
+     * @param rowId Row ID.
+     * @param supplier Supplier to execute under the lock.
+     * @return Value.
+     */
+    public <T> T inLock(RowId rowId, Supplier<T> supplier) {
+        acquireLock0(rowId);
+
+        try {
+            return supplier.get();
+        } finally {
+            releaseLock0(rowId, false);
+        }
+    }
+
+    /**
+     * Acquires the lock by row ID.
+     *
+     * @param rowId Row ID.
+     */
+    public void acquireLock(RowId rowId) {
+        acquireLock0(rowId);
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        if (lockedRowIds == null) {
+            this.lockedRowIds.set(rowId);
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            if (!lockedRowId.equals(rowId)) {
+                Set<RowId> rowIds = new HashSet<>();
+
+                rowIds.add(lockedRowId);
+                rowIds.add(rowId);
+
+                this.lockedRowIds.set(rowIds);
+            }
+        } else {
+            ((Set<RowId>) lockedRowIds).add(rowId);
+        }
+    }
+
+    /**
+     * Releases the lock by row ID.
+     *
+     * @param rowId Row ID.
+     * @throws IllegalStateException If the lock could not be found by row ID.
+     * @throws IllegalMonitorStateException If the current thread does not hold this lock.
+     */
+    public void releaseLock(RowId rowId) {
+        releaseLock0(rowId, false);
+
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder != null && lockHolder.getLock().isHeldByCurrentThread()) {
+            return;
+        }
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        assert lockedRowIds != null : rowId;
+
+        if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            assert lockedRowId.equals(rowId) : ""rowId="" + rowId + "", lockedRowId="" + lockedRowId;
+
+            this.lockedRowIds.remove();
+        } else {
+            Set<RowId> rowIds = ((Set<RowId>) lockedRowIds);
+
+            boolean remove = rowIds.remove(rowId);
+
+            assert remove : ""rowId="" + rowId + "", lockedRowIds="" + rowIds;
+
+            if (rowIds.isEmpty()) {
+                this.lockedRowIds.remove();
+            }
+        }
+    }
+
+    /**
+     * Releases all locks {@link #acquireLock(RowId) acquired} by the current thread if exists.
+     *
+     * <p>Order of releasing the locks is not defined, each lock will be released with all re-entries.
+     */
+    public void releaseAllLockByCurrentThread() {
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        this.lockedRowIds.remove();
+
+        if (lockedRowIds == null) {
+            return;
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            releaseLock0(((RowId) lockedRowIds), true);
+        } else {
+            ((Set<RowId>) lockedRowIds).forEach(rowId -> releaseLock0(rowId, true));
+        }
+    }
+
+    private void acquireLock0(RowId rowId) {
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {
+            if (reentrantLockLockHolder == null) {
+                reentrantLockLockHolder = new LockHolder<>(new ReentrantLock());
+            }
+
+            reentrantLockLockHolder.incrementHolders();
+
+            return reentrantLockLockHolder;
+        });
+
+        lockHolder.getLock().lock();
+    }
+
+    private void releaseLock0(RowId rowId, boolean untilHoldByCurrentThread) {

Review Comment:
   Tried to rename.



;23/Feb/23 04:36;githubbot;600","tkalkirill commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115228932


##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowId.java:
##########
@@ -0,0 +1,175 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Supplier;
+import org.apache.ignite.internal.storage.RowId;
+
+/**
+ * {@link ReentrantLock} by row ID.
+ *
+ * <p>Allows synchronization of version chain update operations.
+ */
+public class ReentrantLockByRowId {
+    private final ThreadLocal<Object> lockedRowIds = new ThreadLocal<>();
+
+    private final ConcurrentMap<RowId, LockHolder<ReentrantLock>> lockHolderByRowId = new ConcurrentHashMap<>();
+
+    /**
+     * Executes the supplier under lock by row ID.
+     *
+     * @param <T> Return type.
+     * @param rowId Row ID.
+     * @param supplier Supplier to execute under the lock.
+     * @return Value.
+     */
+    public <T> T inLock(RowId rowId, Supplier<T> supplier) {
+        acquireLock0(rowId);
+
+        try {
+            return supplier.get();
+        } finally {
+            releaseLock0(rowId, false);
+        }
+    }
+
+    /**
+     * Acquires the lock by row ID.
+     *
+     * @param rowId Row ID.
+     */
+    public void acquireLock(RowId rowId) {
+        acquireLock0(rowId);
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        if (lockedRowIds == null) {
+            this.lockedRowIds.set(rowId);
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            if (!lockedRowId.equals(rowId)) {
+                Set<RowId> rowIds = new HashSet<>();
+
+                rowIds.add(lockedRowId);
+                rowIds.add(rowId);
+
+                this.lockedRowIds.set(rowIds);
+            }
+        } else {
+            ((Set<RowId>) lockedRowIds).add(rowId);
+        }
+    }
+
+    /**
+     * Releases the lock by row ID.
+     *
+     * @param rowId Row ID.
+     * @throws IllegalStateException If the lock could not be found by row ID.
+     * @throws IllegalMonitorStateException If the current thread does not hold this lock.
+     */
+    public void releaseLock(RowId rowId) {
+        releaseLock0(rowId, false);
+
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder != null && lockHolder.getLock().isHeldByCurrentThread()) {
+            return;
+        }
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        assert lockedRowIds != null : rowId;
+
+        if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            assert lockedRowId.equals(rowId) : ""rowId="" + rowId + "", lockedRowId="" + lockedRowId;
+
+            this.lockedRowIds.remove();
+        } else {
+            Set<RowId> rowIds = ((Set<RowId>) lockedRowIds);
+
+            boolean remove = rowIds.remove(rowId);
+
+            assert remove : ""rowId="" + rowId + "", lockedRowIds="" + rowIds;
+
+            if (rowIds.isEmpty()) {
+                this.lockedRowIds.remove();
+            }
+        }
+    }
+
+    /**
+     * Releases all locks {@link #acquireLock(RowId) acquired} by the current thread if exists.
+     *
+     * <p>Order of releasing the locks is not defined, each lock will be released with all re-entries.
+     */
+    public void releaseAllLockByCurrentThread() {
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        this.lockedRowIds.remove();
+
+        if (lockedRowIds == null) {
+            return;
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            releaseLock0(((RowId) lockedRowIds), true);
+        } else {
+            ((Set<RowId>) lockedRowIds).forEach(rowId -> releaseLock0(rowId, true));
+        }
+    }
+
+    private void acquireLock0(RowId rowId) {
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {
+            if (reentrantLockLockHolder == null) {
+                reentrantLockLockHolder = new LockHolder<>(new ReentrantLock());
+            }
+
+            reentrantLockLockHolder.incrementHolders();
+
+            return reentrantLockLockHolder;
+        });
+
+        lockHolder.getLock().lock();
+    }
+
+    private void releaseLock0(RowId rowId, boolean untilHoldByCurrentThread) {
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder == null) {
+            throw new IllegalStateException(""Could not find lock by row ID: "" + rowId);
+        }
+
+        ReentrantLock lock = lockHolder.getLock();
+
+        do {
+            lock.unlock();
+
+            lockHolderByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {
+                assert reentrantLockLockHolder != null;
+
+                return reentrantLockLockHolder.decrementHolders() ? null : reentrantLockLockHolder;
+            });
+        } while (untilHoldByCurrentThread && lock.getHoldCount() > 0);

Review Comment:
   I think that I delete holder when `LockHolder#decrementHolders` returned `true` i.e. no one else holds the lock.



;23/Feb/23 04:39;githubbot;600","tkalkirill commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115230829


##########
modules/storage-api/src/test/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowIdTest.java:
##########
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.runAsync;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willFailFast;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeoutException;
+import org.apache.ignite.internal.storage.RowId;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Class for testing {@link ReentrantLockByRowId}.
+ */
+public class ReentrantLockByRowIdTest {
+    @Test
+    void testSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.releaseLock(rowId);
+
+        assertEquals(1, lockByRowId.inLock(rowId, () -> 1));
+    }
+
+    @Test
+    void testSimpleReEnter() {

Review Comment:
   This is a simple test that checks that there are no errors when using the api.



;23/Feb/23 04:44;githubbot;600","tkalkirill commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115233226


##########
modules/storage-api/src/testFixtures/java/org/apache/ignite/internal/storage/AbstractMvPartitionStorageConcurrencyTest.java:
##########
@@ -193,19 +202,39 @@ void testConcurrentGc(AddAndCommit addAndCommit) {
         for (int i = 0; i < REPEATS; i++) {
             addAndCommit.perform(this, TABLE_ROW);
 
+            addAndCommit.perform(this, TABLE_ROW2);
+
             addAndCommit.perform(this, null);
 
+            Collection<byte[]> rows = toRowBytes(TABLE_ROW, TABLE_ROW2);
+
             runRace(
-                    () -> pollForVacuum(HybridTimestamp.MAX_VALUE),
-                    () -> pollForVacuum(HybridTimestamp.MAX_VALUE),
-                    () -> pollForVacuum(HybridTimestamp.MAX_VALUE),
-                    () -> pollForVacuum(HybridTimestamp.MAX_VALUE)
+                    () -> assertRemoveRow(pollForVacuum(HybridTimestamp.MAX_VALUE).binaryRow().bytes(), rows),
+                    () -> assertRemoveRow(pollForVacuum(HybridTimestamp.MAX_VALUE).binaryRow().bytes(), rows)
             );
 
+            assertNull(pollForVacuum(HybridTimestamp.MAX_VALUE));
+
             assertNull(storage.closestRowId(ROW_ID));
+
+            assertThat(rows, empty());
         }
     }
 
+    private void assertRemoveRow(byte[] rowBytes, Collection<byte[]> rows) {
+        assertNotNull(rowBytes);
+
+        byte[] found = rows.stream().filter(bytes -> Arrays.equals(bytes, rowBytes)).findFirst().orElseGet(null);

Review Comment:
   Fix it



;23/Feb/23 04:49;githubbot;600","tkalkirill commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115236486


##########
modules/storage-api/src/test/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowIdTest.java:
##########
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.runAsync;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willFailFast;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeoutException;
+import org.apache.ignite.internal.storage.RowId;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Class for testing {@link ReentrantLockByRowId}.
+ */
+public class ReentrantLockByRowIdTest {
+    @Test
+    void testSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.releaseLock(rowId);
+
+        assertEquals(1, lockByRowId.inLock(rowId, () -> 1));
+    }
+
+    @Test
+    void testSimpleReEnter() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.acquireLock(rowId);
+
+        lockByRowId.inLock(rowId, () -> {
+            lockByRowId.acquireLock(rowId);
+
+            lockByRowId.releaseLock(rowId);
+
+            return null;
+        });
+
+        lockByRowId.releaseLock(rowId);
+        lockByRowId.releaseLock(rowId);
+    }
+
+    @Test
+    void testReleaseError() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        assertThrows(IllegalStateException.class, () -> lockByRowId.releaseLock(new RowId(0)));
+
+        RowId rowId = new RowId(0);
+
+        assertThat(runAsync(() -> lockByRowId.acquireLock(rowId)), willCompleteSuccessfully());
+
+        assertThrows(IllegalMonitorStateException.class, () -> lockByRowId.releaseLock(rowId));
+    }
+
+    @Test
+    void testBlockSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.acquireLock(rowId);
+
+        CompletableFuture<?> acquireLockFuture = runAsync(() -> {
+            lockByRowId.acquireLock(rowId);
+            lockByRowId.releaseLock(rowId);
+        });
+
+        assertThat(acquireLockFuture, willFailFast(TimeoutException.class));
+
+        lockByRowId.releaseLock(rowId);
+
+        assertThat(acquireLockFuture, willFailFast(TimeoutException.class));
+
+        lockByRowId.releaseLock(rowId);
+
+        assertThat(acquireLockFuture, willCompleteSuccessfully());
+
+        lockByRowId.acquireLock(rowId);

Review Comment:
   > Why do you re-acquire the lock?
   Just to make sure we can acquire the lock again after another thread has used it.
   
   > Also, why don't you use try/finally blocks in your tests?
   I don’t think that it is necessary in these tests, they will only create unnecessary noise in the code.



##########
modules/storage-api/src/test/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowIdTest.java:
##########
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.runAsync;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willFailFast;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeoutException;
+import org.apache.ignite.internal.storage.RowId;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Class for testing {@link ReentrantLockByRowId}.
+ */
+public class ReentrantLockByRowIdTest {
+    @Test
+    void testSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.releaseLock(rowId);
+
+        assertEquals(1, lockByRowId.inLock(rowId, () -> 1));
+    }
+
+    @Test
+    void testSimpleReEnter() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.acquireLock(rowId);
+
+        lockByRowId.inLock(rowId, () -> {
+            lockByRowId.acquireLock(rowId);
+
+            lockByRowId.releaseLock(rowId);
+
+            return null;
+        });
+
+        lockByRowId.releaseLock(rowId);
+        lockByRowId.releaseLock(rowId);
+    }
+
+    @Test
+    void testReleaseError() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        assertThrows(IllegalStateException.class, () -> lockByRowId.releaseLock(new RowId(0)));
+
+        RowId rowId = new RowId(0);
+
+        assertThat(runAsync(() -> lockByRowId.acquireLock(rowId)), willCompleteSuccessfully());
+
+        assertThrows(IllegalMonitorStateException.class, () -> lockByRowId.releaseLock(rowId));
+    }
+
+    @Test
+    void testBlockSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.acquireLock(rowId);
+
+        CompletableFuture<?> acquireLockFuture = runAsync(() -> {
+            lockByRowId.acquireLock(rowId);
+            lockByRowId.releaseLock(rowId);
+        });
+
+        assertThat(acquireLockFuture, willFailFast(TimeoutException.class));
+
+        lockByRowId.releaseLock(rowId);
+
+        assertThat(acquireLockFuture, willFailFast(TimeoutException.class));
+
+        lockByRowId.releaseLock(rowId);
+
+        assertThat(acquireLockFuture, willCompleteSuccessfully());
+
+        lockByRowId.acquireLock(rowId);

Review Comment:
   > Why do you re-acquire the lock?
   
   Just to make sure we can acquire the lock again after another thread has used it.
   
   > Also, why don't you use try/finally blocks in your tests?
   
   I don’t think that it is necessary in these tests, they will only create unnecessary noise in the code.



;23/Feb/23 04:54;githubbot;600","tkalkirill commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115241233


##########
modules/storage-api/src/test/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowIdTest.java:
##########
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.runAsync;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willFailFast;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeoutException;
+import org.apache.ignite.internal.storage.RowId;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Class for testing {@link ReentrantLockByRowId}.
+ */
+public class ReentrantLockByRowIdTest {
+    @Test
+    void testSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.releaseLock(rowId);
+
+        assertEquals(1, lockByRowId.inLock(rowId, () -> 1));
+    }
+
+    @Test
+    void testSimpleReEnter() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.acquireLock(rowId);
+
+        lockByRowId.inLock(rowId, () -> {
+            lockByRowId.acquireLock(rowId);
+
+            lockByRowId.releaseLock(rowId);
+
+            return null;
+        });
+
+        lockByRowId.releaseLock(rowId);
+        lockByRowId.releaseLock(rowId);
+    }
+
+    @Test
+    void testReleaseError() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        assertThrows(IllegalStateException.class, () -> lockByRowId.releaseLock(new RowId(0)));
+
+        RowId rowId = new RowId(0);
+
+        assertThat(runAsync(() -> lockByRowId.acquireLock(rowId)), willCompleteSuccessfully());
+
+        assertThrows(IllegalMonitorStateException.class, () -> lockByRowId.releaseLock(rowId));
+    }
+
+    @Test
+    void testBlockSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.acquireLock(rowId);
+
+        CompletableFuture<?> acquireLockFuture = runAsync(() -> {
+            lockByRowId.acquireLock(rowId);
+            lockByRowId.releaseLock(rowId);
+        });
+
+        assertThat(acquireLockFuture, willFailFast(TimeoutException.class));
+
+        lockByRowId.releaseLock(rowId);
+
+        assertThat(acquireLockFuture, willFailFast(TimeoutException.class));

Review Comment:
   Tried to fix it



;23/Feb/23 05:04;githubbot;600","ibessonov commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115292041


##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowId.java:
##########
@@ -0,0 +1,175 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Supplier;
+import org.apache.ignite.internal.storage.RowId;
+
+/**
+ * {@link ReentrantLock} by row ID.
+ *
+ * <p>Allows synchronization of version chain update operations.
+ */
+public class ReentrantLockByRowId {
+    private final ThreadLocal<Object> lockedRowIds = new ThreadLocal<>();
+
+    private final ConcurrentMap<RowId, LockHolder<ReentrantLock>> lockHolderByRowId = new ConcurrentHashMap<>();
+
+    /**
+     * Executes the supplier under lock by row ID.
+     *
+     * @param <T> Return type.
+     * @param rowId Row ID.
+     * @param supplier Supplier to execute under the lock.
+     * @return Value.
+     */
+    public <T> T inLock(RowId rowId, Supplier<T> supplier) {
+        acquireLock0(rowId);
+
+        try {
+            return supplier.get();
+        } finally {
+            releaseLock0(rowId, false);
+        }
+    }
+
+    /**
+     * Acquires the lock by row ID.
+     *
+     * @param rowId Row ID.
+     */
+    public void acquireLock(RowId rowId) {
+        acquireLock0(rowId);
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        if (lockedRowIds == null) {
+            this.lockedRowIds.set(rowId);
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            if (!lockedRowId.equals(rowId)) {
+                Set<RowId> rowIds = new HashSet<>();
+
+                rowIds.add(lockedRowId);
+                rowIds.add(rowId);
+
+                this.lockedRowIds.set(rowIds);
+            }
+        } else {
+            ((Set<RowId>) lockedRowIds).add(rowId);
+        }
+    }
+
+    /**
+     * Releases the lock by row ID.
+     *
+     * @param rowId Row ID.
+     * @throws IllegalStateException If the lock could not be found by row ID.
+     * @throws IllegalMonitorStateException If the current thread does not hold this lock.
+     */
+    public void releaseLock(RowId rowId) {
+        releaseLock0(rowId, false);
+
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder != null && lockHolder.getLock().isHeldByCurrentThread()) {
+            return;
+        }
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        assert lockedRowIds != null : rowId;
+
+        if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            assert lockedRowId.equals(rowId) : ""rowId="" + rowId + "", lockedRowId="" + lockedRowId;
+
+            this.lockedRowIds.remove();
+        } else {
+            Set<RowId> rowIds = ((Set<RowId>) lockedRowIds);
+
+            boolean remove = rowIds.remove(rowId);
+
+            assert remove : ""rowId="" + rowId + "", lockedRowIds="" + rowIds;
+
+            if (rowIds.isEmpty()) {
+                this.lockedRowIds.remove();
+            }
+        }
+    }
+
+    /**
+     * Releases all locks {@link #acquireLock(RowId) acquired} by the current thread if exists.
+     *
+     * <p>Order of releasing the locks is not defined, each lock will be released with all re-entries.
+     */
+    public void releaseAllLockByCurrentThread() {
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        this.lockedRowIds.remove();
+
+        if (lockedRowIds == null) {
+            return;
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            releaseLock0(((RowId) lockedRowIds), true);
+        } else {
+            ((Set<RowId>) lockedRowIds).forEach(rowId -> releaseLock0(rowId, true));
+        }
+    }
+
+    private void acquireLock0(RowId rowId) {
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {
+            if (reentrantLockLockHolder == null) {
+                reentrantLockLockHolder = new LockHolder<>(new ReentrantLock());
+            }
+
+            reentrantLockLockHolder.incrementHolders();
+
+            return reentrantLockLockHolder;
+        });
+
+        lockHolder.getLock().lock();
+    }
+
+    private void releaseLock0(RowId rowId, boolean untilHoldByCurrentThread) {
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder == null) {
+            throw new IllegalStateException(""Could not find lock by row ID: "" + rowId);
+        }
+
+        ReentrantLock lock = lockHolder.getLock();
+
+        do {
+            lock.unlock();
+
+            lockHolderByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {
+                assert reentrantLockLockHolder != null;
+
+                return reentrantLockLockHolder.decrementHolders() ? null : reentrantLockLockHolder;
+            });
+        } while (untilHoldByCurrentThread && lock.getHoldCount() > 0);

Review Comment:
   I'm sorry, I made a mistake, I probably meant a thread-local set. You nullify it once somewhere later, right?



;23/Feb/23 06:50;githubbot;600","ibessonov commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115292900


##########
modules/storage-api/src/test/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowIdTest.java:
##########
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.runAsync;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willFailFast;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeoutException;
+import org.apache.ignite.internal.storage.RowId;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Class for testing {@link ReentrantLockByRowId}.
+ */
+public class ReentrantLockByRowIdTest {
+    @Test
+    void testSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.releaseLock(rowId);
+
+        assertEquals(1, lockByRowId.inLock(rowId, () -> 1));
+    }
+
+    @Test
+    void testSimpleReEnter() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.acquireLock(rowId);
+
+        lockByRowId.inLock(rowId, () -> {
+            lockByRowId.acquireLock(rowId);
+
+            lockByRowId.releaseLock(rowId);
+
+            return null;
+        });
+
+        lockByRowId.releaseLock(rowId);
+        lockByRowId.releaseLock(rowId);
+    }
+
+    @Test
+    void testReleaseError() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        assertThrows(IllegalStateException.class, () -> lockByRowId.releaseLock(new RowId(0)));
+
+        RowId rowId = new RowId(0);
+
+        assertThat(runAsync(() -> lockByRowId.acquireLock(rowId)), willCompleteSuccessfully());
+
+        assertThrows(IllegalMonitorStateException.class, () -> lockByRowId.releaseLock(rowId));
+    }
+
+    @Test
+    void testBlockSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.acquireLock(rowId);
+
+        CompletableFuture<?> acquireLockFuture = runAsync(() -> {
+            lockByRowId.acquireLock(rowId);
+            lockByRowId.releaseLock(rowId);
+        });
+
+        assertThat(acquireLockFuture, willFailFast(TimeoutException.class));
+
+        lockByRowId.releaseLock(rowId);
+
+        assertThat(acquireLockFuture, willFailFast(TimeoutException.class));
+
+        lockByRowId.releaseLock(rowId);
+
+        assertThat(acquireLockFuture, willCompleteSuccessfully());
+
+        lockByRowId.acquireLock(rowId);

Review Comment:
   I don't feel comfortable when there are unreleased locks in general. Can you please fix it? At least call that ""release everything"" method in ""afterEach""



;23/Feb/23 06:52;githubbot;600","ibessonov commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115293039


##########
modules/core/src/testFixtures/java/org/apache/ignite/internal/testframework/matchers/CompletableFutureMatcher.java:
##########
@@ -174,6 +174,26 @@ public static CompletableFutureMatcher<Object> willFailIn(int time, TimeUnit tim
         return new CompletableFutureMatcher<>(anything(), time, timeUnit, cause);
     }
 
+    /**
+     * Creates a matcher that matches a future that <strong>not</strong> completes decently fast.
+     *
+     * @return matcher.
+     */
+    public static CompletableFutureMatcher<Object> willTimeoutFast() {
+        return willTimeoutIn(1, TimeUnit.SECONDS);

Review Comment:
   1 second is ""fast""?



;23/Feb/23 06:52;githubbot;600","tkalkirill commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115294613


##########
modules/core/src/testFixtures/java/org/apache/ignite/internal/testframework/matchers/CompletableFutureMatcher.java:
##########
@@ -174,6 +174,26 @@ public static CompletableFutureMatcher<Object> willFailIn(int time, TimeUnit tim
         return new CompletableFutureMatcher<>(anything(), time, timeUnit, cause);
     }
 
+    /**
+     * Creates a matcher that matches a future that <strong>not</strong> completes decently fast.
+     *
+     * @return matcher.
+     */
+    public static CompletableFutureMatcher<Object> willTimeoutFast() {
+        return willTimeoutIn(1, TimeUnit.SECONDS);

Review Comment:
   I can do a quarter/half of a second, for example, for the win os, less than 200 ms may not be enough.



;23/Feb/23 06:56;githubbot;600","tkalkirill commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115297423


##########
modules/storage-api/src/test/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowIdTest.java:
##########
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.runAsync;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willFailFast;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeoutException;
+import org.apache.ignite.internal.storage.RowId;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Class for testing {@link ReentrantLockByRowId}.
+ */
+public class ReentrantLockByRowIdTest {
+    @Test
+    void testSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.releaseLock(rowId);
+
+        assertEquals(1, lockByRowId.inLock(rowId, () -> 1));
+    }
+
+    @Test
+    void testSimpleReEnter() {

Review Comment:
   I do it outside the method.



;23/Feb/23 07:01;githubbot;600","tkalkirill commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115301569


##########
modules/core/src/testFixtures/java/org/apache/ignite/internal/testframework/matchers/CompletableFutureMatcher.java:
##########
@@ -174,6 +174,26 @@ public static CompletableFutureMatcher<Object> willFailIn(int time, TimeUnit tim
         return new CompletableFutureMatcher<>(anything(), time, timeUnit, cause);
     }
 
+    /**
+     * Creates a matcher that matches a future that <strong>not</strong> completes decently fast.
+     *
+     * @return matcher.
+     */
+    public static CompletableFutureMatcher<Object> willTimeoutFast() {
+        return willTimeoutIn(1, TimeUnit.SECONDS);

Review Comment:
   set 250 ms



;23/Feb/23 07:08;githubbot;600","tkalkirill commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115301742


##########
modules/storage-api/src/test/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowIdTest.java:
##########
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.runAsync;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willFailFast;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeoutException;
+import org.apache.ignite.internal.storage.RowId;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Class for testing {@link ReentrantLockByRowId}.
+ */
+public class ReentrantLockByRowIdTest {
+    @Test
+    void testSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.releaseLock(rowId);
+
+        assertEquals(1, lockByRowId.inLock(rowId, () -> 1));
+    }
+
+    @Test
+    void testSimpleReEnter() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.acquireLock(rowId);
+
+        lockByRowId.inLock(rowId, () -> {
+            lockByRowId.acquireLock(rowId);
+
+            lockByRowId.releaseLock(rowId);
+
+            return null;
+        });
+
+        lockByRowId.releaseLock(rowId);
+        lockByRowId.releaseLock(rowId);
+    }
+
+    @Test
+    void testReleaseError() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        assertThrows(IllegalStateException.class, () -> lockByRowId.releaseLock(new RowId(0)));
+
+        RowId rowId = new RowId(0);
+
+        assertThat(runAsync(() -> lockByRowId.acquireLock(rowId)), willCompleteSuccessfully());
+
+        assertThrows(IllegalMonitorStateException.class, () -> lockByRowId.releaseLock(rowId));
+    }
+
+    @Test
+    void testBlockSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.acquireLock(rowId);
+
+        CompletableFuture<?> acquireLockFuture = runAsync(() -> {
+            lockByRowId.acquireLock(rowId);
+            lockByRowId.releaseLock(rowId);
+        });
+
+        assertThat(acquireLockFuture, willFailFast(TimeoutException.class));
+
+        lockByRowId.releaseLock(rowId);
+
+        assertThat(acquireLockFuture, willFailFast(TimeoutException.class));
+
+        lockByRowId.releaseLock(rowId);
+
+        assertThat(acquireLockFuture, willCompleteSuccessfully());
+
+        lockByRowId.acquireLock(rowId);

Review Comment:
   Try to fix it



;23/Feb/23 07:08;githubbot;600","tkalkirill commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115297423


##########
modules/storage-api/src/test/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowIdTest.java:
##########
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import static org.apache.ignite.internal.testframework.IgniteTestUtils.runAsync;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willCompleteSuccessfully;
+import static org.apache.ignite.internal.testframework.matchers.CompletableFutureMatcher.willFailFast;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeoutException;
+import org.apache.ignite.internal.storage.RowId;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Class for testing {@link ReentrantLockByRowId}.
+ */
+public class ReentrantLockByRowIdTest {
+    @Test
+    void testSimple() {
+        ReentrantLockByRowId lockByRowId = new ReentrantLockByRowId();
+
+        RowId rowId = new RowId(0);
+
+        lockByRowId.acquireLock(rowId);
+        lockByRowId.releaseLock(rowId);
+
+        assertEquals(1, lockByRowId.inLock(rowId, () -> 1));
+    }
+
+    @Test
+    void testSimpleReEnter() {

Review Comment:
   I do it outside the method.



##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowId.java:
##########
@@ -0,0 +1,175 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Supplier;
+import org.apache.ignite.internal.storage.RowId;
+
+/**
+ * {@link ReentrantLock} by row ID.
+ *
+ * <p>Allows synchronization of version chain update operations.
+ */
+public class ReentrantLockByRowId {
+    private final ThreadLocal<Object> lockedRowIds = new ThreadLocal<>();
+
+    private final ConcurrentMap<RowId, LockHolder<ReentrantLock>> lockHolderByRowId = new ConcurrentHashMap<>();
+
+    /**
+     * Executes the supplier under lock by row ID.
+     *
+     * @param <T> Return type.
+     * @param rowId Row ID.
+     * @param supplier Supplier to execute under the lock.
+     * @return Value.
+     */
+    public <T> T inLock(RowId rowId, Supplier<T> supplier) {
+        acquireLock0(rowId);
+
+        try {
+            return supplier.get();
+        } finally {
+            releaseLock0(rowId, false);
+        }
+    }
+
+    /**
+     * Acquires the lock by row ID.
+     *
+     * @param rowId Row ID.
+     */
+    public void acquireLock(RowId rowId) {
+        acquireLock0(rowId);
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        if (lockedRowIds == null) {
+            this.lockedRowIds.set(rowId);
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            if (!lockedRowId.equals(rowId)) {
+                Set<RowId> rowIds = new HashSet<>();
+
+                rowIds.add(lockedRowId);
+                rowIds.add(rowId);
+
+                this.lockedRowIds.set(rowIds);
+            }
+        } else {
+            ((Set<RowId>) lockedRowIds).add(rowId);
+        }
+    }
+
+    /**
+     * Releases the lock by row ID.
+     *
+     * @param rowId Row ID.
+     * @throws IllegalStateException If the lock could not be found by row ID.
+     * @throws IllegalMonitorStateException If the current thread does not hold this lock.
+     */
+    public void releaseLock(RowId rowId) {
+        releaseLock0(rowId, false);
+
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder != null && lockHolder.getLock().isHeldByCurrentThread()) {
+            return;
+        }
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        assert lockedRowIds != null : rowId;
+
+        if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            assert lockedRowId.equals(rowId) : ""rowId="" + rowId + "", lockedRowId="" + lockedRowId;
+
+            this.lockedRowIds.remove();
+        } else {
+            Set<RowId> rowIds = ((Set<RowId>) lockedRowIds);
+
+            boolean remove = rowIds.remove(rowId);
+
+            assert remove : ""rowId="" + rowId + "", lockedRowIds="" + rowIds;
+
+            if (rowIds.isEmpty()) {
+                this.lockedRowIds.remove();
+            }
+        }
+    }
+
+    /**
+     * Releases all locks {@link #acquireLock(RowId) acquired} by the current thread if exists.
+     *
+     * <p>Order of releasing the locks is not defined, each lock will be released with all re-entries.
+     */
+    public void releaseAllLockByCurrentThread() {
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        this.lockedRowIds.remove();
+
+        if (lockedRowIds == null) {
+            return;
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            releaseLock0(((RowId) lockedRowIds), true);
+        } else {
+            ((Set<RowId>) lockedRowIds).forEach(rowId -> releaseLock0(rowId, true));
+        }
+    }
+
+    private void acquireLock0(RowId rowId) {
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {
+            if (reentrantLockLockHolder == null) {
+                reentrantLockLockHolder = new LockHolder<>(new ReentrantLock());
+            }
+
+            reentrantLockLockHolder.incrementHolders();
+
+            return reentrantLockLockHolder;
+        });
+
+        lockHolder.getLock().lock();
+    }
+
+    private void releaseLock0(RowId rowId, boolean untilHoldByCurrentThread) {
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder == null) {
+            throw new IllegalStateException(""Could not find lock by row ID: "" + rowId);
+        }
+
+        ReentrantLock lock = lockHolder.getLock();
+
+        do {
+            lock.unlock();
+
+            lockHolderByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {
+                assert reentrantLockLockHolder != null;
+
+                return reentrantLockLockHolder.decrementHolders() ? null : reentrantLockLockHolder;
+            });
+        } while (untilHoldByCurrentThread && lock.getHoldCount() > 0);

Review Comment:
   I do it outside the method.



;23/Feb/23 07:09;githubbot;600","tkalkirill commented on code in PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697#discussion_r1115302180


##########
modules/storage-api/src/main/java/org/apache/ignite/internal/storage/util/ReentrantLockByRowId.java:
##########
@@ -0,0 +1,175 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.util;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Supplier;
+import org.apache.ignite.internal.storage.RowId;
+
+/**
+ * {@link ReentrantLock} by row ID.
+ *
+ * <p>Allows synchronization of version chain update operations.
+ */
+public class ReentrantLockByRowId {
+    private final ThreadLocal<Object> lockedRowIds = new ThreadLocal<>();
+
+    private final ConcurrentMap<RowId, LockHolder<ReentrantLock>> lockHolderByRowId = new ConcurrentHashMap<>();
+
+    /**
+     * Executes the supplier under lock by row ID.
+     *
+     * @param <T> Return type.
+     * @param rowId Row ID.
+     * @param supplier Supplier to execute under the lock.
+     * @return Value.
+     */
+    public <T> T inLock(RowId rowId, Supplier<T> supplier) {
+        acquireLock0(rowId);
+
+        try {
+            return supplier.get();
+        } finally {
+            releaseLock0(rowId, false);
+        }
+    }
+
+    /**
+     * Acquires the lock by row ID.
+     *
+     * @param rowId Row ID.
+     */
+    public void acquireLock(RowId rowId) {
+        acquireLock0(rowId);
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        if (lockedRowIds == null) {
+            this.lockedRowIds.set(rowId);
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            if (!lockedRowId.equals(rowId)) {
+                Set<RowId> rowIds = new HashSet<>();
+
+                rowIds.add(lockedRowId);
+                rowIds.add(rowId);
+
+                this.lockedRowIds.set(rowIds);
+            }
+        } else {
+            ((Set<RowId>) lockedRowIds).add(rowId);
+        }
+    }
+
+    /**
+     * Releases the lock by row ID.
+     *
+     * @param rowId Row ID.
+     * @throws IllegalStateException If the lock could not be found by row ID.
+     * @throws IllegalMonitorStateException If the current thread does not hold this lock.
+     */
+    public void releaseLock(RowId rowId) {
+        releaseLock0(rowId, false);
+
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder != null && lockHolder.getLock().isHeldByCurrentThread()) {
+            return;
+        }
+
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        assert lockedRowIds != null : rowId;
+
+        if (lockedRowIds.getClass() == RowId.class) {
+            RowId lockedRowId = (RowId) lockedRowIds;
+
+            assert lockedRowId.equals(rowId) : ""rowId="" + rowId + "", lockedRowId="" + lockedRowId;
+
+            this.lockedRowIds.remove();
+        } else {
+            Set<RowId> rowIds = ((Set<RowId>) lockedRowIds);
+
+            boolean remove = rowIds.remove(rowId);
+
+            assert remove : ""rowId="" + rowId + "", lockedRowIds="" + rowIds;
+
+            if (rowIds.isEmpty()) {
+                this.lockedRowIds.remove();
+            }
+        }
+    }
+
+    /**
+     * Releases all locks {@link #acquireLock(RowId) acquired} by the current thread if exists.
+     *
+     * <p>Order of releasing the locks is not defined, each lock will be released with all re-entries.
+     */
+    public void releaseAllLockByCurrentThread() {
+        Object lockedRowIds = this.lockedRowIds.get();
+
+        this.lockedRowIds.remove();
+
+        if (lockedRowIds == null) {
+            return;
+        } else if (lockedRowIds.getClass() == RowId.class) {
+            releaseLock0(((RowId) lockedRowIds), true);
+        } else {
+            ((Set<RowId>) lockedRowIds).forEach(rowId -> releaseLock0(rowId, true));
+        }
+    }
+
+    private void acquireLock0(RowId rowId) {
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {
+            if (reentrantLockLockHolder == null) {
+                reentrantLockLockHolder = new LockHolder<>(new ReentrantLock());
+            }
+
+            reentrantLockLockHolder.incrementHolders();
+
+            return reentrantLockLockHolder;
+        });
+
+        lockHolder.getLock().lock();
+    }
+
+    private void releaseLock0(RowId rowId, boolean untilHoldByCurrentThread) {
+        LockHolder<ReentrantLock> lockHolder = lockHolderByRowId.get(rowId);
+
+        if (lockHolder == null) {
+            throw new IllegalStateException(""Could not find lock by row ID: "" + rowId);
+        }
+
+        ReentrantLock lock = lockHolder.getLock();
+
+        do {
+            lock.unlock();
+
+            lockHolderByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {
+                assert reentrantLockLockHolder != null;
+
+                return reentrantLockLockHolder.decrementHolders() ? null : reentrantLockLockHolder;
+            });
+        } while (untilHoldByCurrentThread && lock.getHoldCount() > 0);

Review Comment:
   I do it outside this private method.



;23/Feb/23 07:13;githubbot;600","tkalkirill merged PR #1697:
URL: https://github.com/apache/ignite-3/pull/1697


;23/Feb/23 07:40;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,0,12600,,,0,12600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17571,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-02-20 06:24:02.0,,,,,,,,,,"0|z1g1o0:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
Get rid of skipping safe time waiting on a primary node,IGNITE-18835,13525212,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,v.pyatkov,maliev,maliev,17/Feb/23 13:30,11/May/23 15:22,13/Jul/23 09:11,07/Mar/23 17:13,,,,,,,,,,,,0,ignite-3,,,"Currently, we have a logic of skipping safe time waiting on a primary node in {{PartitionReplicaListener}} for read-only transaction, for example in {{PartitionReplicaListener#processReadOnlySingleEntryAction}}


{code:java}
        CompletableFuture<Void> safeReadFuture = isPrimary ? completedFuture(null) : safeTime.waitFor(request.readTimestamp());

        return safeReadFuture.thenCompose(unused -> resolveRowByPkForReadOnly(searchRow, readTimestamp));
{code}

This is a wrong behaviour, we expect that this awaiting must be done on a primary node as well",,maliev,v.pyatkov,,,,"sanpwc commented on code in PR #1688:
URL: https://github.com/apache/ignite-3/pull/1688#discussion_r1127501400


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItRaftCommandLeftInLogUntilRestartTest.java:
##########
@@ -175,9 +174,9 @@ private void restartClusterWithNotAppliedCommands(
         BinaryRowEx key = new TupleMarshallerImpl(table.schemaView()).marshal(Tuple.create().set(""id"", 42));
 
         if (isNode0Leader) {
-            assertNull(table.internalTable().get(key, new HybridClockImpl().now(), node1.node()).get());
+            assertNull(table.internalTable().get(key, node1.clock().now(), node1.node()).get());
         } else {
-            assertNull(table.internalTable().get(key, new HybridClockImpl().now(), node0.node()).get());
+            assertNull(table.internalTable().get(key, node1.clock().now(), node0.node()).get());

Review Comment:
   Should we use node0.clock().now() here or using node1 is fine?



;07/Mar/23 08:16;githubbot;600","sanpwc commented on code in PR #1688:
URL: https://github.com/apache/ignite-3/pull/1688#discussion_r1127508369


##########
modules/runner/src/main/java/org/apache/ignite/internal/app/IgniteImpl.java:
##########
@@ -944,4 +944,14 @@ public BiPredicate<String, NetworkMessage> dropMessagesPredicate() {
     public void stopDroppingMessages() {
         ((DefaultMessagingService) clusterSvc.messagingService()).stopDroppingMessages();
     }
+
+    /**
+     * Gets a hybrid clock specific of the node.

Review Comment:
   ""specif of the node"", sounds a bit unnatural from my point of view.
   I'd rather use ""Returns the node's hybrid clock."" or similar.



;07/Mar/23 08:23;githubbot;600","vldpyatkov commented on code in PR #1688:
URL: https://github.com/apache/ignite-3/pull/1688#discussion_r1127923345


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/runner/app/ItRaftCommandLeftInLogUntilRestartTest.java:
##########
@@ -175,9 +174,9 @@ private void restartClusterWithNotAppliedCommands(
         BinaryRowEx key = new TupleMarshallerImpl(table.schemaView()).marshal(Tuple.create().set(""id"", 42));
 
         if (isNode0Leader) {
-            assertNull(table.internalTable().get(key, new HybridClockImpl().now(), node1.node()).get());
+            assertNull(table.internalTable().get(key, node1.clock().now(), node1.node()).get());
         } else {
-            assertNull(table.internalTable().get(key, new HybridClockImpl().now(), node0.node()).get());
+            assertNull(table.internalTable().get(key, node1.clock().now(), node0.node()).get());

Review Comment:
   Here it has no difference.
   The only thing that matters is that the data was applied finally.



;07/Mar/23 14:11;githubbot;600","alievmirza commented on code in PR #1688:
URL: https://github.com/apache/ignite-3/pull/1688#discussion_r1127963680


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/replicator/PartitionReplicaListener.java:
##########
@@ -486,11 +487,23 @@ private CompletableFuture<BinaryRow> processReadOnlySingleEntryAction(ReadOnlySi
                     format(""Unknown single request [actionType={}]"", request.requestType()));
         }
 
-        CompletableFuture<Void> safeReadFuture = isPrimary ? completedFuture(null) : safeTime.waitFor(request.readTimestamp());
+        CompletableFuture<Void> safeReadFuture = isPrimaryInTimestamp(isPrimary, readTimestamp) ? completedFuture(null)
+                : safeTime.waitFor(request.readTimestamp());
 
         return safeReadFuture.thenCompose(unused -> resolveRowByPkForReadOnly(searchRow, readTimestamp));
     }
 
+    /**
+     * Checks that the node is primary in a passed timestamp.
+     *
+     * @param isPrimary True is the node is primary, false otherwise.
+     * @param timestamp Timestamp to check.
+     * @return True if the timestamp is already come and node in primary, otherwise false.

Review Comment:
   ```suggestion
        * @return True if the timestamp is already passed in the reference system of the current node and node is primary, false otherwise.
   ```



##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/replicator/PartitionReplicaListener.java:
##########
@@ -486,11 +487,23 @@ private CompletableFuture<BinaryRow> processReadOnlySingleEntryAction(ReadOnlySi
                     format(""Unknown single request [actionType={}]"", request.requestType()));
         }
 
-        CompletableFuture<Void> safeReadFuture = isPrimary ? completedFuture(null) : safeTime.waitFor(request.readTimestamp());
+        CompletableFuture<Void> safeReadFuture = isPrimaryInTimestamp(isPrimary, readTimestamp) ? completedFuture(null)
+                : safeTime.waitFor(request.readTimestamp());
 
         return safeReadFuture.thenCompose(unused -> resolveRowByPkForReadOnly(searchRow, readTimestamp));
     }
 
+    /**
+     * Checks that the node is primary in a passed timestamp.
+     *
+     * @param isPrimary True is the node is primary, false otherwise.

Review Comment:
   ```suggestion
        * @param isPrimary True if the node is primary, false otherwise.
   ```



##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/replicator/PartitionReplicaListener.java:
##########
@@ -486,11 +487,23 @@ private CompletableFuture<BinaryRow> processReadOnlySingleEntryAction(ReadOnlySi
                     format(""Unknown single request [actionType={}]"", request.requestType()));
         }
 
-        CompletableFuture<Void> safeReadFuture = isPrimary ? completedFuture(null) : safeTime.waitFor(request.readTimestamp());
+        CompletableFuture<Void> safeReadFuture = isPrimaryInTimestamp(isPrimary, readTimestamp) ? completedFuture(null)
+                : safeTime.waitFor(request.readTimestamp());
 
         return safeReadFuture.thenCompose(unused -> resolveRowByPkForReadOnly(searchRow, readTimestamp));
     }
 
+    /**
+     * Checks that the node is primary in a passed timestamp.

Review Comment:
   ```suggestion
        * Checks that the node is primary and {@code timestamp} is already passed in the reference system of the current node.
   ```



;07/Mar/23 14:38;githubbot;600","vldpyatkov merged PR #1688:
URL: https://github.com/apache/ignite-3/pull/1688


;07/Mar/23 17:12;githubbot;600","alievmirza closed pull request #1740: IGNITE-18835 Get rid of skipping safe time waiting on a primary node.
URL: https://github.com/apache/ignite-3/pull/1740


;11/May/23 15:22;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3600,,,0,3600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Mar 07 17:13:38 UTC 2023,,,,,,,,,,"0|z1g0og:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"07/Mar/23 14:50;maliev;[~v.pyatkov] LGTM;;;","07/Mar/23 17:13;v.pyatkov;Merged cd7d97990125cb02b2401c6140ea98da3ca646e4;;;",,,,
Java thin client hangs on close,IGNITE-18826,13525032,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,NSAmelchev,NSAmelchev,NSAmelchev,16/Feb/23 14:26,21/Feb/23 12:25,13/Jul/23 09:11,20/Feb/23 10:51,,,,,,,,2.15,,,,0,ise,,,"There are several places where thin client threads can hang:

GridNioClientConnectionMultiplexer: SSL enabled + PA enabled
{noformat}
// Can return finished future with error -> sslHandshakeFut will not complete.
GridNioFuture<GridNioSession> sesFut = srv.createSession(ch, meta, false, null);

 if (sslHandshakeFut != null)
      sslHandshakeFut.get();
{noformat}

TcpClientChannel: PA enabled
{noformat}
ClientRequestFuture fut = new ClientRequestFuture(requestId, ClientOperation.HANDSHAKE);

 // TcpClientChannel may be closed and fut will not complete.
assert !closed.get();

pendingReqs.put(requestId, fut);
...
ByteBuffer buf = timeout > 0 ? fut.get(timeout) : fut.get();
{noformat}
",,ignitetcbot,NSAmelchev,ptupitsyn,,,"NSAmelchev opened a new pull request, #10549:
URL: https://github.com/apache/ignite/pull/10549

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;17/Feb/23 13:55;githubbot;600","NSAmelchev merged PR #10549:
URL: https://github.com/apache/ignite/pull/10549


;20/Feb/23 10:50;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-18591,IGNITE-14789,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Mon Feb 20 10:51:24 UTC 2023,,,,,,,,,,"0|z1fzkg:",9223372036854775807,Java thin client: fixed the pending requests race on close,,,,,,,,,,,,,,,,,,,,"17/Feb/23 22:14;ignitetcbot;{panel:title=Branch: [pull/10549/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10549/head] Base: [master] : New Tests (2)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Thin Client: Java{color} [[tests 2|https://ci2.ignite.apache.org/viewLog.html?buildId=7054497]]
* {color:#013220}ClientTestSuite: ThinClientPartitionAwarenessUnstableTopologyTest.testSessionCloseBeforeHandshake - PASSED{color}
* {color:#013220}ClientTestSuite: ThinClientPartitionAwarenessUnstableTopologyTest.testCreateSessionAfterClose - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7054511&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","20/Feb/23 10:51;NSAmelchev;Merged into the master.

[~ivandasch], Thank you for the review.;;;",,,,
C++ 3.0: Transaction should be rolled back synchronously on destruction,IGNITE-18815,13524922,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,isapego,isapego,isapego,15/Feb/23 23:02,16/Feb/23 06:59,13/Jul/23 09:11,16/Feb/23 06:59,3.0.0-beta1,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Currently, {{transaction_impl}} is rolled back asynchronously on destruction. This can result in locking conflicts looking like this:
{noformat}
Failed to acquire a lock due to a conflict [txId=000f7d63-d563-0000-0242-ac78000a0000, conflictingWaiter=WaiterImpl [txId=000f7d63-d55b-0000-0242-ac78000a0000, intendedLockMode=null, lockMode=X, ex=null, isDone=true]
{noformat}
Transaction should be rolled back synchronously on destruction.

Test is to be un-muted when the issue is fixed: https://ci.ignite.apache.org/test/-3102268643379533778?currentProjectId=ApacheIgnite3xGradle_Test",,isapego,ptupitsyn,,,,"isapego opened a new pull request, #1683:
URL: https://github.com/apache/ignite-3/pull/1683

   Transactions now rolled back synchronously on destruction.
   No new tests as existing tests cover this case.


;15/Feb/23 23:17;githubbot;600","isapego merged PR #1683:
URL: https://github.com/apache/ignite-3/pull/1683


;16/Feb/23 06:59;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Feb 16 06:59:58 UTC 2023,,,,,,,,,,"0|z1fyw0:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"15/Feb/23 23:17;isapego;[~ptupitsyn] please review.;;;","16/Feb/23 06:41;ptupitsyn;[~isapego] looks good to me.;;;","16/Feb/23 06:59;isapego;Merged to main;;;",,,
Fix ItTxDistributedTestSingleNode#assertPartitionsSame,IGNITE-18814,13524855,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,v.pyatkov,ibessonov,ibessonov,15/Feb/23 13:45,13/Jun/23 11:36,13/Jul/23 09:11,22/Feb/23 14:28,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"*Motivation*
{code:java}
MvPartitionStorage storage = listener.getMvStorage();

if (hash == 0) {
    hash = storage.hashCode();
} else if (hash != storage.hashCode()) {
    return false;
}{code}
This code is wrong, hash code is not defined for storage.
*Implementation notes*
To summarize all the mentioned before, the main issue is finding a way to compare data stored in different replicas.
The obvious approach to calculate hash all object that stored in each replica storage. But the implementation can be difficult and time expensive in the test.
The easy way to compare stored indexies ( _MvPartitionStorage#lastAppliedIndex_ , _MvPartitionStorage#persistedIndex_). The both are applicable for comparison, but _persistedIndex_ upgrades latter.
{code}
MvPartitionStorage storage = listener.getMvStorage();

if (idx == 0) {
    idx = storage.persistedIndex();
} else if (idx != storage.persistedIndex()) {
    return false;
}
{code}",,ibessonov,v.pyatkov,,,,"alievmirza commented on code in PR #1689:
URL: https://github.com/apache/ignite-3/pull/1689#discussion_r1113964161


##########
modules/table/src/integrationTest/java/org/apache/ignite/distributed/ItTxDistributedTestSingleNode.java:
##########
@@ -635,9 +643,9 @@ protected boolean assertPartitionsSame(TableImpl table, int partId) {
 
             MvPartitionStorage storage = listener.getMvStorage();
 
-            if (hash == 0) {
-                hash = storage.hashCode();
-            } else if (hash != storage.hashCode()) {
+            if (storageIdx == 0) {

Review Comment:
   Please add todo here that we need to change the way how we compare partitions after consistency checker feature will be implemented https://issues.apache.org/jira/browse/IGNITE-18869



;22/Feb/23 08:09;githubbot;600","alievmirza commented on code in PR #1689:
URL: https://github.com/apache/ignite-3/pull/1689#discussion_r1113964161


##########
modules/table/src/integrationTest/java/org/apache/ignite/distributed/ItTxDistributedTestSingleNode.java:
##########
@@ -635,9 +643,9 @@ protected boolean assertPartitionsSame(TableImpl table, int partId) {
 
             MvPartitionStorage storage = listener.getMvStorage();
 
-            if (hash == 0) {
-                hash = storage.hashCode();
-            } else if (hash != storage.hashCode()) {
+            if (storageIdx == 0) {

Review Comment:
   Please add todo here that we need to change the way how we compare partitions after consistency checker feature will be implemented https://issues.apache.org/jira/browse/IGNITE-18869
   And please, add comment to the epic that we have this todo, so we couldn't forget to fix this place 



;22/Feb/23 08:09;githubbot;600","vldpyatkov commented on code in PR #1689:
URL: https://github.com/apache/ignite-3/pull/1689#discussion_r1114251258


##########
modules/table/src/integrationTest/java/org/apache/ignite/distributed/ItTxDistributedTestSingleNode.java:
##########
@@ -635,9 +643,9 @@ protected boolean assertPartitionsSame(TableImpl table, int partId) {
 
             MvPartitionStorage storage = listener.getMvStorage();
 
-            if (hash == 0) {
-                hash = storage.hashCode();
-            } else if (hash != storage.hashCode()) {
+            if (storageIdx == 0) {

Review Comment:
   I added the todo in a summary of the method.



;22/Feb/23 12:23;githubbot;600","alievmirza commented on code in PR #1689:
URL: https://github.com/apache/ignite-3/pull/1689#discussion_r1114300003


##########
modules/table/src/integrationTest/java/org/apache/ignite/distributed/ItTxDistributedTestSingleNode.java:
##########
@@ -613,10 +613,18 @@ protected TxManager txManager(Table t) {
         return manager;
     }
 
-    /** {@inheritDoc} */
+    /**
+     * Check the storage of partition is the same across all nodes.
+     * The checking is based on {@link MvPartitionStorage#lastAppliedIndex()} that is increased on all update storage operation.
+     * TODO: IGNITE-18869 The method is required to update when a procedure is based on comparison of all storage entries will appear.

Review Comment:
   ```suggestion
        * TODO: IGNITE-18869 The method must be updated when a proper way to compare storages will be implemented.
   ```



;22/Feb/23 13:10;githubbot;600","vldpyatkov merged PR #1689:
URL: https://github.com/apache/ignite-3/pull/1689


;22/Feb/23 14:28;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-18813,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Feb 22 14:28:38 UTC 2023,,,,,,,,,,"0|z1fyh4:",9223372036854775807,,,maliev,,,,,,,,,,,,,,,,,,"22/Feb/23 14:28;v.pyatkov;Merged de1ee322a7c86ba087a81962bf95f68e6783c9db;;;",,,,,
Fix compilation error of ignite-hibernate-ext,IGNITE-18803,13524686,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,aonikolaev,shishkovilja,shishkovilja,14/Feb/23 15:16,15/Feb/23 09:15,13/Jul/23 09:11,15/Feb/23 09:15,,,,,,,,,extensions,,,0,ise,newbie,,"Build fails because {{CacheMetricsMXBean}} was deleted from Apache Ignite:
{noformat}
/opt/buildagent/work/9319dd66c384518/modules/hibernate-ext/hibernate/src/main/java/org/apache/ignite/cache/hibernate/HibernateCacheProxy.java:[44,32] cannot find symbol
  symbol:   class CacheMetricsMXBean
  location: package org.apache.ignite.mxbean
/opt/buildagent/work/9319dd66c384518/modules/hibernate-ext/hibernate/src/main/java/org/apache/ignite/cache/hibernate/HibernateCacheProxy.java:[549,22] cannot find symbol
  symbol:   class CacheMetricsMXBean
  location: class org.apache.ignite.cache.hibernate.HibernateCacheProxy
/opt/buildagent/work/9319dd66c384518/modules/hibernate-ext/hibernate/src/main/java/org/apache/ignite/cache/hibernate/HibernateCacheProxy.java:[554,22] cannot find symbol
  symbol:   class CacheMetricsMXBean
  location: class org.apache.ignite.cache.hibernate.HibernateCacheProxy
/opt/buildagent/work/9319dd66c384518/modules/hibernate-ext/hibernate/src/main/java/org/apache/ignite/cache/hibernate/HibernateCacheProxy.java:[549,5] method does not override or implement a method from a supertype
/opt/buildagent/work/9319dd66c384518/modules/hibernate-ext/hibernate/src/main/java/org/apache/ignite/cache/hibernate/HibernateCacheProxy.java:[550,30] cannot find symbol
  symbol:   method clusterMxBean()
  location: interface org.apache.ignite.internal.processors.cache.IgniteInternalCache<java.lang.Object,java.lang.Object>
/opt/buildagent/work/9319dd66c384518/modules/hibernate-ext/hibernate/src/main/java/org/apache/ignite/cache/hibernate/HibernateCacheProxy.java:[554,5] method does not override or implement a method from a supertype
/opt/buildagent/work/9319dd66c384518/modules/hibernate-ext/hibernate/src/main/java/org/apache/ignite/cache/hibernate/HibernateCacheProxy.java:[555,30] cannot find symbol
  symbol:   method localMxBean()
  location: interface org.apache.ignite.internal.processors.cache.IgniteInternalCache<java.lang.Object,java.lang.Object>
{noformat}

Build history on TC1 & TC2:
# https://ci.ignite.apache.org/buildConfiguration/IgniteExtensions_Tests_Hibernate?branch=%3Cdefault%3E&mode=builds
# https://ci2.ignite.apache.org/buildConfiguration/IgniteExtensions_Tests_Hibernate?branch=%3Cdefault%3E&mode=builds",,aonikolaev,shishkovilja,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-18232,,,IGNITE-15761,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Wed Feb 15 09:14:56 UTC 2023,,,,,,,,,,"0|z1fxfs:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"15/Feb/23 09:14;aonikolaev;[~timonin.maksim]   thanks for review! ;;;",,,,,
ItClusterManagerTest#testNodeRestart is flaky,IGNITE-18795,13524647,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,apolovtcev,apolovtcev,apolovtcev,14/Feb/23 10:25,15/Feb/23 15:26,13/Jul/23 09:11,15/Feb/23 15:26,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"This test fails sometimes with the following error:

{noformat}
java.lang.AssertionError: 
Expected: is iterable with items [<ClusterNode [id=65b15c06-2a55-4718-ac16-033a4e12775c, name=icmt_tnr_10000, address=192.168.10.11:10000, nodeMetadata=null]>, <ClusterNode [id=a2386ee4-1190-4160-bda2-004d469c282b, name=icmt_tnr_10001, address=192.168.10.11:10001, nodeMetadata=null]>] in any order
     but: was <[ClusterNode [id=65b15c06-2a55-4718-ac16-033a4e12775c, name=icmt_tnr_10000, address=192.168.10.11:10000, nodeMetadata=null]]>
{noformat}
",,apolovtcev,,,,,"sashapolo opened a new pull request, #1679:
URL: https://github.com/apache/ignite-3/pull/1679

   https://issues.apache.org/jira/browse/IGNITE-18795


;15/Feb/23 14:10;githubbot;600","ibessonov commented on code in PR #1679:
URL: https://github.com/apache/ignite-3/pull/1679#discussion_r1107200012


##########
modules/cluster-management/src/main/java/org/apache/ignite/internal/cluster/management/ClusterManagementGroupManager.java:
##########
@@ -594,21 +595,33 @@ private void sendClusterState(CmgRaftService raftService, ClusterNode node) {
     }
 
     private void sendClusterState(CmgRaftService raftService, Collection<ClusterNode> nodes) {
-        raftService.readClusterState()
-                .thenAccept(state -> {
-                    // Raft state might not have been initialized in case of leader failure during cluster init
-                    // TODO: properly handle this case, see https://issues.apache.org/jira/browse/IGNITE-16819
-                    if (state == null) {
-                        throw new IllegalStateException(""Cluster state is empty"");
+        raftService.logicalTopology()
+                .thenCompose(topology -> {
+                    // Only send the ClusterStateMessage to nodes not already present in the Logical Topology.

Review Comment:
   But why? I don't understand the situation



;15/Feb/23 14:30;githubbot;600","ibessonov merged PR #1679:
URL: https://github.com/apache/ignite-3/pull/1679


;15/Feb/23 15:26;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-02-14 10:25:45.0,,,,,,,,,,"0|z1fx74:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
Query listener in python thin client fire events only if a debug logging level enabled,IGNITE-18788,13524608,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,ivandasch,ivandasch,ivandasch,14/Feb/23 07:42,16/Feb/23 11:36,13/Jul/23 09:11,14/Feb/23 10:27,python-0.6.0,,,,,,,python-0.6.1,python,thin client,,0,ise,,,,,ivandasch,,,,,"ivandasch merged PR #62:
URL: https://github.com/apache/ignite-python-thin-client/pull/62


;14/Feb/23 10:27;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-15102,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Tue Feb 14 10:27:59 UTC 2023,,,,,,,,,,"0|z1fwyg:",9223372036854775807,* Fixed query listener firing events only if a debug logging level enabled,,,,,,,,,,,,,,,,,,,,"14/Feb/23 10:27;ivandasch;[~NIzhikov] Thanks for review, merged;;;",,,,,
Sql. TPC-H query#22:  Add SUBSTR alias for SUBSTRING function ,IGNITE-18787,13524603,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,mzhuravkov,mzhuravkov,mzhuravkov,14/Feb/23 07:04,01/Mar/23 13:05,13/Jul/23 09:11,01/Mar/23 13:04,,,,,,,,3.0.0-beta2,sql,,,0,calcite2-required,calcite3-required,ignite-3,"SqlValidator rejects TPC-H query#22 with an error that a function does not exist.

{code:java}
Failed to prepare a query
org.apache.calcite.runtime.CalciteContextException: From line 15, column 18 to line 15, column 38: No match found for function signature SUBSTR(<CHARACTER>, <NUMERIC>, <NUMERIC>)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)
	at org.apache.calcite.runtime.Resources$ExInstWithCause.ex(Resources.java:505)
	at org.apache.calcite.sql.SqlUtil.newContextException(SqlUtil.java:932)
	at org.apache.calcite.sql.SqlUtil.newContextException(SqlUtil.java:917)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.newValidationError(SqlValidatorImpl.java:5362)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.handleUnresolvedFunction(SqlValidatorImpl.java:1955)
	at org.apache.calcite.sql.SqlFunction.deriveType(SqlFunction.java:326)
	at org.apache.calcite.sql.SqlFunction.deriveType(SqlFunction.java:231)
	at org.apache.calcite.sql.validate.SqlValidatorImpl$DeriveTypeVisitor.visit(SqlValidatorImpl.java:6373)
	at org.apache.calcite.sql.validate.SqlValidatorImpl$DeriveTypeVisitor.visit(SqlValidatorImpl.java:6360)
	at org.apache.calcite.sql.SqlCall.accept(SqlCall.java:161)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.deriveTypeImpl(SqlValidatorImpl.java:1869)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.deriveType(SqlValidatorImpl.java:1854)
	at org.apache.calcite.sql.type.SqlTypeUtil.deriveType(SqlTypeUtil.java:200)
	at org.apache.calcite.sql.type.InferTypes.lambda$static$0(InferTypes.java:47)
	at org.apache.ignite.internal.sql.engine.prepare.IgniteSqlValidator.inferUnknownTypes(IgniteSqlValidator.java:541)
	at org.apache.ignite.internal.sql.engine.prepare.IgniteSqlValidator.inferUnknownTypes(IgniteSqlValidator.java:564)
	at org.apache.ignite.internal.sql.engine.prepare.IgniteSqlValidator.inferUnknownTypes(IgniteSqlValidator.java:564)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateWhereOrOn(SqlValidatorImpl.java:4422)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateWhereClause(SqlValidatorImpl.java:4414)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateSelect(SqlValidatorImpl.java:3700)
	at org.apache.ignite.internal.sql.engine.prepare.IgniteSqlValidator.validateSelect(IgniteSqlValidator.java:251)
	at org.apache.calcite.sql.validate.SelectNamespace.validateImpl(SelectNamespace.java:64)
	at org.apache.calcite.sql.validate.AbstractNamespace.validate(AbstractNamespace.java:89)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateNamespace(SqlValidatorImpl.java:1107)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateQuery(SqlValidatorImpl.java:1078)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateFrom(SqlValidatorImpl.java:3381)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateFrom(SqlValidatorImpl.java:3360)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateSelect(SqlValidatorImpl.java:3697)
	at org.apache.ignite.internal.sql.engine.prepare.IgniteSqlValidator.validateSelect(IgniteSqlValidator.java:251)
	at org.apache.calcite.sql.validate.SelectNamespace.validateImpl(SelectNamespace.java:64)
	at org.apache.calcite.sql.validate.AbstractNamespace.validate(AbstractNamespace.java:89)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateNamespace(SqlValidatorImpl.java:1107)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateQuery(SqlValidatorImpl.java:1078)
	at org.apache.calcite.sql.SqlSelect.validate(SqlSelect.java:248)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validateScopedExpression(SqlValidatorImpl.java:1053)
	at org.apache.calcite.sql.validate.SqlValidatorImpl.validate(SqlValidatorImpl.java:759)
	at org.apache.ignite.internal.sql.engine.prepare.IgniteSqlValidator.validate(IgniteSqlValidator.java:136)
	at org.apache.ignite.internal.sql.engine.prepare.IgnitePlanner.validateAndGetTypeMetadata(IgnitePlanner.java:210)
	at org.apache.ignite.internal.sql.engine.prepare.PrepareServiceImpl.lambda$prepareQuery$3(PrepareServiceImpl.java:234)
	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1700)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:829)
	Suppressed: java.lang.RuntimeException: This is a trimmed root
		at org.apache.ignite.internal.testframework.IgniteTestUtils.await(IgniteTestUtils.java:752)
		at org.apache.ignite.internal.sql.engine.framework.TestNode.prepare(TestNode.java:194)
		at org.apache.ignite.internal.sql.engine.benchmarks.TpcTest$RunQuery.executeQuery(TpcTest.java:154)
		at org.apache.ignite.internal.sql.engine.benchmarks.TpcTest$RunQuery.execute(TpcTest.java:141)
		at org.junit.jupiter.engine.descriptor.DynamicTestTestDescriptor.lambda$execute$0(DynamicTestTestDescriptor.java:53)
		at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
		at org.junit.jupiter.api.extension.InvocationInterceptor.interceptDynamicTest(InvocationInterceptor.java:167)
		at org.junit.jupiter.api.extension.InvocationInterceptor.interceptDynamicTest(InvocationInterceptor.java:184)
		at org.junit.jupiter.engine.descriptor.DynamicTestTestDescriptor.lambda$execute$1(DynamicTestTestDescriptor.java:61)
		at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptorCall.lambda$ofVoid$0(InvocationInterceptorChain.java:78)
		at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
		at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
		at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
		at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
		at org.junit.jupiter.engine.descriptor.DynamicTestTestDescriptor.execute(DynamicTestTestDescriptor.java:60)
		at org.junit.jupiter.engine.descriptor.DynamicTestTestDescriptor.execute(DynamicTestTestDescriptor.java:32)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
		at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:226)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:204)
		at java.base/java.util.Optional.ifPresent(Optional.java:183)
		at org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor.lambda$invokeTestMethod$1(TestFactoryTestDescriptor.java:108)
		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
		at org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor.invokeTestMethod(TestFactoryTestDescriptor.java:95)
		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135)
		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
		at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
		at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
		at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
		at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
		at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)
		at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
		at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)
		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107)
		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)
		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)
		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)
		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)
		at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)
		at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86)
		at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86)
		at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53)
		at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:99)
		at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79)
		at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75)
		at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:566)
		at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
		at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
		at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33)
		at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94)
		at com.sun.proxy.$Proxy5.stop(Unknown Source)
		at org.gradle.api.internal.tasks.testing.worker.TestWorker$3.run(TestWorker.java:193)
		at org.gradle.api.internal.tasks.testing.worker.TestWorker.executeAndMaintainThreadName(TestWorker.java:129)
		at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:100)
		at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:60)
		at org.gradle.process.internal.worker.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:56)
		at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:133)
		at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:71)
{code}
",,mzhuravkov,,,,,"AMashenkov merged PR #1724:
URL: https://github.com/apache/ignite-3/pull/1724


;01/Mar/23 13:04;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,2023-02-14 07:04:07.0,,,,,,,,,,"0|z1fwxc:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
Sql. TPC-H query#6: Failed to parse query: BETWEEN operator has no terminating AND,IGNITE-18786,13524601,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,mzhuravkov,mzhuravkov,mzhuravkov,14/Feb/23 07:00,27/Feb/23 10:34,13/Jul/23 09:11,27/Feb/23 10:34,,,,,,,,3.0.0-beta2,sql,,,0,calcite2-required,calcite3-required,ignite-3,"Sql parser is unable to parse TPC-H query#6.
Error:
{code:java}
org.apache.ignite.sql.SqlException: IGN-SQL-3 TraceId:f9be2841-ea95-4995-bde3-27742e8642dd Failed to parse query: BETWEEN operator has no terminating AND
	at org.apache.ignite.internal.util.ExceptionUtils.lambda$withCauseAndCode$3(ExceptionUtils.java:408)
	at org.apache.ignite.internal.util.ExceptionUtils.withCauseInternal(ExceptionUtils.java:435)
	at org.apache.ignite.internal.util.ExceptionUtils.withCauseAndCode(ExceptionUtils.java:408)
	at org.apache.ignite.internal.sql.engine.util.Commons.parse(Commons.java:751)
	at org.apache.ignite.internal.sql.engine.framework.TestNode.prepare(TestNode.java:190)
	at org.apache.ignite.internal.sql.engine.benchmarks.TpcTest$RunQuery.executeQuery(TpcTest.java:154)
	at org.apache.ignite.internal.sql.engine.benchmarks.TpcTest$RunQuery.execute(TpcTest.java:141)
	at org.junit.jupiter.engine.descriptor.DynamicTestTestDescriptor.lambda$execute$0(DynamicTestTestDescriptor.java:53)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.api.extension.InvocationInterceptor.interceptDynamicTest(InvocationInterceptor.java:167)
	at org.junit.jupiter.api.extension.InvocationInterceptor.interceptDynamicTest(InvocationInterceptor.java:184)
	at org.junit.jupiter.engine.descriptor.DynamicTestTestDescriptor.lambda$execute$1(DynamicTestTestDescriptor.java:61)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptorCall.lambda$ofVoid$0(InvocationInterceptorChain.java:78)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.descriptor.DynamicTestTestDescriptor.execute(DynamicTestTestDescriptor.java:60)
	at org.junit.jupiter.engine.descriptor.DynamicTestTestDescriptor.execute(DynamicTestTestDescriptor.java:32)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:226)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask$DefaultDynamicTestExecutor.execute(NodeTestTask.java:204)
	at java.base/java.util.Optional.ifPresent(Optional.java:183)
	at org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor.lambda$invokeTestMethod$1(TestFactoryTestDescriptor.java:108)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor.invokeTestMethod(TestFactoryTestDescriptor.java:95)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)
	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86)
	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86)
	at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53)
	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:99)
	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79)
	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94)
	at com.sun.proxy.$Proxy5.stop(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker$3.run(TestWorker.java:193)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.executeAndMaintainThreadName(TestWorker.java:129)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:100)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:60)
	at org.gradle.process.internal.worker.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:56)
	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:133)
	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:71)
	at worker.org.gradle.process.internal.worker.GradleWorkerMain.run(GradleWorkerMain.java:69)
	at worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74)
Caused by: org.apache.calcite.sql.parser.SqlParseException: BETWEEN operator has no terminating AND
	at org.apache.ignite.internal.generated.query.calcite.sql.IgniteSqlParserImpl.convertException(IgniteSqlParserImpl.java:422)
	at org.apache.ignite.internal.generated.query.calcite.sql.IgniteSqlParserImpl.normalizeException(IgniteSqlParserImpl.java:175)
	at org.apache.calcite.sql.parser.SqlParser.handleException(SqlParser.java:156)
	at org.apache.calcite.sql.parser.SqlParser.parseStmtList(SqlParser.java:211)
	at org.apache.ignite.internal.sql.engine.util.Commons.parse(Commons.java:770)
	at org.apache.ignite.internal.sql.engine.util.Commons.parse(Commons.java:749)
	... 94 more
Caused by: org.apache.calcite.sql.validate.SqlValidatorException: BETWEEN operator has no terminating AND
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)
	at org.apache.calcite.runtime.Resources$ExInstWithCause.ex(Resources.java:505)
	at org.apache.calcite.runtime.Resources$ExInst.ex(Resources.java:599)
	at org.apache.calcite.sql.SqlUtil.newContextException(SqlUtil.java:932)
	at org.apache.calcite.sql.SqlUtil.newContextException(SqlUtil.java:917)
	at org.apache.calcite.sql.fun.SqlBetweenOperator.reduceExpr(SqlBetweenOperator.java:219)
	at org.apache.calcite.sql.parser.SqlParserUtil$OldTokenSequenceImpl.lambda$parser$0(SqlParserUtil.java:906)
	at org.apache.calcite.util.PrecedenceClimbingParser.partialParse(PrecedenceClimbingParser.java:121)
	at org.apache.calcite.sql.parser.SqlParserUtil.toTreeEx(SqlParserUtil.java:668)
	at org.apache.calcite.sql.parser.SqlParserUtil.toTree(SqlParserUtil.java:631)
	at org.apache.ignite.internal.generated.query.calcite.sql.IgniteSqlParserImpl.Expression(IgniteSqlParserImpl.java:4452)
	at org.apache.ignite.internal.generated.query.calcite.sql.IgniteSqlParserImpl.Where(IgniteSqlParserImpl.java:3319)
	at org.apache.ignite.internal.generated.query.calcite.sql.IgniteSqlParserImpl.SqlSelect(IgniteSqlParserImpl.java:1974)
	at org.apache.ignite.internal.generated.query.calcite.sql.IgniteSqlParserImpl.LeafQuery(IgniteSqlParserImpl.java:719)
	at org.apache.ignite.internal.generated.query.calcite.sql.IgniteSqlParserImpl.LeafQueryOrExpr(IgniteSqlParserImpl.java:4430)
	at org.apache.ignite.internal.generated.query.calcite.sql.IgniteSqlParserImpl.QueryOrExpr(IgniteSqlParserImpl.java:4296)
	at org.apache.ignite.internal.generated.query.calcite.sql.IgniteSqlParserImpl.OrderedQueryOrExpr(IgniteSqlParserImpl.java:576)
	at org.apache.ignite.internal.generated.query.calcite.sql.IgniteSqlParserImpl.SqlStmt(IgniteSqlParserImpl.java:1066)
	at org.apache.ignite.internal.generated.query.calcite.sql.IgniteSqlParserImpl.SqlStmtList(IgniteSqlParserImpl.java:1026)
	at org.apache.ignite.internal.generated.query.calcite.sql.IgniteSqlParserImpl.parseSqlStmtList(IgniteSqlParserImpl.java:231)
{code}
",,amashenkov,mzhuravkov,,,,"AMashenkov merged PR #1719:
URL: https://github.com/apache/ignite-3/pull/1719


;27/Feb/23 10:34;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Mon Feb 27 10:34:58 UTC 2023,,,,,,,,,,"0|z1fwww:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"27/Feb/23 10:34;amashenkov;[~mzhuravkov], LGTM, merged to main.
Thanks for your contribution.;;;",,,,,
DistributedProcess hangs if a single future completes with AssertionError,IGNITE-18783,13524498,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,timonin.maksim,timonin.maksim,timonin.maksim,13/Feb/23 16:05,16/Feb/23 08:44,13/Jul/23 09:11,16/Feb/23 08:44,,,,,,,,2.15,,,,0,ise,,,"DistributedProcess#sendSingleMessage tries to cast local process future error to Exception, while it might completed with AssertionError.

In a such case SingleMessage isn't sent, and originated node hangs while waiting response from the node.",,ignitetcbot,timonin.maksim,,,,"timoninmaxim opened a new pull request, #10537:
URL: https://github.com/apache/ignite/pull/10537

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;13/Feb/23 16:50;githubbot;600","ivandasch commented on code in PR #10537:
URL: https://github.com/apache/ignite/pull/10537#discussion_r1107143914


##########
modules/core/src/test/java/org/apache/ignite/internal/util/DistributedProcessTest.java:
##########
@@ -0,0 +1,162 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.util;
+
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.function.BiFunction;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.failure.StopNodeFailureHandler;
+import org.apache.ignite.internal.util.distributed.DistributedProcess;
+import org.apache.ignite.internal.util.future.GridFinishedFuture;
+import org.apache.ignite.internal.util.typedef.F;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.internal.util.distributed.DistributedProcess.DistributedProcessType.TEST_PROCESS;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+
+/** */
+@RunWith(Parameterized.class)
+public class DistributedProcessTest extends GridCommonAbstractTest {
+    /** */
+    private static final int SRV_NODES = 3;
+
+    /** If {@code true} then client fails, otherwise server node fails. */
+    @Parameterized.Parameter
+    public boolean failCln;
+
+    /** */
+    @Parameterized.Parameters(name = ""failClient={0}"")
+    public static Iterable<Boolean> params() {
+        return F.asList(false, true);
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String instanceName) throws Exception {
+        IgniteConfiguration cfg = super.getConfiguration(instanceName);
+
+        cfg.setFailureHandler(new StopNodeFailureHandler());
+
+        return cfg;
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        startGrids(SRV_NODES);
+
+        startClientGrid(SRV_NODES);
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() {
+        stopAllGrids();
+    }
+
+    /** */
+    @Test
+    public void testBackgroundExecFailureHandled() throws Exception {
+        checkDistributedProcess((n, latch) ->
+            new DistributedProcess<>(grid(n).context(), TEST_PROCESS,
+                req -> runAsync(() -> {
+                    failOnNode(n);  // Fails processing request in a spawned thread.
+
+                    return 0;
+                }),
+                (id, res, err) -> {
+                    if (failCln)
+                        assertEquals(SRV_NODES, res.values().size());
+                    else {
+                        assertEquals(SRV_NODES - 1, res.values().size());
+                        assertEquals(1, err.size());
+                        assertTrue(err.get(grid(1).localNode().id()) instanceof AssertionError);
+                    }
+
+                    latch.countDown();
+                }));
+    }
+
+    /** */
+    @Test
+    public void testExecFailureHandled() throws Exception {
+        checkDistributedProcess((n, latch) ->
+            new DistributedProcess<>(grid(n).context(), TEST_PROCESS,
+                req -> {
+                    failOnNode(n);  // Fails processing request in the discovery thread.
+
+                    return new GridFinishedFuture<>(0);
+                },
+                (id, res, err) -> {
+                    if (failCln)
+                        assertEquals(SRV_NODES, res.values().size());
+                    else {
+                        assertEquals(SRV_NODES - 1, res.values().size());
+                        assertEquals(1, err.size());
+                        assertTrue(err.get(grid(1).localNode().id()) instanceof AssertionError);
+                    }
+
+                    latch.countDown();
+                }));
+    }
+
+    /** */
+    @Test
+    public void testFinishFailureHandled() throws Exception {
+        checkDistributedProcess((n, latch) ->
+            new DistributedProcess<>(grid(n).context(), TEST_PROCESS,
+                req -> new GridFinishedFuture<>(0),
+                (uuid, res, err) -> {
+                    assertEquals(SRV_NODES, res.values().size());
+                    latch.countDown();
+
+                    failOnNode(n);
+                }));
+    }
+
+    /** */
+    private void checkDistributedProcess(
+        BiFunction<Integer, CountDownLatch, DistributedProcess<Integer, Integer>> processFactory
+    ) throws Exception {
+        DistributedProcess<Integer, Integer> process = null;
+
+        CountDownLatch latch = new CountDownLatch(SRV_NODES + 1);
+
+        for (int n = SRV_NODES; n >= 0; n--)
+            process = processFactory.apply(n, latch);
+
+        process.start(UUID.randomUUID(), 0);
+
+        assertTrue(latch.await(30, TimeUnit.SECONDS));

Review Comment:
   It seems that this timeout is too big. What about to reduce it?



##########
modules/core/src/test/java/org/apache/ignite/internal/util/DistributedProcessTest.java:
##########
@@ -0,0 +1,162 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.util;
+
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.function.BiFunction;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.failure.StopNodeFailureHandler;
+import org.apache.ignite.internal.util.distributed.DistributedProcess;
+import org.apache.ignite.internal.util.future.GridFinishedFuture;
+import org.apache.ignite.internal.util.typedef.F;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.internal.util.distributed.DistributedProcess.DistributedProcessType.TEST_PROCESS;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+
+/** */
+@RunWith(Parameterized.class)
+public class DistributedProcessTest extends GridCommonAbstractTest {
+    /** */
+    private static final int SRV_NODES = 3;
+
+    /** If {@code true} then client fails, otherwise server node fails. */
+    @Parameterized.Parameter
+    public boolean failCln;

Review Comment:
   Seems that just `failClient` is better. At first glance it looks like `failCnt`



##########
modules/core/src/test/java/org/apache/ignite/internal/util/DistributedProcessTest.java:
##########
@@ -0,0 +1,162 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.util;
+
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.function.BiFunction;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.failure.StopNodeFailureHandler;
+import org.apache.ignite.internal.util.distributed.DistributedProcess;
+import org.apache.ignite.internal.util.future.GridFinishedFuture;
+import org.apache.ignite.internal.util.typedef.F;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.internal.util.distributed.DistributedProcess.DistributedProcessType.TEST_PROCESS;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+
+/** */
+@RunWith(Parameterized.class)
+public class DistributedProcessTest extends GridCommonAbstractTest {
+    /** */
+    private static final int SRV_NODES = 3;
+
+    /** If {@code true} then client fails, otherwise server node fails. */
+    @Parameterized.Parameter
+    public boolean failCln;
+
+    /** */
+    @Parameterized.Parameters(name = ""failClient={0}"")
+    public static Iterable<Boolean> params() {
+        return F.asList(false, true);
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String instanceName) throws Exception {
+        IgniteConfiguration cfg = super.getConfiguration(instanceName);
+
+        cfg.setFailureHandler(new StopNodeFailureHandler());
+
+        return cfg;
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        startGrids(SRV_NODES);
+
+        startClientGrid(SRV_NODES);
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() {
+        stopAllGrids();
+    }
+
+    /** */
+    @Test
+    public void testBackgroundExecFailureHandled() throws Exception {
+        checkDistributedProcess((n, latch) ->
+            new DistributedProcess<>(grid(n).context(), TEST_PROCESS,
+                req -> runAsync(() -> {
+                    failOnNode(n);  // Fails processing request in a spawned thread.
+
+                    return 0;
+                }),
+                (id, res, err) -> {
+                    if (failCln)
+                        assertEquals(SRV_NODES, res.values().size());
+                    else {
+                        assertEquals(SRV_NODES - 1, res.values().size());
+                        assertEquals(1, err.size());
+                        assertTrue(err.get(grid(1).localNode().id()) instanceof AssertionError);
+                    }
+
+                    latch.countDown();
+                }));
+    }
+
+    /** */
+    @Test
+    public void testExecFailureHandled() throws Exception {
+        checkDistributedProcess((n, latch) ->
+            new DistributedProcess<>(grid(n).context(), TEST_PROCESS,
+                req -> {
+                    failOnNode(n);  // Fails processing request in the discovery thread.
+
+                    return new GridFinishedFuture<>(0);
+                },
+                (id, res, err) -> {
+                    if (failCln)
+                        assertEquals(SRV_NODES, res.values().size());
+                    else {
+                        assertEquals(SRV_NODES - 1, res.values().size());
+                        assertEquals(1, err.size());
+                        assertTrue(err.get(grid(1).localNode().id()) instanceof AssertionError);
+                    }
+
+                    latch.countDown();
+                }));
+    }
+
+    /** */
+    @Test
+    public void testFinishFailureHandled() throws Exception {
+        checkDistributedProcess((n, latch) ->
+            new DistributedProcess<>(grid(n).context(), TEST_PROCESS,
+                req -> new GridFinishedFuture<>(0),
+                (uuid, res, err) -> {
+                    assertEquals(SRV_NODES, res.values().size());
+                    latch.countDown();
+
+                    failOnNode(n);
+                }));
+    }
+
+    /** */
+    private void checkDistributedProcess(
+        BiFunction<Integer, CountDownLatch, DistributedProcess<Integer, Integer>> processFactory
+    ) throws Exception {
+        DistributedProcess<Integer, Integer> process = null;
+
+        CountDownLatch latch = new CountDownLatch(SRV_NODES + 1);
+
+        for (int n = SRV_NODES; n >= 0; n--)
+            process = processFactory.apply(n, latch);

Review Comment:
   It seems that a bunch of processes is created here but only one of them actually is started



##########
modules/core/src/test/java/org/apache/ignite/internal/util/DistributedProcessTest.java:
##########
@@ -0,0 +1,162 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.util;
+
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.function.BiFunction;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.failure.StopNodeFailureHandler;
+import org.apache.ignite.internal.util.distributed.DistributedProcess;
+import org.apache.ignite.internal.util.future.GridFinishedFuture;
+import org.apache.ignite.internal.util.typedef.F;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.internal.util.distributed.DistributedProcess.DistributedProcessType.TEST_PROCESS;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+
+/** */
+@RunWith(Parameterized.class)
+public class DistributedProcessTest extends GridCommonAbstractTest {
+    /** */
+    private static final int SRV_NODES = 3;
+
+    /** If {@code true} then client fails, otherwise server node fails. */
+    @Parameterized.Parameter
+    public boolean failCln;
+
+    /** */
+    @Parameterized.Parameters(name = ""failClient={0}"")
+    public static Iterable<Boolean> params() {
+        return F.asList(false, true);
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String instanceName) throws Exception {
+        IgniteConfiguration cfg = super.getConfiguration(instanceName);
+
+        cfg.setFailureHandler(new StopNodeFailureHandler());
+
+        return cfg;
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        startGrids(SRV_NODES);
+
+        startClientGrid(SRV_NODES);
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() {
+        stopAllGrids();
+    }
+
+    /** */
+    @Test
+    public void testBackgroundExecFailureHandled() throws Exception {
+        checkDistributedProcess((n, latch) ->
+            new DistributedProcess<>(grid(n).context(), TEST_PROCESS,
+                req -> runAsync(() -> {
+                    failOnNode(n);  // Fails processing request in a spawned thread.
+
+                    return 0;
+                }),
+                (id, res, err) -> {
+                    if (failCln)
+                        assertEquals(SRV_NODES, res.values().size());
+                    else {
+                        assertEquals(SRV_NODES - 1, res.values().size());
+                        assertEquals(1, err.size());
+                        assertTrue(err.get(grid(1).localNode().id()) instanceof AssertionError);
+                    }
+
+                    latch.countDown();
+                }));
+    }
+
+    /** */
+    @Test
+    public void testExecFailureHandled() throws Exception {
+        checkDistributedProcess((n, latch) ->
+            new DistributedProcess<>(grid(n).context(), TEST_PROCESS,
+                req -> {
+                    failOnNode(n);  // Fails processing request in the discovery thread.
+
+                    return new GridFinishedFuture<>(0);
+                },
+                (id, res, err) -> {
+                    if (failCln)
+                        assertEquals(SRV_NODES, res.values().size());
+                    else {
+                        assertEquals(SRV_NODES - 1, res.values().size());
+                        assertEquals(1, err.size());
+                        assertTrue(err.get(grid(1).localNode().id()) instanceof AssertionError);
+                    }
+
+                    latch.countDown();
+                }));
+    }
+
+    /** */
+    @Test
+    public void testFinishFailureHandled() throws Exception {
+        checkDistributedProcess((n, latch) ->
+            new DistributedProcess<>(grid(n).context(), TEST_PROCESS,
+                req -> new GridFinishedFuture<>(0),
+                (uuid, res, err) -> {
+                    assertEquals(SRV_NODES, res.values().size());
+                    latch.countDown();
+
+                    failOnNode(n);
+                }));
+    }
+
+    /** */
+    private void checkDistributedProcess(
+        BiFunction<Integer, CountDownLatch, DistributedProcess<Integer, Integer>> processFactory
+    ) throws Exception {
+        DistributedProcess<Integer, Integer> process = null;
+
+        CountDownLatch latch = new CountDownLatch(SRV_NODES + 1);
+
+        for (int n = SRV_NODES; n >= 0; n--)
+            process = processFactory.apply(n, latch);
+
+        process.start(UUID.randomUUID(), 0);
+
+        assertTrue(latch.await(30, TimeUnit.SECONDS));
+
+        // Just checks that node is alive.
+        grid(1).cluster().state(ClusterState.INACTIVE);
+
+        awaitPartitionMapExchange();
+
+        checkTopology(SRV_NODES + 1);
+    }
+
+    /** Checks whether to fail on specified node. */
+    private void failOnNode(int nodeIdx) {
+        assert (failCln && nodeIdx != SRV_NODES) || nodeIdx != 1;

Review Comment:
   Looks quite cryptic.
   
   Let's set a client id to  `CLIENT_NODE_IDX`



;15/Feb/23 14:16;githubbot;600","ivandasch commented on code in PR #10537:
URL: https://github.com/apache/ignite/pull/10537#discussion_r1107182956


##########
modules/core/src/test/java/org/apache/ignite/internal/util/DistributedProcessTest.java:
##########
@@ -0,0 +1,162 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.util;
+
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.function.BiFunction;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.failure.StopNodeFailureHandler;
+import org.apache.ignite.internal.util.distributed.DistributedProcess;
+import org.apache.ignite.internal.util.future.GridFinishedFuture;
+import org.apache.ignite.internal.util.typedef.F;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.internal.util.distributed.DistributedProcess.DistributedProcessType.TEST_PROCESS;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+
+/** */
+@RunWith(Parameterized.class)
+public class DistributedProcessTest extends GridCommonAbstractTest {
+    /** */
+    private static final int SRV_NODES = 3;
+
+    /** If {@code true} then client fails, otherwise server node fails. */
+    @Parameterized.Parameter
+    public boolean failCln;
+
+    /** */
+    @Parameterized.Parameters(name = ""failClient={0}"")
+    public static Iterable<Boolean> params() {
+        return F.asList(false, true);
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String instanceName) throws Exception {
+        IgniteConfiguration cfg = super.getConfiguration(instanceName);
+
+        cfg.setFailureHandler(new StopNodeFailureHandler());
+
+        return cfg;
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        startGrids(SRV_NODES);
+
+        startClientGrid(SRV_NODES);
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() {
+        stopAllGrids();
+    }
+
+    /** */
+    @Test
+    public void testBackgroundExecFailureHandled() throws Exception {
+        checkDistributedProcess((n, latch) ->
+            new DistributedProcess<>(grid(n).context(), TEST_PROCESS,
+                req -> runAsync(() -> {
+                    failOnNode(n);  // Fails processing request in a spawned thread.
+
+                    return 0;
+                }),
+                (id, res, err) -> {
+                    if (failCln)
+                        assertEquals(SRV_NODES, res.values().size());
+                    else {
+                        assertEquals(SRV_NODES - 1, res.values().size());
+                        assertEquals(1, err.size());
+                        assertTrue(err.get(grid(1).localNode().id()) instanceof AssertionError);
+                    }
+
+                    latch.countDown();
+                }));
+    }
+
+    /** */
+    @Test
+    public void testExecFailureHandled() throws Exception {
+        checkDistributedProcess((n, latch) ->
+            new DistributedProcess<>(grid(n).context(), TEST_PROCESS,
+                req -> {
+                    failOnNode(n);  // Fails processing request in the discovery thread.
+
+                    return new GridFinishedFuture<>(0);
+                },
+                (id, res, err) -> {
+                    if (failCln)
+                        assertEquals(SRV_NODES, res.values().size());
+                    else {
+                        assertEquals(SRV_NODES - 1, res.values().size());
+                        assertEquals(1, err.size());
+                        assertTrue(err.get(grid(1).localNode().id()) instanceof AssertionError);
+                    }
+
+                    latch.countDown();
+                }));
+    }
+
+    /** */
+    @Test
+    public void testFinishFailureHandled() throws Exception {
+        checkDistributedProcess((n, latch) ->
+            new DistributedProcess<>(grid(n).context(), TEST_PROCESS,
+                req -> new GridFinishedFuture<>(0),
+                (uuid, res, err) -> {
+                    assertEquals(SRV_NODES, res.values().size());
+                    latch.countDown();
+
+                    failOnNode(n);
+                }));
+    }
+
+    /** */
+    private void checkDistributedProcess(
+        BiFunction<Integer, CountDownLatch, DistributedProcess<Integer, Integer>> processFactory
+    ) throws Exception {
+        DistributedProcess<Integer, Integer> process = null;
+
+        CountDownLatch latch = new CountDownLatch(SRV_NODES + 1);
+
+        for (int n = SRV_NODES; n >= 0; n--)
+            process = processFactory.apply(n, latch);

Review Comment:
   It seems that a bunch of processes is created here but only one of them actually is started



;15/Feb/23 15:07;githubbot;600","timoninmaxim commented on code in PR #10537:
URL: https://github.com/apache/ignite/pull/10537#discussion_r1107312486


##########
modules/core/src/test/java/org/apache/ignite/internal/util/DistributedProcessTest.java:
##########
@@ -0,0 +1,162 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.util;
+
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.function.BiFunction;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.failure.StopNodeFailureHandler;
+import org.apache.ignite.internal.util.distributed.DistributedProcess;
+import org.apache.ignite.internal.util.future.GridFinishedFuture;
+import org.apache.ignite.internal.util.typedef.F;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.internal.util.distributed.DistributedProcess.DistributedProcessType.TEST_PROCESS;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+
+/** */
+@RunWith(Parameterized.class)
+public class DistributedProcessTest extends GridCommonAbstractTest {
+    /** */
+    private static final int SRV_NODES = 3;
+
+    /** If {@code true} then client fails, otherwise server node fails. */
+    @Parameterized.Parameter
+    public boolean failCln;
+
+    /** */
+    @Parameterized.Parameters(name = ""failClient={0}"")
+    public static Iterable<Boolean> params() {
+        return F.asList(false, true);
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String instanceName) throws Exception {
+        IgniteConfiguration cfg = super.getConfiguration(instanceName);
+
+        cfg.setFailureHandler(new StopNodeFailureHandler());
+
+        return cfg;
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        startGrids(SRV_NODES);
+
+        startClientGrid(SRV_NODES);
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() {
+        stopAllGrids();
+    }
+
+    /** */
+    @Test
+    public void testBackgroundExecFailureHandled() throws Exception {
+        checkDistributedProcess((n, latch) ->
+            new DistributedProcess<>(grid(n).context(), TEST_PROCESS,
+                req -> runAsync(() -> {
+                    failOnNode(n);  // Fails processing request in a spawned thread.
+
+                    return 0;
+                }),
+                (id, res, err) -> {
+                    if (failCln)
+                        assertEquals(SRV_NODES, res.values().size());
+                    else {
+                        assertEquals(SRV_NODES - 1, res.values().size());
+                        assertEquals(1, err.size());
+                        assertTrue(err.get(grid(1).localNode().id()) instanceof AssertionError);
+                    }
+
+                    latch.countDown();
+                }));
+    }
+
+    /** */
+    @Test
+    public void testExecFailureHandled() throws Exception {
+        checkDistributedProcess((n, latch) ->
+            new DistributedProcess<>(grid(n).context(), TEST_PROCESS,
+                req -> {
+                    failOnNode(n);  // Fails processing request in the discovery thread.
+
+                    return new GridFinishedFuture<>(0);
+                },
+                (id, res, err) -> {
+                    if (failCln)
+                        assertEquals(SRV_NODES, res.values().size());
+                    else {
+                        assertEquals(SRV_NODES - 1, res.values().size());
+                        assertEquals(1, err.size());
+                        assertTrue(err.get(grid(1).localNode().id()) instanceof AssertionError);
+                    }
+
+                    latch.countDown();
+                }));
+    }
+
+    /** */
+    @Test
+    public void testFinishFailureHandled() throws Exception {
+        checkDistributedProcess((n, latch) ->
+            new DistributedProcess<>(grid(n).context(), TEST_PROCESS,
+                req -> new GridFinishedFuture<>(0),
+                (uuid, res, err) -> {
+                    assertEquals(SRV_NODES, res.values().size());
+                    latch.countDown();
+
+                    failOnNode(n);
+                }));
+    }
+
+    /** */
+    private void checkDistributedProcess(
+        BiFunction<Integer, CountDownLatch, DistributedProcess<Integer, Integer>> processFactory
+    ) throws Exception {
+        DistributedProcess<Integer, Integer> process = null;
+
+        CountDownLatch latch = new CountDownLatch(SRV_NODES + 1);
+
+        for (int n = SRV_NODES; n >= 0; n--)
+            process = processFactory.apply(n, latch);
+
+        process.start(UUID.randomUUID(), 0);
+
+        assertTrue(latch.await(30, TimeUnit.SECONDS));
+
+        // Just checks that node is alive.
+        grid(1).cluster().state(ClusterState.INACTIVE);
+
+        awaitPartitionMapExchange();
+
+        checkTopology(SRV_NODES + 1);
+    }
+
+    /** Checks whether to fail on specified node. */
+    private void failOnNode(int nodeIdx) {
+        assert (failCln && nodeIdx != SRV_NODES) || nodeIdx != 1;

Review Comment:
   Use Ignite.config().isClientMode() instead.



;15/Feb/23 15:54;githubbot;600","timoninmaxim merged PR #10537:
URL: https://github.com/apache/ignite/pull/10537


;16/Feb/23 08:43;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Feb 16 08:44:22 UTC 2023,,,,,,,,,,"0|z1fwa0:",9223372036854775807,,,ivandasch,,,,,,,,,,,,,,,,,,"14/Feb/23 12:44;ignitetcbot;{panel:title=Branch: [pull/10537/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10537/head] Base: [master] : New Tests (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Basic 1{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7049181]]
* {color:#013220}IgniteBasicTestSuite: DistributedProcessTest.testAssertionErrorHandled - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7048257&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","16/Feb/23 07:33;ignitetcbot;{panel:title=Branch: [pull/10537/head] Base: [master] : Possible Blockers (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}
{color:#d04437}SPI (Discovery){color} [[tests 0 TIMEOUT , Exit Code , Failure on metric |https://ci2.ignite.apache.org/viewLog.html?buildId=7051647]]

{panel}
{panel:title=Branch: [pull/10537/head] Base: [master] : New Tests (6)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Basic 1{color} [[tests 6|https://ci2.ignite.apache.org/viewLog.html?buildId=7052333]]
* {color:#013220}IgniteBasicTestSuite: DistributedProcessErrorHandlingTest.testExecFailureHandled[failClient=false] - PASSED{color}
* {color:#013220}IgniteBasicTestSuite: DistributedProcessErrorHandlingTest.testFinishFailureHandled[failClient=false] - PASSED{color}
* {color:#013220}IgniteBasicTestSuite: DistributedProcessErrorHandlingTest.testBackgroundExecFailureHandled[failClient=false] - PASSED{color}
* {color:#013220}IgniteBasicTestSuite: DistributedProcessErrorHandlingTest.testExecFailureHandled[failClient=true] - PASSED{color}
* {color:#013220}IgniteBasicTestSuite: DistributedProcessErrorHandlingTest.testFinishFailureHandled[failClient=true] - PASSED{color}
* {color:#013220}IgniteBasicTestSuite: DistributedProcessErrorHandlingTest.testBackgroundExecFailureHandled[failClient=true] - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7051666&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","16/Feb/23 08:44;timonin.maksim;[~ivandasch] thanks for review! merged to master;;;",,,
PartitionReplicaListenerTest#testReadOnlyGetAllAfterRowRewrite hangs forever,IGNITE-18774,13524214,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,Denis Chudov,Denis Chudov,Denis Chudov,10/Feb/23 11:44,14/Feb/23 10:38,13/Jul/23 09:11,14/Feb/23 10:38,,,,,,,,,,,,0,ignite-3,,,https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunUnitTests/7069824?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandBuildProblemsSection=true&expandBuildChangesSection=true,,Denis Chudov,v.pyatkov,,,,"denis-chudov opened a new pull request, #1661:
URL: https://github.com/apache/ignite-3/pull/1661

   https://issues.apache.org/jira/browse/IGNITE-18774 


;10/Feb/23 12:23;githubbot;600","vldpyatkov merged PR #1661:
URL: https://github.com/apache/ignite-3/pull/1661


;13/Feb/23 12:25;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Feb 13 12:26:06 UTC 2023,,,,,,,,,,"0|z1fuiw:",9223372036854775807,,,v.pyatkov,,,,,,,,,,,,,,,,,,"10/Feb/23 13:42;Denis Chudov;[~v.pyatkov] could you review pls? ;;;","13/Feb/23 12:25;v.pyatkov;LGTM;;;","13/Feb/23 12:26;v.pyatkov;Merged f3ac586d7da227e79a0c80e8488a667b73b1f2bb;;;",,,
Fix compilation in main,IGNITE-18771,13524010,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ibessonov,ibessonov,ibessonov,09/Feb/23 16:10,09/Feb/23 16:17,13/Jul/23 09:11,09/Feb/23 16:16,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,,,ibessonov,,,,,"ibessonov opened a new pull request, #1658:
URL: https://github.com/apache/ignite-3/pull/1658

   https://issues.apache.org/jira/browse/IGNITE-18771


;09/Feb/23 16:11;githubbot;600","ibessonov merged PR #1658:
URL: https://github.com/apache/ignite-3/pull/1658


;09/Feb/23 16:16;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-02-09 16:10:35.0,,,,,,,,,,"0|z1ft9s:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
Test CacheMetricsForClusterGroupSelfTest.testMetricsStatisticsEnabled fails,IGNITE-18769,13523994,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,alex_pl,alex_pl,alex_pl,09/Feb/23 15:17,10/Feb/23 08:04,13/Jul/23 09:11,10/Feb/23 08:04,,,,,,,,2.15,,,,0,MakeTeamcityGreenAgain,,,"Test {{CacheMetricsForClusterGroupSelfTest.testMetricsStatisticsEnabled}} fails due to two reasons:
 # Last started node assumed to be non affinity node (it was daemon node, but become regular server node after IGNITE-18304)
 # Sometimes intermediate metrics state is cought by metrics snapshot ",,alex_pl,,,,,"alex-plekhanov opened a new pull request, #10531:
URL: https://github.com/apache/ignite/pull/10531

   …sticsEnabled failure
   
   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;09/Feb/23 15:21;githubbot;600","nizhikov merged PR #10531:
URL: https://github.com/apache/ignite/pull/10531


;10/Feb/23 08:04;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,IGNITE-18304,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-02-09 15:17:31.0,,,,,,,,,,"0|z1ft68:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect safe time initialization,IGNITE-18768,13523975,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,maliev,Denis Chudov,Denis Chudov,09/Feb/23 13:15,21/Feb/23 21:03,13/Jul/23 09:11,21/Feb/23 21:03,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"There is following code in TableManager, which initializes safe time tracker:
{code:java}
PendingComparableValuesTracker<HybridTimestamp> safeTime = new PendingComparableValuesTracker<>(clock.now());
{code}
This means means that safe time is at least greater than now, whic is not correct. It should be initialized with 0.",,Denis Chudov,v.pyatkov,,,,"vldpyatkov merged PR #1696:
URL: https://github.com/apache/ignite-3/pull/1696


;21/Feb/23 16:30;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Feb 21 16:31:41 UTC 2023,,,,,,,,,,"0|z1ft20:",9223372036854775807,,,vpyatkov,,,,,,,,,,,,,,,,,,"21/Feb/23 16:31;v.pyatkov;LGTM
Merged f480078692acd0696e0a19a951e54ab3b56e2fa6;;;",,,,,
Incorrect id check in ClusterGroupAdapter.forNodeId,IGNITE-18766,13523880,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,brat_kuzma,ptupitsyn,ptupitsyn,09/Feb/23 06:16,14/Apr/23 07:54,13/Jul/23 09:11,14/Apr/23 07:54,2.14,,,,,,,2.15,,,,0,ise,newbie,,"ClusterGroup.forNodeId checks *id* in a loop instead of *id0*:

{code:java}
                for (UUID id0 : ids) {
                    if (contains(id))
                        nodeIds.add(id0);
                }
{code}

https://github.com/apache/ignite/blob/3de1dc44f53ea510328badf6cb6b423fe6975bd8/modules/core/src/main/java/org/apache/ignite/internal/cluster/ClusterGroupAdapter.java#L461

The following unit test demonstrates the problem:


{code:java}
    @Test
    public void testProjectionWithBadId() {
        ClusterNode locNode = ignite.cluster().localNode();

        ClusterGroup prj = ignite.cluster().forNodeId(UUID.randomUUID(), locNode.id());
        Collection<ClusterNode> nodes = prj.nodes();

        assertEquals(1, nodes.size());
    }
{code}

(add to GridProjectionForCachesSelfTest)",,alex_pl,ignitetcbot,ptupitsyn,,,"brat-kuzma opened a new pull request, #10640:
URL: https://github.com/apache/ignite/pull/10640

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;10/Apr/23 15:28;githubbot;600","sonarcloud[bot] commented on PR #10640:
URL: https://github.com/apache/ignite/pull/10640#issuecomment-1501963231

   Kudos, SonarCloud Quality Gate passed!&nbsp; &nbsp; [![Quality Gate passed](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/QualityGateBadge/passed-16px.png 'Quality Gate passed')](https://sonarcloud.io/dashboard?id=apache_ignite&pullRequest=10640)
   
   [![Bug](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/bug-16px.png 'Bug')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10640&resolved=false&types=BUG) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10640&resolved=false&types=BUG) [0 Bugs](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10640&resolved=false&types=BUG)  
   [![Vulnerability](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/vulnerability-16px.png 'Vulnerability')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10640&resolved=false&types=VULNERABILITY) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10640&resolved=false&types=VULNERABILITY) [0 Vulnerabilities](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10640&resolved=false&types=VULNERABILITY)  
   [![Security Hotspot](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/security_hotspot-16px.png 'Security Hotspot')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10640&resolved=false&types=SECURITY_HOTSPOT) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10640&resolved=false&types=SECURITY_HOTSPOT) [0 Security Hotspots](https://sonarcloud.io/project/security_hotspots?id=apache_ignite&pullRequest=10640&resolved=false&types=SECURITY_HOTSPOT)  
   [![Code Smell](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/common/code_smell-16px.png 'Code Smell')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10640&resolved=false&types=CODE_SMELL) [![A](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/RatingBadge/A-16px.png 'A')](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10640&resolved=false&types=CODE_SMELL) [0 Code Smells](https://sonarcloud.io/project/issues?id=apache_ignite&pullRequest=10640&resolved=false&types=CODE_SMELL)
   
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/CoverageChart/0-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10640&metric=new_coverage&view=list) [0.0% Coverage](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10640&metric=new_coverage&view=list)  
   [![0.0%](https://sonarsource.github.io/sonarcloud-github-static-resources/v2/checks/Duplications/3-16px.png '0.0%')](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10640&metric=new_duplicated_lines_density&view=list) [0.0% Duplication](https://sonarcloud.io/component_measures?id=apache_ignite&pullRequest=10640&metric=new_duplicated_lines_density&view=list)
   
   


;10/Apr/23 15:34;githubbot;600","brat-kuzma commented on PR #10640:
URL: https://github.com/apache/ignite/pull/10640#issuecomment-1503654722

   https://ci2.ignite.apache.org/viewLog.html?buildId=7132674&buildTypeId=IgniteTests24Java8_RunAll


;11/Apr/23 15:49;githubbot;600","asfgit closed pull request #10640: IGNITE-18766 Fix incorrect id check in ClusterGroupAdapter.forNodeId
URL: https://github.com/apache/ignite/pull/10640


;14/Apr/23 07:50;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Fri Apr 14 07:51:54 UTC 2023,,,,,,,,,,"0|z1fsgw:",9223372036854775807,Fixed incorrect id check in ClusterGroup.forNodeId,,,,,,,,,,,,,,,,,,,,"10/Apr/23 19:24;ignitetcbot;{panel:title=Branch: [pull/10640/head] Base: [master] : Possible Blockers (4)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}
{color:#d04437}Cache 6{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7132577]]
* IgniteCacheTestSuite6: CacheExchangeMergeTest.testMergeAndHistoryCleanup - Test has low fail rate in base branch 0,0% and is not flaky

{color:#d04437}Cache 12{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7132571]]
* IgniteCacheTestSuite12: TxCrossCacheRemoteMultiplePartitionReservationTest.testRemoteCommitPartitionReservations - Test has low fail rate in base branch 0,0% and is not flaky

{color:#d04437}Cache (Failover) 1{color} [[tests 0 TIMEOUT , Exit Code , Failure on metric |https://ci2.ignite.apache.org/viewLog.html?buildId=7132583]]

{color:#d04437}PDS 5{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7132630]]
* IgnitePdsTestSuite5: SegmentAwareTest.testFinishWaitNextAbsoluteIndex_WhenSetToArchivedFirst - Test has low fail rate in base branch 0,0% and is not flaky

{panel}
{panel:title=Branch: [pull/10640/head] Base: [master] : New Tests (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Basic 1{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7132563]]
* {color:#013220}IgniteBasicTestSuite: GridProjectionForCachesSelfTest.testProjectionWithBadId - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7132674&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","11/Apr/23 15:48;ignitetcbot;{panel:title=Branch: [pull/10640/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10640/head] Base: [master] : New Tests (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Basic 1{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7132563]]
* {color:#013220}IgniteBasicTestSuite: GridProjectionForCachesSelfTest.testProjectionWithBadId - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7132674&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","14/Apr/23 07:51;alex_pl;[~brat_kuzma], looks good to me. Merged to master, cherry-picked to 2.15. Thanks for the contribution!;;;",,,
Cluster snapshot doesn't restore marshaller data,IGNITE-18764,13523781,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,timonin.maksim,timonin.maksim,timonin.maksim,08/Feb/23 13:58,13/Feb/23 10:57,13/Jul/23 09:11,13/Feb/23 10:57,,,,,,,,2.15,,,,0,ise,,,"Case:
 # There is a cache - IgniteCache<Integer, Account>
 # cache.put(0, new BetterAccount()), where BetterAccount extends Account
 # createSnapshot()
 # restoreSnapshot on clean environment
 # cache.get(0) throws java.lang.ClassNotFoundException: Failed to resolve class name [platformId=0, platform=Java, typeId=-68243360]

Reason  that Ignite restores binary meta but misses marshaller data.",,ignitetcbot,timonin.maksim,,,,"timoninmaxim opened a new pull request, #10527:
URL: https://github.com/apache/ignite/pull/10527

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;08/Feb/23 20:55;githubbot;600","petrov-mg commented on code in PR #10527:
URL: https://github.com/apache/ignite/pull/10527#discussion_r1101981274


##########
modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/snapshot/SnapshotRestoreProcess.java:
##########
@@ -1134,6 +1143,31 @@ private IgniteInternalFuture<Boolean> preload(UUID reqId) {
         return retFut;
     }
 
+    /** Restore registered mappings for user classes. */
+    private void restoreMappings(File marshallerDir, BooleanSupplier stopChecker) throws IgniteCheckedException {
+        File[] mappings = marshallerDir.listFiles(BinaryUtils::notTmpFile);
+
+        if (mappings == null)
+            throw new IgniteException(""Failed to list marshaller directory: "" + marshallerDir);

Review Comment:
   To keep some consistency across all exception messages we can change this particular message to something like that:
   
   `Failed to list marshaller directory content [dirName="" + marshallerDir + ']'`
   
   Actually that is up to you.
   
   
   
   
   



;09/Feb/23 20:22;githubbot;600","petrov-mg commented on code in PR #10527:
URL: https://github.com/apache/ignite/pull/10527#discussion_r1101995023


##########
modules/core/src/test/java/org/apache/ignite/testframework/junits/common/GridCommonAbstractTest.java:
##########
@@ -2810,4 +2815,35 @@ protected DistributedChangeableProperty<Serializable> computeJobWorkerInterruptT
 
         return timeoutProperty;
     }
+
+    /** Clean work directory, excluding snapshot directory. */
+    protected IgniteEx restartWithCleanPersistence(int nodes, Collection<String> caches) throws Exception {
+        stopAllGrids();

Review Comment:
   It seems to be clearer given the method name if we use ` int nodesCnt = Ignition.allGrids().size();` instead of `nodes` argument.
   
   That is up to you.



##########
modules/core/src/test/java/org/apache/ignite/testframework/junits/common/GridCommonAbstractTest.java:
##########
@@ -2810,4 +2815,35 @@ protected DistributedChangeableProperty<Serializable> computeJobWorkerInterruptT
 
         return timeoutProperty;
     }
+
+    /** Clean work directory, excluding snapshot directory. */
+    protected IgniteEx restartWithCleanPersistence(int nodes, Collection<String> caches) throws Exception {
+        stopAllGrids();
+
+        assertTrue(U.delete(Paths.get(U.defaultWorkDirectory(), ""cp"").toFile()));
+        assertTrue(U.delete(Paths.get(U.defaultWorkDirectory(), DFLT_MARSHALLER_PATH).toFile()));
+
+        deleteNodesDirs(nodes, DFLT_STORE_DIR, DFLT_BINARY_METADATA_PATH, DFLT_WAL_PATH, DFLT_WAL_ARCHIVE_PATH);
+
+        IgniteEx ign = startGrids(nodes);
+
+        ign.cluster().state(ClusterState.ACTIVE);
+
+        // Destroy caches configured with IgniteConfiguration before restoring snapshot.
+        ign.destroyCaches(caches);

Review Comment:
   We can avoid explicitly destroying caches  by moving current test to `IgniteClusterSnapshotRestoreSelfTest` and setting `dfltCacheCfg = null;` before `IgniteEx ign = startGrids(nodes);` It also will make `Collection<String> caches` argument unnecessary.



##########
modules/core/src/test/java/org/apache/ignite/testframework/junits/common/GridCommonAbstractTest.java:
##########
@@ -2810,4 +2815,35 @@ protected DistributedChangeableProperty<Serializable> computeJobWorkerInterruptT
 
         return timeoutProperty;
     }
+
+    /** Clean work directory, excluding snapshot directory. */
+    protected IgniteEx restartWithCleanPersistence(int nodes, Collection<String> caches) throws Exception {
+        stopAllGrids();
+
+        assertTrue(U.delete(Paths.get(U.defaultWorkDirectory(), ""cp"").toFile()));
+        assertTrue(U.delete(Paths.get(U.defaultWorkDirectory(), DFLT_MARSHALLER_PATH).toFile()));
+
+        deleteNodesDirs(nodes, DFLT_STORE_DIR, DFLT_BINARY_METADATA_PATH, DFLT_WAL_PATH, DFLT_WAL_ARCHIVE_PATH);
+
+        IgniteEx ign = startGrids(nodes);
+
+        ign.cluster().state(ClusterState.ACTIVE);
+
+        // Destroy caches configured with IgniteConfiguration before restoring snapshot.
+        ign.destroyCaches(caches);
+
+        awaitPartitionMapExchange();
+
+        return ign;
+    }
+
+    /** */
+    private void deleteNodesDirs(int nodes, String... dirs) throws IgniteCheckedException {

Review Comment:
   It seems that we can make this method more reusable if we change the `nodes` count argument to the name or index of a single node.



;09/Feb/23 20:40;githubbot;600","timoninmaxim commented on code in PR #10527:
URL: https://github.com/apache/ignite/pull/10527#discussion_r1103048376


##########
modules/core/src/test/java/org/apache/ignite/testframework/junits/common/GridCommonAbstractTest.java:
##########
@@ -2810,4 +2815,35 @@ protected DistributedChangeableProperty<Serializable> computeJobWorkerInterruptT
 
         return timeoutProperty;
     }
+
+    /** Clean work directory, excluding snapshot directory. */
+    protected IgniteEx restartWithCleanPersistence(int nodes, Collection<String> caches) throws Exception {
+        stopAllGrids();

Review Comment:
   I also thought this way. But it's possible that user might have some client nodes in random order. Then we should filter G.allGrids() for server nodes and client nodes, and re-start only server nodes. Looks too complicated actually.
   
   Then I think it's ok to specify nodes param for a while. Somebody who wants to use this method in the future can change it.
   



;10/Feb/23 17:44;githubbot;600","timoninmaxim commented on code in PR #10527:
URL: https://github.com/apache/ignite/pull/10527#discussion_r1103064298


##########
modules/core/src/test/java/org/apache/ignite/testframework/junits/common/GridCommonAbstractTest.java:
##########
@@ -2810,4 +2815,35 @@ protected DistributedChangeableProperty<Serializable> computeJobWorkerInterruptT
 
         return timeoutProperty;
     }
+
+    /** Clean work directory, excluding snapshot directory. */
+    protected IgniteEx restartWithCleanPersistence(int nodes, Collection<String> caches) throws Exception {
+        stopAllGrids();
+
+        assertTrue(U.delete(Paths.get(U.defaultWorkDirectory(), ""cp"").toFile()));
+        assertTrue(U.delete(Paths.get(U.defaultWorkDirectory(), DFLT_MARSHALLER_PATH).toFile()));
+
+        deleteNodesDirs(nodes, DFLT_STORE_DIR, DFLT_BINARY_METADATA_PATH, DFLT_WAL_PATH, DFLT_WAL_ARCHIVE_PATH);
+
+        IgniteEx ign = startGrids(nodes);
+
+        ign.cluster().state(ClusterState.ACTIVE);
+
+        // Destroy caches configured with IgniteConfiguration before restoring snapshot.
+        ign.destroyCaches(caches);

Review Comment:
   Cool, nice catch.



;10/Feb/23 18:02;githubbot;600","petrov-mg commented on code in PR #10527:
URL: https://github.com/apache/ignite/pull/10527#discussion_r1103176200


##########
modules/core/src/test/java/org/apache/ignite/testframework/junits/common/GridCommonAbstractTest.java:
##########
@@ -2810,4 +2815,35 @@ protected DistributedChangeableProperty<Serializable> computeJobWorkerInterruptT
 
         return timeoutProperty;
     }
+
+    /** Clean work directory, excluding snapshot directory. */
+    protected IgniteEx restartWithCleanPersistence(int nodes, Collection<String> caches) throws Exception {
+        stopAllGrids();

Review Comment:
   OK.



;10/Feb/23 19:56;githubbot;600","timoninmaxim commented on code in PR #10527:
URL: https://github.com/apache/ignite/pull/10527#discussion_r1103866655


##########
modules/core/src/test/java/org/apache/ignite/testframework/junits/common/GridCommonAbstractTest.java:
##########
@@ -2810,4 +2815,35 @@ protected DistributedChangeableProperty<Serializable> computeJobWorkerInterruptT
 
         return timeoutProperty;
     }
+
+    /** Clean work directory, excluding snapshot directory. */
+    protected IgniteEx restartWithCleanPersistence(int nodes, Collection<String> caches) throws Exception {
+        stopAllGrids();
+
+        assertTrue(U.delete(Paths.get(U.defaultWorkDirectory(), ""cp"").toFile()));
+        assertTrue(U.delete(Paths.get(U.defaultWorkDirectory(), DFLT_MARSHALLER_PATH).toFile()));
+
+        deleteNodesDirs(nodes, DFLT_STORE_DIR, DFLT_BINARY_METADATA_PATH, DFLT_WAL_PATH, DFLT_WAL_ARCHIVE_PATH);
+
+        IgniteEx ign = startGrids(nodes);
+
+        ign.cluster().state(ClusterState.ACTIVE);
+
+        // Destroy caches configured with IgniteConfiguration before restoring snapshot.
+        ign.destroyCaches(caches);
+
+        awaitPartitionMapExchange();
+
+        return ign;
+    }
+
+    /** */
+    private void deleteNodesDirs(int nodes, String... dirs) throws IgniteCheckedException {

Review Comment:
   Remove this function at all. Reuse `cleanPersistenceDir` instead.



;12/Feb/23 19:59;githubbot;600","timoninmaxim commented on code in PR #10527:
URL: https://github.com/apache/ignite/pull/10527#discussion_r1103866694


##########
modules/core/src/test/java/org/apache/ignite/testframework/junits/common/GridCommonAbstractTest.java:
##########
@@ -2810,4 +2815,35 @@ protected DistributedChangeableProperty<Serializable> computeJobWorkerInterruptT
 
         return timeoutProperty;
     }
+
+    /** Clean work directory, excluding snapshot directory. */
+    protected IgniteEx restartWithCleanPersistence(int nodes, Collection<String> caches) throws Exception {
+        stopAllGrids();

Review Comment:
   Remove this function at all. Reuse `cleanPersistenceDir` instead.



;12/Feb/23 19:59;githubbot;600","timoninmaxim merged PR #10527:
URL: https://github.com/apache/ignite/pull/10527


;13/Feb/23 10:54;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,5400,,,0,5400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Feb 13 10:57:05 UTC 2023,,,,,,,,,,"0|z1fruw:",9223372036854775807,,,PetrovMikhail,,,,,,,,,,,,,,,,,,"09/Feb/23 09:51;ignitetcbot;{panel:title=Branch: [pull/10527/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10527/head] Base: [master] : New Tests (3)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Disk Page Compressions 1{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7040194]]
* {color:#013220}IgnitePdsCompressionTestSuite: IgniteClusterSnapshotRestoreSelfTest.testUserClassRestored[Encryption=false] - PASSED{color}

{color:#00008b}Snapshots{color} [[tests 2|https://ci2.ignite.apache.org/viewLog.html?buildId=7040507]]
* {color:#013220}IgniteSnapshotTestSuite: IgniteClusterSnapshotRestoreSelfTest.testUserClassRestored[Encryption=false] - PASSED{color}
* {color:#013220}IgniteSnapshotTestSuite: IgniteClusterSnapshotRestoreSelfTest.testUserClassRestored[Encryption=true] - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7040197&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","10/Feb/23 06:27;ignitetcbot;{panel:title=Branch: [pull/10527/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10527/head] Base: [master] : New Tests (3)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Disk Page Compressions 1{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7040194]]
* {color:#013220}IgnitePdsCompressionTestSuite: IgniteClusterSnapshotRestoreSelfTest.testUserClassRestored[Encryption=false] - PASSED{color}

{color:#00008b}Snapshots{color} [[tests 2|https://ci2.ignite.apache.org/viewLog.html?buildId=7040507]]
* {color:#013220}IgniteSnapshotTestSuite: IgniteClusterSnapshotRestoreSelfTest.testUserClassRestored[Encryption=false] - PASSED{color}
* {color:#013220}IgniteSnapshotTestSuite: IgniteClusterSnapshotRestoreSelfTest.testUserClassRestored[Encryption=true] - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7040197&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","13/Feb/23 10:53;ignitetcbot;{panel:title=Branch: [pull/10527/head] Base: [master] : Possible Blockers (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}
{color:#d04437}Platform .NET (Core Linux){color} [[tests 0 TIMEOUT , Exit Code , TC_SERVICE_MESSAGE |https://ci2.ignite.apache.org/viewLog.html?buildId=7047584]]

{panel}
{panel:title=Branch: [pull/10527/head] Base: [master] : New Tests (3)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Disk Page Compressions 1{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7047592]]
* {color:#013220}IgnitePdsCompressionTestSuite: IgniteClusterSnapshotRestoreSelfTest.testUserClassRestored[Encryption=false] - PASSED{color}

{color:#00008b}Snapshots{color} [[tests 2|https://ci2.ignite.apache.org/viewLog.html?buildId=7047616]]
* {color:#013220}IgniteSnapshotTestSuite: IgniteClusterSnapshotRestoreSelfTest.testUserClassRestored[Encryption=false] - PASSED{color}
* {color:#013220}IgniteSnapshotTestSuite: IgniteClusterSnapshotRestoreSelfTest.testUserClassRestored[Encryption=true] - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7046903&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","13/Feb/23 10:57;timonin.maksim;[~PetrovMikhail] thanks for review! Merged to master.;;;",,
Sql. TypeOf can short-circuit only when its argument is a constant expression.,IGNITE-18761,13523757,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,mzhuravkov,mzhuravkov,mzhuravkov,08/Feb/23 11:34,03/May/23 10:49,13/Jul/23 09:11,03/May/23 10:49,3.0.0-beta2,,,,,,,3.0.0-beta2,sql,,,0,calcite2-required,ignite-3,,"The current implement of typeof simply checks the type its operand but this is not correct because the operand maybe an invalid expression or a function that produces a side effect.
MRE:

{code:java}
assertThrows(RuntimeException.class, () -> assertQuery(""SELECT TYPEOF(CAST('NOT_A_NUMBER' AS INTEGER))"").check());
{code}
This query should return an error but it returns a string INTEGER.

",,mzhuravkov,,,,,"AMashenkov commented on code in PR #2000:
URL: https://github.com/apache/ignite-3/pull/2000#discussion_r1182379104


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItFunctionsTest.java:
##########
@@ -267,16 +271,40 @@ public void testTypeOf() {
         assertQuery(""SELECT TYPEOF('a'::varchar(1))"").returns(""VARCHAR(1)"").check();
         assertQuery(""SELECT TYPEOF(NULL)"").returns(""NULL"").check();
         assertQuery(""SELECT TYPEOF(NULL::VARCHAR(100))"").returns(""VARCHAR(100)"").check();
+        // A compound expression
+        assertQuery(""SELECT TYPEOF('abcd' || COALESCE('efg', ?))"").withParams(""2"").returns(""VARCHAR"").check();
+
+        // An expression that produces an error
+        IgniteException failed = assertThrows(IgniteException.class, () -> assertQuery(""SELECT typeof(CAST('NONE' as INTEGER))"").check());
+        assertSame(NumberFormatException.class, failed.getCause().getClass(), ""cause"");
+        assertThat(failed.getCause().getMessage(), containsString(""For input string: \""NONE\""""));
+
         try {
             sql(""SELECT TYPEOF()"");
+            fail();

Review Comment:
   assertThrowsWithCause(() -> sql(""SELECT TYPEOF()""), SqlValidatorException.class, ""Invalid number of arguments"");



;02/May/23 10:38;githubbot;600","AMashenkov commented on code in PR #2000:
URL: https://github.com/apache/ignite-3/pull/2000#discussion_r1182379104


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItFunctionsTest.java:
##########
@@ -267,16 +271,40 @@ public void testTypeOf() {
         assertQuery(""SELECT TYPEOF('a'::varchar(1))"").returns(""VARCHAR(1)"").check();
         assertQuery(""SELECT TYPEOF(NULL)"").returns(""NULL"").check();
         assertQuery(""SELECT TYPEOF(NULL::VARCHAR(100))"").returns(""VARCHAR(100)"").check();
+        // A compound expression
+        assertQuery(""SELECT TYPEOF('abcd' || COALESCE('efg', ?))"").withParams(""2"").returns(""VARCHAR"").check();
+
+        // An expression that produces an error
+        IgniteException failed = assertThrows(IgniteException.class, () -> assertQuery(""SELECT typeof(CAST('NONE' as INTEGER))"").check());
+        assertSame(NumberFormatException.class, failed.getCause().getClass(), ""cause"");
+        assertThat(failed.getCause().getMessage(), containsString(""For input string: \""NONE\""""));
+
         try {
             sql(""SELECT TYPEOF()"");
+            fail();

Review Comment:
   `IgniteTestUtils.assertThrowsWithCause(() -> sql(""SELECT TYPEOF()""), SqlValidatorException.class, ""Invalid number of arguments"");`



;02/May/23 10:42;githubbot;600","lowka commented on code in PR #2000:
URL: https://github.com/apache/ignite-3/pull/2000#discussion_r1183341193


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItFunctionsTest.java:
##########
@@ -267,16 +271,40 @@ public void testTypeOf() {
         assertQuery(""SELECT TYPEOF('a'::varchar(1))"").returns(""VARCHAR(1)"").check();
         assertQuery(""SELECT TYPEOF(NULL)"").returns(""NULL"").check();
         assertQuery(""SELECT TYPEOF(NULL::VARCHAR(100))"").returns(""VARCHAR(100)"").check();
+        // A compound expression
+        assertQuery(""SELECT TYPEOF('abcd' || COALESCE('efg', ?))"").withParams(""2"").returns(""VARCHAR"").check();
+
+        // An expression that produces an error
+        IgniteException failed = assertThrows(IgniteException.class, () -> assertQuery(""SELECT typeof(CAST('NONE' as INTEGER))"").check());
+        assertSame(NumberFormatException.class, failed.getCause().getClass(), ""cause"");
+        assertThat(failed.getCause().getMessage(), containsString(""For input string: \""NONE\""""));
+
         try {
             sql(""SELECT TYPEOF()"");
+            fail();

Review Comment:
   fixed.



;03/May/23 07:42;githubbot;600","AMashenkov merged PR #2000:
URL: https://github.com/apache/ignite-3/pull/2000


;03/May/23 10:49;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-02-08 11:34:48.0,,,,,,,,,,"0|z1frpk:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
Sql. Jdbc. ItJdbcResultSetSelfTest#testTimestamp fails locally but works on CI,IGNITE-18754,13523713,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,apolovtcev,mzhuravkov,mzhuravkov,08/Feb/23 06:30,03/Mar/23 08:58,13/Jul/23 09:11,03/Mar/23 08:58,,,,,,,,3.0.0-beta2,sql,,,0,calcite2-required,ignite-3,,"{code:java}
2023-02-02 20:06:47:409 +0400 [INFO][Test worker][ItJdbcResultSetSelfTest] >>> Stopping test: ItJdbcResultSetSelfTest#testTimestamp, displayName: testTimestamp(), cost: 58ms.

expected: <-10800000> but was: <-14400000>
Expected :-10800000
Actual   :-14400000

at app//org.apache.ignite.jdbc.ItJdbcResultSetSelfTest.testTimestamp(ItJdbcResultSetSelfTest.java:551)
{code}
",,korlov,mzhuravkov,,,,"sashapolo opened a new pull request, #1746:
URL: https://github.com/apache/ignite-3/pull/1746

   https://issues.apache.org/jira/browse/IGNITE-18754


;03/Mar/23 08:31;githubbot;600","korlov42 merged PR #1746:
URL: https://github.com/apache/ignite-3/pull/1746


;03/Mar/23 08:57;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Mar 03 08:58:05 UTC 2023,,,,,,,,,,"0|z1frfs:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"03/Mar/23 08:58;korlov;[~apolovtcev] , thanks for the contribution!

Merged to [main|https://github.com/apache/ignite-3/commit/23563c650f15942a8c39ac5c12f1f18ca9981326].;;;",,,,,
Sql. Conversion to relational algebra failed to preserve datatypes.,IGNITE-18753,13523712,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,zstan,mzhuravkov,mzhuravkov,08/Feb/23 06:26,10/Feb/23 10:23,13/Jul/23 09:11,10/Feb/23 10:23,,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"MRE:

{code:java}
@Test
public void testThis() {
    assertQuery(""SELECT ?::INTEGER = '8'"")
            .withParams(8)
            .returns(true)
            .check();
}
{code}

Output:
{code:java}
Conversion to relational algebra failed to preserve datatypes:
validated type:
RecordType(BOOLEAN NOT NULL EXPR$0) NOT NULL
converted type:
RecordType(BOOLEAN EXPR$0) NOT NULL
rel:
LogicalProject(EXPR$0=[=(?0, 8)])
  LogicalValues(tuples=[[{ 0 }]])

	at org.apache.calcite.sql2rel.SqlToRelConverter.checkConvertedType(SqlToRelConverter.java:492)
	at org.apache.calcite.sql2rel.SqlToRelConverter.convertQuery(SqlToRelConverter.java:607)
	at org.apache.ignite.internal.sql.engine.prepare.IgnitePlanner.rel(IgnitePlanner.java:222)
	at org.apache.ignite.internal.sql.engine.prepare.PlannerHelper.optimize(PlannerHelper.java:63)
	at org.apache.ignite.internal.sql.engine.prepare.PrepareServiceImpl.lambda$prepareExplain$0(PrepareServiceImpl.java:208)
{code}
It seems that nullability attribute is being lost somewhere at the validation stage.

The error does not depend on a type of a dynamic parameter because the query below also trigger the same assertion:

{code:java}
@Test
public void oops() {
    assertQuery(""SELECT ?::VARCHAR = '8'"")
            .withParams(""8"")
            .returns(true)
            .check();
}
{code}

P.S.
From the first glance it may look like it is related to dynamic parameters. This error is present in main branch.
Then I switched to commit that introduces IGNITE-18282: Illegal use of dynamic parameter exception in SQL functions (#1418) (November)  and commented out IgniteSqlValidator::inferUnknownTypes. And I still got this error.
",,mzhuravkov,zstan,,,,"zstan merged PR #1654:
URL: https://github.com/apache/ignite-3/pull/1654


;10/Feb/23 10:22;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,IGNITE-15559,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Feb 08 12:08:49 UTC 2023,,,,,,,,,,"0|z1frfk:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"08/Feb/23 12:08;zstan;[~mzhuravkov] can you make a review plz ?;;;",,,,,
.NET: Compute modificators are not reset properly after task execution.,IGNITE-18750,13523536,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,PetrovMikhail,PetrovMikhail,PetrovMikhail,07/Feb/23 16:56,13/Feb/23 12:36,13/Jul/23 09:11,13/Feb/23 12:36,,,,,,,,2.15,platforms,,,0,.NET,,,"Consider the followig exampte (It can be placed in ComputeApiTest to run it)
{code:java}
[Test]
        public void TestTaskOptionsPropagation()
        {
            ICompute compute = _grid1.GetCompute();
            
            compute.WithTimeout(500).Call(new ComputeFunc());

            compute.ExecuteJavaTask<object>(ComputeClientTests.TestTask, (long)1000);
        }
{code}
Currently compute.ExecuteJavaTask call will fail with timeout exception even no ""withTimeout"" modifier was applied.

It happens because during PlatformCompute#processInLongOutLong execution we apply task modifiers to both compute instances. As a result after
`compute.WithTimeout(500).Call(new ComputeFunc());` execution
`computeForPlatform` compute instance will reset its task modifiers and `compute`
comput instance will not.

So the next task execution after `compute.WithTimeout(500).Call(new ComputeFunc());` that uses `compute`instance will be executed with timout modifier applied even it was not applied by the user.",,ignitetcbot,PetrovMikhail,ptupitsyn,,,"petrov-mg opened a new pull request, #10523:
URL: https://github.com/apache/ignite/pull/10523

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;07/Feb/23 16:58;githubbot;600","petrov-mg merged PR #10523:
URL: https://github.com/apache/ignite/pull/10523


;13/Feb/23 12:33;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,IGNITE-18545,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Feb 13 12:35:52 UTC 2023,,,,,,,,,,"0|z1fqcg:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"13/Feb/23 12:29;ignitetcbot;{panel:title=Branch: [pull/10523/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10523/head] Base: [master] : New Tests (4)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Platform .NET (Core Linux){color} [[tests 2|https://ci.ignite.apache.org/viewLog.html?buildId=7072492]]
* {color:#013220}DotNetCore: ComputeApiTest.TestTaskOptionsPropagation - PASSED{color}
* {color:#013220}DotNetCore: ComputeApiTestFullFooter.TestTaskOptionsPropagation - PASSED{color}

{color:#00008b}Platform .NET (Windows){color} [[tests 2|https://ci.ignite.apache.org/viewLog.html?buildId=7072493]]
* {color:#013220}exe: ComputeApiTest.TestTaskOptionsPropagation - PASSED{color}
* {color:#013220}exe: ComputeApiTestFullFooter.TestTaskOptionsPropagation - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci.ignite.apache.org/viewLog.html?buildId=7072527&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","13/Feb/23 12:30;ignitetcbot;{panel:title=Branch: [pull/10523/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10523/head] Base: [master] : New Tests (4)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Platform .NET (Core Linux){color} [[tests 2|https://ci2.ignite.apache.org/viewLog.html?buildId=7046653]]
* {color:#013220}DotNetCore: ComputeApiTestFullFooter.TestTaskOptionsPropagation - PASSED{color}
* {color:#013220}DotNetCore: ComputeApiTest.TestTaskOptionsPropagation - PASSED{color}

{color:#00008b}Platform .NET (Windows){color} [[tests 2|https://ci2.ignite.apache.org/viewLog.html?buildId=7045795]]
* {color:#013220}exe: ComputeApiTestFullFooter.TestTaskOptionsPropagation - PASSED{color}
* {color:#013220}exe: ComputeApiTest.TestTaskOptionsPropagation - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7045829&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","13/Feb/23 12:35;PetrovMikhail;[~namelchev]  Thank you for the review.;;;",,,
Sql. Some muted slow tests failed after IGNITE-13022,IGNITE-18746,13523511,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,zstan,zstan,zstan,07/Feb/23 13:42,07/Mar/23 07:04,13/Jul/23 09:11,07/Mar/23 07:04,3.0.0-beta1,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"orderby1_10_7.test_slow failed after IGNITE-13022
it can be fixed by porting: https://issues.apache.org/jira/browse/IGNITE-17889
Probably in scope of this issue it would be helpful to fix code duplication :
RexUtils#buildHashSearchBounds(org.apache.calcite.plan.RelOptCluster, org.apache.calcite.rex.RexNode, org.apache.calcite.rel.type.RelDataType, org.apache.calcite.util.ImmutableBitSet)
RexUtils#buildHashSearchBounds(org.apache.calcite.plan.RelOptCluster, org.apache.calcite.rel.RelCollation, org.apache.calcite.rex.RexNode, org.apache.calcite.rel.type.RelDataType, org.apache.calcite.util.ImmutableBitSet)",,zstan,,,,,"AMashenkov commented on code in PR #1721:
URL: https://github.com/apache/ignite-3/pull/1721#discussion_r1121702498


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItSecondaryIndexTest.java:
##########
@@ -920,4 +947,249 @@ public void testNullCondition3() {
                 .returns(7, null)
                 .check();
     }
+
+    @Test
+    public void testNullsInCorrNestedLoopJoinSearchRow() throws InterruptedException {
+        try {
+            sql(""CREATE TABLE t(i0 INTEGER PRIMARY KEY, i1 INTEGER, i2 INTEGER)"");
+            sql(""CREATE INDEX t_idx ON t(i1)"");
+            // FIXME: https://issues.apache.org/jira/browse/IGNITE-18203
+            waitForIndex(""t_idx"");
+            sql(""INSERT INTO t VALUES (1, 0, null), (2, 1, null), (3, 2, 2), (4, 3, null), (5, 4, null), (6, null, 5)"");
+
+            List<RowCountingIndex> idxs = injectRowCountingIndex(""T"", ""T_IDX"");
+
+            String sql = ""SELECT /*+ DISABLE_RULE('NestedLoopJoinConverter', 'MergeJoinConverter') */ t1.i1, t2.i1 ""
+                    + ""FROM t t1 ""
+                    + ""LEFT JOIN t t2 ON t1.i2 = t2.i1"";
+
+            assertQuery(sql)

Review Comment:
   ```suggestion
               assertQuery(sql)
                   .disableRules('NestedLoopJoinConverter', 'MergeJoinConverter')
   ```



;01/Mar/23 13:09;githubbot;600","AMashenkov commented on code in PR #1721:
URL: https://github.com/apache/ignite-3/pull/1721#discussion_r1121720617


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/planner/IndexSearchBoundsPlannerTest.java:
##########
@@ -0,0 +1,510 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.sql.engine.planner;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.UUID;
+import java.util.function.Predicate;
+import java.util.stream.IntStream;
+import org.apache.calcite.rel.RelCollations;
+import org.apache.calcite.rel.type.RelDataTypeFactory;
+import org.apache.calcite.rex.RexLiteral;
+import org.apache.calcite.rex.RexNode;
+import org.apache.calcite.rex.RexUtil;
+import org.apache.calcite.sql.type.SqlTypeName;
+import org.apache.ignite.internal.index.ColumnCollation;
+import org.apache.ignite.internal.sql.engine.metadata.ColocationGroup;
+import org.apache.ignite.internal.sql.engine.prepare.MappingQueryContext;
+import org.apache.ignite.internal.sql.engine.prepare.bounds.ExactBounds;
+import org.apache.ignite.internal.sql.engine.prepare.bounds.MultiBounds;
+import org.apache.ignite.internal.sql.engine.prepare.bounds.RangeBounds;
+import org.apache.ignite.internal.sql.engine.prepare.bounds.SearchBounds;
+import org.apache.ignite.internal.sql.engine.rel.IgniteIndexScan;
+import org.apache.ignite.internal.sql.engine.rel.IgniteUnionAll;
+import org.apache.ignite.internal.sql.engine.schema.IgniteSchema;
+import org.apache.ignite.internal.sql.engine.trait.IgniteDistribution;
+import org.apache.ignite.internal.sql.engine.trait.IgniteDistributions;
+import org.apache.ignite.internal.sql.engine.trait.TraitUtils;
+import org.apache.ignite.internal.sql.engine.type.IgniteTypeFactory;
+import org.apache.ignite.internal.sql.engine.type.IgniteTypeSystem;
+import org.apache.ignite.internal.sql.engine.util.RexUtils;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Index bounds check tests.
+ */
+public class IndexSearchBoundsPlannerTest extends AbstractPlannerTest {
+    private static List<String> NODES = new ArrayList<>(4);
+
+    private IgniteSchema publicSchema;
+
+    private TestTable tbl;
+
+    @BeforeAll
+    public static void init() {
+        IntStream.rangeClosed(0, 3).forEach(i -> NODES.add(UUID.randomUUID().toString()));
+    }
+
+    @BeforeEach
+    public void beforeEach() {
+        IgniteTypeFactory typeFactory = new IgniteTypeFactory(IgniteTypeSystem.INSTANCE);
+
+        tbl = new TestTable(
+                new RelDataTypeFactory.Builder(typeFactory)
+                        .add(""C1"", typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.INTEGER), true))
+                        .add(""C2"", typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.VARCHAR), true))
+                        .add(""C3"", typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.INTEGER), true))
+                        .add(""C4"", typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.INTEGER), true))
+                        .build(), ""TEST"") {
+            @Override
+            public ColocationGroup colocationGroup(MappingQueryContext ctx) {
+                return ColocationGroup.forNodes(select(NODES, 0));
+            }
+
+            @Override
+            public IgniteDistribution distribution() {
+                return IgniteDistributions.single();
+            }
+        };
+
+        tbl.addIndex(""C1C2C3"", 0, 1, 2);
+
+        publicSchema = new IgniteSchema(""PUBLIC"");
+
+        publicSchema.addTable(tbl);
+    }
+
+    /** Simple case on one field, without multi tuple SEARCH/SARG. */
+    @Test
+    public void testBoundsOneFieldSingleTuple() throws Exception {
+        assertBounds(""SELECT * FROM TEST WHERE C1 = 1"", exact(1));
+
+        assertBounds(""SELECT * FROM TEST WHERE C1 = 1 AND C3 = 1"", exact(1), empty(), empty());
+
+        assertBounds(""SELECT * FROM TEST WHERE C1 > 1 AND C1 <= 3"",
+                range(1, 3, false, true));
+
+        assertBounds(""SELECT * FROM TEST WHERE C1 < 3 AND C1 IS NOT NULL"",
+                range(null, 3, true, false));
+
+        // Redundant ""IS NOT NULL condition"".
+        assertBounds(""SELECT * FROM TEST WHERE C1 > 3 AND C1 IS NOT NULL"",
+                range(3, ""$NULL_BOUND()"", false, false));
+
+        // C4 field not in collation.
+        assertBounds(""SELECT * FROM TEST WHERE C1 > 1 AND C1 <= 3 AND C4 = 1"",
+                range(1, 3, false, true),
+                empty(),
+                empty()
+        );
+
+        // Cannot proceed to C3 without C2.
+        assertBounds(""SELECT * FROM TEST WHERE C1 = 1 AND C3 = 1"",
+                exact(1),
+                empty(),
+                empty()
+        );
+
+        assertBounds(""SELECT * FROM TEST WHERE C1 > 1 AND C1 <= 3 AND C3 = 1"",
+                range(1, 3, false, true),
+                empty(),
+                empty()
+        );
+    }
+
+    /** Simple SEARCH/SARG. */
+    @Test
+    public void testBoundsOneFieldSearch() throws Exception {
+        assertBounds(""SELECT * FROM TEST WHERE C1 IN (1, 2, 3)"",
+                multi(exact(1), exact(2), exact(3)));
+
+        assertBounds(""SELECT * FROM TEST WHERE C1 IN (1, 2, 3) AND C1 IS NOT NULL"",

Review Comment:
   Will be IN condition merged with inequality?
   C1 IN (1, 2, 3) AND C1 > 1



;01/Mar/23 13:22;githubbot;600","AMashenkov commented on code in PR #1721:
URL: https://github.com/apache/ignite-3/pull/1721#discussion_r1121720617


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/planner/IndexSearchBoundsPlannerTest.java:
##########
@@ -0,0 +1,510 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.sql.engine.planner;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.UUID;
+import java.util.function.Predicate;
+import java.util.stream.IntStream;
+import org.apache.calcite.rel.RelCollations;
+import org.apache.calcite.rel.type.RelDataTypeFactory;
+import org.apache.calcite.rex.RexLiteral;
+import org.apache.calcite.rex.RexNode;
+import org.apache.calcite.rex.RexUtil;
+import org.apache.calcite.sql.type.SqlTypeName;
+import org.apache.ignite.internal.index.ColumnCollation;
+import org.apache.ignite.internal.sql.engine.metadata.ColocationGroup;
+import org.apache.ignite.internal.sql.engine.prepare.MappingQueryContext;
+import org.apache.ignite.internal.sql.engine.prepare.bounds.ExactBounds;
+import org.apache.ignite.internal.sql.engine.prepare.bounds.MultiBounds;
+import org.apache.ignite.internal.sql.engine.prepare.bounds.RangeBounds;
+import org.apache.ignite.internal.sql.engine.prepare.bounds.SearchBounds;
+import org.apache.ignite.internal.sql.engine.rel.IgniteIndexScan;
+import org.apache.ignite.internal.sql.engine.rel.IgniteUnionAll;
+import org.apache.ignite.internal.sql.engine.schema.IgniteSchema;
+import org.apache.ignite.internal.sql.engine.trait.IgniteDistribution;
+import org.apache.ignite.internal.sql.engine.trait.IgniteDistributions;
+import org.apache.ignite.internal.sql.engine.trait.TraitUtils;
+import org.apache.ignite.internal.sql.engine.type.IgniteTypeFactory;
+import org.apache.ignite.internal.sql.engine.type.IgniteTypeSystem;
+import org.apache.ignite.internal.sql.engine.util.RexUtils;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Index bounds check tests.
+ */
+public class IndexSearchBoundsPlannerTest extends AbstractPlannerTest {
+    private static List<String> NODES = new ArrayList<>(4);
+
+    private IgniteSchema publicSchema;
+
+    private TestTable tbl;
+
+    @BeforeAll
+    public static void init() {
+        IntStream.rangeClosed(0, 3).forEach(i -> NODES.add(UUID.randomUUID().toString()));
+    }
+
+    @BeforeEach
+    public void beforeEach() {
+        IgniteTypeFactory typeFactory = new IgniteTypeFactory(IgniteTypeSystem.INSTANCE);
+
+        tbl = new TestTable(
+                new RelDataTypeFactory.Builder(typeFactory)
+                        .add(""C1"", typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.INTEGER), true))
+                        .add(""C2"", typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.VARCHAR), true))
+                        .add(""C3"", typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.INTEGER), true))
+                        .add(""C4"", typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.INTEGER), true))
+                        .build(), ""TEST"") {
+            @Override
+            public ColocationGroup colocationGroup(MappingQueryContext ctx) {
+                return ColocationGroup.forNodes(select(NODES, 0));
+            }
+
+            @Override
+            public IgniteDistribution distribution() {
+                return IgniteDistributions.single();
+            }
+        };
+
+        tbl.addIndex(""C1C2C3"", 0, 1, 2);
+
+        publicSchema = new IgniteSchema(""PUBLIC"");
+
+        publicSchema.addTable(tbl);
+    }
+
+    /** Simple case on one field, without multi tuple SEARCH/SARG. */
+    @Test
+    public void testBoundsOneFieldSingleTuple() throws Exception {
+        assertBounds(""SELECT * FROM TEST WHERE C1 = 1"", exact(1));
+
+        assertBounds(""SELECT * FROM TEST WHERE C1 = 1 AND C3 = 1"", exact(1), empty(), empty());
+
+        assertBounds(""SELECT * FROM TEST WHERE C1 > 1 AND C1 <= 3"",
+                range(1, 3, false, true));
+
+        assertBounds(""SELECT * FROM TEST WHERE C1 < 3 AND C1 IS NOT NULL"",
+                range(null, 3, true, false));
+
+        // Redundant ""IS NOT NULL condition"".
+        assertBounds(""SELECT * FROM TEST WHERE C1 > 3 AND C1 IS NOT NULL"",
+                range(3, ""$NULL_BOUND()"", false, false));
+
+        // C4 field not in collation.
+        assertBounds(""SELECT * FROM TEST WHERE C1 > 1 AND C1 <= 3 AND C4 = 1"",
+                range(1, 3, false, true),
+                empty(),
+                empty()
+        );
+
+        // Cannot proceed to C3 without C2.
+        assertBounds(""SELECT * FROM TEST WHERE C1 = 1 AND C3 = 1"",
+                exact(1),
+                empty(),
+                empty()
+        );
+
+        assertBounds(""SELECT * FROM TEST WHERE C1 > 1 AND C1 <= 3 AND C3 = 1"",
+                range(1, 3, false, true),
+                empty(),
+                empty()
+        );
+    }
+
+    /** Simple SEARCH/SARG. */
+    @Test
+    public void testBoundsOneFieldSearch() throws Exception {
+        assertBounds(""SELECT * FROM TEST WHERE C1 IN (1, 2, 3)"",
+                multi(exact(1), exact(2), exact(3)));
+
+        assertBounds(""SELECT * FROM TEST WHERE C1 IN (1, 2, 3) AND C1 IS NOT NULL"",

Review Comment:
   Will be IN condition merged with inequality?
   
   C1 IN (1, 2, 3) AND C1 > 1
   
   C1 IN (1, 2, 3) OR C1 > 1



;01/Mar/23 13:23;githubbot;600","AMashenkov commented on code in PR #1721:
URL: https://github.com/apache/ignite-3/pull/1721#discussion_r1121720617


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/planner/IndexSearchBoundsPlannerTest.java:
##########
@@ -0,0 +1,510 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.sql.engine.planner;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.UUID;
+import java.util.function.Predicate;
+import java.util.stream.IntStream;
+import org.apache.calcite.rel.RelCollations;
+import org.apache.calcite.rel.type.RelDataTypeFactory;
+import org.apache.calcite.rex.RexLiteral;
+import org.apache.calcite.rex.RexNode;
+import org.apache.calcite.rex.RexUtil;
+import org.apache.calcite.sql.type.SqlTypeName;
+import org.apache.ignite.internal.index.ColumnCollation;
+import org.apache.ignite.internal.sql.engine.metadata.ColocationGroup;
+import org.apache.ignite.internal.sql.engine.prepare.MappingQueryContext;
+import org.apache.ignite.internal.sql.engine.prepare.bounds.ExactBounds;
+import org.apache.ignite.internal.sql.engine.prepare.bounds.MultiBounds;
+import org.apache.ignite.internal.sql.engine.prepare.bounds.RangeBounds;
+import org.apache.ignite.internal.sql.engine.prepare.bounds.SearchBounds;
+import org.apache.ignite.internal.sql.engine.rel.IgniteIndexScan;
+import org.apache.ignite.internal.sql.engine.rel.IgniteUnionAll;
+import org.apache.ignite.internal.sql.engine.schema.IgniteSchema;
+import org.apache.ignite.internal.sql.engine.trait.IgniteDistribution;
+import org.apache.ignite.internal.sql.engine.trait.IgniteDistributions;
+import org.apache.ignite.internal.sql.engine.trait.TraitUtils;
+import org.apache.ignite.internal.sql.engine.type.IgniteTypeFactory;
+import org.apache.ignite.internal.sql.engine.type.IgniteTypeSystem;
+import org.apache.ignite.internal.sql.engine.util.RexUtils;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Index bounds check tests.
+ */
+public class IndexSearchBoundsPlannerTest extends AbstractPlannerTest {
+    private static List<String> NODES = new ArrayList<>(4);
+
+    private IgniteSchema publicSchema;
+
+    private TestTable tbl;
+
+    @BeforeAll
+    public static void init() {
+        IntStream.rangeClosed(0, 3).forEach(i -> NODES.add(UUID.randomUUID().toString()));
+    }
+
+    @BeforeEach
+    public void beforeEach() {
+        IgniteTypeFactory typeFactory = new IgniteTypeFactory(IgniteTypeSystem.INSTANCE);
+
+        tbl = new TestTable(
+                new RelDataTypeFactory.Builder(typeFactory)
+                        .add(""C1"", typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.INTEGER), true))
+                        .add(""C2"", typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.VARCHAR), true))
+                        .add(""C3"", typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.INTEGER), true))
+                        .add(""C4"", typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.INTEGER), true))
+                        .build(), ""TEST"") {
+            @Override
+            public ColocationGroup colocationGroup(MappingQueryContext ctx) {
+                return ColocationGroup.forNodes(select(NODES, 0));
+            }
+
+            @Override
+            public IgniteDistribution distribution() {
+                return IgniteDistributions.single();
+            }
+        };
+
+        tbl.addIndex(""C1C2C3"", 0, 1, 2);
+
+        publicSchema = new IgniteSchema(""PUBLIC"");
+
+        publicSchema.addTable(tbl);
+    }
+
+    /** Simple case on one field, without multi tuple SEARCH/SARG. */
+    @Test
+    public void testBoundsOneFieldSingleTuple() throws Exception {
+        assertBounds(""SELECT * FROM TEST WHERE C1 = 1"", exact(1));
+
+        assertBounds(""SELECT * FROM TEST WHERE C1 = 1 AND C3 = 1"", exact(1), empty(), empty());
+
+        assertBounds(""SELECT * FROM TEST WHERE C1 > 1 AND C1 <= 3"",
+                range(1, 3, false, true));
+
+        assertBounds(""SELECT * FROM TEST WHERE C1 < 3 AND C1 IS NOT NULL"",
+                range(null, 3, true, false));
+
+        // Redundant ""IS NOT NULL condition"".
+        assertBounds(""SELECT * FROM TEST WHERE C1 > 3 AND C1 IS NOT NULL"",
+                range(3, ""$NULL_BOUND()"", false, false));
+
+        // C4 field not in collation.
+        assertBounds(""SELECT * FROM TEST WHERE C1 > 1 AND C1 <= 3 AND C4 = 1"",
+                range(1, 3, false, true),
+                empty(),
+                empty()
+        );
+
+        // Cannot proceed to C3 without C2.
+        assertBounds(""SELECT * FROM TEST WHERE C1 = 1 AND C3 = 1"",
+                exact(1),
+                empty(),
+                empty()
+        );
+
+        assertBounds(""SELECT * FROM TEST WHERE C1 > 1 AND C1 <= 3 AND C3 = 1"",
+                range(1, 3, false, true),
+                empty(),
+                empty()
+        );
+    }
+
+    /** Simple SEARCH/SARG. */
+    @Test
+    public void testBoundsOneFieldSearch() throws Exception {
+        assertBounds(""SELECT * FROM TEST WHERE C1 IN (1, 2, 3)"",
+                multi(exact(1), exact(2), exact(3)));
+
+        assertBounds(""SELECT * FROM TEST WHERE C1 IN (1, 2, 3) AND C1 IS NOT NULL"",

Review Comment:
   Will be IN condition merged with inequality?
   
   C1 IN (1, 2, 3) AND C1 > 1
   
   C1 IN (1, 2, 3) OR C1 > 1



;01/Mar/23 13:28;githubbot;600","ygerzhedovich commented on code in PR #1721:
URL: https://github.com/apache/ignite-3/pull/1721#discussion_r1124591676


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItJoinTest.java:
##########
@@ -794,17 +794,14 @@ public void testNatural(JoinType joinType) {
     @ParameterizedTest(name = ""join algo : {0}, index present: {1}"")
     @MethodSource(""joinTypes"")
     @WithSystemProperty(key = ""IMPLICIT_PK_ENABLED"", value = ""true"")
-    public void testIsNotDistinctFrom(JoinType joinType, boolean indexScan) {
-        if (indexScan) {
-            // TODO: https://issues.apache.org/jira/browse/IGNITE-18468 Index scan eventually return partial data.

Review Comment:
   should be the ticket IGNITE-18468 closed after merging the PR?



;03/Mar/23 15:11;githubbot;600","zstan closed pull request #1721: IGNITE-18746 Sql. Sargs implementation alignment
URL: https://github.com/apache/ignite-3/pull/1721


;07/Mar/23 07:04;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3600,,,0,3600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Feb 27 11:53:20 UTC 2023,,,,,,,,,,"0|z1fq6w:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"27/Feb/23 11:53;zstan;In scope of this issue additionally merged [1]

[1] https://issues.apache.org/jira/browse/IGNITE-13024
;;;",,,,,
ItLearnersTest Raft retry timeout is too small,IGNITE-18740,13523498,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,apolovtcev,apolovtcev,apolovtcev,07/Feb/23 12:22,07/Feb/23 13:26,13/Jul/23 09:11,07/Feb/23 13:26,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,ItLearnersTest#testChangePeersToAddLearnerToSameNodeAsPeer has become flaky (it fails with a TimeoutException). This is mostly likely caused by a custom Raft retry timeout value in the configuration (which was changed to speed up some tests). This timeout should be changed back to the default value.,,apolovtcev,,,,,"sashapolo opened a new pull request, #1647:
URL: https://github.com/apache/ignite-3/pull/1647

   [IGNITE-18740](https://issues.apache.org/jira/browse/IGNITE-18740)


;07/Feb/23 12:23;githubbot;600","ibessonov merged PR #1647:
URL: https://github.com/apache/ignite-3/pull/1647


;07/Feb/23 13:26;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-02-07 12:22:04.0,,,,,,,,,,"0|z1fq40:",9223372036854775807,,,maliev,,,,,,,,,,,,,,,,,,,,,,,
Tests from ItIgniteNodeRestartTest  became flaky  ,IGNITE-18737,13523479,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Sergey Uttsel,maliev,maliev,07/Feb/23 11:10,23/Feb/23 09:40,13/Jul/23 09:11,22/Feb/23 07:32,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"h3. *Motivation*

After https://issues.apache.org/jira/browse/IGNITE-18088 test from ItIgniteNodeRestartTest started to fail. Need to investigate the reason of fails
{noformat}
Caused by: java.util.concurrent.CancellationException
	at java.base/java.util.concurrent.CompletableFuture.cancel(CompletableFuture.java:2396)
	at org.apache.ignite.internal.raft.RaftGroupServiceImpl.sendWithRetry(RaftGroupServiceImpl.java:491)
	at org.apache.ignite.internal.raft.RaftGroupServiceImpl.sendWithRetry(RaftGroupServiceImpl.java:473)
	at org.apache.ignite.internal.raft.RaftGroupServiceImpl.refreshAndGetLeaderWithTerm(RaftGroupServiceImpl.java:232)
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.ensureReplicaIsPrimary(PartitionReplicaListener.java:1880)
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.invoke(PartitionReplicaListener.java:275)
	at org.apache.ignite.internal.replicator.Replica.processRequest(Replica.java:61)
	at org.apache.ignite.internal.replicator.ReplicaManager.lambda$new$5(ReplicaManager.java:162)
	at org.apache.ignite.network.DefaultMessagingService.sendToSelf(DefaultMessagingService.java:279)
	at org.apache.ignite.network.DefaultMessagingService.invoke0(DefaultMessagingService.java:226)
	at org.apache.ignite.network.DefaultMessagingService.invoke(DefaultMessagingService.java:154)
	at org.apache.ignite.internal.replicator.ReplicaService.sendToReplica(ReplicaService.java:91)
	at org.apache.ignite.internal.replicator.ReplicaService.invoke(ReplicaService.java:178)
	at org.apache.ignite.internal.tx.impl.TxManagerImpl.cleanup(TxManagerImpl.java:150)
	at org.apache.ignite.internal.table.distributed.replicator.PartitionReplicaListener.lambda$processTxFinishAction$42(PartitionReplicaListener.java:984)
	at java.base/java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:1072)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2073)
	at org.apache.ignite.internal.raft.RaftGroupServiceImpl.lambda$sendWithRetry$38(RaftGroupServiceImpl.java:526)
	at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859)
	at java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:837)
	at java.base/java.util.concurrent.CompletableFuture$Completion.exec(CompletableFuture.java:479)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1020)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1656)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1594)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183){noformat}
The root cause is that distribution zones data nodes watch listener in TableManager invokes updatePendingAssignmentsKeys with the same data nodes as in table configuration assignments so RaftGroupServiceImpl stops and new the same RaftGroupServiceImpl starts. It cancels invokes to old RaftGroupServiceImpl so we have CancellationException at sendWithRetry.
h3. *Implementation Notes*

It is not need to change the assignments if the calculated assignments equals to the assignments in the table configuration.",,maliev,,,,,"alievmirza opened a new pull request, #1646:
URL: https://github.com/apache/ignite-3/pull/1646

   https://issues.apache.org/jira/browse/IGNITE-18737


;07/Feb/23 11:17;githubbot;600","sanpwc merged PR #1646:
URL: https://github.com/apache/ignite-3/pull/1646


;07/Feb/23 11:55;githubbot;600","alievmirza commented on code in PR #1655:
URL: https://github.com/apache/ignite-3/pull/1655#discussion_r1104862325


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -1863,23 +1863,36 @@ public void onUpdate(WatchEvent evt) {
                         if (zoneId == tableZoneId) {
                             TableConfiguration tableCfg = tables.get(tableView.name());
 
+                            byte[] assignmentsBytes = ((ExtendedTableConfiguration) tableCfg).assignments().value();
+
+                            List<Set<Assignment>> tableAssignments = ByteUtils.fromBytes(assignmentsBytes);
+
                             for (int part = 0; part < tableView.partitions(); part++) {
                                 UUID tableId = ((ExtendedTableConfiguration) tableCfg).id().value();
 
                                 TablePartitionId replicaGrpId = new TablePartitionId(tableId, part);
 
-                                int partId = part;
+                                int replicas = tableView.replicas();
 
-                                updatePendingAssignmentsKeys(
-                                        tableView.name(), replicaGrpId, dataNodes, tableView.replicas(),
-                                        evt.entryEvent().newEntry().revision(), metaStorageMgr, part
-                                ).exceptionally(e -> {
-                                    LOG.error(
-                                            ""Exception on updating assignments for [table={}, partition={}]"", e, tableView.name(), partId
-                                    );
+                                Set<Assignment> partAssignments = AffinityUtils.calculateAssignmentForPartition(dataNodes, part, replicas);
+
+                                // TODO IGNITE-18624 This check will not be needed when dataNodes from distribution zone will be used

Review Comment:
   I would remove this todo, and leave this check in any cases, because, for example, we still can rewrite `dataNodes` with the same value, for example, when we start node and init data nodes from the Vauit with method `DistributionZoneManager#initDataNodesFromVaultManager`.



;13/Feb/23 18:21;githubbot;600","sanpwc commented on code in PR #1655:
URL: https://github.com/apache/ignite-3/pull/1655#discussion_r1105560862


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -1863,23 +1863,36 @@ public void onUpdate(WatchEvent evt) {
                         if (zoneId == tableZoneId) {
                             TableConfiguration tableCfg = tables.get(tableView.name());
 
+                            byte[] assignmentsBytes = ((ExtendedTableConfiguration) tableCfg).assignments().value();
+
+                            List<Set<Assignment>> tableAssignments = ByteUtils.fromBytes(assignmentsBytes);
+
                             for (int part = 0; part < tableView.partitions(); part++) {
                                 UUID tableId = ((ExtendedTableConfiguration) tableCfg).id().value();
 
                                 TablePartitionId replicaGrpId = new TablePartitionId(tableId, part);
 
-                                int partId = part;
+                                int replicas = tableView.replicas();
 
-                                updatePendingAssignmentsKeys(

Review Comment:
   Besides updating pending assignments inside updatePendingAssignmentsKeys we also update `partition.change.trigger.revision `. Should we update it even if won't update the assignments themselves?



;14/Feb/23 09:59;githubbot;600","sanpwc commented on code in PR #1655:
URL: https://github.com/apache/ignite-3/pull/1655#discussion_r1105562451


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -1863,23 +1863,36 @@ public void onUpdate(WatchEvent evt) {
                         if (zoneId == tableZoneId) {
                             TableConfiguration tableCfg = tables.get(tableView.name());
 
+                            byte[] assignmentsBytes = ((ExtendedTableConfiguration) tableCfg).assignments().value();
+
+                            List<Set<Assignment>> tableAssignments = ByteUtils.fromBytes(assignmentsBytes);
+
                             for (int part = 0; part < tableView.partitions(); part++) {
                                 UUID tableId = ((ExtendedTableConfiguration) tableCfg).id().value();
 
                                 TablePartitionId replicaGrpId = new TablePartitionId(tableId, part);
 
-                                int partId = part;
+                                int replicas = tableView.replicas();
 
-                                updatePendingAssignmentsKeys(
-                                        tableView.name(), replicaGrpId, dataNodes, tableView.replicas(),
-                                        evt.entryEvent().newEntry().revision(), metaStorageMgr, part
-                                ).exceptionally(e -> {
-                                    LOG.error(
-                                            ""Exception on updating assignments for [table={}, partition={}]"", e, tableView.name(), partId
-                                    );
+                                Set<Assignment> partAssignments = AffinityUtils.calculateAssignmentForPartition(dataNodes, part, replicas);

Review Comment:
   So, we will recalculate partAssignments twice, here and inside updatePendingAssignmentsKeys. Is it possible to have one calculation only?



##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -1863,23 +1863,36 @@ public void onUpdate(WatchEvent evt) {
                         if (zoneId == tableZoneId) {
                             TableConfiguration tableCfg = tables.get(tableView.name());
 
+                            byte[] assignmentsBytes = ((ExtendedTableConfiguration) tableCfg).assignments().value();
+
+                            List<Set<Assignment>> tableAssignments = ByteUtils.fromBytes(assignmentsBytes);
+
                             for (int part = 0; part < tableView.partitions(); part++) {
                                 UUID tableId = ((ExtendedTableConfiguration) tableCfg).id().value();
 
                                 TablePartitionId replicaGrpId = new TablePartitionId(tableId, part);
 
-                                int partId = part;
+                                int replicas = tableView.replicas();
 
-                                updatePendingAssignmentsKeys(
-                                        tableView.name(), replicaGrpId, dataNodes, tableView.replicas(),
-                                        evt.entryEvent().newEntry().revision(), metaStorageMgr, part
-                                ).exceptionally(e -> {
-                                    LOG.error(
-                                            ""Exception on updating assignments for [table={}, partition={}]"", e, tableView.name(), partId
-                                    );
+                                Set<Assignment> partAssignments = AffinityUtils.calculateAssignmentForPartition(dataNodes, part, replicas);

Review Comment:
   Why we check this only for assignments recalculation triggered by dataNodes change? Is it possible to face same issue in case of other updatePendingAssignmentsKeys triggers?



##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -1863,23 +1863,36 @@ public void onUpdate(WatchEvent evt) {
                         if (zoneId == tableZoneId) {
                             TableConfiguration tableCfg = tables.get(tableView.name());
 
+                            byte[] assignmentsBytes = ((ExtendedTableConfiguration) tableCfg).assignments().value();
+
+                            List<Set<Assignment>> tableAssignments = ByteUtils.fromBytes(assignmentsBytes);
+
                             for (int part = 0; part < tableView.partitions(); part++) {
                                 UUID tableId = ((ExtendedTableConfiguration) tableCfg).id().value();
 
                                 TablePartitionId replicaGrpId = new TablePartitionId(tableId, part);
 
-                                int partId = part;
+                                int replicas = tableView.replicas();
 
-                                updatePendingAssignmentsKeys(
-                                        tableView.name(), replicaGrpId, dataNodes, tableView.replicas(),
-                                        evt.entryEvent().newEntry().revision(), metaStorageMgr, part
-                                ).exceptionally(e -> {
-                                    LOG.error(
-                                            ""Exception on updating assignments for [table={}, partition={}]"", e, tableView.name(), partId
-                                    );
+                                Set<Assignment> partAssignments = AffinityUtils.calculateAssignmentForPartition(dataNodes, part, replicas);
+
+                                // TODO IGNITE-18624 This check will not be needed when dataNodes from distribution zone will be used
+                                // instead of BaselineManager.nodes.
+                                if (!partAssignments.equals(tableAssignments.get(part))) {
+                                    int partId = part;
 
-                                    return null;
-                                });
+                                    updatePendingAssignmentsKeys(

Review Comment:
   What if we already have pending rebalance and should add calculated ones as planned ones? I mean following:
   current A,B,C
   pending A,B
   new one that we've calculated, again A,B,C
   despite the fact that current == new one we shouldn't skip it.
   
   Please pay attention, that we have the logic similar to the one we want inside updatePendingAssignmentsKeys that checks assignments.stable and new assignments equality 
   `&& partition.assignments.stable != calcPartAssighments()`  



;14/Feb/23 10:07;githubbot;600","sanpwc commented on code in PR #1655:
URL: https://github.com/apache/ignite-3/pull/1655#discussion_r1109394339


##########
modules/table/src/test/java/org/apache/ignite/internal/utils/RebalanceUtilUpdateAssignmentsTest.java:
##########
@@ -0,0 +1,437 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.utils;
+
+import static java.util.stream.Collectors.toSet;
+import static org.apache.ignite.configuration.annotation.ConfigurationType.DISTRIBUTED;
+import static org.apache.ignite.internal.affinity.AffinityUtils.calculateAssignmentForPartition;
+import static org.apache.ignite.internal.util.ByteUtils.toBytes;
+import static org.apache.ignite.internal.utils.RebalanceUtil.pendingPartAssignmentsKey;
+import static org.apache.ignite.internal.utils.RebalanceUtil.plannedPartAssignmentsKey;
+import static org.apache.ignite.internal.utils.RebalanceUtil.stablePartAssignmentsKey;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.lenient;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.IntStream;
+import org.apache.ignite.internal.affinity.Assignment;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.storage.TestConfigurationStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZonesConfiguration;
+import org.apache.ignite.internal.logger.IgniteLogger;
+import org.apache.ignite.internal.logger.Loggers;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.command.MetaStorageCommandsFactory;
+import org.apache.ignite.internal.metastorage.command.MultiInvokeCommand;
+import org.apache.ignite.internal.metastorage.dsl.Iif;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.metastorage.server.raft.MetaStorageListener;
+import org.apache.ignite.internal.raft.Command;
+import org.apache.ignite.internal.raft.WriteCommand;
+import org.apache.ignite.internal.raft.service.CommandClosure;
+import org.apache.ignite.internal.raft.service.RaftGroupService;
+import org.apache.ignite.internal.table.distributed.replicator.TablePartitionId;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.util.ByteUtils;
+import org.apache.ignite.lang.IgniteInternalException;
+import org.apache.ignite.network.ClusterService;
+import org.apache.ignite.network.MessagingService;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.junit.jupiter.MockitoExtension;
+import org.mockito.junit.jupiter.MockitoSettings;
+import org.mockito.quality.Strictness;
+
+/**
+ * Tests for updating assignment in the meta storage.
+ */
+@ExtendWith({MockitoExtension.class, ConfigurationExtension.class})
+@MockitoSettings(strictness = Strictness.LENIENT)
+public class RebalanceUtilUpdateAssignmentsTest extends IgniteAbstractTest {
+    private static final IgniteLogger LOG = Loggers.forClass(RebalanceUtilUpdateAssignmentsTest.class);
+
+    private SimpleInMemoryKeyValueStorage keyValueStorage;
+
+    private ConfigurationManager clusterCfgMgr;
+
+    private ClusterService clusterService;
+
+    private MetaStorageManager metaStorageManager;
+
+    static int partNum = 2;

Review Comment:
   Related to all that static values:
   - Do you really need them to be non-private?
   - If not, what about converting them to constants?



##########
modules/table/src/test/java/org/apache/ignite/internal/utils/RebalanceUtilUpdateAssignmentsTest.java:
##########
@@ -0,0 +1,437 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.utils;
+
+import static java.util.stream.Collectors.toSet;
+import static org.apache.ignite.configuration.annotation.ConfigurationType.DISTRIBUTED;
+import static org.apache.ignite.internal.affinity.AffinityUtils.calculateAssignmentForPartition;
+import static org.apache.ignite.internal.util.ByteUtils.toBytes;
+import static org.apache.ignite.internal.utils.RebalanceUtil.pendingPartAssignmentsKey;
+import static org.apache.ignite.internal.utils.RebalanceUtil.plannedPartAssignmentsKey;
+import static org.apache.ignite.internal.utils.RebalanceUtil.stablePartAssignmentsKey;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.lenient;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.IntStream;
+import org.apache.ignite.internal.affinity.Assignment;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.storage.TestConfigurationStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZonesConfiguration;
+import org.apache.ignite.internal.logger.IgniteLogger;
+import org.apache.ignite.internal.logger.Loggers;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.command.MetaStorageCommandsFactory;
+import org.apache.ignite.internal.metastorage.command.MultiInvokeCommand;
+import org.apache.ignite.internal.metastorage.dsl.Iif;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.metastorage.server.raft.MetaStorageListener;
+import org.apache.ignite.internal.raft.Command;
+import org.apache.ignite.internal.raft.WriteCommand;
+import org.apache.ignite.internal.raft.service.CommandClosure;
+import org.apache.ignite.internal.raft.service.RaftGroupService;
+import org.apache.ignite.internal.table.distributed.replicator.TablePartitionId;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.util.ByteUtils;
+import org.apache.ignite.lang.IgniteInternalException;
+import org.apache.ignite.network.ClusterService;
+import org.apache.ignite.network.MessagingService;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.junit.jupiter.MockitoExtension;
+import org.mockito.junit.jupiter.MockitoSettings;
+import org.mockito.quality.Strictness;
+
+/**
+ * Tests for updating assignment in the meta storage.
+ */
+@ExtendWith({MockitoExtension.class, ConfigurationExtension.class})
+@MockitoSettings(strictness = Strictness.LENIENT)
+public class RebalanceUtilUpdateAssignmentsTest extends IgniteAbstractTest {
+    private static final IgniteLogger LOG = Loggers.forClass(RebalanceUtilUpdateAssignmentsTest.class);
+
+    private SimpleInMemoryKeyValueStorage keyValueStorage;
+
+    private ConfigurationManager clusterCfgMgr;
+
+    private ClusterService clusterService;
+
+    private MetaStorageManager metaStorageManager;
+
+    static int partNum = 2;
+    static int replicas = 2;
+
+    static Set<String> nodes1 = IntStream.of(5).mapToObj(i -> ""nodes1_"" + i).collect(toSet());
+    static Set<String> nodes2 = IntStream.of(5).mapToObj(i -> ""nodes2_"" + i).collect(toSet());
+    static Set<String> nodes3 = IntStream.of(5).mapToObj(i -> ""nodes3_"" + i).collect(toSet());
+    static Set<String> nodes4 = IntStream.of(5).mapToObj(i -> ""nodes4_"" + i).collect(toSet());
+
+    static Set<Assignment> assignments1 = calculateAssignmentForPartition(nodes1, partNum, replicas);
+    static Set<Assignment> assignments2 = calculateAssignmentForPartition(nodes2, partNum, replicas);
+    static Set<Assignment> assignments3 = calculateAssignmentForPartition(nodes3, partNum, replicas);
+    static Set<Assignment> assignments4 = calculateAssignmentForPartition(nodes4, partNum, replicas);
+
+    @BeforeEach

Review Comment:
   Why it's beforeEach and not beforeAll?



##########
modules/table/src/test/java/org/apache/ignite/internal/utils/RebalanceUtilUpdateAssignmentsTest.java:
##########
@@ -0,0 +1,437 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.utils;
+
+import static java.util.stream.Collectors.toSet;
+import static org.apache.ignite.configuration.annotation.ConfigurationType.DISTRIBUTED;
+import static org.apache.ignite.internal.affinity.AffinityUtils.calculateAssignmentForPartition;
+import static org.apache.ignite.internal.util.ByteUtils.toBytes;
+import static org.apache.ignite.internal.utils.RebalanceUtil.pendingPartAssignmentsKey;
+import static org.apache.ignite.internal.utils.RebalanceUtil.plannedPartAssignmentsKey;
+import static org.apache.ignite.internal.utils.RebalanceUtil.stablePartAssignmentsKey;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.lenient;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.IntStream;
+import org.apache.ignite.internal.affinity.Assignment;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.storage.TestConfigurationStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZonesConfiguration;
+import org.apache.ignite.internal.logger.IgniteLogger;
+import org.apache.ignite.internal.logger.Loggers;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.command.MetaStorageCommandsFactory;
+import org.apache.ignite.internal.metastorage.command.MultiInvokeCommand;
+import org.apache.ignite.internal.metastorage.dsl.Iif;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.metastorage.server.raft.MetaStorageListener;
+import org.apache.ignite.internal.raft.Command;
+import org.apache.ignite.internal.raft.WriteCommand;
+import org.apache.ignite.internal.raft.service.CommandClosure;
+import org.apache.ignite.internal.raft.service.RaftGroupService;
+import org.apache.ignite.internal.table.distributed.replicator.TablePartitionId;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.util.ByteUtils;
+import org.apache.ignite.lang.IgniteInternalException;
+import org.apache.ignite.network.ClusterService;
+import org.apache.ignite.network.MessagingService;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.junit.jupiter.MockitoExtension;
+import org.mockito.junit.jupiter.MockitoSettings;
+import org.mockito.quality.Strictness;
+
+/**
+ * Tests for updating assignment in the meta storage.
+ */
+@ExtendWith({MockitoExtension.class, ConfigurationExtension.class})
+@MockitoSettings(strictness = Strictness.LENIENT)
+public class RebalanceUtilUpdateAssignmentsTest extends IgniteAbstractTest {
+    private static final IgniteLogger LOG = Loggers.forClass(RebalanceUtilUpdateAssignmentsTest.class);
+
+    private SimpleInMemoryKeyValueStorage keyValueStorage;
+
+    private ConfigurationManager clusterCfgMgr;
+
+    private ClusterService clusterService;
+
+    private MetaStorageManager metaStorageManager;
+
+    static int partNum = 2;
+    static int replicas = 2;
+
+    static Set<String> nodes1 = IntStream.of(5).mapToObj(i -> ""nodes1_"" + i).collect(toSet());
+    static Set<String> nodes2 = IntStream.of(5).mapToObj(i -> ""nodes2_"" + i).collect(toSet());
+    static Set<String> nodes3 = IntStream.of(5).mapToObj(i -> ""nodes3_"" + i).collect(toSet());
+    static Set<String> nodes4 = IntStream.of(5).mapToObj(i -> ""nodes4_"" + i).collect(toSet());
+
+    static Set<Assignment> assignments1 = calculateAssignmentForPartition(nodes1, partNum, replicas);
+    static Set<Assignment> assignments2 = calculateAssignmentForPartition(nodes2, partNum, replicas);
+    static Set<Assignment> assignments3 = calculateAssignmentForPartition(nodes3, partNum, replicas);
+    static Set<Assignment> assignments4 = calculateAssignmentForPartition(nodes4, partNum, replicas);
+
+    @BeforeEach
+    public void setUp() {
+        clusterCfgMgr = new ConfigurationManager(
+                List.of(DistributionZonesConfiguration.KEY),
+                Set.of(),
+                new TestConfigurationStorage(DISTRIBUTED),
+                List.of(),
+                List.of()
+        );
+
+        clusterService = mock(ClusterService.class);
+
+        metaStorageManager = mock(MetaStorageManager.class);
+
+        clusterCfgMgr.start();

Review Comment:
   As a rule of thumb if you start something you need to stop it, and if you start the IgniteComponent you should also call beforeNodeStop before calling the stop.



;17/Feb/23 07:49;githubbot;600","sanpwc commented on code in PR #1655:
URL: https://github.com/apache/ignite-3/pull/1655#discussion_r1109405079


##########
modules/table/src/test/java/org/apache/ignite/internal/utils/RebalanceUtilUpdateAssignmentsTest.java:
##########
@@ -0,0 +1,437 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.utils;
+
+import static java.util.stream.Collectors.toSet;
+import static org.apache.ignite.configuration.annotation.ConfigurationType.DISTRIBUTED;
+import static org.apache.ignite.internal.affinity.AffinityUtils.calculateAssignmentForPartition;
+import static org.apache.ignite.internal.util.ByteUtils.toBytes;
+import static org.apache.ignite.internal.utils.RebalanceUtil.pendingPartAssignmentsKey;
+import static org.apache.ignite.internal.utils.RebalanceUtil.plannedPartAssignmentsKey;
+import static org.apache.ignite.internal.utils.RebalanceUtil.stablePartAssignmentsKey;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.lenient;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.IntStream;
+import org.apache.ignite.internal.affinity.Assignment;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.storage.TestConfigurationStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZonesConfiguration;
+import org.apache.ignite.internal.logger.IgniteLogger;
+import org.apache.ignite.internal.logger.Loggers;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.command.MetaStorageCommandsFactory;
+import org.apache.ignite.internal.metastorage.command.MultiInvokeCommand;
+import org.apache.ignite.internal.metastorage.dsl.Iif;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.metastorage.server.raft.MetaStorageListener;
+import org.apache.ignite.internal.raft.Command;
+import org.apache.ignite.internal.raft.WriteCommand;
+import org.apache.ignite.internal.raft.service.CommandClosure;
+import org.apache.ignite.internal.raft.service.RaftGroupService;
+import org.apache.ignite.internal.table.distributed.replicator.TablePartitionId;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.util.ByteUtils;
+import org.apache.ignite.lang.IgniteInternalException;
+import org.apache.ignite.network.ClusterService;
+import org.apache.ignite.network.MessagingService;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.junit.jupiter.MockitoExtension;
+import org.mockito.junit.jupiter.MockitoSettings;
+import org.mockito.quality.Strictness;
+
+/**
+ * Tests for updating assignment in the meta storage.
+ */
+@ExtendWith({MockitoExtension.class, ConfigurationExtension.class})
+@MockitoSettings(strictness = Strictness.LENIENT)
+public class RebalanceUtilUpdateAssignmentsTest extends IgniteAbstractTest {
+    private static final IgniteLogger LOG = Loggers.forClass(RebalanceUtilUpdateAssignmentsTest.class);
+
+    private SimpleInMemoryKeyValueStorage keyValueStorage;
+
+    private ConfigurationManager clusterCfgMgr;
+
+    private ClusterService clusterService;
+
+    private MetaStorageManager metaStorageManager;
+
+    static int partNum = 2;
+    static int replicas = 2;
+
+    static Set<String> nodes1 = IntStream.of(5).mapToObj(i -> ""nodes1_"" + i).collect(toSet());
+    static Set<String> nodes2 = IntStream.of(5).mapToObj(i -> ""nodes2_"" + i).collect(toSet());
+    static Set<String> nodes3 = IntStream.of(5).mapToObj(i -> ""nodes3_"" + i).collect(toSet());
+    static Set<String> nodes4 = IntStream.of(5).mapToObj(i -> ""nodes4_"" + i).collect(toSet());
+
+    static Set<Assignment> assignments1 = calculateAssignmentForPartition(nodes1, partNum, replicas);
+    static Set<Assignment> assignments2 = calculateAssignmentForPartition(nodes2, partNum, replicas);
+    static Set<Assignment> assignments3 = calculateAssignmentForPartition(nodes3, partNum, replicas);
+    static Set<Assignment> assignments4 = calculateAssignmentForPartition(nodes4, partNum, replicas);
+
+    @BeforeEach
+    public void setUp() {
+        clusterCfgMgr = new ConfigurationManager(
+                List.of(DistributionZonesConfiguration.KEY),
+                Set.of(),
+                new TestConfigurationStorage(DISTRIBUTED),
+                List.of(),
+                List.of()
+        );
+
+        clusterService = mock(ClusterService.class);
+
+        metaStorageManager = mock(MetaStorageManager.class);
+
+        clusterCfgMgr.start();
+
+        AtomicLong raftIndex = new AtomicLong();
+
+        keyValueStorage = spy(new SimpleInMemoryKeyValueStorage(""test""));
+
+        MetaStorageListener metaStorageListener = new MetaStorageListener(keyValueStorage);
+
+        RaftGroupService metaStorageService = mock(RaftGroupService.class);
+
+        // Delegate directly to listener.
+        lenient().doAnswer(
+                invocationClose -> {
+                    Command cmd = invocationClose.getArgument(0);
+
+                    long commandIndex = raftIndex.incrementAndGet();
+
+                    CompletableFuture<Serializable> res = new CompletableFuture<>();
+
+                    CommandClosure<WriteCommand> clo = new CommandClosure<>() {
+                        /** {@inheritDoc} */
+                        @Override
+                        public long index() {
+                            return commandIndex;
+                        }
+
+                        /** {@inheritDoc} */
+                        @Override
+                        public WriteCommand command() {
+                            return (WriteCommand) cmd;
+                        }
+
+                        /** {@inheritDoc} */
+                        @Override
+                        public void result(@Nullable Serializable r) {
+                            if (r instanceof Throwable) {
+                                res.completeExceptionally((Throwable) r);
+                            } else {
+                                res.complete(r);
+                            }
+                        }
+                    };
+
+                    try {
+                        metaStorageListener.onWrite(List.of(clo).iterator());
+                    } catch (Throwable e) {
+                        res.completeExceptionally(new IgniteInternalException(e));
+                    }
+
+                    return res;
+                }
+        ).when(metaStorageService).run(any());
+
+        MetaStorageCommandsFactory commandsFactory = new MetaStorageCommandsFactory();
+
+        lenient().doAnswer(invocationClose -> {
+            Iif iif = invocationClose.getArgument(0);
+
+            MultiInvokeCommand multiInvokeCommand = commandsFactory.multiInvokeCommand().iif(iif).build();
+
+            return metaStorageService.run(multiInvokeCommand);
+        }).when(metaStorageManager).invoke(any());
+
+        when(clusterService.messagingService()).thenAnswer(invocation -> {
+            MessagingService ret = mock(MessagingService.class);
+
+            return ret;
+        });
+    }
+
+    @Test
+    void test1() {
+        test(
+                nodes1, assignments2,
+                null, null, null,
+                null, assignments1, null
+        );
+    }
+
+    /**
+     * Impossible invariant in real environment.
+     */
+    @Test
+    void test2() {
+        test(
+                nodes1, assignments1,
+                null, null, null,
+                null, null, null
+        );
+    }
+
+    @Test
+    void test3() {
+        test(
+                nodes1, assignments2,
+                null, assignments3, null,
+                null, assignments3, assignments1
+        );
+    }
+
+    @Test
+    void test4() {
+        test(
+                nodes1, assignments1,
+                null, assignments3, null,
+                null, assignments3, assignments1
+        );
+    }
+
+    @Test
+    void test5() {
+        test(
+                nodes1, assignments2,
+                assignments3, null, null,
+                assignments3, assignments1, null
+        );
+    }
+
+    @Test
+    void test6() {
+        test(
+                nodes1, assignments1,
+                assignments3, null, null,
+                assignments3, assignments1, null
+        );
+    }
+
+    @Test
+    void test7() {
+        test(
+                nodes1, assignments2,
+                assignments1, null, null,
+                assignments1, null, null
+        );
+    }
+
+    @Test
+    void test8() {
+        test(
+                nodes1, assignments1,
+                assignments1, null, null,
+                assignments1, null, null
+        );
+    }
+
+    @Test
+    void test9() {
+        test(
+                nodes1, assignments2,
+                assignments2, null, null,
+                assignments2, assignments1, null
+        );
+    }
+
+    @Test
+    void test10() {
+        test(
+                nodes1, assignments2,
+                assignments4, assignments3, null,
+                assignments4, assignments3, assignments1
+        );
+    }
+
+    @Test
+    void test11() {
+        test(
+                nodes1, assignments1,
+                assignments3, assignments2, null,
+                assignments3, assignments2, assignments1
+        );
+    }
+
+    @Test
+    void test12() {
+        test(
+                nodes1, assignments2,
+                assignments1, assignments3, null,
+                assignments1, assignments3, assignments1
+        );
+    }
+
+    @Test
+    void test13() {
+        test(
+                nodes1, assignments2,
+                assignments2, assignments3, null,
+                assignments2, assignments3, assignments1
+        );
+    }
+
+    /**
+     * Nodes for new assignments calculating: nodes1.
+     * The table configuration assignments: assignments1.
+     * Current assignments in the metastorage: stable=assignments1, pending=assignments2, planned=null.
+     * Expected assignments in the metastorage after updating: stable=assignments1, pending=assignments2, planned=assignments1.
+     */
+    @Test

Review Comment:
   Why we only have the javadoc for test14?



;17/Feb/23 07:54;githubbot;600","sanpwc commented on code in PR #1655:
URL: https://github.com/apache/ignite-3/pull/1655#discussion_r1109425014


##########
modules/table/src/test/java/org/apache/ignite/internal/utils/RebalanceUtilUpdateAssignmentsTest.java:
##########
@@ -0,0 +1,437 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.utils;
+
+import static java.util.stream.Collectors.toSet;
+import static org.apache.ignite.configuration.annotation.ConfigurationType.DISTRIBUTED;
+import static org.apache.ignite.internal.affinity.AffinityUtils.calculateAssignmentForPartition;
+import static org.apache.ignite.internal.util.ByteUtils.toBytes;
+import static org.apache.ignite.internal.utils.RebalanceUtil.pendingPartAssignmentsKey;
+import static org.apache.ignite.internal.utils.RebalanceUtil.plannedPartAssignmentsKey;
+import static org.apache.ignite.internal.utils.RebalanceUtil.stablePartAssignmentsKey;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.lenient;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.IntStream;
+import org.apache.ignite.internal.affinity.Assignment;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.storage.TestConfigurationStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZonesConfiguration;
+import org.apache.ignite.internal.logger.IgniteLogger;
+import org.apache.ignite.internal.logger.Loggers;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.command.MetaStorageCommandsFactory;
+import org.apache.ignite.internal.metastorage.command.MultiInvokeCommand;
+import org.apache.ignite.internal.metastorage.dsl.Iif;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.metastorage.server.raft.MetaStorageListener;
+import org.apache.ignite.internal.raft.Command;
+import org.apache.ignite.internal.raft.WriteCommand;
+import org.apache.ignite.internal.raft.service.CommandClosure;
+import org.apache.ignite.internal.raft.service.RaftGroupService;
+import org.apache.ignite.internal.table.distributed.replicator.TablePartitionId;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.util.ByteUtils;
+import org.apache.ignite.lang.IgniteInternalException;
+import org.apache.ignite.network.ClusterService;
+import org.apache.ignite.network.MessagingService;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.junit.jupiter.MockitoExtension;
+import org.mockito.junit.jupiter.MockitoSettings;
+import org.mockito.quality.Strictness;
+
+/**
+ * Tests for updating assignment in the meta storage.
+ */
+@ExtendWith({MockitoExtension.class, ConfigurationExtension.class})
+@MockitoSettings(strictness = Strictness.LENIENT)
+public class RebalanceUtilUpdateAssignmentsTest extends IgniteAbstractTest {
+    private static final IgniteLogger LOG = Loggers.forClass(RebalanceUtilUpdateAssignmentsTest.class);
+
+    private SimpleInMemoryKeyValueStorage keyValueStorage;
+
+    private ConfigurationManager clusterCfgMgr;
+
+    private ClusterService clusterService;
+
+    private MetaStorageManager metaStorageManager;
+
+    static int partNum = 2;
+    static int replicas = 2;
+
+    static Set<String> nodes1 = IntStream.of(5).mapToObj(i -> ""nodes1_"" + i).collect(toSet());
+    static Set<String> nodes2 = IntStream.of(5).mapToObj(i -> ""nodes2_"" + i).collect(toSet());
+    static Set<String> nodes3 = IntStream.of(5).mapToObj(i -> ""nodes3_"" + i).collect(toSet());
+    static Set<String> nodes4 = IntStream.of(5).mapToObj(i -> ""nodes4_"" + i).collect(toSet());
+
+    static Set<Assignment> assignments1 = calculateAssignmentForPartition(nodes1, partNum, replicas);
+    static Set<Assignment> assignments2 = calculateAssignmentForPartition(nodes2, partNum, replicas);
+    static Set<Assignment> assignments3 = calculateAssignmentForPartition(nodes3, partNum, replicas);
+    static Set<Assignment> assignments4 = calculateAssignmentForPartition(nodes4, partNum, replicas);
+
+    @BeforeEach
+    public void setUp() {
+        clusterCfgMgr = new ConfigurationManager(
+                List.of(DistributionZonesConfiguration.KEY),
+                Set.of(),
+                new TestConfigurationStorage(DISTRIBUTED),
+                List.of(),
+                List.of()
+        );
+
+        clusterService = mock(ClusterService.class);
+
+        metaStorageManager = mock(MetaStorageManager.class);
+
+        clusterCfgMgr.start();
+
+        AtomicLong raftIndex = new AtomicLong();
+
+        keyValueStorage = spy(new SimpleInMemoryKeyValueStorage(""test""));
+
+        MetaStorageListener metaStorageListener = new MetaStorageListener(keyValueStorage);
+
+        RaftGroupService metaStorageService = mock(RaftGroupService.class);
+
+        // Delegate directly to listener.
+        lenient().doAnswer(
+                invocationClose -> {
+                    Command cmd = invocationClose.getArgument(0);
+
+                    long commandIndex = raftIndex.incrementAndGet();
+
+                    CompletableFuture<Serializable> res = new CompletableFuture<>();
+
+                    CommandClosure<WriteCommand> clo = new CommandClosure<>() {
+                        /** {@inheritDoc} */
+                        @Override
+                        public long index() {
+                            return commandIndex;
+                        }
+
+                        /** {@inheritDoc} */
+                        @Override
+                        public WriteCommand command() {
+                            return (WriteCommand) cmd;
+                        }
+
+                        /** {@inheritDoc} */
+                        @Override
+                        public void result(@Nullable Serializable r) {
+                            if (r instanceof Throwable) {
+                                res.completeExceptionally((Throwable) r);
+                            } else {
+                                res.complete(r);
+                            }
+                        }
+                    };
+
+                    try {
+                        metaStorageListener.onWrite(List.of(clo).iterator());
+                    } catch (Throwable e) {
+                        res.completeExceptionally(new IgniteInternalException(e));
+                    }
+
+                    return res;
+                }
+        ).when(metaStorageService).run(any());
+
+        MetaStorageCommandsFactory commandsFactory = new MetaStorageCommandsFactory();
+
+        lenient().doAnswer(invocationClose -> {
+            Iif iif = invocationClose.getArgument(0);
+
+            MultiInvokeCommand multiInvokeCommand = commandsFactory.multiInvokeCommand().iif(iif).build();
+
+            return metaStorageService.run(multiInvokeCommand);
+        }).when(metaStorageManager).invoke(any());
+
+        when(clusterService.messagingService()).thenAnswer(invocation -> {
+            MessagingService ret = mock(MessagingService.class);
+
+            return ret;
+        });
+    }
+
+    @Test
+    void test1() {
+        test(
+                nodes1, assignments2,
+                null, null, null,
+                null, assignments1, null
+        );
+    }
+
+    /**
+     * Impossible invariant in real environment.
+     */
+    @Test
+    void test2() {
+        test(
+                nodes1, assignments1,
+                null, null, null,
+                null, null, null
+        );
+    }
+
+    @Test
+    void test3() {
+        test(
+                nodes1, assignments2,
+                null, assignments3, null,
+                null, assignments3, assignments1
+        );
+    }
+
+    @Test
+    void test4() {
+        test(
+                nodes1, assignments1,
+                null, assignments3, null,
+                null, assignments3, assignments1
+        );
+    }
+
+    @Test
+    void test5() {
+        test(
+                nodes1, assignments2,
+                assignments3, null, null,
+                assignments3, assignments1, null
+        );
+    }
+
+    @Test
+    void test6() {
+        test(
+                nodes1, assignments1,
+                assignments3, null, null,
+                assignments3, assignments1, null
+        );
+    }
+
+    @Test
+    void test7() {
+        test(
+                nodes1, assignments2,
+                assignments1, null, null,
+                assignments1, null, null
+        );
+    }
+
+    @Test
+    void test8() {
+        test(
+                nodes1, assignments1,
+                assignments1, null, null,
+                assignments1, null, null
+        );
+    }
+
+    @Test
+    void test9() {
+        test(
+                nodes1, assignments2,
+                assignments2, null, null,
+                assignments2, assignments1, null
+        );
+    }
+
+    @Test
+    void test10() {
+        test(
+                nodes1, assignments2,
+                assignments4, assignments3, null,
+                assignments4, assignments3, assignments1
+        );
+    }
+
+    @Test
+    void test11() {
+        test(
+                nodes1, assignments1,
+                assignments3, assignments2, null,
+                assignments3, assignments2, assignments1
+        );
+    }
+
+    @Test
+    void test12() {
+        test(
+                nodes1, assignments2,
+                assignments1, assignments3, null,
+                assignments1, assignments3, assignments1
+        );
+    }
+
+    @Test
+    void test13() {
+        test(
+                nodes1, assignments2,
+                assignments2, assignments3, null,
+                assignments2, assignments3, assignments1
+        );
+    }
+
+    /**
+     * Nodes for new assignments calculating: nodes1.
+     * The table configuration assignments: assignments1.
+     * Current assignments in the metastorage: stable=assignments1, pending=assignments2, planned=null.
+     * Expected assignments in the metastorage after updating: stable=assignments1, pending=assignments2, planned=assignments1.
+     */
+    @Test
+    void test14() {
+        test(
+                nodes1, assignments1,
+                assignments1, assignments2, null,
+                assignments1, assignments2, assignments1
+        );
+    }
+
+    @Test
+    void test15() {
+        test(
+                nodes1, assignments1,
+                assignments1, assignments2, assignments3,
+                assignments1, assignments2, assignments1
+        );
+    }
+
+    @Test
+    void test16() {
+        test(
+                nodes1, assignments4,
+                assignments1, assignments2, assignments1,
+                assignments1, assignments2, assignments1
+        );
+    }
+
+    @Test
+    void test17() {
+        test(
+                nodes2, assignments2,
+                assignments1, assignments2, assignments1,
+                assignments1, assignments2, null
+        );
+    }
+
+    @Test
+    void test18() {
+        test(
+                nodes2, assignments4,
+                assignments1, assignments2, assignments1,
+                assignments1, assignments2, null
+        );
+    }
+
+    private void test(
+            Collection<String> nodesForNewAssignments,
+            Set<Assignment> tableCfgAssignments,
+            Set<Assignment> currentStableAssignments,
+            Set<Assignment> currentPendingAssignments,
+            Set<Assignment> currentPlannedAssignments,
+            Set<Assignment> expectedStableAssignments,
+            Set<Assignment> expectedPendingAssignments,
+            Set<Assignment> expectedPlannedAssignments
+    ) {
+        TablePartitionId tablePartitionId = new TablePartitionId(UUID.randomUUID(), 1);
+
+        if (currentStableAssignments != null) {
+            keyValueStorage.put(stablePartAssignmentsKey(tablePartitionId).bytes(), toBytes(currentStableAssignments));
+        }
+
+        if (currentPendingAssignments != null) {
+            keyValueStorage.put(pendingPartAssignmentsKey(tablePartitionId).bytes(), toBytes(currentPendingAssignments));
+        }
+
+        if (currentPlannedAssignments != null) {
+            keyValueStorage.put(plannedPartAssignmentsKey(tablePartitionId).bytes(), toBytes(currentPlannedAssignments));
+        }
+
+        RebalanceUtil.updatePendingAssignmentsKeys(
+                ""table1"", tablePartitionId, nodesForNewAssignments,
+                replicas, 1, metaStorageManager, partNum, tableCfgAssignments
+        );
+
+        byte[] actualStableBytes = keyValueStorage.get(stablePartAssignmentsKey(tablePartitionId).bytes()).value();
+        Set<Assignment> actualStableAssignments = null;
+
+        if (actualStableBytes != null) {
+            actualStableAssignments = ByteUtils.fromBytes(actualStableBytes);
+        }
+
+        byte[] actualPendingBytes = keyValueStorage.get(pendingPartAssignmentsKey(tablePartitionId).bytes()).value();
+        Set<Assignment> actualPendingAssignments = null;
+
+        if (actualPendingBytes != null) {
+            actualPendingAssignments = ByteUtils.fromBytes(actualPendingBytes);
+        }
+
+        byte[] actualPlannedBytes = keyValueStorage.get(plannedPartAssignmentsKey(tablePartitionId).bytes()).value();
+        Set<Assignment> actualPlannedAssignments = null;
+
+        if (actualPlannedBytes != null) {
+            actualPlannedAssignments = ByteUtils.fromBytes(actualPlannedBytes);
+        }
+
+        LOG.info(""stableAssignments "" + actualStableAssignments);
+        LOG.info(""pendingAssignments "" + actualPendingAssignments);
+        LOG.info(""plannedAssignments "" + actualPlannedAssignments);
+
+        if (expectedStableAssignments != null) {
+            assertNotNull(actualStableBytes);
+            assertTrue(actualStableAssignments.containsAll(expectedStableAssignments));

Review Comment:
   what about assertEquals



##########
modules/table/src/test/java/org/apache/ignite/internal/utils/RebalanceUtilUpdateAssignmentsTest.java:
##########
@@ -0,0 +1,437 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.utils;
+
+import static java.util.stream.Collectors.toSet;
+import static org.apache.ignite.configuration.annotation.ConfigurationType.DISTRIBUTED;
+import static org.apache.ignite.internal.affinity.AffinityUtils.calculateAssignmentForPartition;
+import static org.apache.ignite.internal.util.ByteUtils.toBytes;
+import static org.apache.ignite.internal.utils.RebalanceUtil.pendingPartAssignmentsKey;
+import static org.apache.ignite.internal.utils.RebalanceUtil.plannedPartAssignmentsKey;
+import static org.apache.ignite.internal.utils.RebalanceUtil.stablePartAssignmentsKey;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.lenient;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.IntStream;
+import org.apache.ignite.internal.affinity.Assignment;
+import org.apache.ignite.internal.configuration.ConfigurationManager;
+import org.apache.ignite.internal.configuration.storage.TestConfigurationStorage;
+import org.apache.ignite.internal.configuration.testframework.ConfigurationExtension;
+import org.apache.ignite.internal.distributionzones.configuration.DistributionZonesConfiguration;
+import org.apache.ignite.internal.logger.IgniteLogger;
+import org.apache.ignite.internal.logger.Loggers;
+import org.apache.ignite.internal.metastorage.MetaStorageManager;
+import org.apache.ignite.internal.metastorage.command.MetaStorageCommandsFactory;
+import org.apache.ignite.internal.metastorage.command.MultiInvokeCommand;
+import org.apache.ignite.internal.metastorage.dsl.Iif;
+import org.apache.ignite.internal.metastorage.server.SimpleInMemoryKeyValueStorage;
+import org.apache.ignite.internal.metastorage.server.raft.MetaStorageListener;
+import org.apache.ignite.internal.raft.Command;
+import org.apache.ignite.internal.raft.WriteCommand;
+import org.apache.ignite.internal.raft.service.CommandClosure;
+import org.apache.ignite.internal.raft.service.RaftGroupService;
+import org.apache.ignite.internal.table.distributed.replicator.TablePartitionId;
+import org.apache.ignite.internal.testframework.IgniteAbstractTest;
+import org.apache.ignite.internal.util.ByteUtils;
+import org.apache.ignite.lang.IgniteInternalException;
+import org.apache.ignite.network.ClusterService;
+import org.apache.ignite.network.MessagingService;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.junit.jupiter.MockitoExtension;
+import org.mockito.junit.jupiter.MockitoSettings;
+import org.mockito.quality.Strictness;
+
+/**
+ * Tests for updating assignment in the meta storage.
+ */
+@ExtendWith({MockitoExtension.class, ConfigurationExtension.class})
+@MockitoSettings(strictness = Strictness.LENIENT)
+public class RebalanceUtilUpdateAssignmentsTest extends IgniteAbstractTest {
+    private static final IgniteLogger LOG = Loggers.forClass(RebalanceUtilUpdateAssignmentsTest.class);
+
+    private SimpleInMemoryKeyValueStorage keyValueStorage;
+
+    private ConfigurationManager clusterCfgMgr;
+
+    private ClusterService clusterService;
+
+    private MetaStorageManager metaStorageManager;
+
+    static int partNum = 2;
+    static int replicas = 2;
+
+    static Set<String> nodes1 = IntStream.of(5).mapToObj(i -> ""nodes1_"" + i).collect(toSet());
+    static Set<String> nodes2 = IntStream.of(5).mapToObj(i -> ""nodes2_"" + i).collect(toSet());
+    static Set<String> nodes3 = IntStream.of(5).mapToObj(i -> ""nodes3_"" + i).collect(toSet());
+    static Set<String> nodes4 = IntStream.of(5).mapToObj(i -> ""nodes4_"" + i).collect(toSet());
+
+    static Set<Assignment> assignments1 = calculateAssignmentForPartition(nodes1, partNum, replicas);
+    static Set<Assignment> assignments2 = calculateAssignmentForPartition(nodes2, partNum, replicas);
+    static Set<Assignment> assignments3 = calculateAssignmentForPartition(nodes3, partNum, replicas);
+    static Set<Assignment> assignments4 = calculateAssignmentForPartition(nodes4, partNum, replicas);
+
+    @BeforeEach
+    public void setUp() {
+        clusterCfgMgr = new ConfigurationManager(
+                List.of(DistributionZonesConfiguration.KEY),
+                Set.of(),
+                new TestConfigurationStorage(DISTRIBUTED),
+                List.of(),
+                List.of()
+        );
+
+        clusterService = mock(ClusterService.class);
+
+        metaStorageManager = mock(MetaStorageManager.class);
+
+        clusterCfgMgr.start();
+
+        AtomicLong raftIndex = new AtomicLong();
+
+        keyValueStorage = spy(new SimpleInMemoryKeyValueStorage(""test""));
+
+        MetaStorageListener metaStorageListener = new MetaStorageListener(keyValueStorage);
+
+        RaftGroupService metaStorageService = mock(RaftGroupService.class);
+
+        // Delegate directly to listener.
+        lenient().doAnswer(
+                invocationClose -> {
+                    Command cmd = invocationClose.getArgument(0);
+
+                    long commandIndex = raftIndex.incrementAndGet();
+
+                    CompletableFuture<Serializable> res = new CompletableFuture<>();
+
+                    CommandClosure<WriteCommand> clo = new CommandClosure<>() {
+                        /** {@inheritDoc} */
+                        @Override
+                        public long index() {
+                            return commandIndex;
+                        }
+
+                        /** {@inheritDoc} */
+                        @Override
+                        public WriteCommand command() {
+                            return (WriteCommand) cmd;
+                        }
+
+                        /** {@inheritDoc} */
+                        @Override
+                        public void result(@Nullable Serializable r) {
+                            if (r instanceof Throwable) {
+                                res.completeExceptionally((Throwable) r);
+                            } else {
+                                res.complete(r);
+                            }
+                        }
+                    };
+
+                    try {
+                        metaStorageListener.onWrite(List.of(clo).iterator());
+                    } catch (Throwable e) {
+                        res.completeExceptionally(new IgniteInternalException(e));
+                    }
+
+                    return res;
+                }
+        ).when(metaStorageService).run(any());
+
+        MetaStorageCommandsFactory commandsFactory = new MetaStorageCommandsFactory();
+
+        lenient().doAnswer(invocationClose -> {
+            Iif iif = invocationClose.getArgument(0);
+
+            MultiInvokeCommand multiInvokeCommand = commandsFactory.multiInvokeCommand().iif(iif).build();
+
+            return metaStorageService.run(multiInvokeCommand);
+        }).when(metaStorageManager).invoke(any());
+
+        when(clusterService.messagingService()).thenAnswer(invocation -> {
+            MessagingService ret = mock(MessagingService.class);
+
+            return ret;
+        });
+    }
+
+    @Test
+    void test1() {
+        test(
+                nodes1, assignments2,
+                null, null, null,
+                null, assignments1, null
+        );
+    }
+
+    /**
+     * Impossible invariant in real environment.
+     */
+    @Test
+    void test2() {
+        test(
+                nodes1, assignments1,
+                null, null, null,
+                null, null, null
+        );
+    }
+
+    @Test
+    void test3() {
+        test(
+                nodes1, assignments2,
+                null, assignments3, null,
+                null, assignments3, assignments1
+        );
+    }
+
+    @Test
+    void test4() {
+        test(
+                nodes1, assignments1,
+                null, assignments3, null,
+                null, assignments3, assignments1
+        );
+    }
+
+    @Test
+    void test5() {
+        test(
+                nodes1, assignments2,
+                assignments3, null, null,
+                assignments3, assignments1, null
+        );
+    }
+
+    @Test
+    void test6() {
+        test(
+                nodes1, assignments1,
+                assignments3, null, null,
+                assignments3, assignments1, null
+        );
+    }
+
+    @Test
+    void test7() {
+        test(
+                nodes1, assignments2,
+                assignments1, null, null,
+                assignments1, null, null
+        );
+    }
+
+    @Test
+    void test8() {
+        test(
+                nodes1, assignments1,
+                assignments1, null, null,
+                assignments1, null, null
+        );
+    }
+
+    @Test
+    void test9() {
+        test(
+                nodes1, assignments2,
+                assignments2, null, null,
+                assignments2, assignments1, null
+        );
+    }
+
+    @Test
+    void test10() {
+        test(
+                nodes1, assignments2,
+                assignments4, assignments3, null,
+                assignments4, assignments3, assignments1
+        );
+    }
+
+    @Test
+    void test11() {
+        test(
+                nodes1, assignments1,
+                assignments3, assignments2, null,
+                assignments3, assignments2, assignments1
+        );
+    }
+
+    @Test
+    void test12() {
+        test(
+                nodes1, assignments2,
+                assignments1, assignments3, null,
+                assignments1, assignments3, assignments1
+        );
+    }
+
+    @Test
+    void test13() {
+        test(
+                nodes1, assignments2,
+                assignments2, assignments3, null,
+                assignments2, assignments3, assignments1
+        );
+    }
+
+    /**
+     * Nodes for new assignments calculating: nodes1.
+     * The table configuration assignments: assignments1.
+     * Current assignments in the metastorage: stable=assignments1, pending=assignments2, planned=null.
+     * Expected assignments in the metastorage after updating: stable=assignments1, pending=assignments2, planned=assignments1.
+     */
+    @Test
+    void test14() {
+        test(
+                nodes1, assignments1,
+                assignments1, assignments2, null,
+                assignments1, assignments2, assignments1
+        );
+    }
+
+    @Test
+    void test15() {
+        test(
+                nodes1, assignments1,
+                assignments1, assignments2, assignments3,
+                assignments1, assignments2, assignments1
+        );
+    }
+
+    @Test
+    void test16() {
+        test(
+                nodes1, assignments4,
+                assignments1, assignments2, assignments1,
+                assignments1, assignments2, assignments1
+        );
+    }
+
+    @Test
+    void test17() {
+        test(
+                nodes2, assignments2,
+                assignments1, assignments2, assignments1,
+                assignments1, assignments2, null
+        );
+    }
+
+    @Test
+    void test18() {
+        test(
+                nodes2, assignments4,
+                assignments1, assignments2, assignments1,
+                assignments1, assignments2, null
+        );
+    }
+
+    private void test(
+            Collection<String> nodesForNewAssignments,
+            Set<Assignment> tableCfgAssignments,
+            Set<Assignment> currentStableAssignments,
+            Set<Assignment> currentPendingAssignments,
+            Set<Assignment> currentPlannedAssignments,
+            Set<Assignment> expectedStableAssignments,
+            Set<Assignment> expectedPendingAssignments,
+            Set<Assignment> expectedPlannedAssignments
+    ) {
+        TablePartitionId tablePartitionId = new TablePartitionId(UUID.randomUUID(), 1);
+
+        if (currentStableAssignments != null) {
+            keyValueStorage.put(stablePartAssignmentsKey(tablePartitionId).bytes(), toBytes(currentStableAssignments));
+        }
+
+        if (currentPendingAssignments != null) {
+            keyValueStorage.put(pendingPartAssignmentsKey(tablePartitionId).bytes(), toBytes(currentPendingAssignments));
+        }
+
+        if (currentPlannedAssignments != null) {
+            keyValueStorage.put(plannedPartAssignmentsKey(tablePartitionId).bytes(), toBytes(currentPlannedAssignments));
+        }
+
+        RebalanceUtil.updatePendingAssignmentsKeys(
+                ""table1"", tablePartitionId, nodesForNewAssignments,
+                replicas, 1, metaStorageManager, partNum, tableCfgAssignments
+        );
+
+        byte[] actualStableBytes = keyValueStorage.get(stablePartAssignmentsKey(tablePartitionId).bytes()).value();
+        Set<Assignment> actualStableAssignments = null;
+
+        if (actualStableBytes != null) {
+            actualStableAssignments = ByteUtils.fromBytes(actualStableBytes);
+        }
+
+        byte[] actualPendingBytes = keyValueStorage.get(pendingPartAssignmentsKey(tablePartitionId).bytes()).value();
+        Set<Assignment> actualPendingAssignments = null;
+
+        if (actualPendingBytes != null) {
+            actualPendingAssignments = ByteUtils.fromBytes(actualPendingBytes);
+        }
+
+        byte[] actualPlannedBytes = keyValueStorage.get(plannedPartAssignmentsKey(tablePartitionId).bytes()).value();
+        Set<Assignment> actualPlannedAssignments = null;
+
+        if (actualPlannedBytes != null) {
+            actualPlannedAssignments = ByteUtils.fromBytes(actualPlannedBytes);
+        }
+
+        LOG.info(""stableAssignments "" + actualStableAssignments);
+        LOG.info(""pendingAssignments "" + actualPendingAssignments);
+        LOG.info(""plannedAssignments "" + actualPlannedAssignments);
+
+        if (expectedStableAssignments != null) {
+            assertNotNull(actualStableBytes);
+            assertTrue(actualStableAssignments.containsAll(expectedStableAssignments));

Review Comment:
   What about assertEquals?



;17/Feb/23 08:19;githubbot;600","alievmirza commented on code in PR #1655:
URL: https://github.com/apache/ignite-3/pull/1655#discussion_r1109686559


##########
modules/table/src/main/java/org/apache/ignite/internal/utils/RebalanceUtil.java:
##########
@@ -100,32 +114,53 @@ public class RebalanceUtil {
 
         Set<Assignment> partAssignments = AffinityUtils.calculateAssignmentForPartition(dataNodes, partNum, replicas);
 
+        boolean isNewAssignments = !tableCfgPartAssignments.equals(partAssignments);
+
         byte[] partAssignmentsBytes = ByteUtils.toBytes(partAssignments);
 
         //    if empty(partition.change.trigger.revision) || partition.change.trigger.revision < event.revision:
-        //        if empty(partition.assignments.pending) && partition.assignments.stable != calcPartAssighments():
+        //        if empty(partition.assignments.pending)
+        //              && ((isNewAssignments && empty(partition.assignments.stable))
+        //                  || (partition.assignments.stable != calcPartAssighments() && !empty(partition.assignments.stable))):
         //            partition.assignments.pending = calcPartAssignments()
         //            partition.change.trigger.revision = event.revision
         //        else:
-        //            if partition.assignments.pending != calcPartAssignments
+        //            if partition.assignments.pending != calcPartAssignments && !empty(partition.assignments.pending)

Review Comment:
   Please correct pseudocode according to the new iff



;17/Feb/23 11:48;githubbot;600","asfgit closed pull request #1655: IGNITE-18737 Fixed updating of partition assignments when new assignments equal to table configuration assignments and stable assignments are empty.
URL: https://github.com/apache/ignite-3/pull/1655


;22/Feb/23 07:31;githubbot;600","sergeyuttsel closed pull request #1656: IGNITE-18737 Tests
URL: https://github.com/apache/ignite-3/pull/1656


;23/Feb/23 09:40;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,6600,,,0,6600,,,,,,,,,,,,,,,,,,,,,,IGNITE-18847,,,,IGNITE-18714,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Feb 21 15:29:18 UTC 2023,,,,,,,,,,"0|z1fpzs:",9223372036854775807,,,maliev,,,,,,,,,,,,,,,,,,"21/Feb/23 15:29;maliev;[~Sergey Uttsel] LGTM, thanks! ;;;",,,,,
IndexQuery skips critertia after checking first IN clause,IGNITE-18725,13523259,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,timonin.maksim,timonin.maksim,timonin.maksim,06/Feb/23 15:34,21/Apr/23 12:28,13/Jul/23 09:11,08/Feb/23 16:44,,,,,,,,2.15,,,,0,,,,"[https://github.com/apache/ignite/issues/10515]

If a IN criterion for field F is specified in IndexQuery, it checks all criteria until F and skips all following criteria.

Note, that this bug affects queries where a IN criterion applies to not first index field:

1. ""eq"" + ""in"" - works
2. ""in"" + ""eq""  - works
3. ""eq"" + ""in"" + ""eq"" - doesn't work.

 ",,ignitetcbot,timonin.maksim,,,,"timoninmaxim opened a new pull request, #10520:
URL: https://github.com/apache/ignite/pull/10520

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;06/Feb/23 16:25;githubbot;600","timoninmaxim merged PR #10520:
URL: https://github.com/apache/ignite/pull/10520


;08/Feb/23 16:42;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Wed Feb 08 16:44:45 UTC 2023,,,,,,,,,,"0|z1fomw:",9223372036854775807,Fixed criteria skipping after first IN clause for IndexQuery,,tledkov-gridgain,,,,,,,,,,,,,,,,,,"07/Feb/23 11:02;ignitetcbot;{panel:title=Branch: [pull/10520/head] Base: [master] : Possible Blockers (2)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1}
{color:#d04437}Disk Page Compressions 2{color} [[tests 0 JVM CRASH , Exit Code |https://ci2.ignite.apache.org/viewLog.html?buildId=7035746]]

{color:#d04437}[Javadoc]{color} [[tests 0 BuildFailureOnMessage |https://ci2.ignite.apache.org/viewLog.html?buildId=7035690]]

{panel}
{panel:title=Branch: [pull/10520/head] Base: [master] : New Tests (2)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Index Query API{color} [[tests 2|https://ci2.ignite.apache.org/viewLog.html?buildId=7035683]]
* {color:#013220}IndexQueryTestSuite: IndexQueryInCriterionDescTest.testMultipleInsCriteria - PASSED{color}
* {color:#013220}IndexQueryTestSuite: IndexQueryInCriterionTest.testMultipleInsCriteria - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7035748&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","08/Feb/23 16:44;timonin.maksim;Merged to  master. [~tledkov-gridgain] thanks for review!;;;",,,,
Fix broken JavaDoc because of incorrect CFG_VIEW link,IGNITE-18724,13523256,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,PetrovMikhail,PetrovMikhail,PetrovMikhail,06/Feb/23 15:17,06/Feb/23 15:48,13/Jul/23 09:11,06/Feb/23 15:48,,,,,,,,2.15,,,,0,,,,https://ci.ignite.apache.org/viewLog.html?buildId=7054874&tab=buildResultsDiv&buildTypeId=IgniteTests24Java8_Javadoc,,NSAmelchev,PetrovMikhail,,,,"petrov-mg opened a new pull request, #10519:
URL: https://github.com/apache/ignite/pull/10519

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;06/Feb/23 15:19;githubbot;600","petrov-mg merged PR #10519:
URL: https://github.com/apache/ignite/pull/10519


;06/Feb/23 15:46;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Feb 06 15:48:10 UTC 2023,,,,,,,,,,"0|z1fom8:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"06/Feb/23 15:30;PetrovMikhail;Successfull run of JavaDoc test suite https://ci.ignite.apache.org/viewType.html?buildTypeId=IgniteTests24Java8_Javadoc&branch_IgniteTests24Java8=pull%2F10519%2Fhead&tab=buildTypeStatusDiv;;;","06/Feb/23 15:44;NSAmelchev;LGTM:);;;","06/Feb/23 15:48;PetrovMikhail;[~NSAmelchev] Thank you a lot for the review!;;;",,,
ClientArchTest should check client dependencies,IGNITE-18723,13523249,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,aleksandr.pakhomov,Mikhail Pochatkin,Mikhail Pochatkin,06/Feb/23 15:06,03/Mar/23 07:14,13/Jul/23 09:11,03/Mar/23 07:14,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,ClientArchTest should check not only client source code but also all depended Ignite modules.,,korlov,Mikhail Pochatkin,,,,"PakhomovAlexander opened a new pull request, #1695:
URL: https://github.com/apache/ignite-3/pull/1695

   https://issues.apache.org/jira/browse/IGNITE-18723
   
   Update the archunit lib to the stable version. And Fix API changes like the usage of Optional.


;20/Feb/23 14:49;githubbot;600","korlov42 merged PR #1695:
URL: https://github.com/apache/ignite-3/pull/1695


;03/Mar/23 07:13;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Mar 03 07:14:47 UTC 2023,,,,,,,,,,"0|z1foko:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"03/Mar/23 07:14;korlov;[~aleksandr.pakhomov], thanks for the contribution!

Merged to [main|https://github.com/apache/ignite-3/commit/3de57be81e1d32b51ba6df903870d3da751e7940];;;",,,,,
Fix parallel read and delete RowVersion for PageMemoryMvPartitionStorage,IGNITE-18717,13523204,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ktkalenko@gridgain.com,ktkalenko@gridgain.com,06/Feb/23 09:59,14/Feb/23 14:53,13/Jul/23 09:11,14/Feb/23 14:53,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"It was found that we do not have protection against parallel deletion and read RowVersion for PageMemoryMvPartitionStorage. 

See the epic for a little more details.

For a start, you can see the problems if you enable tests:
* *org.apache.ignite.internal.storage.pagememory.mv.PersistentPageMemoryMvPartitionStorageConcurrencyTest*
* *org.apache.ignite.internal.storage.pagememory.mv.VolatilePageMemoryMvPartitionStorageConcurrencyTest*",,ktkalenko@gridgain.com,,,,,"tkalkirill opened a new pull request, #1652:
URL: https://github.com/apache/ignite-3/pull/1652

   https://issues.apache.org/jira/browse/IGNITE-18717


;08/Feb/23 08:24;githubbot;600","ibessonov commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1102834310


##########
modules/page-memory/src/integrationTest/java/org/apache/ignite/internal/pagememory/tree/AbstractBplusTreePageMemoryTest.java:
##########
@@ -2367,6 +2372,138 @@ void testFindNext() throws Exception {
         assertEquals(0L, tree.findNext(-1L, true));
     }
 
+    @Test
+    void testFindOneWithMapper() throws Exception {
+        TestTree tree = createTestTree(true);
+
+        tree.put(0L);
+
+        assertEquals(""row0"", tree.findOne(0L, row -> ""row"" + row));
+        assertEquals(""rownull"", tree.findOne(1L, row -> ""row"" + row));
+    }
+
+    @Test
+    void testFindWithMapper() throws Exception {
+        TestTree tree = createTestTree(true);
+
+        tree.put(0L);
+        tree.put(1L);
+
+        PeekTreeRowCursor<Long, String> cursor = tree.find(null, null, row -> ""row"" + row);
+
+        assertNull(cursor.peek());
+
+        assertTrue(cursor.hasNext());
+        assertEquals(0L, cursor.peek());
+        assertEquals(""row0"", cursor.next());
+
+        assertTrue(cursor.hasNext());
+        assertEquals(1L, cursor.peek());
+        assertEquals(""row1"", cursor.next());
+
+        assertFalse(cursor.hasNext());
+        assertNull(cursor.peek());
+        assertThrows(NoSuchElementException.class, cursor::next);
+    }
+
+    @Test
+    void testInvokeClosureWithOnUpdateCallbackForPut() throws Exception {
+        TestTree tree = createTestTree(true);
+
+        // Checks insert.
+        CompletableFuture<Void> future0 = new CompletableFuture<>();

Review Comment:
   Are you sure that the future is the best solution for the test? Looks like an overkill to me.
   You can use flag, for example, or you can use mockito to ensure that method has been called (although I wouldn't recommend it in this case)



##########
modules/page-memory/src/integrationTest/java/org/apache/ignite/internal/pagememory/tree/AbstractBplusTreePageMemoryTest.java:
##########
@@ -2367,6 +2372,138 @@ void testFindNext() throws Exception {
         assertEquals(0L, tree.findNext(-1L, true));
     }
 
+    @Test
+    void testFindOneWithMapper() throws Exception {
+        TestTree tree = createTestTree(true);
+
+        tree.put(0L);
+
+        assertEquals(""row0"", tree.findOne(0L, row -> ""row"" + row));
+        assertEquals(""rownull"", tree.findOne(1L, row -> ""row"" + row));
+    }
+
+    @Test
+    void testFindWithMapper() throws Exception {
+        TestTree tree = createTestTree(true);
+
+        tree.put(0L);
+        tree.put(1L);
+
+        PeekTreeRowCursor<Long, String> cursor = tree.find(null, null, row -> ""row"" + row);
+
+        assertNull(cursor.peek());
+
+        assertTrue(cursor.hasNext());
+        assertEquals(0L, cursor.peek());
+        assertEquals(""row0"", cursor.next());
+
+        assertTrue(cursor.hasNext());
+        assertEquals(1L, cursor.peek());
+        assertEquals(""row1"", cursor.next());
+
+        assertFalse(cursor.hasNext());
+        assertNull(cursor.peek());
+        assertThrows(NoSuchElementException.class, cursor::next);
+    }
+
+    @Test
+    void testInvokeClosureWithOnUpdateCallbackForPut() throws Exception {
+        TestTree tree = createTestTree(true);
+
+        // Checks insert.
+        CompletableFuture<Void> future0 = new CompletableFuture<>();
+
+        tree.invoke(0L, null, new InvokeClosure<>() {
+            @Override
+            public void call(@Nullable Long oldRow) {
+                assertNull(oldRow);
+            }
+
+            @Override
+            public @Nullable Long newRow() {
+                return 0L;
+            }
+
+            @Override
+            public OperationType operationType() {
+                return PUT;
+            }
+
+            @Override
+            public void onUpdate() {
+                future0.complete(null);
+            }
+        });
+
+        assertThat(future0, willCompleteSuccessfully());
+
+        assertEquals(0L, tree.findOne(0L));
+
+        // Checks replace.
+        CompletableFuture<Void> future1 = new CompletableFuture<>();

Review Comment:
   Same here



##########
modules/page-memory/src/integrationTest/java/org/apache/ignite/internal/pagememory/tree/AbstractBplusTreePageMemoryTest.java:
##########
@@ -2367,6 +2371,157 @@ void testFindNext() throws Exception {
         assertEquals(0L, tree.findNext(-1L, true));
     }
 
+    @Test
+    void testFindOneWithMapper() throws Exception {
+        TestTree tree = createTestTree(true);
+
+        tree.put(0L);
+
+        TreeRowClosure<Long, Long> treeRowClosure = new TreeRowClosure<>() {
+            @Override
+            public boolean apply(BplusTree<Long, Long> tree, BplusIo<Long> io, long pageAddr, int idx) {
+                return true;
+            }
+
+            @Override
+            public String map(Long treeRow) {

Review Comment:
   I see that this is a closure with `<Long, Long>`. Where's the `String` in that signature?



##########
modules/page-memory/src/main/java/org/apache/ignite/internal/pagememory/tree/BplusTree.java:
##########
@@ -1270,12 +1270,14 @@ public Cursor<T> find(
      * @param upper Upper bound or {@code null} if unbounded.
      * @param lowIncl {@code true} if lower bound is inclusive.
      * @param upIncl {@code true} if upper bound is inclusive.
-     * @param c Filter closure.
+     * @param c Tree row closure.
      * @param x Implementation specific argument, {@code null} always means that we need to return full detached data row.
      * @return Cursor.
-     * @throws IgniteInternalCheckedException If failed.
+     * @throws CorruptedDataStructureException If the data structure is broken.
+     * @throws CorruptedTreeException If there were {@link RuntimeException} or {@link AssertionError}.
+     * @throws IgniteInternalCheckedException If other errors occurred.
      */
-    public Cursor<T> find(
+    public <R> Cursor<R> find(

Review Comment:
   Same question as before - R is an arbitrary type, it's not good enough, there's no type safety whatsoever



##########
modules/page-memory/src/main/java/org/apache/ignite/internal/pagememory/tree/BplusTree.java:
##########
@@ -6117,35 +6194,37 @@ private void iterate() throws IgniteInternalCheckedException {
     /**
      * Forward cursor.
      */
-    private final class ForwardCursor extends AbstractForwardCursor implements Cursor<T> {
+    private final class ForwardCursor<R> extends AbstractForwardCursor implements Cursor<R> {
         /** Implementation specific argument. */
-        @Nullable
-        final Object arg;
+        private final @Nullable Object arg;

Review Comment:
   Why do you make these fields private?



##########
modules/page-memory/src/integrationTest/java/org/apache/ignite/internal/pagememory/tree/AbstractBplusTreePageMemoryTest.java:
##########
@@ -2367,6 +2372,138 @@ void testFindNext() throws Exception {
         assertEquals(0L, tree.findNext(-1L, true));
     }
 
+    @Test
+    void testFindOneWithMapper() throws Exception {
+        TestTree tree = createTestTree(true);
+
+        tree.put(0L);
+
+        assertEquals(""row0"", tree.findOne(0L, row -> ""row"" + row));
+        assertEquals(""rownull"", tree.findOne(1L, row -> ""row"" + row));
+    }
+
+    @Test
+    void testFindWithMapper() throws Exception {
+        TestTree tree = createTestTree(true);
+
+        tree.put(0L);
+        tree.put(1L);
+
+        PeekTreeRowCursor<Long, String> cursor = tree.find(null, null, row -> ""row"" + row);
+
+        assertNull(cursor.peek());
+
+        assertTrue(cursor.hasNext());
+        assertEquals(0L, cursor.peek());
+        assertEquals(""row0"", cursor.next());
+
+        assertTrue(cursor.hasNext());
+        assertEquals(1L, cursor.peek());
+        assertEquals(""row1"", cursor.next());
+
+        assertFalse(cursor.hasNext());
+        assertNull(cursor.peek());
+        assertThrows(NoSuchElementException.class, cursor::next);
+    }
+
+    @Test
+    void testInvokeClosureWithOnUpdateCallbackForPut() throws Exception {
+        TestTree tree = createTestTree(true);
+
+        // Checks insert.
+        CompletableFuture<Void> future0 = new CompletableFuture<>();
+
+        tree.invoke(0L, null, new InvokeClosure<>() {
+            @Override
+            public void call(@Nullable Long oldRow) {
+                assertNull(oldRow);
+            }
+
+            @Override
+            public @Nullable Long newRow() {
+                return 0L;
+            }
+
+            @Override
+            public OperationType operationType() {
+                return PUT;
+            }
+
+            @Override
+            public void onUpdate() {
+                future0.complete(null);
+            }
+        });
+
+        assertThat(future0, willCompleteSuccessfully());
+
+        assertEquals(0L, tree.findOne(0L));
+
+        // Checks replace.
+        CompletableFuture<Void> future1 = new CompletableFuture<>();
+
+        tree.invoke(0L, null, new InvokeClosure<>() {
+            @Override
+            public void call(@Nullable Long oldRow) {
+                assertEquals(0L, oldRow);
+            }
+
+            @Override
+            public @Nullable Long newRow() {
+                return 0L;
+            }
+
+            @Override
+            public OperationType operationType() {
+                return PUT;
+            }
+
+            @Override
+            public void onUpdate() {
+                future1.complete(null);
+            }
+        });
+
+        assertThat(future1, willCompleteSuccessfully());
+
+        assertEquals(0L, tree.findOne(0L));
+    }
+
+    @Test
+    void testInvokeClosureWithOnUpdateCallbackForRemove() throws Exception {
+        TestTree tree = createTestTree(true);
+
+        tree.put(0L);
+
+        CompletableFuture<Void> future = new CompletableFuture<>();

Review Comment:
   And here



##########
modules/page-memory/src/main/java/org/apache/ignite/internal/pagememory/tree/BplusTree.java:
##########
@@ -6117,35 +6194,37 @@ private void iterate() throws IgniteInternalCheckedException {
     /**
      * Forward cursor.
      */
-    private final class ForwardCursor extends AbstractForwardCursor implements Cursor<T> {
+    private final class ForwardCursor<R> extends AbstractForwardCursor implements Cursor<R> {
         /** Implementation specific argument. */
-        @Nullable
-        final Object arg;
+        private final @Nullable Object arg;
 
-        /** Rows. */
-        @Nullable
-        private T[] rows = (T[]) OBJECT_EMPTY_ARRAY;
+        private @Nullable R @Nullable [] results = (R[]) OBJECT_EMPTY_ARRAY;

Review Comment:
   Please document that `null` means the end of iteration, and that's why it's started with empty array. It wasn't obvious to me



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbortWriteInvokeClosure.java:
##########
@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.pagememory.mv;
+
+import static org.apache.ignite.internal.pagememory.util.PageIdUtils.NULL_LINK;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.ALWAYS_LOAD_VALUE;
+
+import org.apache.ignite.internal.pagememory.tree.BplusTree;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.InvokeClosure;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.OperationType;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.storage.MvPartitionStorage;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.lang.IgniteInternalCheckedException;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link InvokeClosure} for {@link AbstractPageMemoryMvPartitionStorage#abortWrite(RowId)}.
+ *
+ * <p>Synchronization between reading and updating the version chain occurs due to the locks (read and write) of the page of the tree on
+ * which the version chain is located.
+ *
+ * <p>Synchronization between update operations for the version chain must be external (by {@link RowId row ID}).
+ *
+ * <p>Operation may throw {@link StorageException} which will cause form {@link BplusTree#invoke(Object, Object, InvokeClosure)}.
+ */
+class AbortWriteInvokeClosure implements InvokeClosure<VersionChain> {
+    private final RowId rowId;
+
+    private final AbstractPageMemoryMvPartitionStorage storage;
+
+    private OperationType operationType;
+
+    private @Nullable VersionChain newRow;
+
+    private @Nullable RowVersion toRemove;
+
+    private @Nullable BinaryRow previousUncommittedRowVersion;
+
+    AbortWriteInvokeClosure(RowId rowId, AbstractPageMemoryMvPartitionStorage storage) {
+        this.rowId = rowId;
+        this.storage = storage;
+    }
+
+    @Override
+    public void call(@Nullable VersionChain oldRow) throws IgniteInternalCheckedException {
+        if (oldRow == null || oldRow.transactionId() == null) {
+            // Row doesn't exist or the chain doesn't contain an uncommitted write intent.
+            operationType = OperationType.NOOP;
+
+            return;
+        }
+
+        RowVersion latestVersion = storage.readRowVersion(oldRow.headLink(), ALWAYS_LOAD_VALUE);
+
+        assert latestVersion.isUncommitted();
+
+        toRemove = latestVersion;
+
+        if (latestVersion.hasNextLink()) {
+            // Next can be safely replaced with any value (like 0), because this field is only used when there
+            // is some uncommitted value, but when we add an uncommitted value, we 'fix' such placeholder value
+            // (like 0) by replacing it with a valid value.
+            newRow = VersionChain.createCommitted(rowId, latestVersion.nextLink(), NULL_LINK);
+
+            operationType = OperationType.PUT;
+        } else {
+            // It was the only version, let's remove the chain as well.
+            operationType = OperationType.REMOVE;
+        }
+
+        previousUncommittedRowVersion = storage.rowVersionToBinaryRow(latestVersion);
+    }
+
+    @Override
+    public @Nullable VersionChain newRow() {
+        assert operationType == OperationType.PUT ? newRow != null : newRow == null : ""newRow="" + newRow + "", op="" + operationType;
+
+        return newRow;
+    }
+
+    @Override
+    public OperationType operationType() {
+        assert operationType != null;
+
+        return operationType;
+    }
+
+    @Override
+    public void onUpdate() {
+        assert operationType == OperationType.NOOP ? toRemove == null : toRemove != null : ""toRemove="" + toRemove + "", op="" + operationType;
+
+        if (toRemove != null) {
+            storage.removeRowVersion(toRemove);
+        }

Review Comment:
   I don't like the fact that we're cleaning a free-list while holding a write lock. We can do it while NOT holding the lock and the code would still be safe, right? That's because no one else sees the link that you're deleting. At least that's the idea. This is how it's done in invoke closures for indexes, for example



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPageMemoryMvPartitionStorage.java:
##########
@@ -944,15 +862,67 @@ public void finishCleanup() {
         }
     }
 
-    @Nullable VersionChain readVersionChain(RowId rowId) {
+    void throwExceptionIfStorageNotInRunnableState() {
+        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    }
+
+    /**
+     * Searches version chain by row ID and converts the found version chain to the result if found.
+     *
+     * @param rowId Row ID.
+     * @param function Function for converting the version chain to a result, function is executed under the read lock of the page on which
+     *      the version chain is located. If the version chain is not found, then {@code null} will be passed to the function.
+     */
+    <T> @Nullable T findVersionChain(RowId rowId, Function<VersionChain, T> function) {
         try {
-            return versionChainTree.findOne(new VersionChainKey(rowId));
+            return versionChainTree.findOne(new VersionChainKey(rowId), new TreeRowClosure<>() {
+                @Override
+                public boolean apply(BplusTree<VersionChainKey, VersionChain> tree, BplusIo<VersionChainKey> io, long pageAddr, int idx) {
+                    return true;
+                }
+
+                @Override
+                public T map(VersionChain treeRow) {
+                    return function.apply(treeRow);
+                }
+            }, null);
         } catch (IgniteInternalCheckedException e) {
-            throw new StorageException(""Error getting version chain: [rowId={}, {}]"", e, rowId, createStorageInfo());
+            if (e.getCause() instanceof StorageException) {
+                throw (StorageException) e.getCause();
+            }
+
+            throw new StorageException(""Row version lookup failed: [rowId={}, {}]"", e, rowId, createStorageInfo());
         }
     }
 
-    void throwExceptionIfStorageNotInRunnableState() {
-        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    /**
+     * Organizes external synchronization of update operations for the same version chain.
+     *
+     * <p>NOTE: When you try to execute in the closures on the pages of the tree, it leads to a deadlock.
+     */
+    protected <T> T inUpdateVersionChainLock(RowId rowId, Supplier<T> supplier) {
+        LockHolder<ReentrantLock> lockHolder = updateVersionChainLockByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {

Review Comment:
   Maybe the entire map should be encapsulated into its own class, code would be really simple:
   ```
   locker.lock(rowId);
   ...
   locker.unlock(rowId);
   ```
   Anyway, I see no distinction between readings and writings. Do we only lock stuff when we need updates? That's nice!



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPageMemoryMvPartitionStorage.java:
##########
@@ -944,15 +862,67 @@ public void finishCleanup() {
         }
     }
 
-    @Nullable VersionChain readVersionChain(RowId rowId) {
+    void throwExceptionIfStorageNotInRunnableState() {
+        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    }
+
+    /**
+     * Searches version chain by row ID and converts the found version chain to the result if found.
+     *
+     * @param rowId Row ID.
+     * @param function Function for converting the version chain to a result, function is executed under the read lock of the page on which
+     *      the version chain is located. If the version chain is not found, then {@code null} will be passed to the function.
+     */
+    <T> @Nullable T findVersionChain(RowId rowId, Function<VersionChain, T> function) {

Review Comment:
   Can you provide a better name, other than `function`?



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPageMemoryMvPartitionStorage.java:
##########
@@ -944,15 +862,67 @@ public void finishCleanup() {
         }
     }
 
-    @Nullable VersionChain readVersionChain(RowId rowId) {
+    void throwExceptionIfStorageNotInRunnableState() {
+        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    }
+
+    /**
+     * Searches version chain by row ID and converts the found version chain to the result if found.
+     *
+     * @param rowId Row ID.
+     * @param function Function for converting the version chain to a result, function is executed under the read lock of the page on which
+     *      the version chain is located. If the version chain is not found, then {@code null} will be passed to the function.
+     */
+    <T> @Nullable T findVersionChain(RowId rowId, Function<VersionChain, T> function) {
         try {
-            return versionChainTree.findOne(new VersionChainKey(rowId));
+            return versionChainTree.findOne(new VersionChainKey(rowId), new TreeRowClosure<>() {
+                @Override
+                public boolean apply(BplusTree<VersionChainKey, VersionChain> tree, BplusIo<VersionChainKey> io, long pageAddr, int idx) {
+                    return true;

Review Comment:
   My return true in base implementation



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPageMemoryMvPartitionStorage.java:
##########
@@ -944,15 +862,67 @@ public void finishCleanup() {
         }
     }
 
-    @Nullable VersionChain readVersionChain(RowId rowId) {
+    void throwExceptionIfStorageNotInRunnableState() {
+        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    }
+
+    /**
+     * Searches version chain by row ID and converts the found version chain to the result if found.
+     *
+     * @param rowId Row ID.
+     * @param function Function for converting the version chain to a result, function is executed under the read lock of the page on which
+     *      the version chain is located. If the version chain is not found, then {@code null} will be passed to the function.
+     */
+    <T> @Nullable T findVersionChain(RowId rowId, Function<VersionChain, T> function) {
         try {
-            return versionChainTree.findOne(new VersionChainKey(rowId));
+            return versionChainTree.findOne(new VersionChainKey(rowId), new TreeRowClosure<>() {
+                @Override
+                public boolean apply(BplusTree<VersionChainKey, VersionChain> tree, BplusIo<VersionChainKey> io, long pageAddr, int idx) {
+                    return true;
+                }
+
+                @Override
+                public T map(VersionChain treeRow) {
+                    return function.apply(treeRow);
+                }
+            }, null);
         } catch (IgniteInternalCheckedException e) {
-            throw new StorageException(""Error getting version chain: [rowId={}, {}]"", e, rowId, createStorageInfo());
+            if (e.getCause() instanceof StorageException) {
+                throw (StorageException) e.getCause();
+            }
+
+            throw new StorageException(""Row version lookup failed: [rowId={}, {}]"", e, rowId, createStorageInfo());
         }
     }
 
-    void throwExceptionIfStorageNotInRunnableState() {
-        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    /**
+     * Organizes external synchronization of update operations for the same version chain.
+     *
+     * <p>NOTE: When you try to execute in the closures on the pages of the tree, it leads to a deadlock.

Review Comment:
   I don't get this note. What's its purpose?
   Generally speaking, if you get locks in the wrong order, there's a chance of having a deadlock. That's a  common knowledge. I recommend documenting an overall locks model somewhere, instead of doing such notes in seemingly random places



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPartitionTimestampCursor.java:
##########
@@ -164,28 +152,27 @@ public void close() {
     abstract ReadResult findRowVersion(VersionChain versionChain);
 
     private void createVersionChainCursorIfMissing() {
-        if (versionChainCursor != null) {
+        if (cursor != null) {
             return;
         }
 
         try {
-            versionChainCursor = storage.versionChainTree.find(null, null, (tree, io, pageAddr, idx) -> {
-                // Since the BplusTree cursor caches rows that are on the same page, we should try to get actual ReadResult for them in this
-                // filter so as not to get into a situation when we read the chain and the links in it are no longer valid.
-
-                VersionChain versionChain = tree.getRow(io, pageAddr, idx);
-
-                // TODO: IGNITE-18717 Perhaps add lock by rowId
-
-                ReadResult readResult = findRowVersion(versionChain);
-
-                if (!readResult.isEmpty()) {
-                    readResultByRowId.put(versionChain.rowId(), readResult);
+            cursor = storage.versionChainTree.find(null, null, new TreeRowClosure<>() {
+                @Override
+                public boolean apply(BplusTree<VersionChainKey, VersionChain> tree, BplusIo<VersionChainKey> io, long pageAddr, int idx) {
+                    return true;
                 }
 
-                return true;
+                @Override
+                public ReadResult map(VersionChain treeRow) {
+                    return findRowVersion(treeRow);
+                }
             }, null);
         } catch (IgniteInternalCheckedException e) {
+            if (e.getCause() instanceof StorageException) {
+                throw (StorageException) e.getCause();
+            }

Review Comment:
   We should probably extract a method, such check is pretty common here



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AddWriteCommittedInvokeClosure.java:
##########
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.pagememory.mv;
+
+import static org.apache.ignite.internal.pagememory.util.PageIdUtils.NULL_LINK;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.rowBytes;
+
+import java.nio.ByteBuffer;
+import org.apache.ignite.internal.hlc.HybridTimestamp;
+import org.apache.ignite.internal.pagememory.tree.BplusTree;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.InvokeClosure;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.OperationType;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.lang.IgniteInternalCheckedException;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link InvokeClosure} for
+ * {@link AbstractPageMemoryMvPartitionStorage#addWriteCommitted(RowId, BinaryRow, HybridTimestamp)}.
+ *
+ * <p>Synchronization between reading and updating the version chain occurs due to the locks (read and write) of the page of the tree on
+ * which the version chain is located.
+ *
+ * <p>Synchronization between update operations for the version chain must be external (by {@link RowId row ID}).
+ *
+ * <p>Operation may throw {@link StorageException} which will cause form {@link BplusTree#invoke(Object, Object, InvokeClosure)}.
+ */
+class AddWriteCommittedInvokeClosure implements InvokeClosure<VersionChain> {
+    private final RowId rowId;
+
+    private final @Nullable BinaryRow row;
+
+    private final HybridTimestamp commitTimestamp;
+
+    private final AbstractPageMemoryMvPartitionStorage storage;
+
+    private @Nullable VersionChain newRow;
+
+    AddWriteCommittedInvokeClosure(
+            RowId rowId,
+            @Nullable BinaryRow row,
+            HybridTimestamp commitTimestamp,
+            AbstractPageMemoryMvPartitionStorage storage
+    ) {
+        this.rowId = rowId;
+        this.row = row;
+        this.commitTimestamp = commitTimestamp;
+        this.storage = storage;
+    }
+
+    @Override
+    public void call(@Nullable VersionChain oldRow) throws IgniteInternalCheckedException {
+        if (oldRow != null && oldRow.isUncommitted()) {
+            // This means that there is a bug in our code as the caller must make sure that no write intent exists below this write.
+            throw new StorageException(""Write intent exists: [rowId={}, {}]"", oldRow.rowId(), storage.createStorageInfo());

Review Comment:
   For every thrown exception, we should have some error code. Why do you ignore them?



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AddWriteCommittedInvokeClosure.java:
##########
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.pagememory.mv;
+
+import static org.apache.ignite.internal.pagememory.util.PageIdUtils.NULL_LINK;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.rowBytes;
+
+import java.nio.ByteBuffer;
+import org.apache.ignite.internal.hlc.HybridTimestamp;
+import org.apache.ignite.internal.pagememory.tree.BplusTree;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.InvokeClosure;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.OperationType;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.lang.IgniteInternalCheckedException;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link InvokeClosure} for
+ * {@link AbstractPageMemoryMvPartitionStorage#addWriteCommitted(RowId, BinaryRow, HybridTimestamp)}.
+ *
+ * <p>Synchronization between reading and updating the version chain occurs due to the locks (read and write) of the page of the tree on
+ * which the version chain is located.
+ *
+ * <p>Synchronization between update operations for the version chain must be external (by {@link RowId row ID}).
+ *
+ * <p>Operation may throw {@link StorageException} which will cause form {@link BplusTree#invoke(Object, Object, InvokeClosure)}.
+ */
+class AddWriteCommittedInvokeClosure implements InvokeClosure<VersionChain> {
+    private final RowId rowId;
+
+    private final @Nullable BinaryRow row;
+
+    private final HybridTimestamp commitTimestamp;
+
+    private final AbstractPageMemoryMvPartitionStorage storage;
+
+    private @Nullable VersionChain newRow;
+
+    AddWriteCommittedInvokeClosure(
+            RowId rowId,
+            @Nullable BinaryRow row,
+            HybridTimestamp commitTimestamp,
+            AbstractPageMemoryMvPartitionStorage storage
+    ) {
+        this.rowId = rowId;
+        this.row = row;
+        this.commitTimestamp = commitTimestamp;
+        this.storage = storage;
+    }
+
+    @Override
+    public void call(@Nullable VersionChain oldRow) throws IgniteInternalCheckedException {
+        if (oldRow != null && oldRow.isUncommitted()) {

Review Comment:
   Can we replace it with the assertion?



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AddWriteInvokeClosure.java:
##########
@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.pagememory.mv;
+
+import static org.apache.ignite.internal.pagememory.util.PageIdUtils.NULL_LINK;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.ALWAYS_LOAD_VALUE;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.rowBytes;
+
+import java.nio.ByteBuffer;
+import java.util.UUID;
+import org.apache.ignite.internal.pagememory.tree.BplusTree;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.InvokeClosure;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.OperationType;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.storage.MvPartitionStorage;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.internal.storage.TxIdMismatchException;
+import org.apache.ignite.lang.IgniteInternalCheckedException;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link InvokeClosure} for {@link AbstractPageMemoryMvPartitionStorage#addWrite(RowId, BinaryRow, UUID, UUID, int)}.
+ *
+ * <p>Synchronization between reading and updating the version chain occurs due to the locks (read and write) of the page of the tree on
+ * which the version chain is located.
+ *
+ * <p>Synchronization between update operations for the version chain must be external (by {@link RowId row ID}).
+ *
+ * <p>Operation may throw {@link StorageException} and {@link TxIdMismatchException} which will cause form
+ * {@link BplusTree#invoke(Object, Object, InvokeClosure)}.
+ */
+class AddWriteInvokeClosure implements InvokeClosure<VersionChain> {
+    private final RowId rowId;
+
+    private final @Nullable BinaryRow row;
+
+    private final UUID txId;
+
+    private final UUID commitTableId;
+
+    private final int commitPartitionId;
+
+    private final AbstractPageMemoryMvPartitionStorage storage;
+
+    private @Nullable VersionChain newRow;
+
+    private @Nullable BinaryRow previousUncommittedRowVersion;
+
+    private @Nullable RowVersion toRemove;
+
+    AddWriteInvokeClosure(
+            RowId rowId,
+            @Nullable BinaryRow row,
+            UUID txId,
+            UUID commitTableId,
+            int commitPartitionId,
+            AbstractPageMemoryMvPartitionStorage storage
+    ) {
+        this.rowId = rowId;
+        this.row = row;
+        this.txId = txId;
+        this.commitTableId = commitTableId;
+        this.commitPartitionId = commitPartitionId;
+        this.storage = storage;
+    }
+
+    @Override
+    public void call(@Nullable VersionChain oldRow) throws IgniteInternalCheckedException {
+        if (oldRow == null) {
+            RowVersion newVersion = insertRowVersion(row, NULL_LINK);
+
+            newRow = VersionChain.createUncommitted(rowId, txId, commitTableId, commitPartitionId, newVersion.link(), NULL_LINK);
+
+            return;
+        }
+
+        if (oldRow.isUncommitted()) {
+            throwIfChainBelongsToAnotherTx(oldRow, txId);
+        }
+
+        RowVersion newVersion = insertRowVersion(row, oldRow.newestCommittedLink());
+
+        if (oldRow.isUncommitted()) {
+            RowVersion currentVersion = storage.readRowVersion(oldRow.headLink(), ALWAYS_LOAD_VALUE);
+
+            previousUncommittedRowVersion = storage.rowVersionToBinaryRow(currentVersion);
+
+            // As we replace an uncommitted version with new one, we need to remove old uncommitted version.
+            toRemove = currentVersion;
+        }
+
+        newRow = VersionChain.createUncommitted(rowId, txId, commitTableId, commitPartitionId, newVersion.link(), newVersion.nextLink());
+    }
+
+    @Override
+    public @Nullable VersionChain newRow() {
+        assert newRow != null;
+
+        return newRow;
+    }
+
+    @Override
+    public OperationType operationType() {
+        return OperationType.PUT;
+    }
+
+    @Override
+    public void onUpdate() {
+        if (toRemove != null) {
+            storage.removeRowVersion(toRemove);

Review Comment:
   Again, I recommend removing the data when you don't hold any locks.
   Maybe you can even read the value when holding no locks, it should be safe.



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AddWriteInvokeClosure.java:
##########
@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.pagememory.mv;
+
+import static org.apache.ignite.internal.pagememory.util.PageIdUtils.NULL_LINK;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.ALWAYS_LOAD_VALUE;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.rowBytes;
+
+import java.nio.ByteBuffer;
+import java.util.UUID;
+import org.apache.ignite.internal.pagememory.tree.BplusTree;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.InvokeClosure;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.OperationType;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.storage.MvPartitionStorage;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.internal.storage.TxIdMismatchException;
+import org.apache.ignite.lang.IgniteInternalCheckedException;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link InvokeClosure} for {@link AbstractPageMemoryMvPartitionStorage#addWrite(RowId, BinaryRow, UUID, UUID, int)}.
+ *
+ * <p>Synchronization between reading and updating the version chain occurs due to the locks (read and write) of the page of the tree on
+ * which the version chain is located.
+ *
+ * <p>Synchronization between update operations for the version chain must be external (by {@link RowId row ID}).
+ *
+ * <p>Operation may throw {@link StorageException} and {@link TxIdMismatchException} which will cause form
+ * {@link BplusTree#invoke(Object, Object, InvokeClosure)}.
+ */
+class AddWriteInvokeClosure implements InvokeClosure<VersionChain> {
+    private final RowId rowId;
+
+    private final @Nullable BinaryRow row;
+
+    private final UUID txId;
+
+    private final UUID commitTableId;
+
+    private final int commitPartitionId;
+
+    private final AbstractPageMemoryMvPartitionStorage storage;
+
+    private @Nullable VersionChain newRow;
+
+    private @Nullable BinaryRow previousUncommittedRowVersion;
+
+    private @Nullable RowVersion toRemove;
+
+    AddWriteInvokeClosure(
+            RowId rowId,
+            @Nullable BinaryRow row,
+            UUID txId,
+            UUID commitTableId,
+            int commitPartitionId,
+            AbstractPageMemoryMvPartitionStorage storage
+    ) {
+        this.rowId = rowId;
+        this.row = row;
+        this.txId = txId;
+        this.commitTableId = commitTableId;
+        this.commitPartitionId = commitPartitionId;
+        this.storage = storage;
+    }
+
+    @Override
+    public void call(@Nullable VersionChain oldRow) throws IgniteInternalCheckedException {
+        if (oldRow == null) {
+            RowVersion newVersion = insertRowVersion(row, NULL_LINK);
+
+            newRow = VersionChain.createUncommitted(rowId, txId, commitTableId, commitPartitionId, newVersion.link(), NULL_LINK);
+
+            return;
+        }
+
+        if (oldRow.isUncommitted()) {
+            throwIfChainBelongsToAnotherTx(oldRow, txId);

Review Comment:
   You don't need to pass `txId` because it's a field. Or this method must be static for some reason?



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/CommitWriteInvokeClosure.java:
##########
@@ -0,0 +1,101 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.pagememory.mv;
+
+import org.apache.ignite.internal.hlc.HybridTimestamp;
+import org.apache.ignite.internal.pagememory.tree.BplusTree;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.InvokeClosure;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.OperationType;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.lang.IgniteInternalCheckedException;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link InvokeClosure} for {@link AbstractPageMemoryMvPartitionStorage#commitWrite(RowId, HybridTimestamp)}.
+ *
+ * <p>Synchronization between reading and updating the version chain occurs due to the locks (read and write) of the page of the tree on
+ * which the version chain is located.
+ *
+ * <p>Synchronization between update operations for the version chain must be external (by {@link RowId row ID}).
+ *
+ * <p>Operation may throw {@link StorageException} which will cause form {@link BplusTree#invoke(Object, Object, InvokeClosure)}.

Review Comment:
   I'd prefer a list of error codes as well



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPartitionTimestampCursor.java:
##########
@@ -65,36 +61,32 @@ public boolean hasNext() {
 
             createVersionChainCursorIfMissing();
 
-            currentChain = null;
+            currentRowId = null;
 
             while (true) {
-                if (!versionChainCursor.hasNext()) {
+                if (!cursor.hasNext()) {
                     iterationExhausted = true;
 
                     return false;
                 }
 
-                VersionChain chain = versionChainCursor.next();
-
-                ReadResult result = readResultByRowId.remove(chain.rowId());
+                ReadResult result = cursor.next();
 
-                if (result == null) {
-                    // TODO: IGNITE-18717 Add lock by rowId
-                    chain = storage.readVersionChain(chain.rowId());
+                RowId rowId = result.rowId();
 
-                    if (chain == null) {
-                        continue;
-                    }
-
-                    result = findRowVersion(chain);
+                if (result.isEmpty()) {

Review Comment:
   Total lack of comments makes this code difficult to read and understand.
   For some reason, my guts tell me that this code might be problematic, but I don't understand what it does :(



;14/Feb/23 09:23;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105533296


##########
modules/page-memory/src/integrationTest/java/org/apache/ignite/internal/pagememory/tree/AbstractBplusTreePageMemoryTest.java:
##########
@@ -2367,6 +2372,138 @@ void testFindNext() throws Exception {
         assertEquals(0L, tree.findNext(-1L, true));
     }
 
+    @Test
+    void testFindOneWithMapper() throws Exception {
+        TestTree tree = createTestTree(true);
+
+        tree.put(0L);
+
+        assertEquals(""row0"", tree.findOne(0L, row -> ""row"" + row));
+        assertEquals(""rownull"", tree.findOne(1L, row -> ""row"" + row));
+    }
+
+    @Test
+    void testFindWithMapper() throws Exception {
+        TestTree tree = createTestTree(true);
+
+        tree.put(0L);
+        tree.put(1L);
+
+        PeekTreeRowCursor<Long, String> cursor = tree.find(null, null, row -> ""row"" + row);
+
+        assertNull(cursor.peek());
+
+        assertTrue(cursor.hasNext());
+        assertEquals(0L, cursor.peek());
+        assertEquals(""row0"", cursor.next());
+
+        assertTrue(cursor.hasNext());
+        assertEquals(1L, cursor.peek());
+        assertEquals(""row1"", cursor.next());
+
+        assertFalse(cursor.hasNext());
+        assertNull(cursor.peek());
+        assertThrows(NoSuchElementException.class, cursor::next);
+    }
+
+    @Test
+    void testInvokeClosureWithOnUpdateCallbackForPut() throws Exception {
+        TestTree tree = createTestTree(true);
+
+        // Checks insert.
+        CompletableFuture<Void> future0 = new CompletableFuture<>();

Review Comment:
   I'll use mokito, thanks!



;14/Feb/23 09:36;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105564194


##########
modules/page-memory/src/main/java/org/apache/ignite/internal/pagememory/tree/BplusTree.java:
##########
@@ -6117,35 +6194,37 @@ private void iterate() throws IgniteInternalCheckedException {
     /**
      * Forward cursor.
      */
-    private final class ForwardCursor extends AbstractForwardCursor implements Cursor<T> {
+    private final class ForwardCursor<R> extends AbstractForwardCursor implements Cursor<R> {
         /** Implementation specific argument. */
-        @Nullable
-        final Object arg;
+        private final @Nullable Object arg;

Review Comment:
   Because no one else uses it, does it bother you?



;14/Feb/23 10:02;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105566837


##########
modules/page-memory/src/main/java/org/apache/ignite/internal/pagememory/tree/BplusTree.java:
##########
@@ -6117,35 +6194,37 @@ private void iterate() throws IgniteInternalCheckedException {
     /**
      * Forward cursor.
      */
-    private final class ForwardCursor extends AbstractForwardCursor implements Cursor<T> {
+    private final class ForwardCursor<R> extends AbstractForwardCursor implements Cursor<R> {
         /** Implementation specific argument. */
-        @Nullable
-        final Object arg;
+        private final @Nullable Object arg;
 
-        /** Rows. */
-        @Nullable
-        private T[] rows = (T[]) OBJECT_EMPTY_ARRAY;
+        private @Nullable R @Nullable [] results = (R[]) OBJECT_EMPTY_ARRAY;

Review Comment:
   Tried to fix it.



;14/Feb/23 10:04;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105572436


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPageMemoryMvPartitionStorage.java:
##########
@@ -944,15 +862,67 @@ public void finishCleanup() {
         }
     }
 
-    @Nullable VersionChain readVersionChain(RowId rowId) {
+    void throwExceptionIfStorageNotInRunnableState() {
+        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    }
+
+    /**
+     * Searches version chain by row ID and converts the found version chain to the result if found.
+     *
+     * @param rowId Row ID.
+     * @param function Function for converting the version chain to a result, function is executed under the read lock of the page on which
+     *      the version chain is located. If the version chain is not found, then {@code null} will be passed to the function.
+     */
+    <T> @Nullable T findVersionChain(RowId rowId, Function<VersionChain, T> function) {

Review Comment:
   `mapper` is better?



;14/Feb/23 10:09;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105573402


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPageMemoryMvPartitionStorage.java:
##########
@@ -944,15 +862,67 @@ public void finishCleanup() {
         }
     }
 
-    @Nullable VersionChain readVersionChain(RowId rowId) {
+    void throwExceptionIfStorageNotInRunnableState() {
+        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    }
+
+    /**
+     * Searches version chain by row ID and converts the found version chain to the result if found.
+     *
+     * @param rowId Row ID.
+     * @param function Function for converting the version chain to a result, function is executed under the read lock of the page on which
+     *      the version chain is located. If the version chain is not found, then {@code null} will be passed to the function.
+     */
+    <T> @Nullable T findVersionChain(RowId rowId, Function<VersionChain, T> function) {
         try {
-            return versionChainTree.findOne(new VersionChainKey(rowId));
+            return versionChainTree.findOne(new VersionChainKey(rowId), new TreeRowClosure<>() {
+                @Override
+                public boolean apply(BplusTree<VersionChainKey, VersionChain> tree, BplusIo<VersionChainKey> io, long pageAddr, int idx) {
+                    return true;

Review Comment:
   Didn't understand your comment.



;14/Feb/23 10:10;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105577122


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPageMemoryMvPartitionStorage.java:
##########
@@ -944,15 +862,67 @@ public void finishCleanup() {
         }
     }
 
-    @Nullable VersionChain readVersionChain(RowId rowId) {
+    void throwExceptionIfStorageNotInRunnableState() {
+        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    }
+
+    /**
+     * Searches version chain by row ID and converts the found version chain to the result if found.
+     *
+     * @param rowId Row ID.
+     * @param function Function for converting the version chain to a result, function is executed under the read lock of the page on which
+     *      the version chain is located. If the version chain is not found, then {@code null} will be passed to the function.
+     */
+    <T> @Nullable T findVersionChain(RowId rowId, Function<VersionChain, T> function) {
         try {
-            return versionChainTree.findOne(new VersionChainKey(rowId));
+            return versionChainTree.findOne(new VersionChainKey(rowId), new TreeRowClosure<>() {
+                @Override
+                public boolean apply(BplusTree<VersionChainKey, VersionChain> tree, BplusIo<VersionChainKey> io, long pageAddr, int idx) {
+                    return true;
+                }
+
+                @Override
+                public T map(VersionChain treeRow) {
+                    return function.apply(treeRow);
+                }
+            }, null);
         } catch (IgniteInternalCheckedException e) {
-            throw new StorageException(""Error getting version chain: [rowId={}, {}]"", e, rowId, createStorageInfo());
+            if (e.getCause() instanceof StorageException) {
+                throw (StorageException) e.getCause();
+            }
+
+            throw new StorageException(""Row version lookup failed: [rowId={}, {}]"", e, rowId, createStorageInfo());
         }
     }
 
-    void throwExceptionIfStorageNotInRunnableState() {
-        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    /**
+     * Organizes external synchronization of update operations for the same version chain.
+     *
+     * <p>NOTE: When you try to execute in the closures on the pages of the tree, it leads to a deadlock.
+     */
+    protected <T> T inUpdateVersionChainLock(RowId rowId, Supplier<T> supplier) {
+        LockHolder<ReentrantLock> lockHolder = updateVersionChainLockByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {

Review Comment:
   At the moment, this map only locks updates.
   I will try to describe it in the documentation for the class.



;14/Feb/23 10:13;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105578055


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPageMemoryMvPartitionStorage.java:
##########
@@ -944,15 +862,67 @@ public void finishCleanup() {
         }
     }
 
-    @Nullable VersionChain readVersionChain(RowId rowId) {
+    void throwExceptionIfStorageNotInRunnableState() {
+        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    }
+
+    /**
+     * Searches version chain by row ID and converts the found version chain to the result if found.
+     *
+     * @param rowId Row ID.
+     * @param function Function for converting the version chain to a result, function is executed under the read lock of the page on which
+     *      the version chain is located. If the version chain is not found, then {@code null} will be passed to the function.
+     */
+    <T> @Nullable T findVersionChain(RowId rowId, Function<VersionChain, T> function) {
         try {
-            return versionChainTree.findOne(new VersionChainKey(rowId));
+            return versionChainTree.findOne(new VersionChainKey(rowId), new TreeRowClosure<>() {
+                @Override
+                public boolean apply(BplusTree<VersionChainKey, VersionChain> tree, BplusIo<VersionChainKey> io, long pageAddr, int idx) {
+                    return true;
+                }
+
+                @Override
+                public T map(VersionChain treeRow) {
+                    return function.apply(treeRow);
+                }
+            }, null);
         } catch (IgniteInternalCheckedException e) {
-            throw new StorageException(""Error getting version chain: [rowId={}, {}]"", e, rowId, createStorageInfo());
+            if (e.getCause() instanceof StorageException) {
+                throw (StorageException) e.getCause();
+            }
+
+            throw new StorageException(""Row version lookup failed: [rowId={}, {}]"", e, rowId, createStorageInfo());
         }
     }
 
-    void throwExceptionIfStorageNotInRunnableState() {
-        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    /**
+     * Organizes external synchronization of update operations for the same version chain.
+     *
+     * <p>NOTE: When you try to execute in the closures on the pages of the tree, it leads to a deadlock.

Review Comment:
   I will try to describe it in the documentation for the class.



;14/Feb/23 10:14;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105581554


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AddWriteCommittedInvokeClosure.java:
##########
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.pagememory.mv;
+
+import static org.apache.ignite.internal.pagememory.util.PageIdUtils.NULL_LINK;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.rowBytes;
+
+import java.nio.ByteBuffer;
+import org.apache.ignite.internal.hlc.HybridTimestamp;
+import org.apache.ignite.internal.pagememory.tree.BplusTree;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.InvokeClosure;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.OperationType;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.lang.IgniteInternalCheckedException;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link InvokeClosure} for
+ * {@link AbstractPageMemoryMvPartitionStorage#addWriteCommitted(RowId, BinaryRow, HybridTimestamp)}.
+ *
+ * <p>Synchronization between reading and updating the version chain occurs due to the locks (read and write) of the page of the tree on
+ * which the version chain is located.
+ *
+ * <p>Synchronization between update operations for the version chain must be external (by {@link RowId row ID}).
+ *
+ * <p>Operation may throw {@link StorageException} which will cause form {@link BplusTree#invoke(Object, Object, InvokeClosure)}.
+ */
+class AddWriteCommittedInvokeClosure implements InvokeClosure<VersionChain> {
+    private final RowId rowId;
+
+    private final @Nullable BinaryRow row;
+
+    private final HybridTimestamp commitTimestamp;
+
+    private final AbstractPageMemoryMvPartitionStorage storage;
+
+    private @Nullable VersionChain newRow;
+
+    AddWriteCommittedInvokeClosure(
+            RowId rowId,
+            @Nullable BinaryRow row,
+            HybridTimestamp commitTimestamp,
+            AbstractPageMemoryMvPartitionStorage storage
+    ) {
+        this.rowId = rowId;
+        this.row = row;
+        this.commitTimestamp = commitTimestamp;
+        this.storage = storage;
+    }
+
+    @Override
+    public void call(@Nullable VersionChain oldRow) throws IgniteInternalCheckedException {
+        if (oldRow != null && oldRow.isUncommitted()) {

Review Comment:
   I think that we cannot, for example, it is checked here:
   `org.apache.ignite.internal.storage.AbstractMvPartitionStorageTest#addWriteCommittedThrowsIfUncommittedVersionExists`



;14/Feb/23 10:17;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105585427


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AddWriteCommittedInvokeClosure.java:
##########
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.pagememory.mv;
+
+import static org.apache.ignite.internal.pagememory.util.PageIdUtils.NULL_LINK;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.rowBytes;
+
+import java.nio.ByteBuffer;
+import org.apache.ignite.internal.hlc.HybridTimestamp;
+import org.apache.ignite.internal.pagememory.tree.BplusTree;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.InvokeClosure;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.OperationType;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.lang.IgniteInternalCheckedException;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link InvokeClosure} for
+ * {@link AbstractPageMemoryMvPartitionStorage#addWriteCommitted(RowId, BinaryRow, HybridTimestamp)}.
+ *
+ * <p>Synchronization between reading and updating the version chain occurs due to the locks (read and write) of the page of the tree on
+ * which the version chain is located.
+ *
+ * <p>Synchronization between update operations for the version chain must be external (by {@link RowId row ID}).
+ *
+ * <p>Operation may throw {@link StorageException} which will cause form {@link BplusTree#invoke(Object, Object, InvokeClosure)}.
+ */
+class AddWriteCommittedInvokeClosure implements InvokeClosure<VersionChain> {
+    private final RowId rowId;
+
+    private final @Nullable BinaryRow row;
+
+    private final HybridTimestamp commitTimestamp;
+
+    private final AbstractPageMemoryMvPartitionStorage storage;
+
+    private @Nullable VersionChain newRow;
+
+    AddWriteCommittedInvokeClosure(
+            RowId rowId,
+            @Nullable BinaryRow row,
+            HybridTimestamp commitTimestamp,
+            AbstractPageMemoryMvPartitionStorage storage
+    ) {
+        this.rowId = rowId;
+        this.row = row;
+        this.commitTimestamp = commitTimestamp;
+        this.storage = storage;
+    }
+
+    @Override
+    public void call(@Nullable VersionChain oldRow) throws IgniteInternalCheckedException {
+        if (oldRow != null && oldRow.isUncommitted()) {
+            // This means that there is a bug in our code as the caller must make sure that no write intent exists below this write.
+            throw new StorageException(""Write intent exists: [rowId={}, {}]"", oldRow.rowId(), storage.createStorageInfo());

Review Comment:
   It uses the default code (`org.apache.ignite.lang.ErrorGroups.Storage#GENERIC_ERR`), I don't know how we need the code here.



;14/Feb/23 10:20;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105589131


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AddWriteInvokeClosure.java:
##########
@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.pagememory.mv;
+
+import static org.apache.ignite.internal.pagememory.util.PageIdUtils.NULL_LINK;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.ALWAYS_LOAD_VALUE;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.rowBytes;
+
+import java.nio.ByteBuffer;
+import java.util.UUID;
+import org.apache.ignite.internal.pagememory.tree.BplusTree;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.InvokeClosure;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.OperationType;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.storage.MvPartitionStorage;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.internal.storage.TxIdMismatchException;
+import org.apache.ignite.lang.IgniteInternalCheckedException;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link InvokeClosure} for {@link AbstractPageMemoryMvPartitionStorage#addWrite(RowId, BinaryRow, UUID, UUID, int)}.
+ *
+ * <p>Synchronization between reading and updating the version chain occurs due to the locks (read and write) of the page of the tree on
+ * which the version chain is located.
+ *
+ * <p>Synchronization between update operations for the version chain must be external (by {@link RowId row ID}).
+ *
+ * <p>Operation may throw {@link StorageException} and {@link TxIdMismatchException} which will cause form
+ * {@link BplusTree#invoke(Object, Object, InvokeClosure)}.
+ */
+class AddWriteInvokeClosure implements InvokeClosure<VersionChain> {
+    private final RowId rowId;
+
+    private final @Nullable BinaryRow row;
+
+    private final UUID txId;
+
+    private final UUID commitTableId;
+
+    private final int commitPartitionId;
+
+    private final AbstractPageMemoryMvPartitionStorage storage;
+
+    private @Nullable VersionChain newRow;
+
+    private @Nullable BinaryRow previousUncommittedRowVersion;
+
+    private @Nullable RowVersion toRemove;
+
+    AddWriteInvokeClosure(
+            RowId rowId,
+            @Nullable BinaryRow row,
+            UUID txId,
+            UUID commitTableId,
+            int commitPartitionId,
+            AbstractPageMemoryMvPartitionStorage storage
+    ) {
+        this.rowId = rowId;
+        this.row = row;
+        this.txId = txId;
+        this.commitTableId = commitTableId;
+        this.commitPartitionId = commitPartitionId;
+        this.storage = storage;
+    }
+
+    @Override
+    public void call(@Nullable VersionChain oldRow) throws IgniteInternalCheckedException {
+        if (oldRow == null) {
+            RowVersion newVersion = insertRowVersion(row, NULL_LINK);
+
+            newRow = VersionChain.createUncommitted(rowId, txId, commitTableId, commitPartitionId, newVersion.link(), NULL_LINK);
+
+            return;
+        }
+
+        if (oldRow.isUncommitted()) {
+            throwIfChainBelongsToAnotherTx(oldRow, txId);

Review Comment:
   Fix it



;14/Feb/23 10:23;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105598271


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AddWriteCommittedInvokeClosure.java:
##########
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.pagememory.mv;
+
+import static org.apache.ignite.internal.pagememory.util.PageIdUtils.NULL_LINK;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.rowBytes;
+
+import java.nio.ByteBuffer;
+import org.apache.ignite.internal.hlc.HybridTimestamp;
+import org.apache.ignite.internal.pagememory.tree.BplusTree;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.InvokeClosure;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.OperationType;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.lang.IgniteInternalCheckedException;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link InvokeClosure} for
+ * {@link AbstractPageMemoryMvPartitionStorage#addWriteCommitted(RowId, BinaryRow, HybridTimestamp)}.
+ *
+ * <p>Synchronization between reading and updating the version chain occurs due to the locks (read and write) of the page of the tree on
+ * which the version chain is located.
+ *
+ * <p>Synchronization between update operations for the version chain must be external (by {@link RowId row ID}).
+ *
+ * <p>Operation may throw {@link StorageException} which will cause form {@link BplusTree#invoke(Object, Object, InvokeClosure)}.
+ */
+class AddWriteCommittedInvokeClosure implements InvokeClosure<VersionChain> {
+    private final RowId rowId;
+
+    private final @Nullable BinaryRow row;
+
+    private final HybridTimestamp commitTimestamp;
+
+    private final AbstractPageMemoryMvPartitionStorage storage;
+
+    private @Nullable VersionChain newRow;
+
+    AddWriteCommittedInvokeClosure(
+            RowId rowId,
+            @Nullable BinaryRow row,
+            HybridTimestamp commitTimestamp,
+            AbstractPageMemoryMvPartitionStorage storage
+    ) {
+        this.rowId = rowId;
+        this.row = row;
+        this.commitTimestamp = commitTimestamp;
+        this.storage = storage;
+    }
+
+    @Override
+    public void call(@Nullable VersionChain oldRow) throws IgniteInternalCheckedException {
+        if (oldRow != null && oldRow.isUncommitted()) {

Review Comment:
   This bug was carried over from a previous implementation. 
   I think we need to fix all exceptions in a separate ticket.



;14/Feb/23 10:31;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105598540


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AddWriteCommittedInvokeClosure.java:
##########
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.pagememory.mv;
+
+import static org.apache.ignite.internal.pagememory.util.PageIdUtils.NULL_LINK;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.rowBytes;
+
+import java.nio.ByteBuffer;
+import org.apache.ignite.internal.hlc.HybridTimestamp;
+import org.apache.ignite.internal.pagememory.tree.BplusTree;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.InvokeClosure;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.OperationType;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.lang.IgniteInternalCheckedException;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link InvokeClosure} for
+ * {@link AbstractPageMemoryMvPartitionStorage#addWriteCommitted(RowId, BinaryRow, HybridTimestamp)}.
+ *
+ * <p>Synchronization between reading and updating the version chain occurs due to the locks (read and write) of the page of the tree on
+ * which the version chain is located.
+ *
+ * <p>Synchronization between update operations for the version chain must be external (by {@link RowId row ID}).
+ *
+ * <p>Operation may throw {@link StorageException} which will cause form {@link BplusTree#invoke(Object, Object, InvokeClosure)}.
+ */
+class AddWriteCommittedInvokeClosure implements InvokeClosure<VersionChain> {
+    private final RowId rowId;
+
+    private final @Nullable BinaryRow row;
+
+    private final HybridTimestamp commitTimestamp;
+
+    private final AbstractPageMemoryMvPartitionStorage storage;
+
+    private @Nullable VersionChain newRow;
+
+    AddWriteCommittedInvokeClosure(
+            RowId rowId,
+            @Nullable BinaryRow row,
+            HybridTimestamp commitTimestamp,
+            AbstractPageMemoryMvPartitionStorage storage
+    ) {
+        this.rowId = rowId;
+        this.row = row;
+        this.commitTimestamp = commitTimestamp;
+        this.storage = storage;
+    }
+
+    @Override
+    public void call(@Nullable VersionChain oldRow) throws IgniteInternalCheckedException {
+        if (oldRow != null && oldRow.isUncommitted()) {
+            // This means that there is a bug in our code as the caller must make sure that no write intent exists below this write.
+            throw new StorageException(""Write intent exists: [rowId={}, {}]"", oldRow.rowId(), storage.createStorageInfo());

Review Comment:
   This bug was carried over from a previous implementation. I think we need to fix all exceptions in a separate ticket.



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AddWriteCommittedInvokeClosure.java:
##########
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.pagememory.mv;
+
+import static org.apache.ignite.internal.pagememory.util.PageIdUtils.NULL_LINK;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.rowBytes;
+
+import java.nio.ByteBuffer;
+import org.apache.ignite.internal.hlc.HybridTimestamp;
+import org.apache.ignite.internal.pagememory.tree.BplusTree;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.InvokeClosure;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.OperationType;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.lang.IgniteInternalCheckedException;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link InvokeClosure} for
+ * {@link AbstractPageMemoryMvPartitionStorage#addWriteCommitted(RowId, BinaryRow, HybridTimestamp)}.
+ *
+ * <p>Synchronization between reading and updating the version chain occurs due to the locks (read and write) of the page of the tree on
+ * which the version chain is located.
+ *
+ * <p>Synchronization between update operations for the version chain must be external (by {@link RowId row ID}).
+ *
+ * <p>Operation may throw {@link StorageException} which will cause form {@link BplusTree#invoke(Object, Object, InvokeClosure)}.
+ */
+class AddWriteCommittedInvokeClosure implements InvokeClosure<VersionChain> {
+    private final RowId rowId;
+
+    private final @Nullable BinaryRow row;
+
+    private final HybridTimestamp commitTimestamp;
+
+    private final AbstractPageMemoryMvPartitionStorage storage;
+
+    private @Nullable VersionChain newRow;
+
+    AddWriteCommittedInvokeClosure(
+            RowId rowId,
+            @Nullable BinaryRow row,
+            HybridTimestamp commitTimestamp,
+            AbstractPageMemoryMvPartitionStorage storage
+    ) {
+        this.rowId = rowId;
+        this.row = row;
+        this.commitTimestamp = commitTimestamp;
+        this.storage = storage;
+    }
+
+    @Override
+    public void call(@Nullable VersionChain oldRow) throws IgniteInternalCheckedException {
+        if (oldRow != null && oldRow.isUncommitted()) {
+            // This means that there is a bug in our code as the caller must make sure that no write intent exists below this write.
+            throw new StorageException(""Write intent exists: [rowId={}, {}]"", oldRow.rowId(), storage.createStorageInfo());

Review Comment:
   This error was carried over from a previous implementation. I think we need to fix all exceptions in a separate ticket.



;14/Feb/23 10:32;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105601737


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/CommitWriteInvokeClosure.java:
##########
@@ -0,0 +1,101 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.pagememory.mv;
+
+import org.apache.ignite.internal.hlc.HybridTimestamp;
+import org.apache.ignite.internal.pagememory.tree.BplusTree;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.InvokeClosure;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.OperationType;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.lang.IgniteInternalCheckedException;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link InvokeClosure} for {@link AbstractPageMemoryMvPartitionStorage#commitWrite(RowId, HybridTimestamp)}.
+ *
+ * <p>Synchronization between reading and updating the version chain occurs due to the locks (read and write) of the page of the tree on
+ * which the version chain is located.
+ *
+ * <p>Synchronization between update operations for the version chain must be external (by {@link RowId row ID}).
+ *
+ * <p>Operation may throw {@link StorageException} which will cause form {@link BplusTree#invoke(Object, Object, InvokeClosure)}.

Review Comment:
   I propose to deal with exceptions in individual tickets.



;14/Feb/23 10:35;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105633197


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AddWriteInvokeClosure.java:
##########
@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.pagememory.mv;
+
+import static org.apache.ignite.internal.pagememory.util.PageIdUtils.NULL_LINK;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.ALWAYS_LOAD_VALUE;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.rowBytes;
+
+import java.nio.ByteBuffer;
+import java.util.UUID;
+import org.apache.ignite.internal.pagememory.tree.BplusTree;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.InvokeClosure;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.OperationType;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.storage.MvPartitionStorage;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.internal.storage.TxIdMismatchException;
+import org.apache.ignite.lang.IgniteInternalCheckedException;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link InvokeClosure} for {@link AbstractPageMemoryMvPartitionStorage#addWrite(RowId, BinaryRow, UUID, UUID, int)}.
+ *
+ * <p>Synchronization between reading and updating the version chain occurs due to the locks (read and write) of the page of the tree on
+ * which the version chain is located.
+ *
+ * <p>Synchronization between update operations for the version chain must be external (by {@link RowId row ID}).
+ *
+ * <p>Operation may throw {@link StorageException} and {@link TxIdMismatchException} which will cause form
+ * {@link BplusTree#invoke(Object, Object, InvokeClosure)}.
+ */
+class AddWriteInvokeClosure implements InvokeClosure<VersionChain> {
+    private final RowId rowId;
+
+    private final @Nullable BinaryRow row;
+
+    private final UUID txId;
+
+    private final UUID commitTableId;
+
+    private final int commitPartitionId;
+
+    private final AbstractPageMemoryMvPartitionStorage storage;
+
+    private @Nullable VersionChain newRow;
+
+    private @Nullable BinaryRow previousUncommittedRowVersion;
+
+    private @Nullable RowVersion toRemove;
+
+    AddWriteInvokeClosure(
+            RowId rowId,
+            @Nullable BinaryRow row,
+            UUID txId,
+            UUID commitTableId,
+            int commitPartitionId,
+            AbstractPageMemoryMvPartitionStorage storage
+    ) {
+        this.rowId = rowId;
+        this.row = row;
+        this.txId = txId;
+        this.commitTableId = commitTableId;
+        this.commitPartitionId = commitPartitionId;
+        this.storage = storage;
+    }
+
+    @Override
+    public void call(@Nullable VersionChain oldRow) throws IgniteInternalCheckedException {
+        if (oldRow == null) {
+            RowVersion newVersion = insertRowVersion(row, NULL_LINK);
+
+            newRow = VersionChain.createUncommitted(rowId, txId, commitTableId, commitPartitionId, newVersion.link(), NULL_LINK);
+
+            return;
+        }
+
+        if (oldRow.isUncommitted()) {
+            throwIfChainBelongsToAnotherTx(oldRow, txId);
+        }
+
+        RowVersion newVersion = insertRowVersion(row, oldRow.newestCommittedLink());
+
+        if (oldRow.isUncommitted()) {
+            RowVersion currentVersion = storage.readRowVersion(oldRow.headLink(), ALWAYS_LOAD_VALUE);
+
+            previousUncommittedRowVersion = storage.rowVersionToBinaryRow(currentVersion);
+
+            // As we replace an uncommitted version with new one, we need to remove old uncommitted version.
+            toRemove = currentVersion;
+        }
+
+        newRow = VersionChain.createUncommitted(rowId, txId, commitTableId, commitPartitionId, newVersion.link(), newVersion.nextLink());
+    }
+
+    @Override
+    public @Nullable VersionChain newRow() {
+        assert newRow != null;
+
+        return newRow;
+    }
+
+    @Override
+    public OperationType operationType() {
+        return OperationType.PUT;
+    }
+
+    @Override
+    public void onUpdate() {
+        if (toRemove != null) {
+            storage.removeRowVersion(toRemove);

Review Comment:
   I agree, I'll fix it.



;14/Feb/23 11:04;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105636095


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbortWriteInvokeClosure.java:
##########
@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.storage.pagememory.mv;
+
+import static org.apache.ignite.internal.pagememory.util.PageIdUtils.NULL_LINK;
+import static org.apache.ignite.internal.storage.pagememory.mv.AbstractPageMemoryMvPartitionStorage.ALWAYS_LOAD_VALUE;
+
+import org.apache.ignite.internal.pagememory.tree.BplusTree;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.InvokeClosure;
+import org.apache.ignite.internal.pagememory.tree.IgniteTree.OperationType;
+import org.apache.ignite.internal.schema.BinaryRow;
+import org.apache.ignite.internal.storage.MvPartitionStorage;
+import org.apache.ignite.internal.storage.RowId;
+import org.apache.ignite.internal.storage.StorageException;
+import org.apache.ignite.lang.IgniteInternalCheckedException;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link InvokeClosure} for {@link AbstractPageMemoryMvPartitionStorage#abortWrite(RowId)}.
+ *
+ * <p>Synchronization between reading and updating the version chain occurs due to the locks (read and write) of the page of the tree on
+ * which the version chain is located.
+ *
+ * <p>Synchronization between update operations for the version chain must be external (by {@link RowId row ID}).
+ *
+ * <p>Operation may throw {@link StorageException} which will cause form {@link BplusTree#invoke(Object, Object, InvokeClosure)}.
+ */
+class AbortWriteInvokeClosure implements InvokeClosure<VersionChain> {
+    private final RowId rowId;
+
+    private final AbstractPageMemoryMvPartitionStorage storage;
+
+    private OperationType operationType;
+
+    private @Nullable VersionChain newRow;
+
+    private @Nullable RowVersion toRemove;
+
+    private @Nullable BinaryRow previousUncommittedRowVersion;
+
+    AbortWriteInvokeClosure(RowId rowId, AbstractPageMemoryMvPartitionStorage storage) {
+        this.rowId = rowId;
+        this.storage = storage;
+    }
+
+    @Override
+    public void call(@Nullable VersionChain oldRow) throws IgniteInternalCheckedException {
+        if (oldRow == null || oldRow.transactionId() == null) {
+            // Row doesn't exist or the chain doesn't contain an uncommitted write intent.
+            operationType = OperationType.NOOP;
+
+            return;
+        }
+
+        RowVersion latestVersion = storage.readRowVersion(oldRow.headLink(), ALWAYS_LOAD_VALUE);
+
+        assert latestVersion.isUncommitted();
+
+        toRemove = latestVersion;
+
+        if (latestVersion.hasNextLink()) {
+            // Next can be safely replaced with any value (like 0), because this field is only used when there
+            // is some uncommitted value, but when we add an uncommitted value, we 'fix' such placeholder value
+            // (like 0) by replacing it with a valid value.
+            newRow = VersionChain.createCommitted(rowId, latestVersion.nextLink(), NULL_LINK);
+
+            operationType = OperationType.PUT;
+        } else {
+            // It was the only version, let's remove the chain as well.
+            operationType = OperationType.REMOVE;
+        }
+
+        previousUncommittedRowVersion = storage.rowVersionToBinaryRow(latestVersion);
+    }
+
+    @Override
+    public @Nullable VersionChain newRow() {
+        assert operationType == OperationType.PUT ? newRow != null : newRow == null : ""newRow="" + newRow + "", op="" + operationType;
+
+        return newRow;
+    }
+
+    @Override
+    public OperationType operationType() {
+        assert operationType != null;
+
+        return operationType;
+    }
+
+    @Override
+    public void onUpdate() {
+        assert operationType == OperationType.NOOP ? toRemove == null : toRemove != null : ""toRemove="" + toRemove + "", op="" + operationType;
+
+        if (toRemove != null) {
+            storage.removeRowVersion(toRemove);
+        }

Review Comment:
   I agree, I'll fix it.



;14/Feb/23 11:07;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105647541


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPageMemoryMvPartitionStorage.java:
##########
@@ -944,15 +862,67 @@ public void finishCleanup() {
         }
     }
 
-    @Nullable VersionChain readVersionChain(RowId rowId) {
+    void throwExceptionIfStorageNotInRunnableState() {
+        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    }
+
+    /**
+     * Searches version chain by row ID and converts the found version chain to the result if found.
+     *
+     * @param rowId Row ID.
+     * @param function Function for converting the version chain to a result, function is executed under the read lock of the page on which
+     *      the version chain is located. If the version chain is not found, then {@code null} will be passed to the function.
+     */
+    <T> @Nullable T findVersionChain(RowId rowId, Function<VersionChain, T> function) {

Review Comment:
   Tried to fix it



;14/Feb/23 11:17;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105648573


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPageMemoryMvPartitionStorage.java:
##########
@@ -944,15 +862,67 @@ public void finishCleanup() {
         }
     }
 
-    @Nullable VersionChain readVersionChain(RowId rowId) {
+    void throwExceptionIfStorageNotInRunnableState() {
+        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    }
+
+    /**
+     * Searches version chain by row ID and converts the found version chain to the result if found.
+     *
+     * @param rowId Row ID.
+     * @param function Function for converting the version chain to a result, function is executed under the read lock of the page on which
+     *      the version chain is located. If the version chain is not found, then {@code null} will be passed to the function.
+     */
+    <T> @Nullable T findVersionChain(RowId rowId, Function<VersionChain, T> function) {
         try {
-            return versionChainTree.findOne(new VersionChainKey(rowId));
+            return versionChainTree.findOne(new VersionChainKey(rowId), new TreeRowClosure<>() {
+                @Override
+                public boolean apply(BplusTree<VersionChainKey, VersionChain> tree, BplusIo<VersionChainKey> io, long pageAddr, int idx) {
+                    return true;

Review Comment:
   Discussed personally, we need to add this default behavior to the interface.



;14/Feb/23 11:18;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105577122


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPageMemoryMvPartitionStorage.java:
##########
@@ -944,15 +862,67 @@ public void finishCleanup() {
         }
     }
 
-    @Nullable VersionChain readVersionChain(RowId rowId) {
+    void throwExceptionIfStorageNotInRunnableState() {
+        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    }
+
+    /**
+     * Searches version chain by row ID and converts the found version chain to the result if found.
+     *
+     * @param rowId Row ID.
+     * @param function Function for converting the version chain to a result, function is executed under the read lock of the page on which
+     *      the version chain is located. If the version chain is not found, then {@code null} will be passed to the function.
+     */
+    <T> @Nullable T findVersionChain(RowId rowId, Function<VersionChain, T> function) {
         try {
-            return versionChainTree.findOne(new VersionChainKey(rowId));
+            return versionChainTree.findOne(new VersionChainKey(rowId), new TreeRowClosure<>() {
+                @Override
+                public boolean apply(BplusTree<VersionChainKey, VersionChain> tree, BplusIo<VersionChainKey> io, long pageAddr, int idx) {
+                    return true;
+                }
+
+                @Override
+                public T map(VersionChain treeRow) {
+                    return function.apply(treeRow);
+                }
+            }, null);
         } catch (IgniteInternalCheckedException e) {
-            throw new StorageException(""Error getting version chain: [rowId={}, {}]"", e, rowId, createStorageInfo());
+            if (e.getCause() instanceof StorageException) {
+                throw (StorageException) e.getCause();
+            }
+
+            throw new StorageException(""Row version lookup failed: [rowId={}, {}]"", e, rowId, createStorageInfo());
         }
     }
 
-    void throwExceptionIfStorageNotInRunnableState() {
-        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    /**
+     * Organizes external synchronization of update operations for the same version chain.
+     *
+     * <p>NOTE: When you try to execute in the closures on the pages of the tree, it leads to a deadlock.
+     */
+    protected <T> T inUpdateVersionChainLock(RowId rowId, Supplier<T> supplier) {
+        LockHolder<ReentrantLock> lockHolder = updateVersionChainLockByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {

Review Comment:
   When not very much, do you think we need to put it in a separate class?
   At the moment, this map only locks updates.
   I will try to describe it in the documentation for the class.



##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPageMemoryMvPartitionStorage.java:
##########
@@ -944,15 +862,67 @@ public void finishCleanup() {
         }
     }
 
-    @Nullable VersionChain readVersionChain(RowId rowId) {
+    void throwExceptionIfStorageNotInRunnableState() {
+        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    }
+
+    /**
+     * Searches version chain by row ID and converts the found version chain to the result if found.
+     *
+     * @param rowId Row ID.
+     * @param function Function for converting the version chain to a result, function is executed under the read lock of the page on which
+     *      the version chain is located. If the version chain is not found, then {@code null} will be passed to the function.
+     */
+    <T> @Nullable T findVersionChain(RowId rowId, Function<VersionChain, T> function) {
         try {
-            return versionChainTree.findOne(new VersionChainKey(rowId));
+            return versionChainTree.findOne(new VersionChainKey(rowId), new TreeRowClosure<>() {
+                @Override
+                public boolean apply(BplusTree<VersionChainKey, VersionChain> tree, BplusIo<VersionChainKey> io, long pageAddr, int idx) {
+                    return true;
+                }
+
+                @Override
+                public T map(VersionChain treeRow) {
+                    return function.apply(treeRow);
+                }
+            }, null);
         } catch (IgniteInternalCheckedException e) {
-            throw new StorageException(""Error getting version chain: [rowId={}, {}]"", e, rowId, createStorageInfo());
+            if (e.getCause() instanceof StorageException) {
+                throw (StorageException) e.getCause();
+            }
+
+            throw new StorageException(""Row version lookup failed: [rowId={}, {}]"", e, rowId, createStorageInfo());
         }
     }
 
-    void throwExceptionIfStorageNotInRunnableState() {
-        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    /**
+     * Organizes external synchronization of update operations for the same version chain.
+     *
+     * <p>NOTE: When you try to execute in the closures on the pages of the tree, it leads to a deadlock.
+     */
+    protected <T> T inUpdateVersionChainLock(RowId rowId, Supplier<T> supplier) {
+        LockHolder<ReentrantLock> lockHolder = updateVersionChainLockByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {

Review Comment:
   When not very much, do you think we need to put it in a separate class?
   
   At the moment, this map only locks updates.
   I will try to describe it in the documentation for the class.



;14/Feb/23 11:18;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105678848


##########
modules/page-memory/src/integrationTest/java/org/apache/ignite/internal/pagememory/tree/AbstractBplusTreePageMemoryTest.java:
##########
@@ -2367,6 +2371,157 @@ void testFindNext() throws Exception {
         assertEquals(0L, tree.findNext(-1L, true));
     }
 
+    @Test
+    void testFindOneWithMapper() throws Exception {
+        TestTree tree = createTestTree(true);
+
+        tree.put(0L);
+
+        TreeRowClosure<Long, Long> treeRowClosure = new TreeRowClosure<>() {
+            @Override
+            public boolean apply(BplusTree<Long, Long> tree, BplusIo<Long> io, long pageAddr, int idx) {
+                return true;
+            }
+
+            @Override
+            public String map(Long treeRow) {

Review Comment:
   Tried to fix it.



##########
modules/page-memory/src/main/java/org/apache/ignite/internal/pagememory/tree/BplusTree.java:
##########
@@ -1270,12 +1270,14 @@ public Cursor<T> find(
      * @param upper Upper bound or {@code null} if unbounded.
      * @param lowIncl {@code true} if lower bound is inclusive.
      * @param upIncl {@code true} if upper bound is inclusive.
-     * @param c Filter closure.
+     * @param c Tree row closure.
      * @param x Implementation specific argument, {@code null} always means that we need to return full detached data row.
      * @return Cursor.
-     * @throws IgniteInternalCheckedException If failed.
+     * @throws CorruptedDataStructureException If the data structure is broken.
+     * @throws CorruptedTreeException If there were {@link RuntimeException} or {@link AssertionError}.
+     * @throws IgniteInternalCheckedException If other errors occurred.
      */
-    public Cursor<T> find(
+    public <R> Cursor<R> find(

Review Comment:
   Tried to fix it.



;14/Feb/23 11:33;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105679303


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPageMemoryMvPartitionStorage.java:
##########
@@ -944,15 +862,67 @@ public void finishCleanup() {
         }
     }
 
-    @Nullable VersionChain readVersionChain(RowId rowId) {
+    void throwExceptionIfStorageNotInRunnableState() {
+        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    }
+
+    /**
+     * Searches version chain by row ID and converts the found version chain to the result if found.
+     *
+     * @param rowId Row ID.
+     * @param function Function for converting the version chain to a result, function is executed under the read lock of the page on which
+     *      the version chain is located. If the version chain is not found, then {@code null} will be passed to the function.
+     */
+    <T> @Nullable T findVersionChain(RowId rowId, Function<VersionChain, T> function) {
         try {
-            return versionChainTree.findOne(new VersionChainKey(rowId));
+            return versionChainTree.findOne(new VersionChainKey(rowId), new TreeRowClosure<>() {
+                @Override
+                public boolean apply(BplusTree<VersionChainKey, VersionChain> tree, BplusIo<VersionChainKey> io, long pageAddr, int idx) {
+                    return true;

Review Comment:
   Tried to fix it.



;14/Feb/23 11:34;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105695769


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPartitionTimestampCursor.java:
##########
@@ -65,36 +61,32 @@ public boolean hasNext() {
 
             createVersionChainCursorIfMissing();
 
-            currentChain = null;
+            currentRowId = null;
 
             while (true) {
-                if (!versionChainCursor.hasNext()) {
+                if (!cursor.hasNext()) {
                     iterationExhausted = true;
 
                     return false;
                 }
 
-                VersionChain chain = versionChainCursor.next();
-
-                ReadResult result = readResultByRowId.remove(chain.rowId());
+                ReadResult result = cursor.next();
 
-                if (result == null) {
-                    // TODO: IGNITE-18717 Add lock by rowId
-                    chain = storage.readVersionChain(chain.rowId());
+                RowId rowId = result.rowId();
 
-                    if (chain == null) {
-                        continue;
-                    }
-
-                    result = findRowVersion(chain);
+                if (result.isEmpty()) {

Review Comment:
   Try to fix it



;14/Feb/23 11:45;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105699335


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPartitionTimestampCursor.java:
##########
@@ -164,28 +152,27 @@ public void close() {
     abstract ReadResult findRowVersion(VersionChain versionChain);
 
     private void createVersionChainCursorIfMissing() {
-        if (versionChainCursor != null) {
+        if (cursor != null) {
             return;
         }
 
         try {
-            versionChainCursor = storage.versionChainTree.find(null, null, (tree, io, pageAddr, idx) -> {
-                // Since the BplusTree cursor caches rows that are on the same page, we should try to get actual ReadResult for them in this
-                // filter so as not to get into a situation when we read the chain and the links in it are no longer valid.
-
-                VersionChain versionChain = tree.getRow(io, pageAddr, idx);
-
-                // TODO: IGNITE-18717 Perhaps add lock by rowId
-
-                ReadResult readResult = findRowVersion(versionChain);
-
-                if (!readResult.isEmpty()) {
-                    readResultByRowId.put(versionChain.rowId(), readResult);
+            cursor = storage.versionChainTree.find(null, null, new TreeRowClosure<>() {
+                @Override
+                public boolean apply(BplusTree<VersionChainKey, VersionChain> tree, BplusIo<VersionChainKey> io, long pageAddr, int idx) {
+                    return true;
                 }
 
-                return true;
+                @Override
+                public ReadResult map(VersionChain treeRow) {
+                    return findRowVersion(treeRow);
+                }
             }, null);
         } catch (IgniteInternalCheckedException e) {
+            if (e.getCause() instanceof StorageException) {
+                throw (StorageException) e.getCause();
+            }

Review Comment:
   Didn't understand you a bit.



;14/Feb/23 11:48;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105721796


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPartitionTimestampCursor.java:
##########
@@ -164,28 +152,27 @@ public void close() {
     abstract ReadResult findRowVersion(VersionChain versionChain);
 
     private void createVersionChainCursorIfMissing() {
-        if (versionChainCursor != null) {
+        if (cursor != null) {
             return;
         }
 
         try {
-            versionChainCursor = storage.versionChainTree.find(null, null, (tree, io, pageAddr, idx) -> {
-                // Since the BplusTree cursor caches rows that are on the same page, we should try to get actual ReadResult for them in this
-                // filter so as not to get into a situation when we read the chain and the links in it are no longer valid.
-
-                VersionChain versionChain = tree.getRow(io, pageAddr, idx);
-
-                // TODO: IGNITE-18717 Perhaps add lock by rowId
-
-                ReadResult readResult = findRowVersion(versionChain);
-
-                if (!readResult.isEmpty()) {
-                    readResultByRowId.put(versionChain.rowId(), readResult);
+            cursor = storage.versionChainTree.find(null, null, new TreeRowClosure<>() {
+                @Override
+                public boolean apply(BplusTree<VersionChainKey, VersionChain> tree, BplusIo<VersionChainKey> io, long pageAddr, int idx) {
+                    return true;
                 }
 
-                return true;
+                @Override
+                public ReadResult map(VersionChain treeRow) {
+                    return findRowVersion(treeRow);
+                }
             }, null);
         } catch (IgniteInternalCheckedException e) {
+            if (e.getCause() instanceof StorageException) {
+                throw (StorageException) e.getCause();
+            }

Review Comment:
   Fix it



;14/Feb/23 12:08;githubbot;600","ibessonov commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105843825


##########
modules/page-memory/src/main/java/org/apache/ignite/internal/pagememory/tree/BplusTree.java:
##########
@@ -6117,35 +6194,37 @@ private void iterate() throws IgniteInternalCheckedException {
     /**
      * Forward cursor.
      */
-    private final class ForwardCursor extends AbstractForwardCursor implements Cursor<T> {
+    private final class ForwardCursor<R> extends AbstractForwardCursor implements Cursor<R> {
         /** Implementation specific argument. */
-        @Nullable
-        final Object arg;
+        private final @Nullable Object arg;

Review Comment:
   I wasn't sure that tree class itself doesn't use it. It doesn't bother me



;14/Feb/23 13:46;githubbot;600","ibessonov commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105845239


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPageMemoryMvPartitionStorage.java:
##########
@@ -944,15 +862,67 @@ public void finishCleanup() {
         }
     }
 
-    @Nullable VersionChain readVersionChain(RowId rowId) {
+    void throwExceptionIfStorageNotInRunnableState() {
+        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    }
+
+    /**
+     * Searches version chain by row ID and converts the found version chain to the result if found.
+     *
+     * @param rowId Row ID.
+     * @param function Function for converting the version chain to a result, function is executed under the read lock of the page on which
+     *      the version chain is located. If the version chain is not found, then {@code null} will be passed to the function.
+     */
+    <T> @Nullable T findVersionChain(RowId rowId, Function<VersionChain, T> function) {
         try {
-            return versionChainTree.findOne(new VersionChainKey(rowId));
+            return versionChainTree.findOne(new VersionChainKey(rowId), new TreeRowClosure<>() {
+                @Override
+                public boolean apply(BplusTree<VersionChainKey, VersionChain> tree, BplusIo<VersionChainKey> io, long pageAddr, int idx) {
+                    return true;
+                }
+
+                @Override
+                public T map(VersionChain treeRow) {
+                    return function.apply(treeRow);
+                }
+            }, null);
         } catch (IgniteInternalCheckedException e) {
-            throw new StorageException(""Error getting version chain: [rowId={}, {}]"", e, rowId, createStorageInfo());
+            if (e.getCause() instanceof StorageException) {
+                throw (StorageException) e.getCause();
+            }
+
+            throw new StorageException(""Row version lookup failed: [rowId={}, {}]"", e, rowId, createStorageInfo());
         }
     }
 
-    void throwExceptionIfStorageNotInRunnableState() {
-        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    /**
+     * Organizes external synchronization of update operations for the same version chain.
+     *
+     * <p>NOTE: When you try to execute in the closures on the pages of the tree, it leads to a deadlock.
+     */
+    protected <T> T inUpdateVersionChainLock(RowId rowId, Supplier<T> supplier) {
+        LockHolder<ReentrantLock> lockHolder = updateVersionChainLockByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {

Review Comment:
   Generally speaking, this would be cool to have as a separate class. But it's up to you. Having all these manipulations with map and counters is a boilerplate that can easily be hidden



;14/Feb/23 13:47;githubbot;600","ibessonov commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105846601


##########
modules/page-memory/src/main/java/org/apache/ignite/internal/pagememory/tree/BplusTree.java:
##########
@@ -6576,6 +6577,16 @@ enum Bool {
          * @throws IgniteInternalCheckedException If failed.
          */
         boolean apply(BplusTree<L, T> tree, BplusIo<L> io, long pageAddr, int idx) throws IgniteInternalCheckedException;
+    }
+
+    /**
+     * Extension of the {@link TreeRowClosure} with the ability to {@link #map(Object) convert} tree row to some object.
+     */
+    public interface TreeRowMapClosure<L, T extends L, R> extends TreeRowClosure<L, T> {

Review Comment:
   This is clever, thank you!



;14/Feb/23 13:48;githubbot;600","tkalkirill commented on code in PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652#discussion_r1105882210


##########
modules/storage-page-memory/src/main/java/org/apache/ignite/internal/storage/pagememory/mv/AbstractPageMemoryMvPartitionStorage.java:
##########
@@ -944,15 +862,67 @@ public void finishCleanup() {
         }
     }
 
-    @Nullable VersionChain readVersionChain(RowId rowId) {
+    void throwExceptionIfStorageNotInRunnableState() {
+        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    }
+
+    /**
+     * Searches version chain by row ID and converts the found version chain to the result if found.
+     *
+     * @param rowId Row ID.
+     * @param function Function for converting the version chain to a result, function is executed under the read lock of the page on which
+     *      the version chain is located. If the version chain is not found, then {@code null} will be passed to the function.
+     */
+    <T> @Nullable T findVersionChain(RowId rowId, Function<VersionChain, T> function) {
         try {
-            return versionChainTree.findOne(new VersionChainKey(rowId));
+            return versionChainTree.findOne(new VersionChainKey(rowId), new TreeRowClosure<>() {
+                @Override
+                public boolean apply(BplusTree<VersionChainKey, VersionChain> tree, BplusIo<VersionChainKey> io, long pageAddr, int idx) {
+                    return true;
+                }
+
+                @Override
+                public T map(VersionChain treeRow) {
+                    return function.apply(treeRow);
+                }
+            }, null);
         } catch (IgniteInternalCheckedException e) {
-            throw new StorageException(""Error getting version chain: [rowId={}, {}]"", e, rowId, createStorageInfo());
+            if (e.getCause() instanceof StorageException) {
+                throw (StorageException) e.getCause();
+            }
+
+            throw new StorageException(""Row version lookup failed: [rowId={}, {}]"", e, rowId, createStorageInfo());
         }
     }
 
-    void throwExceptionIfStorageNotInRunnableState() {
-        StorageUtils.throwExceptionIfStorageNotInRunnableState(state.get(), this::createStorageInfo);
+    /**
+     * Organizes external synchronization of update operations for the same version chain.
+     *
+     * <p>NOTE: When you try to execute in the closures on the pages of the tree, it leads to a deadlock.
+     */
+    protected <T> T inUpdateVersionChainLock(RowId rowId, Supplier<T> supplier) {
+        LockHolder<ReentrantLock> lockHolder = updateVersionChainLockByRowId.compute(rowId, (rowId1, reentrantLockLockHolder) -> {

Review Comment:
   Perhaps for the moment I will leave everything as it is, because this map is used in one method.



;14/Feb/23 14:16;githubbot;600","tkalkirill merged PR #1652:
URL: https://github.com/apache/ignite-3/pull/1652


;14/Feb/23 14:53;githubbot;600",,,,,,,,,,,,,,,,,0,18000,,,0,18000,,,IGNITE-18736,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17571,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-02-06 09:59:04.0,,,,,,,,,,"0|z1foao:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
Not thread safe usage of InternalTableImpl#partitionMap,IGNITE-18714,13523188,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Sergey Uttsel,Sergey Uttsel,Sergey Uttsel,06/Feb/23 08:34,09/Feb/23 16:51,13/Jul/23 09:11,09/Feb/23 16:51,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"h3. Motivation

The mutex is used to update the partitionMap, but it is not used when reading from the partitionMap
h3. Definition of Done

Thread-safe usage of InternalTableImpl#partitionMap",,alapin,Sergey Uttsel,,,,"sergeyuttsel opened a new pull request, #1638:
URL: https://github.com/apache/ignite-3/pull/1638

   https://issues.apache.org/jira/browse/IGNITE-18714


;06/Feb/23 09:29;githubbot;600","sanpwc commented on code in PR #1638:
URL: https://github.com/apache/ignite-3/pull/1638#discussion_r1098885169


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/exec/rel/TableScanNodeExecutionTest.java:
##########
@@ -127,7 +128,11 @@ public IgniteDistribution distribution() {
 
         @Override
         public InternalTable table() {
-            return new TestInternalTableImpl(mock(ReplicaService.class));
+            ConcurrentMap<Integer, RaftGroupService> partMap = new ConcurrentSkipListMap<>();

Review Comment:
   What about copy on write approach?



;07/Feb/23 16:17;githubbot;600","sanpwc commented on code in PR #1638:
URL: https://github.com/apache/ignite-3/pull/1638#discussion_r1101085091


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/exec/rel/TableScanNodeExecutionTest.java:
##########
@@ -150,7 +149,6 @@ public TestInternalTableImpl(
             super(
                     ""test"",
                     UUID.randomUUID(),
-                    Int2ObjectMaps.singleton(0, mock(RaftGroupService.class)),

Review Comment:
   Why you've excluded given constructor param?



;09/Feb/23 07:50;githubbot;600","sanpwc commented on code in PR #1638:
URL: https://github.com/apache/ignite-3/pull/1638#discussion_r1101086959


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/storage/InternalTableImpl.java:
##########
@@ -1219,7 +1217,11 @@ public void updateInternalTableRaftGroupService(int p, RaftGroupService raftGrpS
         RaftGroupService oldSrvc;
 
         synchronized (updatePartMapMux) {

Review Comment:
   Do we need explicit synchronization here?



;09/Feb/23 07:52;githubbot;600","sanpwc commented on code in PR #1638:
URL: https://github.com/apache/ignite-3/pull/1638#discussion_r1101728674


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/storage/InternalTableImpl.java:
##########
@@ -1219,7 +1219,13 @@ public void updateInternalTableRaftGroupService(int p, RaftGroupService raftGrpS
         RaftGroupService oldSrvc;
 
         synchronized (updatePartMapMux) {
-            oldSrvc = partitionMap.put(p, raftGrpSvc);
+            Int2ObjectMap<RaftGroupService> newPartitionMap = new Int2ObjectOpenHashMap<>(partitions);
+
+            newPartitionMap.putAll(partitionMap);

Review Comment:
               Int2ObjectMap<RaftGroupService> newPartitionMap = new Int2ObjectOpenHashMap<>(partitionMap);



;09/Feb/23 16:27;githubbot;600","sanpwc commented on code in PR #1638:
URL: https://github.com/apache/ignite-3/pull/1638#discussion_r1101755509


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/storage/InternalTableImpl.java:
##########
@@ -1219,7 +1219,13 @@ public void updateInternalTableRaftGroupService(int p, RaftGroupService raftGrpS
         RaftGroupService oldSrvc;
 
         synchronized (updatePartMapMux) {
-            oldSrvc = partitionMap.put(p, raftGrpSvc);
+            Int2ObjectMap<RaftGroupService> newPartitionMap = new Int2ObjectOpenHashMap<>(partitions);
+
+            newPartitionMap.putAll(partitionMap);

Review Comment:
   Discussed in person. My proposal is incorrect.



;09/Feb/23 16:49;githubbot;600","sanpwc merged PR #1638:
URL: https://github.com/apache/ignite-3/pull/1638


;09/Feb/23 16:50;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,4200,,,0,4200,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-18737,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Feb 09 16:51:42 UTC 2023,,,,,,,,,,"0|z1fo74:",9223372036854775807,,,alapin,,,,,,,,,,,,,,,,,,"09/Feb/23 16:51;alapin;[~Sergey Uttsel] LGTM, thx!;;;",,,,,
"Compute ""withXXX"" modifiers are not applied if they came before withExecutor modifier.",IGNITE-18713,13523187,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,PetrovMikhail,PetrovMikhail,PetrovMikhail,06/Feb/23 08:21,11/Feb/23 09:18,13/Jul/23 09:11,07/Feb/23 11:31,,,,,,,,2.15,,,,0,,,,"After IGNITE-18545 the following code 

{code:java}
IgniteCompute compute = grid(0).compute().withTimeout(1000).withExecutor(""executor"").execute(<task>);
{code}

will result in task execution without timeout modifier applied.
",,ignitetcbot,PetrovMikhail,,,,"petrov-mg opened a new pull request, #10517:
URL: https://github.com/apache/ignite/pull/10517

   
   
   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;06/Feb/23 08:55;githubbot;600","petrov-mg merged PR #10517:
URL: https://github.com/apache/ignite/pull/10517


;07/Feb/23 11:30;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,IGNITE-18545,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Feb 07 11:22:05 UTC 2023,,,,,,,,,,"0|z1fo6w:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"07/Feb/23 08:12;ignitetcbot;{panel:title=Branch: [pull/10517/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10517/head] Base: [master] : New Tests (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Compute (Grid){color} [[tests 1|https://ci.ignite.apache.org/viewLog.html?buildId=7057149]]
* {color:#013220}IgniteBinaryObjectsComputeGridTestSuite: IgniteComputeCustomExecutorSelfTest.testMultipleTaskModifiersWithExecutorName - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci.ignite.apache.org/viewLog.html?buildId=7057226&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","07/Feb/23 11:22;ignitetcbot;{panel:title=Branch: [pull/10517/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10517/head] Base: [master] : New Tests (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Compute (Grid){color} [[tests 1|https://ci.ignite.apache.org/viewLog.html?buildId=7059328]]
* {color:#013220}IgniteBinaryObjectsComputeGridTestSuite: IgniteComputeCustomExecutorSelfTest.testMultipleTaskModifiersWithExecutorName - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci.ignite.apache.org/viewLog.html?buildId=7057226&amp;buildTypeId=IgniteTests24Java8_RunAll];;;",,,,
Incorrect binary tuple column mapping,IGNITE-18701,13522755,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,vpakhnushev,vpakhnushev,02/Feb/23 09:59,08/Feb/23 10:41,13/Jul/23 09:11,08/Feb/23 10:41,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,org.apache.ignite.internal.schema.BinaryTupleSchema.DenseRowSchema#columnIndex incorrectly subtracts the base index from the element index while it should add them.,,korlov,vpakhnushev,,,,"valepakh opened a new pull request, #1620:
URL: https://github.com/apache/ignite-3/pull/1620

   https://issues.apache.org/jira/browse/IGNITE-18701


;02/Feb/23 10:04;githubbot;600","korlov42 merged PR #1620:
URL: https://github.com/apache/ignite-3/pull/1620


;08/Feb/23 10:40;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Feb 08 10:41:30 UTC 2023,,,,,,,,,,"0|z1flj4:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"08/Feb/23 10:41;korlov;[~vpakhnushev], thanks for the contribution!

Merged to [main|https://github.com/apache/ignite-3/commit/2c752ac69f7d2b06f4e262202208074fb633da01].;;;",,,,,
Rebalance test is failed,IGNITE-18692,13522535,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,kgusakov,Sergey Uttsel,Sergey Uttsel,01/Feb/23 15:45,13/Jun/23 12:21,13/Jul/23 09:11,13/Jun/23 12:21,,,,,,,,,,,,0,ignite-3,,,"org.apache.ignite.internal.rebalance.ItRebalanceTest#assignmentsChangingOnNodeLeaveNodeJoin failed.

The failure is caused by commits:

db8f1e38 ""IGNITE-18397 Rework Watches based on Raft Learners (#1490)""

ff27d76d ""IGNITE-18598 Fix compilation after merge (#1560)""

I created separated branch with this test: [https://github.com/gridgain/apache-ignite-3/tree/ignite-18088_test] which based on ff27d76d ""IGNITE-18598 Fix compilation after merge (#1560)""

 
{code:java}
org.opentest4j.AssertionFailedError: expected: <true> but was: <false>
    at app//org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:55)
    at app//org.junit.jupiter.api.AssertTrue.assertTrue(AssertTrue.java:40)
    at app//org.junit.jupiter.api.AssertTrue.assertTrue(AssertTrue.java:35)
    at app//org.junit.jupiter.api.Assertions.assertTrue(Assertions.java:179)
    at app//org.apache.ignite.internal.rebalance.ItRebalanceTest.assignmentsChangingOnNodeLeaveNodeJoin(ItRebalanceTest.java:132) {code}",,apolovtcev,kgusakov,Sergey Uttsel,v.pyatkov,,"sashapolo opened a new pull request, #1771:
URL: https://github.com/apache/ignite-3/pull/1771

   https://issues.apache.org/jira/browse/IGNITE-18692


;09/Mar/23 15:08;githubbot;600","sashapolo closed pull request #1771: IGNITE-18692 Fix ItRebalanceTest
URL: https://github.com/apache/ignite-3/pull/1771


;13/Mar/23 15:05;githubbot;600","kgusakov opened a new pull request, #2157:
URL: https://github.com/apache/ignite-3/pull/2157

   (no comment)


;06/Jun/23 23:57;githubbot;600","sergeyuttsel commented on code in PR #2157:
URL: https://github.com/apache/ignite-3/pull/2157#discussion_r1224503073


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -565,11 +571,17 @@ private CompletableFuture<?> onTableCreate(ConfigurationNotificationEvent<TableV
             DistributionZoneView zone =
                     getZoneById(distributionZonesConfiguration, (ctx.newValue()).zoneId()).value();
 
-            List<Set<Assignment>> assignments = AffinityUtils.calculateAssignments(
-                    // TODO: https://issues.apache.org/jira/browse/IGNITE-19425 use data nodes from DistributionZoneManager instead.
-                    baselineMgr.nodes().stream().map(ClusterNode::name).collect(toList()),
-                    zone.partitions(),
-                    zone.replicas());
+            List<Set<Assignment>> assignments;
+
+            if (partitionAssignments(vaultManager, ctx.newValue().id(), 0) != null) {

Review Comment:
   Looks like some kind of magic. Please add a comment if possible. Is this a temporary or permanent solution? Getting nodes from zone manager will fix this or not?



;09/Jun/23 16:15;githubbot;600","kgusakov commented on code in PR #2157:
URL: https://github.com/apache/ignite-3/pull/2157#discussion_r1226381748


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -565,11 +571,17 @@ private CompletableFuture<?> onTableCreate(ConfigurationNotificationEvent<TableV
             DistributionZoneView zone =
                     getZoneById(distributionZonesConfiguration, (ctx.newValue()).zoneId()).value();
 
-            List<Set<Assignment>> assignments = AffinityUtils.calculateAssignments(
-                    // TODO: https://issues.apache.org/jira/browse/IGNITE-19425 use data nodes from DistributionZoneManager instead.
-                    baselineMgr.nodes().stream().map(ClusterNode::name).collect(toList()),
-                    zone.partitions(),
-                    zone.replicas());
+            List<Set<Assignment>> assignments;
+
+            if (partitionAssignments(vaultManager, ctx.newValue().id(), 0) != null) {

Review Comment:
   Added a comment. Not sure about the temporary or not, but in any case - if we already has assignments we shouldn't recalculate it again on recovery.



;12/Jun/23 09:42;githubbot;600","sergeyuttsel commented on code in PR #2157:
URL: https://github.com/apache/ignite-3/pull/2157#discussion_r1226402939


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/TableManager.java:
##########
@@ -565,11 +571,17 @@ private CompletableFuture<?> onTableCreate(ConfigurationNotificationEvent<TableV
             DistributionZoneView zone =
                     getZoneById(distributionZonesConfiguration, (ctx.newValue()).zoneId()).value();
 
-            List<Set<Assignment>> assignments = AffinityUtils.calculateAssignments(
-                    // TODO: https://issues.apache.org/jira/browse/IGNITE-19425 use data nodes from DistributionZoneManager instead.
-                    baselineMgr.nodes().stream().map(ClusterNode::name).collect(toList()),
-                    zone.partitions(),
-                    zone.replicas());
+            List<Set<Assignment>> assignments;
+
+            if (partitionAssignments(vaultManager, ctx.newValue().id(), 0) != null) {

Review Comment:
   Thanks



;12/Jun/23 09:59;githubbot;600","vldpyatkov merged PR #2157:
URL: https://github.com/apache/ignite-3/pull/2157


;13/Jun/23 12:19;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,4200,,,0,4200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Jun 13 12:19:34 UTC 2023,,,,,,,,,,"0|z1fk6w:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"10/Feb/23 07:17;Sergey Uttsel;All necessary tickets about distribution zones have been merged and again this test is failed caused by the changes in metastorage/watches.;;;","13/Mar/23 15:03;apolovtcev;There are several problems with this test:
1. Rebalance does not happen, because the disabled node takes too long to leave the Logical Topology. I fixed this by decreasing the Logical Topology removal timeout. Here's the branch with the fix: https://github.com/gridgain/apache-ignite-3/tree/ignite-18692
2. This fixes the problem presented in the description of this ticket, but the test still fails: the first read after the Rebalance times out. This happens for the following reason:
    * `PartitionReplicaListener` uses a `safeTime` object to catch up with the provided read timestamp and blocks all reads until it happens.
    * `PartitionListener` is responsible for updating the `safeTime` object (these objects must be the same in both listeners).
    * However, during the Rebalance procedure (see `TableManager#updateAssignmentInternal`), we always restart the ReplicaService (i.e. create a new `PartitionReplicaListener`), but we don't restart the Raft node (i.e.  new `PartitionListener` does not get created). This means that the new `PartitionReplicaListener` and the old `PartitionListener` will use different `safeTime` objects.;;;","24/Mar/23 13:50;kgusakov;So, it’s look like we have some possible ways to fix the issue:
 * Fast track: Introduce the any local map of safeTime values per table, and reuse the safeTimes values from it for any replica/raft node start

 * Better, way: introduce the concept like PartitionContext and store the all needed context inside it, together with the safeTimes. For this way we should investigate which another fields are suitable to be a part of this type of context;;;","13/Jun/23 12:19;v.pyatkov;Merged 7bcea31c9eb6350120584c1ca060131504927d04;;;",,
Assertion fires on snapshot partition sending with paired connections.,IGNITE-18690,13522528,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vladsz83,vladsz83,vladsz83,01/Feb/23 14:31,11/Feb/23 08:12,13/Jul/23 09:11,11/Feb/23 08:11,2.13,,,,,,,2.15,,,,0,ise,,,"An assertion in 
{code:java}
ClientConnectionPool.reserveClient(ClusterNode node, int connIdx)
{code}
can raise on snapshot restoring when set 
{code:java}
TcpCommunicationSpi.setUsePairedConnections(true)
{code}
 and snapshot manager sends partition files:
{code:java}
java.lang.AssertionError: 1026
	at org.apache.ignite.spi.communication.tcp.internal.ConnectionClientPool.reserveClient(ConnectionClientPool.java:190)
	at org.apache.ignite.spi.communication.tcp.internal.CommunicationWorker.processDisconnect(CommunicationWorker.java:376)
	at org.apache.ignite.spi.communication.tcp.internal.CommunicationWorker.body(CommunicationWorker.java:174)
	at org.apache.ignite.internal.util.worker.GridWorker.run(GridWorker.java:125)
	at org.apache.ignite.spi.communication.tcp.TcpCommunicationSpi$3.body(TcpCommunicationSpi.java:848)
	at org.apache.ignite.spi.IgniteSpiThread.run(IgniteSpiThread.java:58)
{code}

Test attached.

If a node failure handler is set and '-ea' JVM option is used, nodes can fail on such snapshot restoration.




",,ignitetcbot,NSAmelchev,vladsz83,,,"Vladsz83 opened a new pull request, #10526:
URL: https://github.com/apache/ignite/pull/10526

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;08/Feb/23 19:31;githubbot;600","NSAmelchev merged PR #10526:
URL: https://github.com/apache/ignite/pull/10526


;11/Feb/23 08:11;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"01/Feb/23 14:31;vladsz83;SnapshotRestoreFromRemoteWithPairedConnectionsTest.java;https://issues.apache.org/jira/secure/attachment/13054995/SnapshotRestoreFromRemoteWithPairedConnectionsTest.java",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Sat Feb 11 08:11:56 UTC 2023,,,,,,,,,,"0|z1fk5c:",9223372036854775807,Fixed possible assertion in Communication SPI when the paired connections are set.,,,,,,,,,,,,,,,,,,,,"11/Feb/23 08:08;ignitetcbot;{panel:title=Branch: [pull/10526/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10526/head] Base: [master] : New Tests (3)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Snapshots{color} [[tests 2|https://ci.ignite.apache.org/viewLog.html?buildId=7071256]]
* {color:#013220}IgniteSnapshotTestSuite: IgniteSnapshotRestoreFromRemoteTest.testRestoreWithPairedConnections[Encryption=true] - PASSED{color}
* {color:#013220}IgniteSnapshotTestSuite: IgniteSnapshotRestoreFromRemoteTest.testRestoreWithPairedConnections[Encryption=false] - PASSED{color}

{color:#00008b}Disk Page Compressions 1{color} [[tests 1|https://ci.ignite.apache.org/viewLog.html?buildId=7070245]]
* {color:#013220}IgnitePdsCompressionTestSuite: IgniteSnapshotRestoreFromRemoteTest.testRestoreWithPairedConnections[Encryption=false] - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci.ignite.apache.org/viewLog.html?buildId=7070248&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","11/Feb/23 08:11;NSAmelchev;Merged into the master.

[~vladsz83], Thanks for the contribution.;;;",,,,
GradualTaskExecutorTest.nonFinishedTasksAreCancelledWhenExecutorIsClosed is flaky,IGNITE-18686,13522430,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,rpuch,rpuch,rpuch,01/Feb/23 08:22,01/Feb/23 09:25,13/Jul/23 09:11,01/Feb/23 09:25,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,https://ggtc.gridgain.com/buildConfiguration/GridGain9Gradle_Test_UnitTests_PageMemory/8624795?showRootCauses=false&expandBuildChangesSection=true&expandBuildProblemsSection=true&expandBuildTestsSection=true,,rpuch,,,,,"rpuch opened a new pull request, #1614:
URL: https://github.com/apache/ignite-3/pull/1614

   https://issues.apache.org/jira/browse/IGNITE-18686


;01/Feb/23 08:24;githubbot;600","ibessonov merged PR #1614:
URL: https://github.com/apache/ignite-3/pull/1614


;01/Feb/23 09:25;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-02-01 08:22:24.0,,,,,,,,,,"0|z1fjjs:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
Fix busyLock.leaveBusy() in IndexManager#onIndexDrop,IGNITE-18684,13522411,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ktkalenko@gridgain.com,ktkalenko@gridgain.com,01/Feb/23 07:10,01/Feb/23 07:53,13/Jul/23 09:11,01/Feb/23 07:53,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"An incorrect use of *busyLock.leaveBusy()* in *IndexManager#onIndexDrop* was detected, we must call method *busyLock.leaveBusy()* on the same thread.",,ktkalenko@gridgain.com,,,,,"tkalkirill opened a new pull request, #1613:
URL: https://github.com/apache/ignite-3/pull/1613

   https://issues.apache.org/jira/browse/IGNITE-18684


;01/Feb/23 07:13;githubbot;600","tkalkirill merged PR #1613:
URL: https://github.com/apache/ignite-3/pull/1613


;01/Feb/23 07:52;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-02-01 07:10:55.0,,,,,,,,,,"0|z1fjfk:",9223372036854775807,,,k.orlov,,,,,,,,,,,,,,,,,,,,,,,
Fix ClientArchTest source provider,IGNITE-18680,13522225,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Mikhail Pochatkin,Mikhail Pochatkin,Mikhail Pochatkin,31/Jan/23 13:07,31/Jan/23 13:50,13/Jul/23 09:11,31/Jan/23 13:50,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"org.apache.ignite.client.ClientArchTest take sources for analize from ignite-client.jar file from build/lib directory. This jar contains class files only from client module. However, in a normal build pipeline, the tests are run before the jar files are built and Gradle test task doesn't depend on jar task. As result, we have false failed test. 
So, us solution we can change location provider org.apache.ignite.client.ClientArchTest.ClassesWithLibsLocationProvider and took *.java files for analizing insted of class files.",,jooger,Mikhail Pochatkin,,,,"Pochatkin opened a new pull request, #1608:
URL: https://github.com/apache/ignite-3/pull/1608

   https://issues.apache.org/jira/browse/IGNITE-18680
   
   * Use source code instead of jar file


;31/Jan/23 13:14;githubbot;600","ibessonov merged PR #1608:
URL: https://github.com/apache/ignite-3/pull/1608


;31/Jan/23 13:50;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-01-31 13:07:37.0,,,,,,,,,,"0|z1fib4:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
Fix org.apache.ignite.internal.pagememory.persistence.checkpoint.CheckpointTimeoutLockTest#testCheckpointReadLock,IGNITE-18679,13522220,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ktkalenko@gridgain.com,ktkalenko@gridgain.com,ktkalenko@gridgain.com,31/Jan/23 12:24,31/Jan/23 13:15,13/Jul/23 09:11,31/Jan/23 13:15,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,It was found that the wrong intervals were chosen in *org.apache.ignite.internal.pagememory.persistence.checkpoint.CheckpointTimeoutLockTest#testCheckpointReadLock* which could lead to flaky tests.,,ktkalenko@gridgain.com,,,,,"tkalkirill opened a new pull request, #1607:
URL: https://github.com/apache/ignite-3/pull/1607

   https://issues.apache.org/jira/browse/IGNITE-18679


;31/Jan/23 12:43;githubbot;600","tkalkirill merged PR #1607:
URL: https://github.com/apache/ignite-3/pull/1607


;31/Jan/23 13:15;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-01-31 12:24:47.0,,,,,,,,,,"0|z1fia0:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
CdcMain is not committing state during index rebuilding,IGNITE-18652,13521934,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,nizhikov,shishkovilja,shishkovilja,29/Jan/23 16:15,24/Apr/23 14:58,13/Jul/23 09:11,01/Feb/23 14:46,2.14,,,,,,,2.15,,,,0,IEP-59,ise,,"For persistent cluster CdcMain is not committing state during index rebuilding if there are no data updates.
It can cause to sharp increase of cdc WAL-archive size in case of big indexes.

Here is a reproducer patch:  [^CdcRebuildTest.patch] ",,nizhikov,shishkovilja,,,,"nizhikov opened a new pull request, #10510:
URL: https://github.com/apache/ignite/pull/10510

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;01/Feb/23 13:35;githubbot;600","nizhikov merged PR #10510:
URL: https://github.com/apache/ignite/pull/10510


;01/Feb/23 14:46;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Jan/23 16:15;shishkovilja;CdcRebuildTest.patch;https://issues.apache.org/jira/secure/attachment/13054862/CdcRebuildTest.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Wed Feb 01 11:38:59 UTC 2023,,,,,,,,,,"0|z1fgj4:",9223372036854775807,Fixed CdcMain state committing during index rebuild,,,,,,,,,,,,,,,,,,,,"01/Feb/23 11:38;nizhikov;Hello [~shishkovilja] 

What correct behavior you have in mind?;;;",,,,,
Occasional NullPointerException in TableManager.assignments,IGNITE-18650,13521733,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,27/Jan/23 13:32,02/Feb/23 15:44,13/Jul/23 09:11,02/Feb/23 15:44,3.0.0-beta1,,,,,,,3.0.0-beta2,thin client,,,0,ignite-3,,,"*TestExecuteColocatedUpdatesTableCacheOnTableDrop*:

{code:java}
Apache.Ignite.IgniteException : Exception of type 'Apache.Ignite.IgniteException' was thrown.
  ----> Apache.Ignite.IgniteException : java.lang.NullPointerException
  at org.apache.ignite.internal.table.distributed.TableManager.assignments(TableManager.java:1051)
  at org.apache.ignite.client.handler.requests.table.ClientTablePartitionAssignmentGetRequest.process(ClientTablePartitionAssignmentGetRequest.java:47)
  at org.apache.ignite.client.handler.ClientInboundMessageHandler.processOperation(ClientInboundMessageHandler.java:493)
  at org.apache.ignite.client.handler.ClientInboundMessageHandler.processOperation(ClientInboundMessageHandler.java:345)
  at org.apache.ignite.client.handler.ClientInboundMessageHandler.channelRead(ClientInboundMessageHandler.java:195)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
  at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:336)
  at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:308)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
  at io.netty.handler.timeout.IdleStateHandler.channelRead(IdleStateHandler.java:286)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
  at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
  at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)
  at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
  at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
  at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
  at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
  at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
  at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
  at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
  at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
  at java.base/java.lang.Thread.run(Thread.java:834)
   at Apache.Ignite.Internal.ClientFailoverSocket.DoOutInOpAndGetSocketAsync(ClientOp clientOp, Transaction tx, PooledArrayBuffer request, PreferredNode preferredNode) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/ClientFailoverSocket.cs:line 203
   at Apache.Ignite.Internal.ClientFailoverSocket.DoOutInOpAsync(ClientOp clientOp, PooledArrayBuffer request, PreferredNode preferredNode) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/ClientFailoverSocket.cs:line 163
   at Apache.Ignite.Internal.Table.Table.LoadPartitionAssignmentAsync() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/Table/Table.cs:line 353
   at Apache.Ignite.Internal.Table.Table.GetPartitionAssignmentAsync() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/Table/Table.cs:line 226
   at Apache.Ignite.Internal.Table.Table.GetPreferredNode(Int32 colocationHash, ITransaction transaction) in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite/Internal/Table/Table.cs:line 196
   at Apache.Ignite.Internal.Compute.Compute.ExecuteColocatedAsync[T,TKey](String tableName, TKey key, Func`2 serializerHandlerFunc, String jobClassName, Object[] args)
   at Apache.Ignite.Internal.Compute.Compute.ExecuteColocatedAsync[T](String tableName, IIgniteTuple key, String jobClassName, Object[] args)
   at Apache.Ignite.Tests.Compute.ComputeTests.TestExecuteColocatedUpdatesTableCacheOnTableDrop() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/Compute/ComputeTests.cs:line 281
   at Apache.Ignite.Tests.Compute.ComputeTests.TestExecuteColocatedUpdatesTableCacheOnTableDrop() in /opt/buildagent/work/b8d4df1365f1f1e5/modules/platforms/dotnet/Apache.Ignite.Tests/Compute/ComputeTests.cs:line 288
{code}

Looks like we don't handle dropped table correctly.

https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunNetTests/7035872?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&expandBuildTestsSection=true",,isapego,ptupitsyn,,,,"ptupitsyn opened a new pull request, #1621:
URL: https://github.com/apache/ignite-3/pull/1621

   Fix NullPointerException when assignments are requested for a table that no longer exists.


;02/Feb/23 12:10;githubbot;600","ptupitsyn merged PR #1621:
URL: https://github.com/apache/ignite-3/pull/1621


;02/Feb/23 15:43;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Feb 02 15:44:01 UTC 2023,,,,,,,,,,"0|z1ffbc:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"02/Feb/23 12:35;ptupitsyn;[~isapego] please review.;;;","02/Feb/23 12:48;isapego;Looks good to me;;;","02/Feb/23 15:44;ptupitsyn;Merged to main: 97f4b772fcf9aab40bd56f552b3932fbe440555f;;;",,,
Barrier for locks after cleanup started,IGNITE-18632,13521264,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,v.pyatkov,Denis Chudov,Denis Chudov,25/Jan/23 10:46,16/Feb/23 09:33,13/Jul/23 09:11,14/Feb/23 14:55,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"*Motivation*
Transaction locks are acquired on primary replicas and must be released on tx cleanup (on processing of cleanup request to primary replica). This means, no lock for certain transaction can be acquired after the processing of cleanup request has begun. However, messaging protocol doesn't provide any linearization guarantees, so we should have this synchronization implemented in replica listener. For current implementation the following is possible:
- put request and cleanup request for the same primary replica and for the same transaction are reordered by messaging;
- cleanup starts and releases locks for corresponding tx;
- processing of put request starts and acquires locks that will never be released.

*Definition of done:*
After cleanup for certain transaction on certain primary replilca has started, it's impossible to acquire lock for this transaction on this primary replica.

*Implementation notes:*
There is synchronization between adding write intents to storage on primary replica and cleanup start (see IGNITE-18527 ). The implementation should take into account that cleanup can't start while write intentis being written into a storage, and cleanup command should not be fired before update command. However, this ticket is not only about update requests/commands, as read requests also acquire locks on primary replica, and they also need to be synchronized with cleanup.
",,Denis Chudov,v.pyatkov,xtern,,,"denis-chudov commented on code in PR #1663:
URL: https://github.com/apache/ignite-3/pull/1663#discussion_r1105182807


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/replicator/PartitionReplicaListener.java:
##########
@@ -2177,14 +2238,19 @@ private CompletableFuture<BinaryTuple> extractKey(@Nullable BinaryRow row) {
     }
 
     /**
-     * Class that stores list of futures for updates that can block tx cleanup, and finished flag.
+     * Class that stores a list of futures for operations that has happened in a specific transaction, and a state of the transaction relate
+     * of the replica.

Review Comment:
   ""a state of the transaction relate of the replica.""
   honestly, I couln't get this, could you rephrase?



##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/replicator/PartitionReplicaListener.java:
##########
@@ -1086,10 +1111,30 @@ private CompletableFuture<Void> processTxCleanupAction(TxCleanupReplicaRequest r
 
             return raftClient
                     .run(txCleanupCmd)
-                    .thenRun(() -> releaseTxLocks(request.txId()));
+                    .thenCompose(ignored -> allOffFuturesExceptionIgnored(txReadFutures, request)
+                            .thenRun(() -> releaseTxLocks(request.txId())));
         });
     }
 
+    /**
+     * Creates a future that waits all transaction operations are completed.
+     *
+     * @param txFutures Transaction operation futures.
+     * @param request Cleanup request.
+     * @return The future completes when all futures in passed list are completed.
+     */
+    private static CompletableFuture<Void> allOffFuturesExceptionIgnored(List<CompletableFuture<?>> txFutures,
+            TxCleanupReplicaRequest request) {
+        return allOf(txFutures.toArray(new CompletableFuture<?>[0]))
+                .exceptionally(e -> {
+                    assert !request.commit() :
+                            ""Transaction is committing, but an operation was completed with exception [txId="" + request.txId()

Review Comment:
   ```suggestion
                               ""Transaction is committing, but an operation has completed with exception [txId="" + request.txId()
   ```



##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/replicator/PartitionReplicaListener.java:
##########
@@ -1086,10 +1111,30 @@ private CompletableFuture<Void> processTxCleanupAction(TxCleanupReplicaRequest r
 
             return raftClient
                     .run(txCleanupCmd)
-                    .thenRun(() -> releaseTxLocks(request.txId()));
+                    .thenCompose(ignored -> allOffFuturesExceptionIgnored(txReadFutures, request)
+                            .thenRun(() -> releaseTxLocks(request.txId())));

Review Comment:
   just a note: is it useful (i mean, waiting read futures separately from update futures) given that we are going to move releaseTxLocks before cleanup raft command?



##########
modules/table/src/testFixtures/java/org/apache/ignite/internal/table/TxAbstractTest.java:
##########
@@ -1898,4 +1900,72 @@ public void testReadOnlyPendingWriteIntentSkippedCombined() {
         Collection<Tuple> retrievedKeys3 = accounts.recordView().getAll(readOnlyTx2, List.of(makeKey(1), makeKey(2)));
         validateBalance(retrievedKeys3, 300.);
     }
+
+    @Test
+    public void testTransactionAlreadyCommitted() {
+        testTransactionAlreadyFixed(true);
+    }
+
+    @Test
+    public void testTransactionAlreadyRolledback() {
+        testTransactionAlreadyFixed(false);
+    }
+
+    /**
+     * Checks operations that act after a transaction is committed, are finished with exception.
+     *
+     * @param commit True when transaction is committed, false the transaction is rolled back.
+     */
+    private void testTransactionAlreadyFixed(boolean commit) {

Review Comment:
   maybe `testTransactionAlreadyFinished`?



;14/Feb/23 01:23;githubbot;600","vldpyatkov commented on code in PR #1663:
URL: https://github.com/apache/ignite-3/pull/1663#discussion_r1105565359


##########
modules/table/src/testFixtures/java/org/apache/ignite/internal/table/TxAbstractTest.java:
##########
@@ -1898,4 +1900,72 @@ public void testReadOnlyPendingWriteIntentSkippedCombined() {
         Collection<Tuple> retrievedKeys3 = accounts.recordView().getAll(readOnlyTx2, List.of(makeKey(1), makeKey(2)));
         validateBalance(retrievedKeys3, 300.);
     }
+
+    @Test
+    public void testTransactionAlreadyCommitted() {
+        testTransactionAlreadyFixed(true);
+    }
+
+    @Test
+    public void testTransactionAlreadyRolledback() {
+        testTransactionAlreadyFixed(false);
+    }
+
+    /**
+     * Checks operations that act after a transaction is committed, are finished with exception.
+     *
+     * @param commit True when transaction is committed, false the transaction is rolled back.
+     */
+    private void testTransactionAlreadyFixed(boolean commit) {

Review Comment:
   Renamed.



;14/Feb/23 10:03;githubbot;600","vldpyatkov commented on code in PR #1663:
URL: https://github.com/apache/ignite-3/pull/1663#discussion_r1105575496


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/replicator/PartitionReplicaListener.java:
##########
@@ -2177,14 +2238,19 @@ private CompletableFuture<BinaryTuple> extractKey(@Nullable BinaryRow row) {
     }
 
     /**
-     * Class that stores list of futures for updates that can block tx cleanup, and finished flag.
+     * Class that stores a list of futures for operations that has happened in a specific transaction, and a state of the transaction relate
+     * of the replica.

Review Comment:
   Rephrased



;14/Feb/23 10:11;githubbot;600","vldpyatkov commented on code in PR #1663:
URL: https://github.com/apache/ignite-3/pull/1663#discussion_r1105586508


##########
modules/table/src/main/java/org/apache/ignite/internal/table/distributed/replicator/PartitionReplicaListener.java:
##########
@@ -1086,10 +1111,30 @@ private CompletableFuture<Void> processTxCleanupAction(TxCleanupReplicaRequest r
 
             return raftClient
                     .run(txCleanupCmd)
-                    .thenRun(() -> releaseTxLocks(request.txId()));
+                    .thenCompose(ignored -> allOffFuturesExceptionIgnored(txReadFutures, request)
+                            .thenRun(() -> releaseTxLocks(request.txId())));

Review Comment:
   Today, it is useful, because we can no-wait of read operations to commit write intents.
   Possibly, we may not wait read operation at all in the future.



;14/Feb/23 10:21;githubbot;600","vldpyatkov merged PR #1663:
URL: https://github.com/apache/ignite-3/pull/1663


;14/Feb/23 14:54;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,,IGNITE-17952,,,,,,,,,,,,IGNITE-17950,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Feb 14 14:55:29 UTC 2023,,,,,,,,,,"0|z1fcfk:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"13/Feb/23 10:47;v.pyatkov;All test passed except PartitionReplicaListenerTest, the reason of these fails is described in IGNITE-18774.;;;","14/Feb/23 14:01;Denis Chudov;LGTM.;;;","14/Feb/23 14:55;v.pyatkov;Merged 5186f9497130b1a8bd8191a9b66b0c318c40b15a;;;",,,
ItSqlAsynchronousApiTest#checkMixedTransactionsForIndex is flaky,IGNITE-18631,13521257,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,apolovtcev,apolovtcev,apolovtcev,25/Jan/23 10:06,25/Jan/23 13:48,13/Jul/23 09:11,25/Jan/23 13:48,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Looks like some data updates miss the index, probable because of IGNITE-18203",,apolovtcev,,,,,"sashapolo opened a new pull request, #1576:
URL: https://github.com/apache/ignite-3/pull/1576

   https://issues.apache.org/jira/browse/IGNITE-18631


;25/Jan/23 10:13;githubbot;600","ibessonov merged PR #1576:
URL: https://github.com/apache/ignite-3/pull/1576


;25/Jan/23 13:48;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,IGNITE-18203,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-01-25 10:06:39.0,,,,,,,,,,"0|z1fce0:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
.NET: Thin 3.0: IndexOutOfRangeException when reading empty result set with IgniteDbDataReader,IGNITE-18627,13521138,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,24/Jan/23 15:52,25/Jan/23 08:21,13/Jul/23 09:11,25/Jan/23 08:21,3.0.0-beta1,,,,,,,3.0.0-beta2,platforms,thin client,,0,.NET,ignite-3,,"
{code}
System.IndexOutOfRangeException
  HResult=0x80131508
  Message=Index was outside the bounds of the array.
  Source=Apache.Ignite
  StackTrace:
   at Apache.Ignite.Internal.Proto.MsgPack.MsgPackReader.ReadBinaryHeader() in Apache.Ignite.Internal.Proto.MsgPack\MsgPackReader.cs:line 226
   at Apache.Ignite.Sql.IgniteDbDataReader.<FetchNextPage>g__ReadFirstRowInCurrentPage|62_0() in Apache.Ignite.Sql\IgniteDbDataReader.cs:line 536
   at Apache.Ignite.Sql.IgniteDbDataReader.<FetchNextPage>d__62.MoveNext() in Apache.Ignite.Sql\IgniteDbDataReader.cs:line 530
   at Apache.Ignite.Sql.IgniteDbDataReader.Read() in Apache.Ignite.Sql\IgniteDbDataReader.cs:line 310
   at System.Data.Common.DataAdapter.FillLoadDataRow(SchemaMapping mapping)
   at System.Data.Common.DataAdapter.FillFromReader(DataSet dataset, DataTable datatable, String srcTable, DataReaderContainer dataReader, Int32 startRecord, Int32 maxRecords, DataColumn parentChapterColumn, Object parentChapterValue)
   at System.Data.Common.DataAdapter.Fill(DataTable[] dataTables, IDataReader dataReader, Int32 startRecord, Int32 maxRecords)
   at System.Data.DataTable.Load(IDataReader reader, LoadOption loadOption, FillErrorEventHandler errorHandler)
   at System.Data.DataTable.Load(IDataReader reader)
{code}
",,isapego,ptupitsyn,,,,"ptupitsyn merged PR #1573:
URL: https://github.com/apache/ignite-3/pull/1573


;25/Jan/23 08:21;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jan 25 08:21:43 UTC 2023,,,,,,,,,,"0|z1fbns:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"25/Jan/23 08:16;ptupitsyn;[~isapego] please review.;;;","25/Jan/23 08:20;isapego;[~ptupitsyn] looks good to me.;;;","25/Jan/23 08:21;ptupitsyn;Merged to main: 748c41b56c026e172e6218001d980ce20dc3a611;;;",,,
.NET: Thin 3.0: LINQ tests crash in Release mode,IGNITE-18626,13521137,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,24/Jan/23 15:51,25/Jan/23 07:41,13/Jul/23 09:11,25/Jan/23 07:41,3.0.0-beta1,,,,,,,3.0.0-beta2,platforms,thin client,,0,.NET,ignite-3,LINQ,"*dotnet test --filter Linq -c Release*


{code}
The active test run was aborted. Reason: Test host process crashed : Fatal error. System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.
   at Apache.Ignite.Internal.Sql.ResultSet`1[[System.Nullable`1[[System.Int32, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].ReadRow(System.Collections.Generic.IReadOnlyList`1<Apache.Ignite.Sql.IColumnMetadata>, Apache.Ignite.Internal.Proto.MsgPack.MsgPackReader ByRef)
   at Apache.Ignite.Internal.Sql.ResultSet`1+<>c__DisplayClass33_0+<<EnumerateRows>g__EnumeratePage|0>d[[System.Nullable`1[[System.Int32, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()
   at Apache.Ignite.Internal.Sql.ResultSet`1+<EnumerateRows>d__33[[System.Nullable`1[[System.Int32, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]](System.__Canon ByRef)
   at Apache.Ignite.Internal.Sql.ResultSet`1+<EnumerateRows>d__33[[System.Nullable`1[[System.Int32, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].System.Collections.Generic.IAsyncEnumerator<T>.MoveNextAsync()
   at Apache.Ignite.Internal.Linq.IgniteQueryExecutor+<ExecuteSingleInternalAsync>d__9`1[[System.Nullable`1[[System.Int32, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Nullable`1[[System.Int32, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Nullable`1[[System.Int32, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext(System.Threading.Thread)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Nullable`1[[System.Int32, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)
   at System.Threading.Tasks.Task.RunContinuations(System.Object)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SetExistingTaskResult(System.Threading.Tasks.Task`1<System.__Canon>, System.__Canon)
   at Apache.Ignite.Internal.Linq.IgniteQueryExecutor+<ExecuteResultSetInternalAsync>d__8`1[[System.Nullable`1[[System.Int32, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext(System.Threading.Thread)
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)
   at System.Threading.Tasks.Task.RunContinuations(System.Object)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SetExistingTaskResult(System.Threading.Tasks.Task`1<System.__Canon>, System.__Canon)
   at Apache.Ignite.Internal.Sql.Sql+<ExecuteAsyncInternal>d__8`1[[System.Nullable`1[[System.Int32, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext(System.Threading.Thread)
   at System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox, Boolean)
   at System.Threading.Tasks.Task.RunContinuations(System.Object)
   at System.Threading.Tasks.Task`1[[System.ValueTuple`2[[Apache.Ignite.Internal.Buffers.PooledBuffer, Apache.Ignite, Version=3.0.0.0, Culture=neutral, PublicKeyToken=2b5ffea60c6b4a0c],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].TrySetResult(System.ValueTuple`2<Apache.Ignite.Internal.Buffers.PooledBuffer,System.__Canon>)
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.ValueTuple`2[[Apache.Ignite.Internal.Buffers.PooledBuffer, Apache.Ignite, Version=3.0.0.0, Culture=neutral, PublicKeyToken=2b5ffea60c6b4a0c],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SetResult(System.ValueTuple`2<Apache.Ignite.Internal.Buffers.PooledBuffer,System.__Canon>)
   at Apache.Ignite.Internal.ClientFailoverSocket+<DoOutInOpAndGetSocketAsync>d__19.MoveNext()
{code}

Seems to crash whenever *Nullable<T>* is used as result type: TestStringFunctions, TestAggregateNullable*, etc.",,isapego,ptupitsyn,,,,"ptupitsyn merged PR #1571:
URL: https://github.com/apache/ignite-3/pull/1571


;25/Jan/23 07:41;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jan 25 07:41:48 UTC 2023,,,,,,,,,,"0|z1fbnk:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"24/Jan/23 17:21;ptupitsyn;[~isapego] please review.;;;","25/Jan/23 07:39;isapego;[~ptupitsyn] looks good to me.;;;","25/Jan/23 07:41;ptupitsyn;Merged to main: 819fe8a02ca892711244d20bf6162cf784f45cad;;;",,,
Sql. Code cleanup,IGNITE-18625,13521135,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,amashenkov,jooger,jooger,24/Jan/23 15:30,01/Feb/23 13:31,13/Jul/23 09:11,01/Feb/23 13:31,,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"We have a bunch of muted tests that could be unmuted partially or fully.
Let's do it for the following mentions:
IGNITE-16952

IGNITE-16905

IGNITE-16529
IGNITE-17304
In addition, let's amend using join() method on futures in SQL test to timeboxed org.apache.ignite.internal.testframework.IgniteTestUtils#await()",,amashenkov,jooger,,,,"ygerzhedovich commented on code in PR #1590:
URL: https://github.com/apache/ignite-3/pull/1590#discussion_r1090385567


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/index/ItIndexManagerTest.java:
##########
@@ -71,7 +71,7 @@ public void eventsAreFiredWhenIndexesCreatedAndDropped() {
         CompletableFuture<IndexEventParameters> indexCreatedFuture = registerListener(indexManager, IndexEvent.CREATE);
 
         indexManager.createIndexAsync(""PUBLIC"", ""INAME"", ""TNAME"", true, tableIndexChange ->
-                tableIndexChange.convert(HashIndexChange.class).changeColumnNames(""C3"", ""C2"")).join();
+                tableIndexChange.convert(HashIndexChange.class).changeColumnNames(""C3"", ""C2"")).get();

Review Comment:
   you keep potentially infinity lock.
   Let's use `await(CompletionStage stage)` instead of any 'join', `get`



;30/Jan/23 09:45;githubbot;600","ygerzhedovich commented on code in PR #1590:
URL: https://github.com/apache/ignite-3/pull/1590#discussion_r1090388575


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItDmlTest.java:
##########
@@ -107,13 +106,7 @@ public void mergeOpChangePrimaryKey() {
                 + ""WHEN MATCHED THEN UPDATE SET b = src.b, k1 = src.k1 ""
                 + ""WHEN NOT MATCHED THEN INSERT (k1, k2, a, b) VALUES (src.k1, src.k2, src.a, src.b)"";
 
-        sql(sql);
-
-        assertQuery(""SELECT * FROM test2 ORDER BY k1"")
-                .returns(222, 222, 1, 300, null)
-                .returns(111, 333, 0, 100, """")
-                .returns(444, 444, 2, 200, null)
-                .check();
+        assertThrows(CalciteContextException.class, () -> sql(sql));

Review Comment:
   Let's add the check SQL code here.



;30/Jan/23 09:48;githubbot;600","AMashenkov commented on code in PR #1590:
URL: https://github.com/apache/ignite-3/pull/1590#discussion_r1090430247


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/index/ItIndexManagerTest.java:
##########
@@ -71,7 +71,7 @@ public void eventsAreFiredWhenIndexesCreatedAndDropped() {
         CompletableFuture<IndexEventParameters> indexCreatedFuture = registerListener(indexManager, IndexEvent.CREATE);
 
         indexManager.createIndexAsync(""PUBLIC"", ""INAME"", ""TNAME"", true, tableIndexChange ->
-                tableIndexChange.convert(HashIndexChange.class).changeColumnNames(""C3"", ""C2"")).join();
+                tableIndexChange.convert(HashIndexChange.class).changeColumnNames(""C3"", ""C2"")).get();

Review Comment:
   The main issue here was the join() is not interruptible, but get() is.
   



;30/Jan/23 10:23;githubbot;600","ygerzhedovich commented on code in PR #1590:
URL: https://github.com/apache/ignite-3/pull/1590#discussion_r1090441169


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/index/ItIndexManagerTest.java:
##########
@@ -71,7 +71,7 @@ public void eventsAreFiredWhenIndexesCreatedAndDropped() {
         CompletableFuture<IndexEventParameters> indexCreatedFuture = registerListener(indexManager, IndexEvent.CREATE);
 
         indexManager.createIndexAsync(""PUBLIC"", ""INAME"", ""TNAME"", true, tableIndexChange ->
-                tableIndexChange.convert(HashIndexChange.class).changeColumnNames(""C3"", ""C2"")).join();
+                tableIndexChange.convert(HashIndexChange.class).changeColumnNames(""C3"", ""C2"")).get();

Review Comment:
   Agree, but with `get` we could wait for a test timeout instead of a short wait timeout in the utility method.



;30/Jan/23 10:32;githubbot;600","korlov42 commented on code in PR #1590:
URL: https://github.com/apache/ignite-3/pull/1590#discussion_r1090567260


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/index/ItIndexManagerTest.java:
##########
@@ -71,7 +71,7 @@ public void eventsAreFiredWhenIndexesCreatedAndDropped() {
         CompletableFuture<IndexEventParameters> indexCreatedFuture = registerListener(indexManager, IndexEvent.CREATE);
 
         indexManager.createIndexAsync(""PUBLIC"", ""INAME"", ""TNAME"", true, tableIndexChange ->
-                tableIndexChange.convert(HashIndexChange.class).changeColumnNames(""C3"", ""C2"")).join();
+                tableIndexChange.convert(HashIndexChange.class).changeColumnNames(""C3"", ""C2"")).get();

Review Comment:
   agree with @ygerzhedovich. It's better to wait for reasonable amount of time in the test itself then wait forever until the whole suite will be killed by TC's watchdog after an hour of awaiting



;30/Jan/23 12:33;githubbot;600","zstan commented on code in PR #1590:
URL: https://github.com/apache/ignite-3/pull/1590#discussion_r1091518698


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/index/ItIndexManagerTest.java:
##########
@@ -71,7 +71,7 @@ public void eventsAreFiredWhenIndexesCreatedAndDropped() {
         CompletableFuture<IndexEventParameters> indexCreatedFuture = registerListener(indexManager, IndexEvent.CREATE);
 
         indexManager.createIndexAsync(""PUBLIC"", ""INAME"", ""TNAME"", true, tableIndexChange ->
-                tableIndexChange.convert(HashIndexChange.class).changeColumnNames(""C3"", ""C2"")).join();
+                tableIndexChange.convert(HashIndexChange.class).changeColumnNames(""C3"", ""C2"")).get();

Review Comment:
   +1 for @AMashenkov approach - we need not guessing each test work time.  



;31/Jan/23 06:53;githubbot;600","AMashenkov commented on code in PR #1590:
URL: https://github.com/apache/ignite-3/pull/1590#discussion_r1091592780


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItDmlTest.java:
##########
@@ -107,13 +106,7 @@ public void mergeOpChangePrimaryKey() {
                 + ""WHEN MATCHED THEN UPDATE SET b = src.b, k1 = src.k1 ""
                 + ""WHEN NOT MATCHED THEN INSERT (k1, k2, a, b) VALUES (src.k1, src.k2, src.a, src.b)"";
 
-        sql(sql);
-
-        assertQuery(""SELECT * FROM test2 ORDER BY k1"")
-                .returns(222, 222, 1, 300, null)
-                .returns(111, 333, 0, 100, """")
-                .returns(444, 444, 2, 200, null)
-                .check();
+        assertThrows(CalciteContextException.class, () -> sql(sql));

Review Comment:
   We have to throw SqlException to check error code, but CalciteContextException is thrown.



;31/Jan/23 08:29;githubbot;600","ygerzhedovich commented on code in PR #1590:
URL: https://github.com/apache/ignite-3/pull/1590#discussion_r1093141727


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/util/CompositeSubscriptionTest.java:
##########
@@ -157,28 +157,27 @@ private void doPublishSubscribe(
 
         lsnr.reset(requested);
 
-        CompletableFuture.runAsync(() -> compPublisher.subscribe(new Subscriber<>() {
-                    @Override
-                    public void onSubscribe(Subscription subscription) {
-                        subscriptionRef.set(subscription);
-                    }
-
-                    @Override
-                    public void onNext(Integer item) {
-                        lsnr.onNext(item);
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        assert false;
-                    }
-
-                    @Override
-                    public void onComplete() {
-                        lsnr.onComplete();
-                    }
-                })
-        ).join();
+        compPublisher.subscribe(new Subscriber<>() {

Review Comment:
   please return back runAsync here, it requeres for the test



;01/Feb/23 12:15;githubbot;600","AMashenkov commented on code in PR #1590:
URL: https://github.com/apache/ignite-3/pull/1590#discussion_r1093217561


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/util/CompositeSubscriptionTest.java:
##########
@@ -157,28 +157,27 @@ private void doPublishSubscribe(
 
         lsnr.reset(requested);
 
-        CompletableFuture.runAsync(() -> compPublisher.subscribe(new Subscriber<>() {
-                    @Override
-                    public void onSubscribe(Subscription subscription) {
-                        subscriptionRef.set(subscription);
-                    }
-
-                    @Override
-                    public void onNext(Integer item) {
-                        lsnr.onNext(item);
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        assert false;
-                    }
-
-                    @Override
-                    public void onComplete() {
-                        lsnr.onComplete();
-                    }
-                })
-        ).join();
+        compPublisher.subscribe(new Subscriber<>() {

Review Comment:
   I think all the guaranties are preserved.
   Test thread will continue work right after subscribe method will be finished in background thread.



;01/Feb/23 13:25;githubbot;600","AMashenkov commented on code in PR #1590:
URL: https://github.com/apache/ignite-3/pull/1590#discussion_r1093217561


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/util/CompositeSubscriptionTest.java:
##########
@@ -157,28 +157,27 @@ private void doPublishSubscribe(
 
         lsnr.reset(requested);
 
-        CompletableFuture.runAsync(() -> compPublisher.subscribe(new Subscriber<>() {
-                    @Override
-                    public void onSubscribe(Subscription subscription) {
-                        subscriptionRef.set(subscription);
-                    }
-
-                    @Override
-                    public void onNext(Integer item) {
-                        lsnr.onNext(item);
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        assert false;
-                    }
-
-                    @Override
-                    public void onComplete() {
-                        lsnr.onComplete();
-                    }
-                })
-        ).join();
+        compPublisher.subscribe(new Subscriber<>() {

Review Comment:
   I think all the guaranties are preserved.
   Test thread would continue work (exit from join()) right after subscribe() method had been finished in background thread.
   Now, test thread just continue after exiting from subscribe() method.
   



;01/Feb/23 13:27;githubbot;600","AMashenkov merged PR #1590:
URL: https://github.com/apache/ignite-3/pull/1590


;01/Feb/23 13:28;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,6600,,,0,6600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Jan 27 09:55:46 UTC 2023,,,,,,,,,,"0|z1fbn4:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"27/Jan/23 09:55;amashenkov;Created a separate ticket to implement missed method instead of IGNITE-16952.
;;;",,,,,
.NET: Thin 3.0: Test timeout is too short,IGNITE-18618,13521110,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,rpuch,rpuch,24/Jan/23 11:18,27/Jan/23 07:52,13/Jul/23 09:11,27/Jan/23 07:52,,,,,,,,3.0.0-beta2,platforms,thin client,,0,.NET,ignite-3,,"In a log from [https://ci.ignite.apache.org/buildConfiguration/ApacheIgnite3xGradle_Test_RunNetTests/7024431?hideProblemsFromDependencies=false&hideTestsFromDependencies=false&pluginCoverage=true&expandBuildTestsSection=true] (attached to this ticket) the following can be seen:

 

[12:06:40] :  [dotnet test]   Passed TestReplaceExact [65 ms]
[12:06:42] :  [dotnet test] Jan 24, 2023 11:06:42 AM io.scalecube.cluster.membership.MembershipProtocolImpl lambda$onDeadMemberDetected$42
[12:06:42] :  [dotnet test] INFO: [default:org.apache.ignite.internal.runner.app.PlatformTestNodeRunner_2:2f32f38d-529d-4d6f-92c7-a0b05d92475e@172.120.0.8:3345] Member leaved without notification: default:org.apache.ignite.internal.runner.app.PlatformTestNodeRunner:db118c3f-14cc-4b63-a0b8-e0a2cdf3cd2e@172.120.0.8:3344... skipped ...[12:06:43] :  [dotnet test] INFO: Node added to the logical topology [node=org.apache.ignite.internal.runner.app.PlatformTestNodeRunner]
[12:06:46] :  [dotnet test] [11:06:46] [Info] [ClientFailoverSocket] Primary socket connection lost, reconnecting.... skipped ...[12:06:46] :  [dotnet test]   Failed TestContains [6 s]
[12:06:46] :  [dotnet test]   Error Message:
[12:06:46] :  [dotnet test]    System.TimeoutException : The operation has timed out.

 

Looks like a node left and returned back (a probable reason for leaving is a GC pause), but it took a few seconds because it's guided by timeouts. So it seems that the timeout of 5 seconds is too low in Dotnet tests, it should be probably set to a higher value.",,isapego,ptupitsyn,rpuch,,,"ptupitsyn merged PR #1591:
URL: https://github.com/apache/ignite-3/pull/1591


;27/Jan/23 07:52;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-18292,,,,,,,"24/Jan/23 11:18;rpuch;_Test_Run_.NET_Tests_7879.log.zip;https://issues.apache.org/jira/secure/attachment/13054787/_Test_Run_.NET_Tests_7879.log.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Jan 27 07:52:52 UTC 2023,,,,,,,,,,"0|z1fbhk:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"27/Jan/23 05:53;ptupitsyn;[~isapego] please review.;;;","27/Jan/23 06:07;isapego;Looks good to me;;;","27/Jan/23 07:52;ptupitsyn;Merged to main: e67d6851e599fa999dbff8d3d9d95d4ab4a25207;;;",,,
.NET: Thin 3.0: Tests fail due to incorrect data cleanup when run with same node twice,IGNITE-18614,13521097,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,24/Jan/23 09:55,25/Jan/23 10:27,13/Jul/23 09:11,25/Jan/23 10:27,,,,,,,,3.0.0-beta2,platforms,thin client,,0,.NET,ignite-3,,"1. Start an external node as described in DEVNOTES
2. Run .NET tests, 1st time it works
3. Rune .NET tests again, some of them fail

Some data is not cleaned up properly.",,isapego,ptupitsyn,,,,"ptupitsyn opened a new pull request, #1575:
URL: https://github.com/apache/ignite-3/pull/1575

   Clean up existing table data to ensure that the same test node can be reused for multiple test runs.


;25/Jan/23 09:04;githubbot;600","ptupitsyn merged PR #1575:
URL: https://github.com/apache/ignite-3/pull/1575


;25/Jan/23 10:27;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jan 25 10:27:30 UTC 2023,,,,,,,,,,"0|z1fbeo:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"25/Jan/23 09:05;ptupitsyn;[~isapego] please review.;;;","25/Jan/23 10:26;isapego;Looks good to me.;;;","25/Jan/23 10:27;ptupitsyn;Merged to main: b6ff1ea62f6a88b768f4d0369e33e90002fb025b;;;",,,
ColumnMetadata.scale does not conform to Javadoc,IGNITE-18602,13520971,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,mzhuravkov,ptupitsyn,ptupitsyn,23/Jan/23 10:31,03/Feb/23 11:39,13/Jul/23 09:11,02/Feb/23 10:37,3.0.0-beta1,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"Javadoc says ""Returns SQL column scale or -1 if scale is not applicable for this type"" (https://github.com/apache/ignite-3/blob/316545c3a15135a6441bbcfa6725f960152408a5/modules/api/src/main/java/org/apache/ignite/sql/ColumnMetadata.java#L66), 

but implementation returns ""UNDEFINED_SCALE = Integer.MIN_VALUE"" (https://github.com/apache/ignite-3/blob/316545c3a15135a6441bbcfa6725f960152408a5/modules/api/src/main/java/org/apache/ignite/sql/ColumnMetadata.java#L30)",,amashenkov,ptupitsyn,,,,"AMashenkov merged PR #1606:
URL: https://github.com/apache/ignite-3/pull/1606


;02/Feb/23 10:37;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Feb 02 10:37:47 UTC 2023,,,,,,,,,,"0|z1fan4:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"02/Feb/23 10:37;amashenkov;[~mzhuravkov], merged to main.
Thanks for your contribution.;;;",,,,,
ItJdbcJoinsSelfTest#testJoin is flaky,IGNITE-18601,13520936,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Critical,Fixed,apolovtcev,apolovtcev,apolovtcev,22/Jan/23 16:52,25/Jan/23 07:31,13/Jul/23 09:11,25/Jan/23 07:31,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"ItJdbcJoinsSelfTest#testJoin sometimes failes with the following exception:

{noformat}
java.sql.SQLException: Exception while executing query [query=CREATE TABLE PUBLIC.BLOOD_GROUP_INFO_PJ (ID INT, BLOOD_GROUP VARCHAR(64), UNIVERSAL_DONOR VARCHAR(64), PRIMARY KEY (ID));]. Error message:IGN-CMN-65535 TraceId:59081ebb-c327-440b-9ddb-90cb61568f35 IGN-CMN-65535 TraceId:59081ebb-c327-440b-9ddb-90cb61568f35 Should not be called
{noformat}

For some reason, PK configuration gets updated twice, even though the data inside the configuration updates is the same.",,apolovtcev,,,,,"sashapolo opened a new pull request, #1570:
URL: https://github.com/apache/ignite-3/pull/1570

   https://issues.apache.org/jira/browse/IGNITE-18601


;24/Jan/23 15:12;githubbot;600","ibessonov commented on code in PR #1570:
URL: https://github.com/apache/ignite-3/pull/1570#discussion_r1085520722


##########
modules/configuration/src/test/java/org/apache/ignite/internal/configuration/util/ConfigurationUtilTest.java:
##########
@@ -808,6 +809,26 @@ void testRemoveLastKey() {
         assertEquals(List.of(""0""), removeLastKey(List.of(""0"", ""1"")));
     }
 
+    /**
+     * Tests that {@link ConfigurationUtil#addDefaults} copies the tree when adding default values.
+     */
+    @Test
+    void testAddDefaultsPurity() {
+        InnerNode parentNode = newNodeInstance(ParentConfigurationSchema.class);
+
+        ParentChange parentChange = (ParentChange) parentNode;
+
+        parentChange.changeElements(elements -> elements.create(""name"", element -> {}));
+
+        NamedListNode<?> beforeDefaults = find(List.of(""elements""), parentNode, true);

Review Comment:
   `find(List.of(""elements""), parentNode, true)`
   This is equivalent to `parentChange.elements()`



;24/Jan/23 15:47;githubbot;600","ibessonov merged PR #1570:
URL: https://github.com/apache/ignite-3/pull/1570


;25/Jan/23 07:30;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-01-22 16:52:42.0,,,,,,,,,,"0|z1fafc:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
Meta Storage Watch events must be atomically persisted in the Vault,IGNITE-18600,13520837,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,apolovtcev,apolovtcev,apolovtcev,20/Jan/23 16:37,23/Jan/23 15:11,13/Jul/23 09:11,23/Jan/23 15:11,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Before IGNITE-18397 all data, that has been processed by Meta Storage Watches, was automatically persisted in the Vault. In IGNITE-18397 this feature was removed, which breaks the expected design. This feature should be re-implemented with the following guarantees:

# Only keys that match any of the registered watches should be saved to the Vault;
# Data should be saved to the Vault atomically in a single batch along with the applied revision;
# If any of the Watch Listeners throws an exception, then no data should be saved.",,alapin,apolovtcev,,,,"sashapolo opened a new pull request, #1561:
URL: https://github.com/apache/ignite-3/pull/1561

   https://issues.apache.org/jira/browse/IGNITE-18600


;20/Jan/23 18:55;githubbot;600","sanpwc merged PR #1561:
URL: https://github.com/apache/ignite-3/pull/1561


;23/Jan/23 15:11;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-18394,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Jan 23 15:11:46 UTC 2023,,,,,,,,,,"0|z1f9ts:",9223372036854775807,,,sanpwc,,,,,,,,,,,,,,,,,,"23/Jan/23 15:11;alapin;[~apolovtcev] LGTM, thx. Merged to main.;;;",,,,,
Fix compilation in the main branch,IGNITE-18598,13520828,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Blocker,Fixed,apolovtcev,apolovtcev,apolovtcev,20/Jan/23 15:11,20/Jan/23 15:19,13/Jul/23 09:11,20/Jan/23 15:19,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,,,apolovtcev,,,,,"sashapolo opened a new pull request, #1560:
URL: https://github.com/apache/ignite-3/pull/1560

   https://issues.apache.org/jira/browse/IGNITE-18598


;20/Jan/23 15:14;githubbot;600","ibessonov merged PR #1560:
URL: https://github.com/apache/ignite-3/pull/1560


;20/Jan/23 15:15;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-01-20 15:11:29.0,,,,,,,,,,"0|z1f9rs:",9223372036854775807,,,ibessonov,,,,,,,,,,,,,,,,,,,,,,,
RocksUtils#incrementArray does not strip tail zeroes,IGNITE-18597,13520572,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,apolovtcev,apolovtcev,apolovtcev,20/Jan/23 12:09,20/Jan/23 14:19,13/Jul/23 09:11,20/Jan/23 14:19,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Consider the following data: {{[1 FF, 2, 2 0]}}. When searching for a {{1 FF}} prefix, current implementation of {{incrementArray}} will return a {{2 0}} upper bound, which will include the {{2}} value. ",,apolovtcev,sdanilov,,,,"sashapolo opened a new pull request, #1558:
URL: https://github.com/apache/ignite-3/pull/1558

   https://issues.apache.org/jira/browse/IGNITE-18597


;20/Jan/23 12:21;githubbot;600","SammyVimes merged PR #1558:
URL: https://github.com/apache/ignite-3/pull/1558


;20/Jan/23 14:19;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Jan 20 14:19:50 UTC 2023,,,,,,,,,,"0|z1f86w:",9223372036854775807,,,sdanilov,,,,,,,,,,,,,,,,,,"20/Jan/23 14:19;sdanilov;The patch looks good to me. Thank you for the contribution, merged to the main branch.;;;",,,,,
Transaction recovery tries rollback a tx concurrently with committing it,IGNITE-18590,13520226,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,timonin.maksim,timonin.maksim,timonin.maksim,19/Jan/23 17:16,13/Feb/23 12:14,13/Jul/23 09:11,13/Feb/23 12:14,,,,,,,,2.15,,,,0,,,,"This is a bug introduced in the patch [https://github.com/apache/ignite/pull/8822.]

When a transaction commits on primary node during TxRecovery procedure, it also sends rollback request (GridDhtTxFinishRequest#commit = false) on backup nodes.

Then it's possible that such a request (commit = false) reaches a backup node earlier than GridCacheTxRecoveryResponse(commit = true).  Then primary node will commit the transaction, and backup node rollbacks it. Then cluster will be in inconsistent state.",,ignitetcbot,timonin.maksim,,,,"timoninmaxim opened a new pull request, #10521:
URL: https://github.com/apache/ignite/pull/10521

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;06/Feb/23 18:09;githubbot;600","timoninmaxim merged PR #10521:
URL: https://github.com/apache/ignite/pull/10521


;13/Feb/23 12:13;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Feb 13 12:14:30 UTC 2023,,,,,,,,,,"0|z1f628:",9223372036854775807,,,av,,,,,,,,,,,,,,,,,,"10/Feb/23 14:57;ignitetcbot;{panel:title=Branch: [pull/10521/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10521/head] Base: [master] : New Tests (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Cache 12{color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7041858]]
* {color:#013220}IgniteCacheTestSuite12: TxRecoveryWithConcurrentRollbackTest.testNoTryRollbackConcurrentlyWithCommit - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7041962&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","12/Feb/23 20:01;ignitetcbot;{panel:title=Branch: [pull/10521/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10521/head] Base: [master] : New Tests (1)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Cache (Tx Recovery){color} [[tests 1|https://ci2.ignite.apache.org/viewLog.html?buildId=7043743]]
* {color:#013220}IgniteCacheTxRecoverySelfTestSuite: TxRecoveryCommitMessagesTest.testNoTryRollbackConcurrentlyWithCommit - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7041962&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","13/Feb/23 12:14;timonin.maksim;[~av] thanks for review! Merged to master.;;;",,,
.NET: Thin 3.0: BinaryTupleReader incorrect behavior on type mismatch,IGNITE-18588,13520208,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ptupitsyn,ptupitsyn,ptupitsyn,19/Jan/23 14:35,20/Jan/23 10:21,13/Jul/23 09:11,20/Jan/23 10:21,3.0.0-beta1,,,,,,,3.0.0-beta2,platforms,thin client,,0,.NET,ignite-3,,"Add the following test to *BinaryTupleTests*:

{code:c#}
[Test]
public void TestShortAsByte()
{
    var bytes = Build((ref BinaryTupleBuilder b) => b.AppendShort(257));
    var reader = new BinaryTupleReader(bytes, 1);

    Assert.AreEqual(257, reader.GetByte(0));
}
{code}

The result is assertion failure ""Expected: 257  But was:  1"" - we get incorrect value, but there should be an exception when the data does not fit into the requested type.",,isapego,ptupitsyn,,,,"ptupitsyn merged PR #1554:
URL: https://github.com/apache/ignite-3/pull/1554


;20/Jan/23 10:21;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,IGNITE-18478,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Jan 20 10:21:55 UTC 2023,,,,,,,,,,"0|z1f5y8:",9223372036854775807,,,isapego,,,,,,,,,,,,,,,,,,"20/Jan/23 07:17;ptupitsyn;[~isapego] please review.;;;","20/Jan/23 09:07;isapego;[~ptupitsyn] looks good to me.;;;","20/Jan/23 10:21;ptupitsyn;Merged to main: c85f3c06b92e84bc8795c0862bb9d7872a296675;;;",,,
Possible memory errors and corruptions because of insufficient size of compression buffer.,IGNITE-18584,13520171,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,ivandasch,ivandasch,ivandasch,19/Jan/23 10:16,20/Apr/23 13:53,13/Jul/23 09:11,20/Jan/23 11:08,2.14,,,,,,,2.15,,,,0,,,,"{{org.apache.ignite.internal.processors.compress.CompressionProcessorImpl#compressBuf}} is initialized with 1024 extra space, that may be not enough for compressing.
I.e. snappy requires 2762 extra space for 16K pages.

The overhead must be calculated during the initialization with help of specialized methods, such as 

{{Snappy#maxCompressedLength}}",,ignitetcbot,ivandasch,,,,"ivandasch opened a new pull request, #10490:
URL: https://github.com/apache/ignite/pull/10490

   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;19/Jan/23 16:12;githubbot;600","ivandasch merged PR #10490:
URL: https://github.com/apache/ignite/pull/10490


;20/Jan/23 11:07;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Fri Jan 20 11:08:21 UTC 2023,,,,,,,,,,"0|z1f5q0:",9223372036854775807,Fixed possible memory corruption because of insufficient size of compression buffer,,,,,,,,,,,,,,,,,,,,"20/Jan/23 07:39;ignitetcbot;{panel:title=Branch: [pull/10490/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10490/head] Base: [master] : New Tests (216)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Disk Page Compressions 1{color} [[tests 216|https://ci2.ignite.apache.org/viewLog.html?buildId=7006635]]
* {color:#013220}IgnitePdsCompressionTestSuite: CompressionProcessorTest.testLeafPage[page_size = 4,096, block_size = 16, compression = SKIP_GARBAGE, level = 0] - PASSED{color}
* {color:#013220}IgnitePdsCompressionTestSuite: CompressionProcessorTest.testDataPage[page_size = 4,096, block_size = 16, compression = SNAPPY, level = 0] - PASSED{color}
* {color:#013220}IgnitePdsCompressionTestSuite: CompressionProcessorTest.testLeafPage[page_size = 4,096, block_size = 16, compression = SNAPPY, level = 0] - PASSED{color}
* {color:#013220}IgnitePdsCompressionTestSuite: CompressionProcessorTest.testInnerPage[page_size = 4,096, block_size = 16, compression = SKIP_GARBAGE, level = 0] - PASSED{color}
* {color:#013220}IgnitePdsCompressionTestSuite: CompressionProcessorTest.testDataPage[page_size = 4,096, block_size = 16, compression = SKIP_GARBAGE, level = 0] - PASSED{color}
* {color:#013220}IgnitePdsCompressionTestSuite: CompressionProcessorTest.testInnerPage[page_size = 4,096, block_size = 16, compression = LZ4, level = 0] - PASSED{color}
* {color:#013220}IgnitePdsCompressionTestSuite: CompressionProcessorTest.testDataPage[page_size = 4,096, block_size = 16, compression = LZ4, level = 0] - PASSED{color}
* {color:#013220}IgnitePdsCompressionTestSuite: CompressionProcessorTest.testLeafPage[page_size = 4,096, block_size = 16, compression = LZ4, level = 0] - PASSED{color}
* {color:#013220}IgnitePdsCompressionTestSuite: CompressionProcessorTest.testInnerPage[page_size = 4,096, block_size = 16, compression = SNAPPY, level = 0] - PASSED{color}
* {color:#013220}IgnitePdsCompressionTestSuite: CompressionProcessorTest.testLeafPage[page_size = 4,096, block_size = 16, compression = ZSTD, level = 3] - PASSED{color}
* {color:#013220}IgnitePdsCompressionTestSuite: CompressionProcessorTest.testInnerPage[page_size = 4,096, block_size = 16, compression = LZ4, level = 17] - PASSED{color}
... and 205 new tests

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7006085&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","20/Jan/23 11:08;ivandasch;[~alexpl] [~av] Thanks for your reviews, merged;;;",,,,
Sql. Some queries exceptionally executed if some rules are disabled.,IGNITE-18569,13520013,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,zstan,zstan,zstan,18/Jan/23 09:44,03/Feb/23 09:52,13/Jul/23 09:11,03/Feb/23 09:50,3.0.0-beta1,,,,,,,,sql,,,0,calcite2-required,ignite-3,,"Found that if only one aggregate rule *HashAggregateConverterRule.COLOCATED* become available (in practice it can win by summary weights), we obtain exception, like :

concrete this test can be found in */sqlite/aggregates/agg1.test*.
There are also numerous faled tests if only one aggregate rule become enabled.

{noformat}
Error at: (agg1.test_slow:113). sql: SELECT DISTINCT + 30 AS col0 FROM tab0, tab1 AS cor0

Caused by: java.lang.IllegalStateException
	at org.apache.ignite.internal.sql.engine.trait.DistributionFunction$SingletonDistribution.destination(DistributionFunction.java:205)
	at org.apache.ignite.internal.sql.engine.trait.DistributionTrait.destination(DistributionTrait.java:109)
	at org.apache.ignite.internal.sql.engine.exec.LogicalRelImplementor.visit(LogicalRelImplementor.java:161)
{noformat}


{noformat}
            //HashAggregateConverterRule.COLOCATED,
            HashAggregateConverterRule.MAP_REDUCE,
            //SortAggregateConverterRule.COLOCATED,
            //SortAggregateConverterRule.MAP_REDUCE,
{noformat}
",,zstan,,,,,"AMashenkov commented on code in PR #1603:
URL: https://github.com/apache/ignite-3/pull/1603#discussion_r1092149491


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItAggregatesTest.java:
##########
@@ -21,149 +21,216 @@
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
+import java.util.Arrays;
+import java.util.Locale;
+import java.util.stream.Stream;
 import org.apache.ignite.internal.sql.engine.util.QueryChecker;
+import org.apache.ignite.internal.testframework.WithSystemProperty;
 import org.apache.ignite.lang.IgniteException;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
 
 /**
  * Group of tests to verify aggregation functions.
  */
 public class ItAggregatesTest extends AbstractBasicIntegrationTest {
+    private static String[] disabledRules = {""MapReduceHashAggregateConverterRule"", ""MapReduceSortAggregateConverterRule"",
+            ""ColocatedHashAggregateConverterRule"", ""ColocatedSortAggregateConverterRule""};
+
+    private static final int ROWS = 103;
+
     /**
      * Before all.
      */
     @BeforeAll
     static void initTestData() {
         createAndPopulateTable();
+
+        sql(""CREATE TABLE test (id INT PRIMARY KEY, grp0 INT, grp1 INT, val0 INT, val1 INT) WITH replicas=2,partitions=10"");
+        sql(""CREATE TABLE test_one_col_idx (pk INT PRIMARY KEY, col0 INT)"");
+
+        // TODO: https://issues.apache.org/jira/browse/IGNITE-17304 uncomment this
+        // sql(""CREATE INDEX test_idx ON test(grp0, grp1)"");
+        // sql(""CREATE INDEX test_one_col_idx_idx ON test_one_col_idx(col0)"");

Review Comment:
   ```suggestion
           sql(""CREATE INDEX test_idx ON test(grp0, grp1)"");
           sql(""CREATE INDEX test_one_col_idx_idx ON test_one_col_idx(col0)"");
           
           // FIXME: https://issues.apache.org/jira/browse/IGNITE-18203
           waitForIndex(""test_idx"");
           waitForIndex(""test_one_col_idx_idx"");
   ```



;31/Jan/23 16:05;githubbot;600","AMashenkov commented on code in PR #1603:
URL: https://github.com/apache/ignite-3/pull/1603#discussion_r1092165794


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItAggregatesTest.java:
##########
@@ -185,36 +252,42 @@ public void testAnyValAggr() {
         assertEquals(""Ilya"", val);
     }
 
-    @Test
-    public void testColocatedAggregate() {
-        sql(""CREATE TABLE t1(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
-                + ""COLOCATE BY (val1)"");
-
-        sql(""CREATE TABLE t2(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
-                + ""COLOCATE BY (val1)"");
-
-        for (int i = 0; i < 100; i++) {
-            sql(""INSERT INTO t1 VALUES (?, ?, ?, ?)"", i, ""val"" + i, ""val"" + i % 2, ""val"" + i);
+    @ParameterizedTest
+    @MethodSource(""provideRules"")
+    public void testColocatedAggregate(String[] rules) {
+        try {
+            sql(""CREATE TABLE t1(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
+                    + ""COLOCATE BY (val1)"");
+
+            sql(""CREATE TABLE t2(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
+                    + ""COLOCATE BY (val1)"");
+
+            for (int i = 0; i < 100; i++) {
+                sql(""INSERT INTO t1 VALUES (?, ?, ?, ?)"", i, ""val"" + i, ""val"" + i % 2, ""val"" + i);
+            }
+
+            sql(""INSERT INTO t2 VALUES (0, 'val0', 'val0', 'val0'), (1, 'val1', 'val1', 'val1')"");
+
+            String sql = ""SELECT val1, count(val2) FROM t1 GROUP BY val1"";
+
+            assertQuery(sql)
+                    .disableRules(rules)
+                    .returns(""val0"", 50L)
+                    .returns(""val1"", 50L)
+                    .check();
+
+            sql = ""SELECT t2.val1, agg.cnt ""
+                    + ""FROM t2 JOIN (SELECT val1, COUNT(val2) AS cnt FROM t1 GROUP BY val1) AS agg ON t2.val1 = agg.val1"";
+
+            assertQuery(sql)
+                    .disableRules(rules)
+                    .returns(""val0"", 50L)
+                    .returns(""val1"", 50L)
+                    .check();
+        } finally {
+            sql(""DROP TABLE IF EXISTS t1"");
+            sql(""DROP TABLE IF EXISTS t2"");
         }
-
-        sql(""INSERT INTO t2 VALUES (0, 'val0', 'val0', 'val0'), (1, 'val1', 'val1', 'val1')"");
-
-        String sql = ""SELECT val1, count(val2) FROM t1 GROUP BY val1"";
-
-        assertQuery(sql)
-                .matches(QueryChecker.matches("".*Exchange.*Colocated.*Aggregate.*""))

Review Comment:
   I guess we checked here some pushdown-aggregate rules are applied,
   but now we disable rules and never check any rules are applied.
   Should we have both kind of tests?



;31/Jan/23 16:18;githubbot;600","AMashenkov commented on code in PR #1603:
URL: https://github.com/apache/ignite-3/pull/1603#discussion_r1092165794


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItAggregatesTest.java:
##########
@@ -185,36 +252,42 @@ public void testAnyValAggr() {
         assertEquals(""Ilya"", val);
     }
 
-    @Test
-    public void testColocatedAggregate() {
-        sql(""CREATE TABLE t1(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
-                + ""COLOCATE BY (val1)"");
-
-        sql(""CREATE TABLE t2(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
-                + ""COLOCATE BY (val1)"");
-
-        for (int i = 0; i < 100; i++) {
-            sql(""INSERT INTO t1 VALUES (?, ?, ?, ?)"", i, ""val"" + i, ""val"" + i % 2, ""val"" + i);
+    @ParameterizedTest
+    @MethodSource(""provideRules"")
+    public void testColocatedAggregate(String[] rules) {
+        try {
+            sql(""CREATE TABLE t1(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
+                    + ""COLOCATE BY (val1)"");
+
+            sql(""CREATE TABLE t2(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
+                    + ""COLOCATE BY (val1)"");
+
+            for (int i = 0; i < 100; i++) {
+                sql(""INSERT INTO t1 VALUES (?, ?, ?, ?)"", i, ""val"" + i, ""val"" + i % 2, ""val"" + i);
+            }
+
+            sql(""INSERT INTO t2 VALUES (0, 'val0', 'val0', 'val0'), (1, 'val1', 'val1', 'val1')"");
+
+            String sql = ""SELECT val1, count(val2) FROM t1 GROUP BY val1"";
+
+            assertQuery(sql)
+                    .disableRules(rules)
+                    .returns(""val0"", 50L)
+                    .returns(""val1"", 50L)
+                    .check();
+
+            sql = ""SELECT t2.val1, agg.cnt ""
+                    + ""FROM t2 JOIN (SELECT val1, COUNT(val2) AS cnt FROM t1 GROUP BY val1) AS agg ON t2.val1 = agg.val1"";
+
+            assertQuery(sql)
+                    .disableRules(rules)
+                    .returns(""val0"", 50L)
+                    .returns(""val1"", 50L)
+                    .check();
+        } finally {
+            sql(""DROP TABLE IF EXISTS t1"");
+            sql(""DROP TABLE IF EXISTS t2"");
         }
-
-        sql(""INSERT INTO t2 VALUES (0, 'val0', 'val0', 'val0'), (1, 'val1', 'val1', 'val1')"");
-
-        String sql = ""SELECT val1, count(val2) FROM t1 GROUP BY val1"";
-
-        assertQuery(sql)
-                .matches(QueryChecker.matches("".*Exchange.*Colocated.*Aggregate.*""))

Review Comment:
   I guess we checked here some pushdown-aggregate rules are applied,
   but now yoou disable rules and never check any rules are applied.
   Should we have both kind of tests? or I missed smth.



##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItAggregatesTest.java:
##########
@@ -185,36 +252,42 @@ public void testAnyValAggr() {
         assertEquals(""Ilya"", val);
     }
 
-    @Test
-    public void testColocatedAggregate() {
-        sql(""CREATE TABLE t1(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
-                + ""COLOCATE BY (val1)"");
-
-        sql(""CREATE TABLE t2(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
-                + ""COLOCATE BY (val1)"");
-
-        for (int i = 0; i < 100; i++) {
-            sql(""INSERT INTO t1 VALUES (?, ?, ?, ?)"", i, ""val"" + i, ""val"" + i % 2, ""val"" + i);
+    @ParameterizedTest
+    @MethodSource(""provideRules"")
+    public void testColocatedAggregate(String[] rules) {
+        try {
+            sql(""CREATE TABLE t1(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
+                    + ""COLOCATE BY (val1)"");
+
+            sql(""CREATE TABLE t2(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
+                    + ""COLOCATE BY (val1)"");
+
+            for (int i = 0; i < 100; i++) {
+                sql(""INSERT INTO t1 VALUES (?, ?, ?, ?)"", i, ""val"" + i, ""val"" + i % 2, ""val"" + i);
+            }
+
+            sql(""INSERT INTO t2 VALUES (0, 'val0', 'val0', 'val0'), (1, 'val1', 'val1', 'val1')"");
+
+            String sql = ""SELECT val1, count(val2) FROM t1 GROUP BY val1"";
+
+            assertQuery(sql)
+                    .disableRules(rules)
+                    .returns(""val0"", 50L)
+                    .returns(""val1"", 50L)
+                    .check();
+
+            sql = ""SELECT t2.val1, agg.cnt ""
+                    + ""FROM t2 JOIN (SELECT val1, COUNT(val2) AS cnt FROM t1 GROUP BY val1) AS agg ON t2.val1 = agg.val1"";
+
+            assertQuery(sql)
+                    .disableRules(rules)
+                    .returns(""val0"", 50L)
+                    .returns(""val1"", 50L)
+                    .check();
+        } finally {
+            sql(""DROP TABLE IF EXISTS t1"");
+            sql(""DROP TABLE IF EXISTS t2"");
         }
-
-        sql(""INSERT INTO t2 VALUES (0, 'val0', 'val0', 'val0'), (1, 'val1', 'val1', 'val1')"");
-
-        String sql = ""SELECT val1, count(val2) FROM t1 GROUP BY val1"";
-
-        assertQuery(sql)
-                .matches(QueryChecker.matches("".*Exchange.*Colocated.*Aggregate.*""))

Review Comment:
   I guess we checked here some pushdown-aggregate rules are applied,
   but now yoou disable rules and never check any rules are applied.
   Should we have both kind of tests? or I missed smth?



;31/Jan/23 16:19;githubbot;600","zstan commented on code in PR #1603:
URL: https://github.com/apache/ignite-3/pull/1603#discussion_r1092822614


##########
modules/runner/src/integrationTest/java/org/apache/ignite/internal/sql/engine/ItAggregatesTest.java:
##########
@@ -185,36 +252,42 @@ public void testAnyValAggr() {
         assertEquals(""Ilya"", val);
     }
 
-    @Test
-    public void testColocatedAggregate() {
-        sql(""CREATE TABLE t1(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
-                + ""COLOCATE BY (val1)"");
-
-        sql(""CREATE TABLE t2(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
-                + ""COLOCATE BY (val1)"");
-
-        for (int i = 0; i < 100; i++) {
-            sql(""INSERT INTO t1 VALUES (?, ?, ?, ?)"", i, ""val"" + i, ""val"" + i % 2, ""val"" + i);
+    @ParameterizedTest
+    @MethodSource(""provideRules"")
+    public void testColocatedAggregate(String[] rules) {
+        try {
+            sql(""CREATE TABLE t1(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
+                    + ""COLOCATE BY (val1)"");
+
+            sql(""CREATE TABLE t2(id INT, val0 VARCHAR, val1 VARCHAR, val2 VARCHAR, PRIMARY KEY(id, val1)) ""
+                    + ""COLOCATE BY (val1)"");
+
+            for (int i = 0; i < 100; i++) {
+                sql(""INSERT INTO t1 VALUES (?, ?, ?, ?)"", i, ""val"" + i, ""val"" + i % 2, ""val"" + i);
+            }
+
+            sql(""INSERT INTO t2 VALUES (0, 'val0', 'val0', 'val0'), (1, 'val1', 'val1', 'val1')"");
+
+            String sql = ""SELECT val1, count(val2) FROM t1 GROUP BY val1"";
+
+            assertQuery(sql)
+                    .disableRules(rules)
+                    .returns(""val0"", 50L)
+                    .returns(""val1"", 50L)
+                    .check();
+
+            sql = ""SELECT t2.val1, agg.cnt ""
+                    + ""FROM t2 JOIN (SELECT val1, COUNT(val2) AS cnt FROM t1 GROUP BY val1) AS agg ON t2.val1 = agg.val1"";
+
+            assertQuery(sql)
+                    .disableRules(rules)
+                    .returns(""val0"", 50L)
+                    .returns(""val1"", 50L)
+                    .check();
+        } finally {
+            sql(""DROP TABLE IF EXISTS t1"");
+            sql(""DROP TABLE IF EXISTS t2"");
         }
-
-        sql(""INSERT INTO t2 VALUES (0, 'val0', 'val0', 'val0'), (1, 'val1', 'val1', 'val1')"");
-
-        String sql = ""SELECT val1, count(val2) FROM t1 GROUP BY val1"";
-
-        assertQuery(sql)
-                .matches(QueryChecker.matches("".*Exchange.*Colocated.*Aggregate.*""))

Review Comment:
   I check blame history also in ai-2 and can`t found issue linked with this test, i revert it and seems we need not integration but execution test for such a thing.



;01/Feb/23 06:50;githubbot;600","zstan closed pull request #1603: IGNITE-18569 Fix planning with MRSortAggregate.
URL: https://github.com/apache/ignite-3/pull/1603


;03/Feb/23 06:18;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,2023-01-18 09:44:52.0,,,,,,,,,,"0|z1f4rk:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,
Fix Meta Storage prefix reads,IGNITE-18558,13519735,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,apolovtcev,apolovtcev,apolovtcev,16/Jan/23 09:35,16/Jan/23 14:17,13/Jul/23 09:11,16/Jan/23 14:17,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Meta Storage Manager prefix method implementations use {{KeyCriterion#nextKey}} method to create an upper bound of a prefix. This method is, unfortunately, incorrect, because it adds a 0 to the array, if the last byte overflows. It also uses signed arithmetic, while internal RocksDB implementation uses unsigned.",,apolovtcev,ktkalenko@gridgain.com,,,,"sashapolo opened a new pull request, #1526:
URL: https://github.com/apache/ignite-3/pull/1526

   https://issues.apache.org/jira/browse/IGNITE-18558


;16/Jan/23 10:41;githubbot;600","tkalkirill commented on code in PR #1526:
URL: https://github.com/apache/ignite-3/pull/1526#discussion_r1071195665


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/raft/MetaStorageListener.java:
##########
@@ -253,19 +254,27 @@ public void onWrite(Iterator<CommandClosure<WriteCommand>> iter) {
 
                 IgniteUuid cursorId = rangeCmd.cursorId();
 
-                Cursor<Entry> cursor = (rangeCmd.revUpperBound() != -1)
+                Cursor<Entry> cursor = rangeCmd.revUpperBound() != -1
                         ? storage.range(rangeCmd.keyFrom(), rangeCmd.keyTo(), rangeCmd.revUpperBound(), rangeCmd.includeTombstones())
                         : storage.range(rangeCmd.keyFrom(), rangeCmd.keyTo(), rangeCmd.includeTombstones());
 
-                cursors.put(
-                        cursorId,
-                        new CursorMeta(
-                                cursor,
-                                CursorType.RANGE,
-                                rangeCmd.requesterNodeId(),
-                                rangeCmd.batchSize()
-                        )
-                );
+                var meta = new CursorMeta(cursor, CursorType.RANGE, rangeCmd.requesterNodeId(), rangeCmd.batchSize());

Review Comment:
   I think `metaCursor` would be a better name.



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/server/raft/MetaStorageListener.java:
##########
@@ -253,19 +254,27 @@ public void onWrite(Iterator<CommandClosure<WriteCommand>> iter) {
 
                 IgniteUuid cursorId = rangeCmd.cursorId();
 
-                Cursor<Entry> cursor = (rangeCmd.revUpperBound() != -1)
+                Cursor<Entry> cursor = rangeCmd.revUpperBound() != -1
                         ? storage.range(rangeCmd.keyFrom(), rangeCmd.keyTo(), rangeCmd.revUpperBound(), rangeCmd.includeTombstones())
                         : storage.range(rangeCmd.keyFrom(), rangeCmd.keyTo(), rangeCmd.includeTombstones());
 
-                cursors.put(
-                        cursorId,
-                        new CursorMeta(
-                                cursor,
-                                CursorType.RANGE,
-                                rangeCmd.requesterNodeId(),
-                                rangeCmd.batchSize()
-                        )
-                );
+                var meta = new CursorMeta(cursor, CursorType.RANGE, rangeCmd.requesterNodeId(), rangeCmd.batchSize());
+
+                cursors.put(cursorId, meta);
+
+                clo.result(cursorId);
+            } else if (command instanceof PrefixCommand) {
+                var prefixCmd = (PrefixCommand) command;
+
+                IgniteUuid cursorId = prefixCmd.cursorId();
+
+                Cursor<Entry> cursor = prefixCmd.revUpperBound() == -1
+                        ? storage.prefix(prefixCmd.prefix(), prefixCmd.includeTombstones())
+                        : storage.prefix(prefixCmd.prefix(), prefixCmd.revUpperBound(), prefixCmd.includeTombstones());
+
+                var meta = new CursorMeta(cursor, CursorType.RANGE, prefixCmd.requesterNodeId(), prefixCmd.batchSize());
+
+                cursors.put(cursorId, meta);

Review Comment:
   I think `metaCursor` would be a better name.



##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -676,17 +676,15 @@ public Cursor<Entry> range(ByteArray keyFrom, @Nullable ByteArray keyTo) throws
      * @see ByteArray
      * @see Entry
      */
-    public @NotNull Cursor<Entry> prefixWithAppliedRevision(@NotNull ByteArray keyPrefix) throws NodeStoppingException {
+    public Cursor<Entry> prefixWithAppliedRevision(ByteArray keyPrefix) throws NodeStoppingException {
         if (!busyLock.enterBusy()) {

Review Comment:
   U can use `org.apache.ignite.internal.util.IgniteUtils#inBusyLock(org.apache.ignite.internal.util.IgniteSpinBusyLock, java.util.function.Supplier<T>)`



##########
modules/metastorage/src/testFixtures/java/org/apache/ignite/internal/metastorage/server/SimpleInMemoryKeyValueStorage.java:
##########
@@ -359,21 +360,30 @@ public StatementResult invoke(If iif) {
         }
     }
 
-    /** {@inheritDoc} */
     @Override
     public Cursor<Entry> range(byte[] keyFrom, byte[] keyTo, boolean includeTombstones) {
         synchronized (mux) {
             return new RangeCursor(keyFrom, keyTo, rev, includeTombstones);
         }
     }
 
-    /** {@inheritDoc} */
     @Override
     public Cursor<Entry> range(byte[] keyFrom, byte[] keyTo, long revUpperBound, boolean includeTombstones) {
         return new RangeCursor(keyFrom, keyTo, revUpperBound, includeTombstones);
     }
 
-    /** {@inheritDoc} */
+    @Override
+    public Cursor<Entry> prefix(byte[] prefix, boolean includeTombstones) {
+        synchronized (mux) {

Review Comment:
   Maybe you should add `synchronized` for `prefix`* methods header, for example `public synchronized Cursor<Entry> prefix(...)`?



;16/Jan/23 12:42;githubbot;600","sashapolo commented on code in PR #1526:
URL: https://github.com/apache/ignite-3/pull/1526#discussion_r1071204424


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -676,17 +676,15 @@ public Cursor<Entry> range(ByteArray keyFrom, @Nullable ByteArray keyTo) throws
      * @see ByteArray
      * @see Entry
      */
-    public @NotNull Cursor<Entry> prefixWithAppliedRevision(@NotNull ByteArray keyPrefix) throws NodeStoppingException {
+    public Cursor<Entry> prefixWithAppliedRevision(ByteArray keyPrefix) throws NodeStoppingException {
         if (!busyLock.enterBusy()) {

Review Comment:
   Why should I?



;16/Jan/23 12:49;githubbot;600","sashapolo commented on code in PR #1526:
URL: https://github.com/apache/ignite-3/pull/1526#discussion_r1071205107


##########
modules/metastorage/src/testFixtures/java/org/apache/ignite/internal/metastorage/server/SimpleInMemoryKeyValueStorage.java:
##########
@@ -359,21 +360,30 @@ public StatementResult invoke(If iif) {
         }
     }
 
-    /** {@inheritDoc} */
     @Override
     public Cursor<Entry> range(byte[] keyFrom, byte[] keyTo, boolean includeTombstones) {
         synchronized (mux) {
             return new RangeCursor(keyFrom, keyTo, rev, includeTombstones);
         }
     }
 
-    /** {@inheritDoc} */
     @Override
     public Cursor<Entry> range(byte[] keyFrom, byte[] keyTo, long revUpperBound, boolean includeTombstones) {
         return new RangeCursor(keyFrom, keyTo, revUpperBound, includeTombstones);
     }
 
-    /** {@inheritDoc} */
+    @Override
+    public Cursor<Entry> prefix(byte[] prefix, boolean includeTombstones) {
+        synchronized (mux) {

Review Comment:
   How would that work? All other methods use a separate object for synchronisation



;16/Jan/23 12:49;githubbot;600","tkalkirill commented on code in PR #1526:
URL: https://github.com/apache/ignite-3/pull/1526#discussion_r1071209772


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -676,17 +676,15 @@ public Cursor<Entry> range(ByteArray keyFrom, @Nullable ByteArray keyTo) throws
      * @see ByteArray
      * @see Entry
      */
-    public @NotNull Cursor<Entry> prefixWithAppliedRevision(@NotNull ByteArray keyPrefix) throws NodeStoppingException {
+    public Cursor<Entry> prefixWithAppliedRevision(ByteArray keyPrefix) throws NodeStoppingException {
         if (!busyLock.enterBusy()) {

Review Comment:
   This **suggestion** will reduce the amount of similar code.



;16/Jan/23 12:54;githubbot;600","sashapolo commented on code in PR #1526:
URL: https://github.com/apache/ignite-3/pull/1526#discussion_r1071211290


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -676,17 +676,15 @@ public Cursor<Entry> range(ByteArray keyFrom, @Nullable ByteArray keyTo) throws
      * @see ByteArray
      * @see Entry
      */
-    public @NotNull Cursor<Entry> prefixWithAppliedRevision(@NotNull ByteArray keyPrefix) throws NodeStoppingException {
+    public Cursor<Entry> prefixWithAppliedRevision(ByteArray keyPrefix) throws NodeStoppingException {
         if (!busyLock.enterBusy()) {

Review Comment:
   We use try-finally approach everywhere else, so I would prefer to leave this as-is for the sake of consistency



;16/Jan/23 12:56;githubbot;600","tkalkirill commented on code in PR #1526:
URL: https://github.com/apache/ignite-3/pull/1526#discussion_r1071218519


##########
modules/metastorage/src/testFixtures/java/org/apache/ignite/internal/metastorage/server/SimpleInMemoryKeyValueStorage.java:
##########
@@ -359,21 +360,30 @@ public StatementResult invoke(If iif) {
         }
     }
 
-    /** {@inheritDoc} */
     @Override
     public Cursor<Entry> range(byte[] keyFrom, byte[] keyTo, boolean includeTombstones) {
         synchronized (mux) {
             return new RangeCursor(keyFrom, keyTo, rev, includeTombstones);
         }
     }
 
-    /** {@inheritDoc} */
     @Override
     public Cursor<Entry> range(byte[] keyFrom, byte[] keyTo, long revUpperBound, boolean includeTombstones) {
         return new RangeCursor(keyFrom, keyTo, revUpperBound, includeTombstones);
     }
 
-    /** {@inheritDoc} */
+    @Override
+    public Cursor<Entry> prefix(byte[] prefix, boolean includeTombstones) {
+        synchronized (mux) {

Review Comment:
   Write a comment why `mux` is used there.



;16/Jan/23 13:03;githubbot;600","tkalkirill commented on code in PR #1526:
URL: https://github.com/apache/ignite-3/pull/1526#discussion_r1071220712


##########
modules/metastorage/src/main/java/org/apache/ignite/internal/metastorage/impl/MetaStorageManagerImpl.java:
##########
@@ -676,17 +676,15 @@ public Cursor<Entry> range(ByteArray keyFrom, @Nullable ByteArray keyTo) throws
      * @see ByteArray
      * @see Entry
      */
-    public @NotNull Cursor<Entry> prefixWithAppliedRevision(@NotNull ByteArray keyPrefix) throws NodeStoppingException {
+    public Cursor<Entry> prefixWithAppliedRevision(ByteArray keyPrefix) throws NodeStoppingException {
         if (!busyLock.enterBusy()) {

Review Comment:
   The balance of ""force"" began to shift =)



;16/Jan/23 13:04;githubbot;600","sashapolo commented on code in PR #1526:
URL: https://github.com/apache/ignite-3/pull/1526#discussion_r1071223554


##########
modules/metastorage/src/testFixtures/java/org/apache/ignite/internal/metastorage/server/SimpleInMemoryKeyValueStorage.java:
##########
@@ -359,21 +360,30 @@ public StatementResult invoke(If iif) {
         }
     }
 
-    /** {@inheritDoc} */
     @Override
     public Cursor<Entry> range(byte[] keyFrom, byte[] keyTo, boolean includeTombstones) {
         synchronized (mux) {
             return new RangeCursor(keyFrom, keyTo, rev, includeTombstones);
         }
     }
 
-    /** {@inheritDoc} */
     @Override
     public Cursor<Entry> range(byte[] keyFrom, byte[] keyTo, long revUpperBound, boolean includeTombstones) {
         return new RangeCursor(keyFrom, keyTo, revUpperBound, includeTombstones);
     }
 
-    /** {@inheritDoc} */
+    @Override
+    public Cursor<Entry> prefix(byte[] prefix, boolean includeTombstones) {
+        synchronized (mux) {

Review Comment:
   I've made the code clearer



;16/Jan/23 13:06;githubbot;600","tkalkirill merged PR #1526:
URL: https://github.com/apache/ignite-3/pull/1526


;16/Jan/23 13:48;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,6000,,,0,6000,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon Jan 16 13:48:20 UTC 2023,,,,,,,,,,"0|z1f32g:",9223372036854775807,,,ktkalenko@gridgain.com,,,,,,,,,,,,,,,,,,"16/Jan/23 13:48;ktkalenko@gridgain.com;[~apolovtcev] Looks good!;;;",,,,,
"When tests are run using IDEA runner, wrong log format is used",IGNITE-18553,13519712,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Mikhail Pochatkin,rpuch,rpuch,16/Jan/23 08:03,16/Mar/23 13:45,13/Jul/23 09:11,16/Mar/23 13:41,,,,,,,,3.0.0-beta2,build,,,0,ignite-3,,,"
An example of such test is {{{}ItComputeTest{}}}. When run with Gradle Runner, I get the following in the log:

2023-01-16 11:41:06:381 +0400 [INFO][Test worker][ConnectionManager] Server started [address=/0:0:0:0:0:0:0:0:3344]

But when I run same test with IDEA runner, I get this:

янв. 16, 2023 12:01:03 PM org.apache.ignite.internal.logger.IgniteLogger logInternal
INFO: Server started [address=/0:0:0:0:0:0:0:0:3344]

The latter is wrong, so it looks like under IDEA runner our logging properties are not picked up.",,aleksandr.pakhomov,rpuch,,,,"Pochatkin opened a new pull request, #1790:
URL: https://github.com/apache/ignite-3/pull/1790

   https://issues.apache.org/jira/browse/IGNITE-18553
   Apply java logging properties for IDEA runner


;14/Mar/23 14:26;githubbot;600","PakhomovAlexander merged PR #1790:
URL: https://github.com/apache/ignite-3/pull/1790


;16/Mar/23 13:40;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Mar 16 13:41:25 UTC 2023,,,,,,,,,,"0|z1f2xc:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"16/Mar/23 13:41;aleksandr.pakhomov;Thanks for the contribution, merged into main:db46430312f916cfa012ae85fefb14c3397ac06a;;;",,,,,
"Compute ""withXXX"" modifiers in some cases are not applied to the user compute method call.",IGNITE-18545,13517921,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Minor,Fixed,PetrovMikhail,PetrovMikhail,PetrovMikhail,12/Jan/23 20:07,11/Feb/23 09:18,13/Jul/23 09:11,22/Jan/23 19:03,,,,,,,,2.15,,,,0,,,,"When the ""withXXX"" IgniteCompute methods are called, we set the corresponding thread-local parameters that are applied to the first task executed (see IgniteComputeImpl#withName).
When we run the task, we clear all the thread-local settings that were set earlier.

Consider the IgniteCompute#affinityCall method.
During its execution, in some cases we run a system task to get the affinity distribution from other nodes before user task execution (see GridAffinityProcessor#affinityKey and GridAffinityProcessor#affinityInfoFromNode). As a result, the mentioned above modifiers are applied to the system task that requests the affinity distribution but not the user task.

It seems that the current approach to setting task parameters via thread-local variables is  error-prone and should be refactored.

",,ignitetcbot,PetrovMikhail,slava.koptilin,,,"NSAmelchev commented on code in PR #10482:
URL: https://github.com/apache/ignite/pull/10482#discussion_r1082922705


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/compute/TaskOptionsPropagationTest.java:
##########
@@ -0,0 +1,315 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.compute;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import org.apache.ignite.IgniteCompute;
+import org.apache.ignite.IgniteException;
+import org.apache.ignite.cluster.ClusterNode;
+import org.apache.ignite.compute.ComputeJob;
+import org.apache.ignite.compute.ComputeTask;
+import org.apache.ignite.compute.ComputeTaskAdapter;
+import org.apache.ignite.compute.ComputeTaskSession;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.lang.RunnableX;
+import org.apache.ignite.lang.IgniteCallable;
+import org.apache.ignite.lang.IgniteClosure;
+import org.apache.ignite.lang.IgniteReducer;
+import org.apache.ignite.lang.IgniteRunnable;
+import org.apache.ignite.resources.TaskSessionResource;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.junit.Test;
+
+import static java.util.Collections.singletonList;
+import static java.util.Collections.singletonMap;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.CALLABLE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.CLOSURE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.RUNNABLE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.TASK;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+
+/** */
+public class TaskOptionsPropagationTest extends GridCommonAbstractTest {
+    /** */
+    private static final String TEST_TASK_NAME = ""test-name"";
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTestsStarted() throws Exception {
+        super.beforeTestsStarted();
+
+        startGrid();
+
+        grid().createCache(DEFAULT_CACHE_NAME).put(0, 0);
+    }
+
+    /** */
+    @Test
+    public void testUserTaskOptionsWithPrecedingSystemTaskExecution() throws Exception {
+        try (IgniteEx cli = startClientGrid(1)) {
+            cli.compute().withName(TEST_TASK_NAME).affinityCall(
+                DEFAULT_CACHE_NAME,
+                0,
+                new TestCallable(TEST_TASK_NAME)
+            );
+        }
+    }
+
+    /** */
+    @Test
+    public void testComputeSharedAcrossMultipleThreads() throws Exception {
+        IgniteCompute compute = grid().compute();
+
+        compute.withName(TEST_TASK_NAME);
+
+        runAsync(() -> compute.call(new TestCallable(TestCallable.class.getName()))).get();
+
+        compute.call(new TestCallable(TEST_TASK_NAME));
+    }
+
+    /** */
+    @Test
+    public void testTaskExecutionOptionsReset() throws Exception {
+        check(TASK, (c, t) -> c.execute((ComputeTask)t, null));
+        check(TASK, (c, t) -> c.executeAsync((ComputeTask)t, null).get());
+
+        check(CALLABLE, (c, t) -> c.call((IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.callAsync((IgniteCallable<Void>)t).get());
+
+        check(CALLABLE, (c, t) -> c.call((toList((IgniteCallable<Void>)t))));
+        check(CALLABLE, (c, t) -> c.callAsync(toList((IgniteCallable<Void>)t)).get());
+
+        check(CALLABLE, (c, t) -> c.call(toList((IgniteCallable<Void>)t), new TestReducer()));
+        check(CALLABLE, (c, t) -> c.callAsync(toList((IgniteCallable<Void>)t), new TestReducer()).get());
+
+        check(RUNNABLE, (c, t) -> c.run((IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.runAsync((IgniteRunnable)t).get());
+
+        check(RUNNABLE, (c, t) -> c.run(toList((IgniteRunnable)t)));
+        check(RUNNABLE, (c, t) -> c.runAsync(toList((IgniteRunnable)t)).get());
+
+        check(RUNNABLE, (c, t) -> c.broadcast((IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.broadcastAsync((IgniteRunnable)t).get());
+
+        check(CALLABLE, (c, t) -> c.broadcast((IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.broadcastAsync((IgniteCallable<Void>)t).get());
+
+        check(CLOSURE, ((c, t) -> c.broadcast((IgniteClosure<Void, Void>)t, null)));
+        check(CLOSURE, (c, t) -> c.broadcastAsync((IgniteClosure<Void, Void>)t, null).get());
+
+        check(CLOSURE, (c, t) -> c.apply((IgniteClosure<Void, Void>)t, (Void)null));
+        check(CLOSURE, (c, t) -> c.applyAsync((IgniteClosure<Void, Void>)t, (Void)null).get());
+
+        check(CLOSURE, (c, t) -> c.apply((IgniteClosure<Void, Void>)t, singletonList(null), new TestReducer()));
+        check(CLOSURE, (c, t) -> c.applyAsync((IgniteClosure<Void, Void>)t, singletonList(null), new TestReducer()).get());
+
+        check(RUNNABLE, (c, t) -> c.affinityRun(DEFAULT_CACHE_NAME, ""key"", (IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.affinityRunAsync(DEFAULT_CACHE_NAME, ""key"", (IgniteRunnable)t).get());
+
+        check(RUNNABLE, (c, t) -> c.affinityRun(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.affinityRunAsync(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteRunnable)t).get());
+
+        check(RUNNABLE, (c, t) -> c.affinityRun(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.affinityRunAsync(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteRunnable)t).get());
+
+        check(CALLABLE, (c, t) -> c.affinityCall(DEFAULT_CACHE_NAME, ""key"", (IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.affinityCallAsync(DEFAULT_CACHE_NAME, ""key"", (IgniteCallable<Void>)t).get());
+
+        check(CALLABLE, (c, t) -> c.affinityCall(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.affinityCallAsync(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteCallable<Void>)t).get());
+
+        check(CALLABLE, (c, t) -> c.affinityCall(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.affinityCallAsync(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteCallable<Void>)t).get());
+    }
+
+    /** */
+    public void check(ComputationType type, ConsumerX<Object> consumer) throws Exception {
+        consumer.accept(grid().compute().withName(TEST_TASK_NAME), getComputationObject(type, TEST_TASK_NAME));
+        consumer.accept(grid().compute(), getComputationObject(type, null));
+
+        assertThrows(() -> consumer.accept(grid().compute().withName(TEST_TASK_NAME), null));
+        consumer.accept(grid().compute(), getComputationObject(type, null));
+    }
+
+    /** */
+    private static class TestCallable extends TaskNameChecker implements IgniteCallable<Void> {
+        /** */
+        public TestCallable(String expName) {
+            super(expName);
+        }
+
+        /** {@inheritDoc} */
+        @Override public Void call() throws Exception {
+            checkName();
+
+            return null;
+        }
+    }
+
+    /** */
+    private static class TestRunnable extends TaskNameChecker implements IgniteRunnable {
+        /** */
+        public TestRunnable(String expName) {
+            super(expName);
+        }
+
+        /** {@inheritDoc} */
+        @Override public void run() {
+            checkName();
+        }
+    }
+
+    /** */
+    private static class TestClosure extends TaskNameChecker implements IgniteClosure<Void, Void> {
+        /** */
+        public TestClosure(String expName) {
+            super(expName);
+        }
+
+        /** {@inheritDoc} */
+        @Override public Void apply(Void arg) {
+            checkName();
+
+            return null;
+        }
+    }
+
+    /** */
+    private static class TestTask extends ComputeTaskAdapter<Void, Void> {
+        /** */
+        private final String name;
+
+        /** */
+        public TestTask(String name) {
+            this.name = name == null ? getClass().getName() : name;
+        }
+
+        /** {@inheritDoc} */
+        @Override public @NotNull Map<? extends ComputeJob, ClusterNode> map(
+            List<ClusterNode> subgrid,
+            @Nullable Void arg
+        ) throws IgniteException {
+            return singletonMap(new TestJob(name), subgrid.iterator().next());
+        }
+
+        /** {@inheritDoc} */
+        @Nullable @Override public Void reduce(List list) throws IgniteException {
+            return null;
+        }
+
+        /** */
+        private static class TestJob extends TaskNameChecker implements ComputeJob {
+            /** */
+            public TestJob(String expName) {
+                super(expName);
+            }
+
+            /** {@inheritDoc} */
+            @Override public Object execute() throws IgniteException {
+                checkName();
+
+                return null;
+            }
+
+            /** {@inheritDoc} */
+            @Override public void cancel() {
+                // No-op.
+            }
+        }
+    }
+
+    /** */
+    private static class TaskNameChecker {
+        /** */
+        @TaskSessionResource
+        private ComputeTaskSession ses;
+
+        /** */
+        private final String expName;
+
+        /** */
+        public TaskNameChecker(String expName) {
+            this.expName = expName == null ? getClass().getName() : expName;
+        }
+
+        /** */
+        protected void checkName() {
+            assertEquals(expName, ses.getTaskName());
+        }
+

Review Comment:
   Unnecessary line break



;20/Jan/23 18:34;githubbot;600","NSAmelchev commented on code in PR #10482:
URL: https://github.com/apache/ignite/pull/10482#discussion_r1082924047


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/compute/TaskOptionsPropagationTest.java:
##########
@@ -0,0 +1,315 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.compute;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import org.apache.ignite.IgniteCompute;
+import org.apache.ignite.IgniteException;
+import org.apache.ignite.cluster.ClusterNode;
+import org.apache.ignite.compute.ComputeJob;
+import org.apache.ignite.compute.ComputeTask;
+import org.apache.ignite.compute.ComputeTaskAdapter;
+import org.apache.ignite.compute.ComputeTaskSession;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.lang.RunnableX;
+import org.apache.ignite.lang.IgniteCallable;
+import org.apache.ignite.lang.IgniteClosure;
+import org.apache.ignite.lang.IgniteReducer;
+import org.apache.ignite.lang.IgniteRunnable;
+import org.apache.ignite.resources.TaskSessionResource;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.junit.Test;
+
+import static java.util.Collections.singletonList;
+import static java.util.Collections.singletonMap;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.CALLABLE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.CLOSURE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.RUNNABLE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.TASK;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+
+/** */
+public class TaskOptionsPropagationTest extends GridCommonAbstractTest {
+    /** */
+    private static final String TEST_TASK_NAME = ""test-name"";
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTestsStarted() throws Exception {
+        super.beforeTestsStarted();
+
+        startGrid();
+
+        grid().createCache(DEFAULT_CACHE_NAME).put(0, 0);
+    }
+
+    /** */
+    @Test
+    public void testUserTaskOptionsWithPrecedingSystemTaskExecution() throws Exception {
+        try (IgniteEx cli = startClientGrid(1)) {
+            cli.compute().withName(TEST_TASK_NAME).affinityCall(
+                DEFAULT_CACHE_NAME,
+                0,
+                new TestCallable(TEST_TASK_NAME)
+            );
+        }
+    }
+
+    /** */
+    @Test
+    public void testComputeSharedAcrossMultipleThreads() throws Exception {
+        IgniteCompute compute = grid().compute();
+
+        compute.withName(TEST_TASK_NAME);
+
+        runAsync(() -> compute.call(new TestCallable(TestCallable.class.getName()))).get();
+
+        compute.call(new TestCallable(TEST_TASK_NAME));
+    }
+
+    /** */
+    @Test
+    public void testTaskExecutionOptionsReset() throws Exception {
+        check(TASK, (c, t) -> c.execute((ComputeTask)t, null));

Review Comment:
   Let's cast to `ComputeTask<Void, Void>` as in the code below.



;20/Jan/23 18:35;githubbot;600","NSAmelchev commented on code in PR #10482:
URL: https://github.com/apache/ignite/pull/10482#discussion_r1082925214


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/compute/TaskOptionsPropagationTest.java:
##########
@@ -0,0 +1,315 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.compute;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import org.apache.ignite.IgniteCompute;
+import org.apache.ignite.IgniteException;
+import org.apache.ignite.cluster.ClusterNode;
+import org.apache.ignite.compute.ComputeJob;
+import org.apache.ignite.compute.ComputeTask;
+import org.apache.ignite.compute.ComputeTaskAdapter;
+import org.apache.ignite.compute.ComputeTaskSession;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.lang.RunnableX;
+import org.apache.ignite.lang.IgniteCallable;
+import org.apache.ignite.lang.IgniteClosure;
+import org.apache.ignite.lang.IgniteReducer;
+import org.apache.ignite.lang.IgniteRunnable;
+import org.apache.ignite.resources.TaskSessionResource;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.junit.Test;
+
+import static java.util.Collections.singletonList;
+import static java.util.Collections.singletonMap;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.CALLABLE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.CLOSURE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.RUNNABLE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.TASK;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+
+/** */
+public class TaskOptionsPropagationTest extends GridCommonAbstractTest {
+    /** */
+    private static final String TEST_TASK_NAME = ""test-name"";
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTestsStarted() throws Exception {
+        super.beforeTestsStarted();
+
+        startGrid();
+
+        grid().createCache(DEFAULT_CACHE_NAME).put(0, 0);
+    }
+
+    /** */
+    @Test
+    public void testUserTaskOptionsWithPrecedingSystemTaskExecution() throws Exception {
+        try (IgniteEx cli = startClientGrid(1)) {
+            cli.compute().withName(TEST_TASK_NAME).affinityCall(
+                DEFAULT_CACHE_NAME,
+                0,
+                new TestCallable(TEST_TASK_NAME)
+            );
+        }
+    }
+
+    /** */
+    @Test
+    public void testComputeSharedAcrossMultipleThreads() throws Exception {
+        IgniteCompute compute = grid().compute();
+
+        compute.withName(TEST_TASK_NAME);
+
+        runAsync(() -> compute.call(new TestCallable(TestCallable.class.getName()))).get();
+
+        compute.call(new TestCallable(TEST_TASK_NAME));
+    }
+
+    /** */
+    @Test
+    public void testTaskExecutionOptionsReset() throws Exception {
+        check(TASK, (c, t) -> c.execute((ComputeTask)t, null));
+        check(TASK, (c, t) -> c.executeAsync((ComputeTask)t, null).get());
+
+        check(CALLABLE, (c, t) -> c.call((IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.callAsync((IgniteCallable<Void>)t).get());
+
+        check(CALLABLE, (c, t) -> c.call((toList((IgniteCallable<Void>)t))));
+        check(CALLABLE, (c, t) -> c.callAsync(toList((IgniteCallable<Void>)t)).get());
+
+        check(CALLABLE, (c, t) -> c.call(toList((IgniteCallable<Void>)t), new TestReducer()));
+        check(CALLABLE, (c, t) -> c.callAsync(toList((IgniteCallable<Void>)t), new TestReducer()).get());
+
+        check(RUNNABLE, (c, t) -> c.run((IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.runAsync((IgniteRunnable)t).get());
+
+        check(RUNNABLE, (c, t) -> c.run(toList((IgniteRunnable)t)));
+        check(RUNNABLE, (c, t) -> c.runAsync(toList((IgniteRunnable)t)).get());
+
+        check(RUNNABLE, (c, t) -> c.broadcast((IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.broadcastAsync((IgniteRunnable)t).get());
+
+        check(CALLABLE, (c, t) -> c.broadcast((IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.broadcastAsync((IgniteCallable<Void>)t).get());
+
+        check(CLOSURE, ((c, t) -> c.broadcast((IgniteClosure<Void, Void>)t, null)));
+        check(CLOSURE, (c, t) -> c.broadcastAsync((IgniteClosure<Void, Void>)t, null).get());
+
+        check(CLOSURE, (c, t) -> c.apply((IgniteClosure<Void, Void>)t, (Void)null));
+        check(CLOSURE, (c, t) -> c.applyAsync((IgniteClosure<Void, Void>)t, (Void)null).get());
+
+        check(CLOSURE, (c, t) -> c.apply((IgniteClosure<Void, Void>)t, singletonList(null), new TestReducer()));
+        check(CLOSURE, (c, t) -> c.applyAsync((IgniteClosure<Void, Void>)t, singletonList(null), new TestReducer()).get());
+
+        check(RUNNABLE, (c, t) -> c.affinityRun(DEFAULT_CACHE_NAME, ""key"", (IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.affinityRunAsync(DEFAULT_CACHE_NAME, ""key"", (IgniteRunnable)t).get());
+
+        check(RUNNABLE, (c, t) -> c.affinityRun(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.affinityRunAsync(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteRunnable)t).get());
+
+        check(RUNNABLE, (c, t) -> c.affinityRun(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.affinityRunAsync(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteRunnable)t).get());
+
+        check(CALLABLE, (c, t) -> c.affinityCall(DEFAULT_CACHE_NAME, ""key"", (IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.affinityCallAsync(DEFAULT_CACHE_NAME, ""key"", (IgniteCallable<Void>)t).get());
+
+        check(CALLABLE, (c, t) -> c.affinityCall(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.affinityCallAsync(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteCallable<Void>)t).get());
+
+        check(CALLABLE, (c, t) -> c.affinityCall(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.affinityCallAsync(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteCallable<Void>)t).get());
+    }
+
+    /** */
+    public void check(ComputationType type, ConsumerX<Object> consumer) throws Exception {
+        consumer.accept(grid().compute().withName(TEST_TASK_NAME), getComputationObject(type, TEST_TASK_NAME));
+        consumer.accept(grid().compute(), getComputationObject(type, null));
+
+        assertThrows(() -> consumer.accept(grid().compute().withName(TEST_TASK_NAME), null));
+        consumer.accept(grid().compute(), getComputationObject(type, null));
+    }
+
+    /** */
+    private static class TestCallable extends TaskNameChecker implements IgniteCallable<Void> {
+        /** */
+        public TestCallable(String expName) {
+            super(expName);
+        }
+
+        /** {@inheritDoc} */
+        @Override public Void call() throws Exception {
+            checkName();
+
+            return null;
+        }
+    }
+
+    /** */
+    private static class TestRunnable extends TaskNameChecker implements IgniteRunnable {
+        /** */
+        public TestRunnable(String expName) {
+            super(expName);
+        }
+
+        /** {@inheritDoc} */
+        @Override public void run() {
+            checkName();
+        }
+    }
+
+    /** */
+    private static class TestClosure extends TaskNameChecker implements IgniteClosure<Void, Void> {
+        /** */
+        public TestClosure(String expName) {
+            super(expName);
+        }
+
+        /** {@inheritDoc} */
+        @Override public Void apply(Void arg) {
+            checkName();
+
+            return null;
+        }
+    }
+
+    /** */
+    private static class TestTask extends ComputeTaskAdapter<Void, Void> {
+        /** */
+        private final String name;
+
+        /** */
+        public TestTask(String name) {
+            this.name = name == null ? getClass().getName() : name;
+        }
+
+        /** {@inheritDoc} */
+        @Override public @NotNull Map<? extends ComputeJob, ClusterNode> map(
+            List<ClusterNode> subgrid,
+            @Nullable Void arg
+        ) throws IgniteException {
+            return singletonMap(new TestJob(name), subgrid.iterator().next());
+        }
+
+        /** {@inheritDoc} */
+        @Nullable @Override public Void reduce(List list) throws IgniteException {
+            return null;
+        }
+
+        /** */
+        private static class TestJob extends TaskNameChecker implements ComputeJob {
+            /** */
+            public TestJob(String expName) {
+                super(expName);
+            }
+
+            /** {@inheritDoc} */
+            @Override public Object execute() throws IgniteException {
+                checkName();
+
+                return null;
+            }
+
+            /** {@inheritDoc} */
+            @Override public void cancel() {
+                // No-op.
+            }
+        }
+    }
+
+    /** */
+    private static class TaskNameChecker {
+        /** */
+        @TaskSessionResource
+        private ComputeTaskSession ses;
+
+        /** */
+        private final String expName;
+
+        /** */
+        public TaskNameChecker(String expName) {
+            this.expName = expName == null ? getClass().getName() : expName;
+        }
+
+        /** */
+        protected void checkName() {
+            assertEquals(expName, ses.getTaskName());
+        }
+
+    }
+
+    /** */
+    private void assertThrows(RunnableX r) {
+        GridTestUtils.assertThrowsWithCause(r, Exception.class);
+    }
+
+    /** */
+    private static class TestReducer implements IgniteReducer<Void, Void> {
+        /** {@inheritDoc} */
+        @Override public boolean collect(@Nullable Void o) {
+            return false;
+        }
+
+        /** {@inheritDoc} */
+        @Override public Void reduce() {
+            return null;
+        }
+    }
+
+    /** */
+    private static <T> Collection<T> toList(T t) {
+        return t == null ? null : singletonList(t);
+    }
+
+    /** */
+    private interface ConsumerX<T> {

Review Comment:
   ComputationConsumer ?



;20/Jan/23 18:36;githubbot;600","NSAmelchev commented on code in PR #10482:
URL: https://github.com/apache/ignite/pull/10482#discussion_r1082947629


##########
modules/core/src/main/java/org/apache/ignite/internal/processors/task/GridTaskProcessor.java:
##########
@@ -626,21 +540,10 @@ private <T, R> ComputeTaskInternalFuture<R> startTask(
         else
             taskClsName = taskCls != null ? taskCls.getName() : taskName;
 
-        // Get values from thread-local context.
-        Map<GridTaskThreadContextKey, Object> map = thCtx.get();
-
-        if (map == null)
-            map = EMPTY_ENUM_MAP;
-        else
-            // Reset thread-local context.
-            thCtx.set(null);
-
-        if (map.get(TC_SKIP_AUTH) == null)
+        if (!opts.isAuthenticationDisabled())
             ctx.security().authorize(taskClsName, SecurityPermission.TASK_EXECUTE);
 
-        Long timeout = (Long)map.get(TC_TIMEOUT);
-
-        long timeout0 = timeout == null || timeout == 0 ? Long.MAX_VALUE : timeout;
+        long timeout0 = opts.timeout().orElse(Long.MAX_VALUE);

Review Comment:
   Timeout should be `Long.MAX_VALUE` in case `timeout == 0` too 



;20/Jan/23 19:03;githubbot;600","petrov-mg commented on code in PR #10482:
URL: https://github.com/apache/ignite/pull/10482#discussion_r1083056001


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/compute/TaskOptionsPropagationTest.java:
##########
@@ -0,0 +1,315 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.compute;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import org.apache.ignite.IgniteCompute;
+import org.apache.ignite.IgniteException;
+import org.apache.ignite.cluster.ClusterNode;
+import org.apache.ignite.compute.ComputeJob;
+import org.apache.ignite.compute.ComputeTask;
+import org.apache.ignite.compute.ComputeTaskAdapter;
+import org.apache.ignite.compute.ComputeTaskSession;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.lang.RunnableX;
+import org.apache.ignite.lang.IgniteCallable;
+import org.apache.ignite.lang.IgniteClosure;
+import org.apache.ignite.lang.IgniteReducer;
+import org.apache.ignite.lang.IgniteRunnable;
+import org.apache.ignite.resources.TaskSessionResource;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.junit.Test;
+
+import static java.util.Collections.singletonList;
+import static java.util.Collections.singletonMap;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.CALLABLE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.CLOSURE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.RUNNABLE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.TASK;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+
+/** */
+public class TaskOptionsPropagationTest extends GridCommonAbstractTest {
+    /** */
+    private static final String TEST_TASK_NAME = ""test-name"";
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTestsStarted() throws Exception {
+        super.beforeTestsStarted();
+
+        startGrid();
+
+        grid().createCache(DEFAULT_CACHE_NAME).put(0, 0);
+    }
+
+    /** */
+    @Test
+    public void testUserTaskOptionsWithPrecedingSystemTaskExecution() throws Exception {
+        try (IgniteEx cli = startClientGrid(1)) {
+            cli.compute().withName(TEST_TASK_NAME).affinityCall(
+                DEFAULT_CACHE_NAME,
+                0,
+                new TestCallable(TEST_TASK_NAME)
+            );
+        }
+    }
+
+    /** */
+    @Test
+    public void testComputeSharedAcrossMultipleThreads() throws Exception {
+        IgniteCompute compute = grid().compute();
+
+        compute.withName(TEST_TASK_NAME);
+
+        runAsync(() -> compute.call(new TestCallable(TestCallable.class.getName()))).get();
+
+        compute.call(new TestCallable(TEST_TASK_NAME));
+    }
+
+    /** */
+    @Test
+    public void testTaskExecutionOptionsReset() throws Exception {
+        check(TASK, (c, t) -> c.execute((ComputeTask)t, null));
+        check(TASK, (c, t) -> c.executeAsync((ComputeTask)t, null).get());
+
+        check(CALLABLE, (c, t) -> c.call((IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.callAsync((IgniteCallable<Void>)t).get());
+
+        check(CALLABLE, (c, t) -> c.call((toList((IgniteCallable<Void>)t))));
+        check(CALLABLE, (c, t) -> c.callAsync(toList((IgniteCallable<Void>)t)).get());
+
+        check(CALLABLE, (c, t) -> c.call(toList((IgniteCallable<Void>)t), new TestReducer()));
+        check(CALLABLE, (c, t) -> c.callAsync(toList((IgniteCallable<Void>)t), new TestReducer()).get());
+
+        check(RUNNABLE, (c, t) -> c.run((IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.runAsync((IgniteRunnable)t).get());
+
+        check(RUNNABLE, (c, t) -> c.run(toList((IgniteRunnable)t)));
+        check(RUNNABLE, (c, t) -> c.runAsync(toList((IgniteRunnable)t)).get());
+
+        check(RUNNABLE, (c, t) -> c.broadcast((IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.broadcastAsync((IgniteRunnable)t).get());
+
+        check(CALLABLE, (c, t) -> c.broadcast((IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.broadcastAsync((IgniteCallable<Void>)t).get());
+
+        check(CLOSURE, ((c, t) -> c.broadcast((IgniteClosure<Void, Void>)t, null)));
+        check(CLOSURE, (c, t) -> c.broadcastAsync((IgniteClosure<Void, Void>)t, null).get());
+
+        check(CLOSURE, (c, t) -> c.apply((IgniteClosure<Void, Void>)t, (Void)null));
+        check(CLOSURE, (c, t) -> c.applyAsync((IgniteClosure<Void, Void>)t, (Void)null).get());
+
+        check(CLOSURE, (c, t) -> c.apply((IgniteClosure<Void, Void>)t, singletonList(null), new TestReducer()));
+        check(CLOSURE, (c, t) -> c.applyAsync((IgniteClosure<Void, Void>)t, singletonList(null), new TestReducer()).get());
+
+        check(RUNNABLE, (c, t) -> c.affinityRun(DEFAULT_CACHE_NAME, ""key"", (IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.affinityRunAsync(DEFAULT_CACHE_NAME, ""key"", (IgniteRunnable)t).get());
+
+        check(RUNNABLE, (c, t) -> c.affinityRun(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.affinityRunAsync(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteRunnable)t).get());
+
+        check(RUNNABLE, (c, t) -> c.affinityRun(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.affinityRunAsync(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteRunnable)t).get());
+
+        check(CALLABLE, (c, t) -> c.affinityCall(DEFAULT_CACHE_NAME, ""key"", (IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.affinityCallAsync(DEFAULT_CACHE_NAME, ""key"", (IgniteCallable<Void>)t).get());
+
+        check(CALLABLE, (c, t) -> c.affinityCall(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.affinityCallAsync(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteCallable<Void>)t).get());
+
+        check(CALLABLE, (c, t) -> c.affinityCall(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.affinityCallAsync(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteCallable<Void>)t).get());
+    }
+
+    /** */
+    public void check(ComputationType type, ConsumerX<Object> consumer) throws Exception {
+        consumer.accept(grid().compute().withName(TEST_TASK_NAME), getComputationObject(type, TEST_TASK_NAME));
+        consumer.accept(grid().compute(), getComputationObject(type, null));
+
+        assertThrows(() -> consumer.accept(grid().compute().withName(TEST_TASK_NAME), null));
+        consumer.accept(grid().compute(), getComputationObject(type, null));
+    }
+
+    /** */
+    private static class TestCallable extends TaskNameChecker implements IgniteCallable<Void> {
+        /** */
+        public TestCallable(String expName) {
+            super(expName);
+        }
+
+        /** {@inheritDoc} */
+        @Override public Void call() throws Exception {
+            checkName();
+
+            return null;
+        }
+    }
+
+    /** */
+    private static class TestRunnable extends TaskNameChecker implements IgniteRunnable {
+        /** */
+        public TestRunnable(String expName) {
+            super(expName);
+        }
+
+        /** {@inheritDoc} */
+        @Override public void run() {
+            checkName();
+        }
+    }
+
+    /** */
+    private static class TestClosure extends TaskNameChecker implements IgniteClosure<Void, Void> {
+        /** */
+        public TestClosure(String expName) {
+            super(expName);
+        }
+
+        /** {@inheritDoc} */
+        @Override public Void apply(Void arg) {
+            checkName();
+
+            return null;
+        }
+    }
+
+    /** */
+    private static class TestTask extends ComputeTaskAdapter<Void, Void> {
+        /** */
+        private final String name;
+
+        /** */
+        public TestTask(String name) {
+            this.name = name == null ? getClass().getName() : name;
+        }
+
+        /** {@inheritDoc} */
+        @Override public @NotNull Map<? extends ComputeJob, ClusterNode> map(
+            List<ClusterNode> subgrid,
+            @Nullable Void arg
+        ) throws IgniteException {
+            return singletonMap(new TestJob(name), subgrid.iterator().next());
+        }
+
+        /** {@inheritDoc} */
+        @Nullable @Override public Void reduce(List list) throws IgniteException {
+            return null;
+        }
+
+        /** */
+        private static class TestJob extends TaskNameChecker implements ComputeJob {
+            /** */
+            public TestJob(String expName) {
+                super(expName);
+            }
+
+            /** {@inheritDoc} */
+            @Override public Object execute() throws IgniteException {
+                checkName();
+
+                return null;
+            }
+
+            /** {@inheritDoc} */
+            @Override public void cancel() {
+                // No-op.
+            }
+        }
+    }
+
+    /** */
+    private static class TaskNameChecker {
+        /** */
+        @TaskSessionResource
+        private ComputeTaskSession ses;
+
+        /** */
+        private final String expName;
+
+        /** */
+        public TaskNameChecker(String expName) {
+            this.expName = expName == null ? getClass().getName() : expName;
+        }
+
+        /** */
+        protected void checkName() {
+            assertEquals(expName, ses.getTaskName());
+        }
+

Review Comment:
   Fixed.



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/compute/TaskOptionsPropagationTest.java:
##########
@@ -0,0 +1,315 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.compute;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import org.apache.ignite.IgniteCompute;
+import org.apache.ignite.IgniteException;
+import org.apache.ignite.cluster.ClusterNode;
+import org.apache.ignite.compute.ComputeJob;
+import org.apache.ignite.compute.ComputeTask;
+import org.apache.ignite.compute.ComputeTaskAdapter;
+import org.apache.ignite.compute.ComputeTaskSession;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.lang.RunnableX;
+import org.apache.ignite.lang.IgniteCallable;
+import org.apache.ignite.lang.IgniteClosure;
+import org.apache.ignite.lang.IgniteReducer;
+import org.apache.ignite.lang.IgniteRunnable;
+import org.apache.ignite.resources.TaskSessionResource;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.junit.Test;
+
+import static java.util.Collections.singletonList;
+import static java.util.Collections.singletonMap;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.CALLABLE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.CLOSURE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.RUNNABLE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.TASK;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+
+/** */
+public class TaskOptionsPropagationTest extends GridCommonAbstractTest {
+    /** */
+    private static final String TEST_TASK_NAME = ""test-name"";
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTestsStarted() throws Exception {
+        super.beforeTestsStarted();
+
+        startGrid();
+
+        grid().createCache(DEFAULT_CACHE_NAME).put(0, 0);
+    }
+
+    /** */
+    @Test
+    public void testUserTaskOptionsWithPrecedingSystemTaskExecution() throws Exception {
+        try (IgniteEx cli = startClientGrid(1)) {
+            cli.compute().withName(TEST_TASK_NAME).affinityCall(
+                DEFAULT_CACHE_NAME,
+                0,
+                new TestCallable(TEST_TASK_NAME)
+            );
+        }
+    }
+
+    /** */
+    @Test
+    public void testComputeSharedAcrossMultipleThreads() throws Exception {
+        IgniteCompute compute = grid().compute();
+
+        compute.withName(TEST_TASK_NAME);
+
+        runAsync(() -> compute.call(new TestCallable(TestCallable.class.getName()))).get();
+
+        compute.call(new TestCallable(TEST_TASK_NAME));
+    }
+
+    /** */
+    @Test
+    public void testTaskExecutionOptionsReset() throws Exception {
+        check(TASK, (c, t) -> c.execute((ComputeTask)t, null));
+        check(TASK, (c, t) -> c.executeAsync((ComputeTask)t, null).get());
+
+        check(CALLABLE, (c, t) -> c.call((IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.callAsync((IgniteCallable<Void>)t).get());
+
+        check(CALLABLE, (c, t) -> c.call((toList((IgniteCallable<Void>)t))));
+        check(CALLABLE, (c, t) -> c.callAsync(toList((IgniteCallable<Void>)t)).get());
+
+        check(CALLABLE, (c, t) -> c.call(toList((IgniteCallable<Void>)t), new TestReducer()));
+        check(CALLABLE, (c, t) -> c.callAsync(toList((IgniteCallable<Void>)t), new TestReducer()).get());
+
+        check(RUNNABLE, (c, t) -> c.run((IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.runAsync((IgniteRunnable)t).get());
+
+        check(RUNNABLE, (c, t) -> c.run(toList((IgniteRunnable)t)));
+        check(RUNNABLE, (c, t) -> c.runAsync(toList((IgniteRunnable)t)).get());
+
+        check(RUNNABLE, (c, t) -> c.broadcast((IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.broadcastAsync((IgniteRunnable)t).get());
+
+        check(CALLABLE, (c, t) -> c.broadcast((IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.broadcastAsync((IgniteCallable<Void>)t).get());
+
+        check(CLOSURE, ((c, t) -> c.broadcast((IgniteClosure<Void, Void>)t, null)));
+        check(CLOSURE, (c, t) -> c.broadcastAsync((IgniteClosure<Void, Void>)t, null).get());
+
+        check(CLOSURE, (c, t) -> c.apply((IgniteClosure<Void, Void>)t, (Void)null));
+        check(CLOSURE, (c, t) -> c.applyAsync((IgniteClosure<Void, Void>)t, (Void)null).get());
+
+        check(CLOSURE, (c, t) -> c.apply((IgniteClosure<Void, Void>)t, singletonList(null), new TestReducer()));
+        check(CLOSURE, (c, t) -> c.applyAsync((IgniteClosure<Void, Void>)t, singletonList(null), new TestReducer()).get());
+
+        check(RUNNABLE, (c, t) -> c.affinityRun(DEFAULT_CACHE_NAME, ""key"", (IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.affinityRunAsync(DEFAULT_CACHE_NAME, ""key"", (IgniteRunnable)t).get());
+
+        check(RUNNABLE, (c, t) -> c.affinityRun(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.affinityRunAsync(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteRunnable)t).get());
+
+        check(RUNNABLE, (c, t) -> c.affinityRun(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteRunnable)t));
+        check(RUNNABLE, (c, t) -> c.affinityRunAsync(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteRunnable)t).get());
+
+        check(CALLABLE, (c, t) -> c.affinityCall(DEFAULT_CACHE_NAME, ""key"", (IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.affinityCallAsync(DEFAULT_CACHE_NAME, ""key"", (IgniteCallable<Void>)t).get());
+
+        check(CALLABLE, (c, t) -> c.affinityCall(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.affinityCallAsync(singletonList(DEFAULT_CACHE_NAME), ""key"", (IgniteCallable<Void>)t).get());
+
+        check(CALLABLE, (c, t) -> c.affinityCall(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteCallable<Void>)t));
+        check(CALLABLE, (c, t) -> c.affinityCallAsync(singletonList(DEFAULT_CACHE_NAME), 0, (IgniteCallable<Void>)t).get());
+    }
+
+    /** */
+    public void check(ComputationType type, ConsumerX<Object> consumer) throws Exception {
+        consumer.accept(grid().compute().withName(TEST_TASK_NAME), getComputationObject(type, TEST_TASK_NAME));
+        consumer.accept(grid().compute(), getComputationObject(type, null));
+
+        assertThrows(() -> consumer.accept(grid().compute().withName(TEST_TASK_NAME), null));
+        consumer.accept(grid().compute(), getComputationObject(type, null));
+    }
+
+    /** */
+    private static class TestCallable extends TaskNameChecker implements IgniteCallable<Void> {
+        /** */
+        public TestCallable(String expName) {
+            super(expName);
+        }
+
+        /** {@inheritDoc} */
+        @Override public Void call() throws Exception {
+            checkName();
+
+            return null;
+        }
+    }
+
+    /** */
+    private static class TestRunnable extends TaskNameChecker implements IgniteRunnable {
+        /** */
+        public TestRunnable(String expName) {
+            super(expName);
+        }
+
+        /** {@inheritDoc} */
+        @Override public void run() {
+            checkName();
+        }
+    }
+
+    /** */
+    private static class TestClosure extends TaskNameChecker implements IgniteClosure<Void, Void> {
+        /** */
+        public TestClosure(String expName) {
+            super(expName);
+        }
+
+        /** {@inheritDoc} */
+        @Override public Void apply(Void arg) {
+            checkName();
+
+            return null;
+        }
+    }
+
+    /** */
+    private static class TestTask extends ComputeTaskAdapter<Void, Void> {
+        /** */
+        private final String name;
+
+        /** */
+        public TestTask(String name) {
+            this.name = name == null ? getClass().getName() : name;
+        }
+
+        /** {@inheritDoc} */
+        @Override public @NotNull Map<? extends ComputeJob, ClusterNode> map(
+            List<ClusterNode> subgrid,
+            @Nullable Void arg
+        ) throws IgniteException {
+            return singletonMap(new TestJob(name), subgrid.iterator().next());
+        }
+
+        /** {@inheritDoc} */
+        @Nullable @Override public Void reduce(List list) throws IgniteException {
+            return null;
+        }
+
+        /** */
+        private static class TestJob extends TaskNameChecker implements ComputeJob {
+            /** */
+            public TestJob(String expName) {
+                super(expName);
+            }
+
+            /** {@inheritDoc} */
+            @Override public Object execute() throws IgniteException {
+                checkName();
+
+                return null;
+            }
+
+            /** {@inheritDoc} */
+            @Override public void cancel() {
+                // No-op.
+            }
+        }
+    }
+
+    /** */
+    private static class TaskNameChecker {
+        /** */
+        @TaskSessionResource
+        private ComputeTaskSession ses;
+
+        /** */
+        private final String expName;
+
+        /** */
+        public TaskNameChecker(String expName) {
+            this.expName = expName == null ? getClass().getName() : expName;
+        }
+
+        /** */
+        protected void checkName() {
+            assertEquals(expName, ses.getTaskName());
+        }
+
+    }
+
+    /** */
+    private void assertThrows(RunnableX r) {
+        GridTestUtils.assertThrowsWithCause(r, Exception.class);
+    }
+
+    /** */
+    private static class TestReducer implements IgniteReducer<Void, Void> {
+        /** {@inheritDoc} */
+        @Override public boolean collect(@Nullable Void o) {
+            return false;
+        }
+
+        /** {@inheritDoc} */
+        @Override public Void reduce() {
+            return null;
+        }
+    }
+
+    /** */
+    private static <T> Collection<T> toList(T t) {
+        return t == null ? null : singletonList(t);
+    }
+
+    /** */
+    private interface ConsumerX<T> {

Review Comment:
   Fixed.



;20/Jan/23 21:14;githubbot;600","petrov-mg commented on code in PR #10482:
URL: https://github.com/apache/ignite/pull/10482#discussion_r1083058621


##########
modules/core/src/main/java/org/apache/ignite/internal/processors/task/GridTaskProcessor.java:
##########
@@ -626,21 +540,10 @@ private <T, R> ComputeTaskInternalFuture<R> startTask(
         else
             taskClsName = taskCls != null ? taskCls.getName() : taskName;
 
-        // Get values from thread-local context.
-        Map<GridTaskThreadContextKey, Object> map = thCtx.get();
-
-        if (map == null)
-            map = EMPTY_ENUM_MAP;
-        else
-            // Reset thread-local context.
-            thCtx.set(null);
-
-        if (map.get(TC_SKIP_AUTH) == null)
+        if (!opts.isAuthenticationDisabled())
             ctx.security().authorize(taskClsName, SecurityPermission.TASK_EXECUTE);
 
-        Long timeout = (Long)map.get(TC_TIMEOUT);
-
-        long timeout0 = timeout == null || timeout == 0 ? Long.MAX_VALUE : timeout;
+        long timeout0 = opts.timeout().orElse(Long.MAX_VALUE);

Review Comment:
   Fixed. I think it's better not to return optional in TaskExecutionOptions#timeout() at all.



;20/Jan/23 21:18;githubbot;600","petrov-mg commented on code in PR #10482:
URL: https://github.com/apache/ignite/pull/10482#discussion_r1083060832


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/compute/TaskOptionsPropagationTest.java:
##########
@@ -0,0 +1,315 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.compute;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import org.apache.ignite.IgniteCompute;
+import org.apache.ignite.IgniteException;
+import org.apache.ignite.cluster.ClusterNode;
+import org.apache.ignite.compute.ComputeJob;
+import org.apache.ignite.compute.ComputeTask;
+import org.apache.ignite.compute.ComputeTaskAdapter;
+import org.apache.ignite.compute.ComputeTaskSession;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.lang.RunnableX;
+import org.apache.ignite.lang.IgniteCallable;
+import org.apache.ignite.lang.IgniteClosure;
+import org.apache.ignite.lang.IgniteReducer;
+import org.apache.ignite.lang.IgniteRunnable;
+import org.apache.ignite.resources.TaskSessionResource;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.junit.Test;
+
+import static java.util.Collections.singletonList;
+import static java.util.Collections.singletonMap;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.CALLABLE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.CLOSURE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.RUNNABLE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.TASK;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+
+/** */
+public class TaskOptionsPropagationTest extends GridCommonAbstractTest {
+    /** */
+    private static final String TEST_TASK_NAME = ""test-name"";
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTestsStarted() throws Exception {
+        super.beforeTestsStarted();
+
+        startGrid();
+
+        grid().createCache(DEFAULT_CACHE_NAME).put(0, 0);
+    }
+
+    /** */
+    @Test
+    public void testUserTaskOptionsWithPrecedingSystemTaskExecution() throws Exception {
+        try (IgniteEx cli = startClientGrid(1)) {
+            cli.compute().withName(TEST_TASK_NAME).affinityCall(
+                DEFAULT_CACHE_NAME,
+                0,
+                new TestCallable(TEST_TASK_NAME)
+            );
+        }
+    }
+
+    /** */
+    @Test
+    public void testComputeSharedAcrossMultipleThreads() throws Exception {
+        IgniteCompute compute = grid().compute();
+
+        compute.withName(TEST_TASK_NAME);
+
+        runAsync(() -> compute.call(new TestCallable(TestCallable.class.getName()))).get();
+
+        compute.call(new TestCallable(TEST_TASK_NAME));
+    }
+
+    /** */
+    @Test
+    public void testTaskExecutionOptionsReset() throws Exception {
+        check(TASK, (c, t) -> c.execute((ComputeTask)t, null));

Review Comment:
   Just refactored tests a bit so dedicated enum with computation classes is no longer needed. Please take a look again



;20/Jan/23 21:21;githubbot;600","petrov-mg commented on code in PR #10482:
URL: https://github.com/apache/ignite/pull/10482#discussion_r1083060832


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/compute/TaskOptionsPropagationTest.java:
##########
@@ -0,0 +1,315 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.compute;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import org.apache.ignite.IgniteCompute;
+import org.apache.ignite.IgniteException;
+import org.apache.ignite.cluster.ClusterNode;
+import org.apache.ignite.compute.ComputeJob;
+import org.apache.ignite.compute.ComputeTask;
+import org.apache.ignite.compute.ComputeTaskAdapter;
+import org.apache.ignite.compute.ComputeTaskSession;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.lang.RunnableX;
+import org.apache.ignite.lang.IgniteCallable;
+import org.apache.ignite.lang.IgniteClosure;
+import org.apache.ignite.lang.IgniteReducer;
+import org.apache.ignite.lang.IgniteRunnable;
+import org.apache.ignite.resources.TaskSessionResource;
+import org.apache.ignite.testframework.GridTestUtils;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.junit.Test;
+
+import static java.util.Collections.singletonList;
+import static java.util.Collections.singletonMap;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.CALLABLE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.CLOSURE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.RUNNABLE;
+import static org.apache.ignite.internal.processors.compute.TaskOptionsPropagationTest.ComputationType.TASK;
+import static org.apache.ignite.testframework.GridTestUtils.runAsync;
+
+/** */
+public class TaskOptionsPropagationTest extends GridCommonAbstractTest {
+    /** */
+    private static final String TEST_TASK_NAME = ""test-name"";
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTestsStarted() throws Exception {
+        super.beforeTestsStarted();
+
+        startGrid();
+
+        grid().createCache(DEFAULT_CACHE_NAME).put(0, 0);
+    }
+
+    /** */
+    @Test
+    public void testUserTaskOptionsWithPrecedingSystemTaskExecution() throws Exception {
+        try (IgniteEx cli = startClientGrid(1)) {
+            cli.compute().withName(TEST_TASK_NAME).affinityCall(
+                DEFAULT_CACHE_NAME,
+                0,
+                new TestCallable(TEST_TASK_NAME)
+            );
+        }
+    }
+
+    /** */
+    @Test
+    public void testComputeSharedAcrossMultipleThreads() throws Exception {
+        IgniteCompute compute = grid().compute();
+
+        compute.withName(TEST_TASK_NAME);
+
+        runAsync(() -> compute.call(new TestCallable(TestCallable.class.getName()))).get();
+
+        compute.call(new TestCallable(TEST_TASK_NAME));
+    }
+
+    /** */
+    @Test
+    public void testTaskExecutionOptionsReset() throws Exception {
+        check(TASK, (c, t) -> c.execute((ComputeTask)t, null));

Review Comment:
   Just refactored tests a bit so dedicated enum with computation types is no longer needed. Please take a look again.



;20/Jan/23 21:23;githubbot;600","petrov-mg commented on code in PR #10482:
URL: https://github.com/apache/ignite/pull/10482#discussion_r1083058621


##########
modules/core/src/main/java/org/apache/ignite/internal/processors/task/GridTaskProcessor.java:
##########
@@ -626,21 +540,10 @@ private <T, R> ComputeTaskInternalFuture<R> startTask(
         else
             taskClsName = taskCls != null ? taskCls.getName() : taskName;
 
-        // Get values from thread-local context.
-        Map<GridTaskThreadContextKey, Object> map = thCtx.get();
-
-        if (map == null)
-            map = EMPTY_ENUM_MAP;
-        else
-            // Reset thread-local context.
-            thCtx.set(null);
-
-        if (map.get(TC_SKIP_AUTH) == null)
+        if (!opts.isAuthenticationDisabled())
             ctx.security().authorize(taskClsName, SecurityPermission.TASK_EXECUTE);
 
-        Long timeout = (Long)map.get(TC_TIMEOUT);
-
-        long timeout0 = timeout == null || timeout == 0 ? Long.MAX_VALUE : timeout;
+        long timeout0 = opts.timeout().orElse(Long.MAX_VALUE);

Review Comment:
   Fixed. I think it's better not to return Optional in TaskExecutionOptions#timeout() at all.



;20/Jan/23 21:23;githubbot;600","petrov-mg merged PR #10482:
URL: https://github.com/apache/ignite/pull/10482


;22/Jan/23 19:00;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,6000,,,0,6000,,,,,,,,,,,,,,,,,,,,,,IGNITE-18750,IGNITE-18713,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Sun Jan 22 19:01:32 UTC 2023,,,,,,,,,,"0|z1ervs:",9223372036854775807,Fixed execution options propagation for compute methods.,,,,,,,,,,,,,,,,,,,,"22/Jan/23 08:57;ignitetcbot;{panel:title=Branch: [pull/10482/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10482/head] Base: [master] : New Tests (3)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Compute (Grid){color} [[tests 3|https://ci.ignite.apache.org/viewLog.html?buildId=7020160]]
* {color:#013220}IgniteBinaryObjectsComputeGridTestSuite: TaskOptionsPropagationTest.testComputeSharedAcrossMultipleThreads - PASSED{color}
* {color:#013220}IgniteBinaryObjectsComputeGridTestSuite: TaskOptionsPropagationTest.testUserTaskOptionsWithPrecedingSystemTaskExecution - PASSED{color}
* {color:#013220}IgniteBinaryObjectsComputeGridTestSuite: TaskOptionsPropagationTest.testTaskExecutionOptionsReset - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci.ignite.apache.org/viewLog.html?buildId=7020237&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","22/Jan/23 08:58;ignitetcbot;{panel:title=Branch: [pull/10482/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10482/head] Base: [master] : New Tests (3)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Compute (Grid){color} [[tests 3|https://ci2.ignite.apache.org/viewLog.html?buildId=7008062]]
* {color:#013220}IgniteBinaryObjectsComputeGridTestSuite: TaskOptionsPropagationTest.testTaskExecutionOptionsReset - PASSED{color}
* {color:#013220}IgniteBinaryObjectsComputeGridTestSuite: TaskOptionsPropagationTest.testUserTaskOptionsWithPrecedingSystemTaskExecution - PASSED{color}
* {color:#013220}IgniteBinaryObjectsComputeGridTestSuite: TaskOptionsPropagationTest.testComputeSharedAcrossMultipleThreads - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7008139&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","22/Jan/23 19:01;PetrovMikhail;[~NSAmelchev] Thank you a lot for the review.;;;",,,
It is necessary to process the default distribution zone like all other zones,IGNITE-18540,13517847,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Sergey Uttsel,Sergey Uttsel,Sergey Uttsel,12/Jan/23 13:08,18/Jan/23 13:58,13/Jul/23 09:11,18/Jan/23 13:58,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"h3. Motivation

The default distribution zone is separated from other zones. So need to check all places where is processed zonesConfiguration.distributionZones() and add processing of zonesConfiguration.defaultDistributionZone().
h3. Definition of Done

The default distribution zone is processed like all other zones.",,alapin,Sergey Uttsel,,,,"sanpwc commented on code in PR #1532:
URL: https://github.com/apache/ignite-3/pull/1532#discussion_r1072526295


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -791,9 +813,19 @@ public boolean onUpdate(@NotNull WatchEvent evt) {
 
                             logicalTopology = newLogicalTopology;
 
-                            zonesConfiguration.distributionZones().value().namedListKeys()
+                            Stream.of(

Review Comment:
   I'd rather encapsulate all actions to be performed with zone  into some fooBar method and simply call fooBar for defaultZone and fooBar for all other zones from the list.



;17/Jan/23 17:29;githubbot;600","alievmirza commented on code in PR #1532:
URL: https://github.com/apache/ignite-3/pull/1532#discussion_r1072283593


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -590,6 +584,32 @@ private void updateMetaStorageOnZoneDelete(int zoneId, long revision) {
         }
     }
 
+    /**
+     * Updates {@link DistributionZoneChange} according to distribution zone configuration.
+     *
+     * @param zoneChange Zone change.
+     * @param distributionZoneCfg Distribution zone configuration.
+     */
+    private void updateZoneChange(DistributionZoneChange zoneChange, DistributionZoneConfigurationParameters distributionZoneCfg) {

Review Comment:
   May be static. 



##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -289,54 +290,43 @@ public CompletableFuture<Void> alterZone(String name, DistributionZoneConfigurat
         try {
             CompletableFuture<Void> fut = new CompletableFuture<>();
 
-            zonesConfiguration.change(zonesChange -> zonesChange.changeDistributionZones(zonesListChange -> {
-                NamedListChange<DistributionZoneView, DistributionZoneChange> renameChange;
+            CompletableFuture<Void> change;
 
-                try {
-                    renameChange = zonesListChange.rename(name, distributionZoneCfg.name());
-                } catch (IllegalArgumentException e) {
-                    throw new DistributionZoneRenameException(name, distributionZoneCfg.name(), e);
-                }
+            if (DEFAULT_ZONE_NAME.equals(name)) {
+                change = zonesConfiguration.change(zonesChange -> zonesChange

Review Comment:
   I would use formatting like this
   ```
                   change = zonesConfiguration.change(
                           zonesChange -> zonesChange.changeDefaultDistributionZone(
                                   zoneChange -> updateZoneChange(zoneChange, distributionZoneCfg)
                           )
                   );
   ```



##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneManagerTest.java:
##########
@@ -226,59 +226,87 @@ public void testDropZoneIfNotExists() {
     }
 
     @Test
-    public void testUpdateZone() throws Exception {
-        distributionZoneManager.createZone(
-                        new DistributionZoneConfigurationParameters.Builder(ZONE_NAME).dataNodesAutoAdjust(100).build()
-                )
-                .get(5, TimeUnit.SECONDS);
+    public void testUpdateDefaultZone() throws Exception {
+        testUpdateZone(DEFAULT_ZONE_NAME);
+    }
 
-        DistributionZoneConfiguration zone1 = registry.getConfiguration(DistributionZonesConfiguration.KEY).distributionZones()
-                .get(ZONE_NAME);
+    @Test
+    public void testUpdateNotDefaultZone() throws Exception {
+        testUpdateZone(ZONE_NAME);
+    }
 
-        assertNotNull(zone1, ""Zone was not created."");
-        assertEquals(ZONE_NAME, zone1.name().value(), ""Zone name is wrong."");
-        assertEquals(Integer.MAX_VALUE, zone1.dataNodesAutoAdjustScaleUp().value(), ""dataNodesAutoAdjustScaleUp is wrong."");
-        assertEquals(Integer.MAX_VALUE, zone1.dataNodesAutoAdjustScaleDown().value(), ""dataNodesAutoAdjustScaleDown is wrong."");
-        assertEquals(100, zone1.dataNodesAutoAdjust().value(), ""dataNodesAutoAdjust is wrong."");
+    public void testUpdateZone(String zoneName) throws Exception {

Review Comment:
   ```suggestion
       private void testUpdateZone(String zoneName) throws Exception {
   ```



;17/Jan/23 17:32;githubbot;600","sergeyuttsel commented on code in PR #1532:
URL: https://github.com/apache/ignite-3/pull/1532#discussion_r1072748804


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -791,9 +813,19 @@ public boolean onUpdate(@NotNull WatchEvent evt) {
 
                             logicalTopology = newLogicalTopology;
 
-                            zonesConfiguration.distributionZones().value().namedListKeys()
+                            Stream.of(

Review Comment:
   Fixed, thanks.



##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -289,54 +290,43 @@ public CompletableFuture<Void> alterZone(String name, DistributionZoneConfigurat
         try {
             CompletableFuture<Void> fut = new CompletableFuture<>();
 
-            zonesConfiguration.change(zonesChange -> zonesChange.changeDistributionZones(zonesListChange -> {
-                NamedListChange<DistributionZoneView, DistributionZoneChange> renameChange;
+            CompletableFuture<Void> change;
 
-                try {
-                    renameChange = zonesListChange.rename(name, distributionZoneCfg.name());
-                } catch (IllegalArgumentException e) {
-                    throw new DistributionZoneRenameException(name, distributionZoneCfg.name(), e);
-                }
+            if (DEFAULT_ZONE_NAME.equals(name)) {
+                change = zonesConfiguration.change(zonesChange -> zonesChange

Review Comment:
   Fixed, thanks.



;17/Jan/23 20:09;githubbot;600","sergeyuttsel commented on code in PR #1532:
URL: https://github.com/apache/ignite-3/pull/1532#discussion_r1072749064


##########
modules/distribution-zones/src/main/java/org/apache/ignite/internal/distributionzones/DistributionZoneManager.java:
##########
@@ -590,6 +584,32 @@ private void updateMetaStorageOnZoneDelete(int zoneId, long revision) {
         }
     }
 
+    /**
+     * Updates {@link DistributionZoneChange} according to distribution zone configuration.
+     *
+     * @param zoneChange Zone change.
+     * @param distributionZoneCfg Distribution zone configuration.
+     */
+    private void updateZoneChange(DistributionZoneChange zoneChange, DistributionZoneConfigurationParameters distributionZoneCfg) {

Review Comment:
   Fixed.



##########
modules/distribution-zones/src/test/java/org/apache/ignite/internal/distributionzones/DistributionZoneManagerTest.java:
##########
@@ -226,59 +226,87 @@ public void testDropZoneIfNotExists() {
     }
 
     @Test
-    public void testUpdateZone() throws Exception {
-        distributionZoneManager.createZone(
-                        new DistributionZoneConfigurationParameters.Builder(ZONE_NAME).dataNodesAutoAdjust(100).build()
-                )
-                .get(5, TimeUnit.SECONDS);
+    public void testUpdateDefaultZone() throws Exception {
+        testUpdateZone(DEFAULT_ZONE_NAME);
+    }
 
-        DistributionZoneConfiguration zone1 = registry.getConfiguration(DistributionZonesConfiguration.KEY).distributionZones()
-                .get(ZONE_NAME);
+    @Test
+    public void testUpdateNotDefaultZone() throws Exception {
+        testUpdateZone(ZONE_NAME);
+    }
 
-        assertNotNull(zone1, ""Zone was not created."");
-        assertEquals(ZONE_NAME, zone1.name().value(), ""Zone name is wrong."");
-        assertEquals(Integer.MAX_VALUE, zone1.dataNodesAutoAdjustScaleUp().value(), ""dataNodesAutoAdjustScaleUp is wrong."");
-        assertEquals(Integer.MAX_VALUE, zone1.dataNodesAutoAdjustScaleDown().value(), ""dataNodesAutoAdjustScaleDown is wrong."");
-        assertEquals(100, zone1.dataNodesAutoAdjust().value(), ""dataNodesAutoAdjust is wrong."");
+    public void testUpdateZone(String zoneName) throws Exception {

Review Comment:
   Fixed.



;17/Jan/23 20:09;githubbot;600","sanpwc merged PR #1532:
URL: https://github.com/apache/ignite-3/pull/1532


;18/Jan/23 13:58;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17924,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jan 18 13:58:36 UTC 2023,,,,,,,,,,"0|z1erfc:",9223372036854775807,,,alapin,,,,,,,,,,,,,,,,,,"18/Jan/23 13:58;alapin;[~Sergey Uttsel] LGTM.;;;",,,,,
The WalWritingRate metric is not calculated when walMode is LOG_ONLY or BACKGROUND,IGNITE-18534,13517766,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,AldoRaine,AldoRaine,AldoRaine,12/Jan/23 08:11,21/Apr/23 12:20,13/Jul/23 09:11,01/Mar/23 07:13,2.14,,,,,,,2.15,,,,0,ise,,,"The WalWritingRate metric is not calculated when walMode is LOG_ONLY or BACKGROUND.
Reproducer  [^IoDatastorageMetricsTest.java].
Quick fix patch  [^patch.patch].
",,AldoRaine,ignitetcbot,zstan,,,"luchnikovbsk opened a new pull request, #10508:
URL: https://github.com/apache/ignite/pull/10508

   The WalWritingRate metric is not calculated when walMode is LOG_ONLY or BACKGROUND
   
   Thank you for submitting the pull request to the Apache Ignite.
   
   In order to streamline the review of the contribution 
   we ask you to ensure the following steps have been taken:
   
   ### The Contribution Checklist
   - [ ] There is a single JIRA ticket related to the pull request. 
   - [ ] The web-link to the pull request is attached to the JIRA ticket.
   - [ ] The JIRA ticket has the _Patch Available_ state.
   - [ ] The pull request body describes changes that have been made. 
   The description explains _WHAT_ and _WHY_ was made instead of _HOW_.
   - [ ] The pull request title is treated as the final commit message. 
   The following pattern must be used: `IGNITE-XXXX Change summary` where `XXXX` - number of JIRA issue.
   - [ ] A reviewer has been mentioned through the JIRA comments 
   (see [the Maintainers list](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute#HowtoContribute-ReviewProcessandMaintainers)) 
   - [ ] The pull request has been checked by the Teamcity Bot and 
   the `green visa` attached to the JIRA ticket (see [TC.Bot: Check PR](https://mtcga.gridgain.com/prs.html))
   
   ### Notes
   - [How to Contribute](https://cwiki.apache.org/confluence/display/IGNITE/How+to+Contribute)
   - [Coding abbreviation rules](https://cwiki.apache.org/confluence/display/IGNITE/Abbreviation+Rules)
   - [Coding Guidelines](https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines)
   - [Apache Ignite Teamcity Bot](https://cwiki.apache.org/confluence/display/IGNITE/Apache+Ignite+Teamcity+Bot)
   
   If you need any help, please email dev@ignite.apache.org or ask anу advice on http://asf.slack.com _#ignite_ channel.
   


;31/Jan/23 11:07;githubbot;600","zstan commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1091788982


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ *
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    private static final long MULTIPLICATOR = U.MB;
+    private static final int MAX_SEGMENTS = 20;
+
+    private static final Map<String, List<Long>> report = new HashMap<>();
+
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    @Override protected void afterTestsStopped() throws Exception {
+        super.afterTestsStopped();
+
+        log().warning("">>> REPORT: "" + report.toString());
+    }
+
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        //for debug
+        LogExporterSpi exporterSpi = new LogExporterSpi();
+        exporterSpi.setPeriod(1000);
+        exporterSpi.setExportFilter(mgrp -> mgrp.name().startsWith(""io.datastorage""));
+
+        return super.getConfiguration(igniteInstanceName)
+            .setMetricExporterSpi(exporterSpi, new JmxMetricExporterSpi())
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalArchivePath(DFLT_WAL_PATH)
+                    .setWalSegments(10)
+                    .setWalSegmentSize((int)(1 * MULTIPLICATOR))
+                    .setMaxWalArchiveSize(20 * MULTIPLICATOR)

Review Comment:
   20 * MB more clear than you proposal, i suppose.



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ *
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    private static final long MULTIPLICATOR = U.MB;
+    private static final int MAX_SEGMENTS = 20;
+
+    private static final Map<String, List<Long>> report = new HashMap<>();
+
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    @Override protected void afterTestsStopped() throws Exception {
+        super.afterTestsStopped();
+
+        log().warning("">>> REPORT: "" + report.toString());
+    }
+
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        //for debug
+        LogExporterSpi exporterSpi = new LogExporterSpi();
+        exporterSpi.setPeriod(1000);
+        exporterSpi.setExportFilter(mgrp -> mgrp.name().startsWith(""io.datastorage""));
+
+        return super.getConfiguration(igniteInstanceName)
+            .setMetricExporterSpi(exporterSpi, new JmxMetricExporterSpi())
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalArchivePath(DFLT_WAL_PATH)
+                    .setWalSegments(10)
+                    .setWalSegmentSize((int)(1 * MULTIPLICATOR))
+                    .setMaxWalArchiveSize(20 * MULTIPLICATOR)

Review Comment:
   20 * MB more clear than your proposal, i suppose.



;31/Jan/23 11:21;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1091799759


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ *
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    private static final long MULTIPLICATOR = U.MB;
+    private static final int MAX_SEGMENTS = 20;
+
+    private static final Map<String, List<Long>> report = new HashMap<>();
+
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    @Override protected void afterTestsStopped() throws Exception {
+        super.afterTestsStopped();
+
+        log().warning("">>> REPORT: "" + report.toString());
+    }
+
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        //for debug
+        LogExporterSpi exporterSpi = new LogExporterSpi();
+        exporterSpi.setPeriod(1000);
+        exporterSpi.setExportFilter(mgrp -> mgrp.name().startsWith(""io.datastorage""));
+
+        return super.getConfiguration(igniteInstanceName)
+            .setMetricExporterSpi(exporterSpi, new JmxMetricExporterSpi())
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalArchivePath(DFLT_WAL_PATH)
+                    .setWalSegments(10)
+                    .setWalSegmentSize((int)(1 * MULTIPLICATOR))
+                    .setMaxWalArchiveSize(20 * MULTIPLICATOR)

Review Comment:
   Ok, MULTIPLICATOR i use for debug, this is not the final PR, this is a PR for questions.
   1. Is this a good fix?
   2. Write a test that will check the correctness of the calculation of this metric?
   The current test is a reproducer.
   



;31/Jan/23 11:31;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1091799759


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ *
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    private static final long MULTIPLICATOR = U.MB;
+    private static final int MAX_SEGMENTS = 20;
+
+    private static final Map<String, List<Long>> report = new HashMap<>();
+
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    @Override protected void afterTestsStopped() throws Exception {
+        super.afterTestsStopped();
+
+        log().warning("">>> REPORT: "" + report.toString());
+    }
+
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        //for debug
+        LogExporterSpi exporterSpi = new LogExporterSpi();
+        exporterSpi.setPeriod(1000);
+        exporterSpi.setExportFilter(mgrp -> mgrp.name().startsWith(""io.datastorage""));
+
+        return super.getConfiguration(igniteInstanceName)
+            .setMetricExporterSpi(exporterSpi, new JmxMetricExporterSpi())
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalArchivePath(DFLT_WAL_PATH)
+                    .setWalSegments(10)
+                    .setWalSegmentSize((int)(1 * MULTIPLICATOR))
+                    .setMaxWalArchiveSize(20 * MULTIPLICATOR)

Review Comment:
   Ok, MULTIPLICATOR i use for debug, this is not the final PR, this is a PR for questions.
   1. Is this a good fix?
   2. Write a test that will check the correctness of the calculation of this metric?
   
   The current test is a reproducer.
   



;31/Jan/23 11:31;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118390913


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;
+
+    /**
+     * Тumber of segments.
+     */
+    private static final int MAX_SEGMENTS = 20;
+
+    /**
+     * Small report for debug.
+     */
+    private static final Map<String, List<Long>> report = new HashMap<>();
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void afterTestsStopped() throws Exception {
+        super.afterTestsStopped();
+
+        log().warning("">>> REPORT: "" + report.toString());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        //for debug
+        LogExporterSpi exporterSpi = new LogExporterSpi();
+        exporterSpi.setPeriod(1000);
+        exporterSpi.setExportFilter(mgrp -> mgrp.name().startsWith(""io.datastorage""));
+
+        return super.getConfiguration(igniteInstanceName)
+            .setMetricExporterSpi(exporterSpi, new JmxMetricExporterSpi())
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalArchivePath(DFLT_WAL_PATH)
+                    .setWalSegments(10)
+                    .setWalSegmentSize((int)(1 * MULTIPLICATOR))
+                    .setMaxWalArchiveSize(20 * MULTIPLICATOR)
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                            .setMaxSize(20 * MULTIPLICATOR)
+                            .setCheckpointPageBufferSize(2 * MULTIPLICATOR)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+     * After the tests are completed, you can see the report with grep by "">>> REPORT""
+     */
+    @Test
+    public void WalWritingRate() throws Exception {
+        IgniteEx ignite = startGrid(0);
+        ignite.cluster().state(ClusterState.ACTIVE);
+
+        AtomicLong key = new AtomicLong();
+        List<Long> walWritingRates = new ArrayList<>();
+
+        long lastSegment = walMgr(ignite).currentSegment() + MAX_SEGMENTS;
+        long prewSegment = walMgr(ignite).currentSegment();

Review Comment:
   typo: prew -> prev



;27/Feb/23 07:59;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118391385


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;
+
+    /**
+     * Тumber of segments.
+     */
+    private static final int MAX_SEGMENTS = 20;
+
+    /**
+     * Small report for debug.
+     */
+    private static final Map<String, List<Long>> report = new HashMap<>();
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void afterTestsStopped() throws Exception {
+        super.afterTestsStopped();
+
+        log().warning("">>> REPORT: "" + report.toString());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        //for debug
+        LogExporterSpi exporterSpi = new LogExporterSpi();

Review Comment:
   It seems we can remove this.



;27/Feb/23 08:00;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118392144


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;
+
+    /**
+     * Тumber of segments.
+     */
+    private static final int MAX_SEGMENTS = 20;
+
+    /**
+     * Small report for debug.
+     */
+    private static final Map<String, List<Long>> report = new HashMap<>();
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /**
+     * {@inheritDoc}

Review Comment:
   This should be one line comment like in other places.



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;
+
+    /**
+     * Тumber of segments.
+     */
+    private static final int MAX_SEGMENTS = 20;
+
+    /**
+     * Small report for debug.
+     */
+    private static final Map<String, List<Long>> report = new HashMap<>();
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void afterTestsStopped() throws Exception {
+        super.afterTestsStopped();
+
+        log().warning("">>> REPORT: "" + report.toString());
+    }
+
+    /**
+     * {@inheritDoc}

Review Comment:
   This should be one line comment like in other places.



;27/Feb/23 08:00;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118392328


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;
+
+    /**
+     * Тumber of segments.
+     */
+    private static final int MAX_SEGMENTS = 20;
+
+    /**
+     * Small report for debug.
+     */
+    private static final Map<String, List<Long>> report = new HashMap<>();

Review Comment:
   It seems this can be removed.



;27/Feb/23 08:01;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118393185


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(

Review Comment:
   Will it work without array? 
   ```
     return Arrays.asList(
               WALMode.FSYNC,
               WALMode.BACKGROUND},
               WALMode.LOG_ONLY
   ```



;27/Feb/23 08:02;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118393761


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;

Review Comment:
   You can use U.MB everywhere in the test without additional review.



;27/Feb/23 08:03;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118394336


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;
+
+    /**
+     * Тumber of segments.
+     */
+    private static final int MAX_SEGMENTS = 20;

Review Comment:
   Do we really need this much segements in the test? 



;27/Feb/23 08:03;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118403418


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;
+
+    /**
+     * Тumber of segments.
+     */
+    private static final int MAX_SEGMENTS = 20;
+
+    /**
+     * Small report for debug.
+     */
+    private static final Map<String, List<Long>> report = new HashMap<>();
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void afterTestsStopped() throws Exception {

Review Comment:
   this method can be removed.



;27/Feb/23 08:14;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118620641


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ *
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    private static final long MULTIPLICATOR = U.MB;
+    private static final int MAX_SEGMENTS = 20;
+
+    private static final Map<String, List<Long>> report = new HashMap<>();
+
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    @Override protected void afterTestsStopped() throws Exception {
+        super.afterTestsStopped();
+
+        log().warning("">>> REPORT: "" + report.toString());
+    }
+
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        //for debug
+        LogExporterSpi exporterSpi = new LogExporterSpi();
+        exporterSpi.setPeriod(1000);
+        exporterSpi.setExportFilter(mgrp -> mgrp.name().startsWith(""io.datastorage""));
+
+        return super.getConfiguration(igniteInstanceName)
+            .setMetricExporterSpi(exporterSpi, new JmxMetricExporterSpi())
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalArchivePath(DFLT_WAL_PATH)
+                    .setWalSegments(10)
+                    .setWalSegmentSize((int)(1 * MULTIPLICATOR))
+                    .setMaxWalArchiveSize(20 * MULTIPLICATOR)

Review Comment:
   done



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;
+
+    /**
+     * Тumber of segments.
+     */
+    private static final int MAX_SEGMENTS = 20;
+
+    /**
+     * Small report for debug.
+     */
+    private static final Map<String, List<Long>> report = new HashMap<>();
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void afterTestsStopped() throws Exception {
+        super.afterTestsStopped();
+
+        log().warning("">>> REPORT: "" + report.toString());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        //for debug
+        LogExporterSpi exporterSpi = new LogExporterSpi();
+        exporterSpi.setPeriod(1000);
+        exporterSpi.setExportFilter(mgrp -> mgrp.name().startsWith(""io.datastorage""));
+
+        return super.getConfiguration(igniteInstanceName)
+            .setMetricExporterSpi(exporterSpi, new JmxMetricExporterSpi())
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalArchivePath(DFLT_WAL_PATH)
+                    .setWalSegments(10)
+                    .setWalSegmentSize((int)(1 * MULTIPLICATOR))
+                    .setMaxWalArchiveSize(20 * MULTIPLICATOR)
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                            .setMaxSize(20 * MULTIPLICATOR)
+                            .setCheckpointPageBufferSize(2 * MULTIPLICATOR)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+     * After the tests are completed, you can see the report with grep by "">>> REPORT""
+     */
+    @Test
+    public void WalWritingRate() throws Exception {
+        IgniteEx ignite = startGrid(0);
+        ignite.cluster().state(ClusterState.ACTIVE);
+
+        AtomicLong key = new AtomicLong();
+        List<Long> walWritingRates = new ArrayList<>();
+
+        long lastSegment = walMgr(ignite).currentSegment() + MAX_SEGMENTS;
+        long prewSegment = walMgr(ignite).currentSegment();

Review Comment:
   done 0_o



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;
+
+    /**
+     * Тumber of segments.
+     */
+    private static final int MAX_SEGMENTS = 20;
+
+    /**
+     * Small report for debug.
+     */
+    private static final Map<String, List<Long>> report = new HashMap<>();
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void afterTestsStopped() throws Exception {
+        super.afterTestsStopped();
+
+        log().warning("">>> REPORT: "" + report.toString());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        //for debug
+        LogExporterSpi exporterSpi = new LogExporterSpi();

Review Comment:
   done



;27/Feb/23 11:33;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118620845


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;
+
+    /**
+     * Тumber of segments.
+     */
+    private static final int MAX_SEGMENTS = 20;
+
+    /**
+     * Small report for debug.
+     */
+    private static final Map<String, List<Long>> report = new HashMap<>();
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /**
+     * {@inheritDoc}

Review Comment:
   done



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;
+
+    /**
+     * Тumber of segments.
+     */
+    private static final int MAX_SEGMENTS = 20;
+
+    /**
+     * Small report for debug.
+     */
+    private static final Map<String, List<Long>> report = new HashMap<>();
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void afterTestsStopped() throws Exception {
+        super.afterTestsStopped();
+
+        log().warning("">>> REPORT: "" + report.toString());
+    }
+
+    /**
+     * {@inheritDoc}

Review Comment:
   done



;27/Feb/23 11:34;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118621125


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;
+
+    /**
+     * Тumber of segments.
+     */
+    private static final int MAX_SEGMENTS = 20;
+
+    /**
+     * Small report for debug.
+     */
+    private static final Map<String, List<Long>> report = new HashMap<>();

Review Comment:
   done



;27/Feb/23 11:34;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118621643


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;

Review Comment:
   deleted it



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;
+
+    /**
+     * Тumber of segments.
+     */
+    private static final int MAX_SEGMENTS = 20;
+
+    /**
+     * Small report for debug.
+     */
+    private static final Map<String, List<Long>> report = new HashMap<>();
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override protected void afterTestsStopped() throws Exception {

Review Comment:
   done



;27/Feb/23 11:35;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118628740


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;
+
+    /**
+     * Тumber of segments.
+     */
+    private static final int MAX_SEGMENTS = 20;

Review Comment:
   In the test, the value of the metric is taken after the segment is filled.
   Decreased to 1 to speed up test execution.
   It seemed more correct to get the value of the meter by filling the segment than by reaching some time, for example, 1 second after the start of recording.



;27/Feb/23 11:42;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118636811


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(

Review Comment:
   done



;27/Feb/23 11:51;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118636811


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(

Review Comment:
   yes, fixed



;27/Feb/23 11:51;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1118628740


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.spi.metric.jmx.JmxMetricExporterSpi;
+import org.apache.ignite.spi.metric.log.LogExporterSpi;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ * After the tests are completed, you can see the report with grep by "">>> REPORT""
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object[]> parameters() {
+        return Arrays.asList(
+            new Object[] {WALMode.FSYNC},
+            new Object[] {WALMode.BACKGROUND},
+            new Object[] {WALMode.LOG_ONLY}
+        );
+    }
+
+    /**
+     * MULTIPLICATOR.
+     */
+    private static final long MULTIPLICATOR = U.MB;
+
+    /**
+     * Тumber of segments.
+     */
+    private static final int MAX_SEGMENTS = 20;

Review Comment:
   In the test, the value of the metric is taken after the segment is filled.
   Decreased to 1 to speed up test execution.
   It seemed more correct to get the value  of the metric by filling the segment than by reaching some time, for example, 1 second after the start of recording.



;27/Feb/23 11:55;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1119664098


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalArchivePath(DFLT_WAL_PATH)
+                    .setWalSegmentSize(1 * 1024 * 1024)

Review Comment:
   1 * 1024 * 1024 -> U.MB



;28/Feb/23 07:28;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1119664434


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))

Review Comment:
   This can be removed and replaced with `ignite.getOrCreateCache`



;28/Feb/23 07:29;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1119666759


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalArchivePath(DFLT_WAL_PATH)
+                    .setWalSegmentSize(1 * 1024 * 1024)
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+     * After the tests are completed, you can see the report with grep by "">>> REPORT""
+     */
+    @Test
+    public void WalWritingRate() throws Exception {
+        IgniteEx ignite = startGrid(0);
+        ignite.cluster().state(ClusterState.ACTIVE);
+
+        AtomicLong key = new AtomicLong();
+        List<Long> walWritingRates = new ArrayList<>();
+
+        long lastSegment = walMgr(ignite).currentSegment() + 1;

Review Comment:
   Let's extract `walMgr(ignite)` into variable.



;28/Feb/23 07:32;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1119674680


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalArchivePath(DFLT_WAL_PATH)
+                    .setWalSegmentSize(1 * 1024 * 1024)
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+     * After the tests are completed, you can see the report with grep by "">>> REPORT""
+     */
+    @Test
+    public void WalWritingRate() throws Exception {
+        IgniteEx ignite = startGrid(0);
+        ignite.cluster().state(ClusterState.ACTIVE);
+
+        AtomicLong key = new AtomicLong();
+        List<Long> walWritingRates = new ArrayList<>();
+
+        long lastSegment = walMgr(ignite).currentSegment() + 1;

Review Comment:
   It seems we don't need to care about segments here.
   Le'ts just do the following:
   
   ```
   long k = 0;
   for (; k<100; k++) {
       long[] arr = new long[64];
       Arrays.fill(arr, k);
   
       ignite.getOrCreateCache(DEFAULT_CACHE_NAME).put(key, arr);
   
       Long writingRate =  metricRegistry(ignite.name(), ""io"", ""datastorage"").getAttribute(""WalWritingRate"");
       if (writingRate != null && writingRate > 0)
           break;
   }
   
   assertTrue(k < 100);
   ```



;28/Feb/23 07:42;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1119675036


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalArchivePath(DFLT_WAL_PATH)

Review Comment:
   Do we really need `WalArchivePath` for this test?



;28/Feb/23 07:42;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1119675390


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.

Review Comment:
   This can be oneline comment.



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.

Review Comment:
   This can be oneline comment.



;28/Feb/23 07:42;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1119675942


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).

Review Comment:
   Test checks that `WalWritingRate` metric updated in all WAL modes.



;28/Feb/23 07:43;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1119676505


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();

Review Comment:
   Cleaning must be done after test.



;28/Feb/23 07:44;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1120013445


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalArchivePath(DFLT_WAL_PATH)
+                    .setWalSegmentSize(1 * 1024 * 1024)

Review Comment:
   done



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))

Review Comment:
   done



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalArchivePath(DFLT_WAL_PATH)
+                    .setWalSegmentSize(1 * 1024 * 1024)
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+     * After the tests are completed, you can see the report with grep by "">>> REPORT""
+     */
+    @Test
+    public void WalWritingRate() throws Exception {
+        IgniteEx ignite = startGrid(0);
+        ignite.cluster().state(ClusterState.ACTIVE);
+
+        AtomicLong key = new AtomicLong();
+        List<Long> walWritingRates = new ArrayList<>();
+
+        long lastSegment = walMgr(ignite).currentSegment() + 1;

Review Comment:
   deleted it



;28/Feb/23 12:50;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1120015437


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalArchivePath(DFLT_WAL_PATH)
+                    .setWalSegmentSize(1 * 1024 * 1024)
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+     * After the tests are completed, you can see the report with grep by "">>> REPORT""
+     */
+    @Test
+    public void WalWritingRate() throws Exception {
+        IgniteEx ignite = startGrid(0);
+        ignite.cluster().state(ClusterState.ACTIVE);
+
+        AtomicLong key = new AtomicLong();
+        List<Long> walWritingRates = new ArrayList<>();
+
+        long lastSegment = walMgr(ignite).currentSegment() + 1;

Review Comment:
   done



;28/Feb/23 12:51;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1120015509


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.Arrays;
+import java.util.Collection;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /** WALMode. */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /** WALMode values. */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() throws Exception {
+        super.afterTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalSegmentSize((int)(U.MB))
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+     */
+    @Test
+    public void WalWritingRate() throws Exception {

Review Comment:
   Please, rename `WalWritingRate` to `testWalWritingRate` or `walWritingRate`.



;28/Feb/23 12:51;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1120015862


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setCacheConfiguration(new CacheConfiguration<>(DEFAULT_CACHE_NAME))
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalArchivePath(DFLT_WAL_PATH)

Review Comment:
   no, deleted



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.

Review Comment:
   done



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.

Review Comment:
   done



;28/Feb/23 12:51;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1120016322


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).

Review Comment:
   done



;28/Feb/23 12:51;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1120016608


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.stream.Collectors;
+import javax.management.DynamicMBean;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.apache.ignite.configuration.DataStorageConfiguration.DFLT_WAL_PATH;
+import static org.junit.Assert.assertNotEquals;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode is in (LOG_ONLY, BACKGROUND).
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /**
+     * WALMode.
+     */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /**
+     * WALMode values.
+     */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();

Review Comment:
   done



;28/Feb/23 12:51;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1120019564


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.Arrays;
+import java.util.Collection;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /** WALMode. */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /** WALMode values. */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() throws Exception {
+        super.afterTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalSegmentSize((int)(U.MB))
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+     */
+    @Test
+    public void WalWritingRate() throws Exception {

Review Comment:
   done



;28/Feb/23 12:54;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1120021818


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.Arrays;
+import java.util.Collection;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /** WALMode. */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /** WALMode values. */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() throws Exception {
+        super.afterTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalSegmentSize((int)(U.MB))
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+     */
+    @Test
+    public void walWritingRate() throws Exception {
+        IgniteEx ignite = startGrid(0);

Review Comment:
   Empty line after this required.



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.Arrays;
+import java.util.Collection;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /** WALMode. */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /** WALMode values. */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() throws Exception {
+        super.afterTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalSegmentSize((int)(U.MB))
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+     */
+    @Test
+    public void walWritingRate() throws Exception {
+        IgniteEx ignite = startGrid(0);
+        ignite.cluster().state(ClusterState.ACTIVE);
+
+        long writingRate = 0;

Review Comment:
   Empty line after this required.



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.Arrays;
+import java.util.Collection;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /** WALMode. */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /** WALMode values. */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() throws Exception {
+        super.afterTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalSegmentSize((int)(U.MB))
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+     */
+    @Test
+    public void walWritingRate() throws Exception {
+        IgniteEx ignite = startGrid(0);
+        ignite.cluster().state(ClusterState.ACTIVE);
+
+        long writingRate = 0;
+        byte i = 0;
+        for (; i<100; i++) {
+            long[] arr = new long[64];

Review Comment:
   Empty line after this required.



;28/Feb/23 12:56;githubbot;600","nizhikov commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1120022065


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.Arrays;
+import java.util.Collection;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /** WALMode. */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /** WALMode values. */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() throws Exception {
+        super.afterTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalSegmentSize((int)(U.MB))
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+     */
+    @Test
+    public void walWritingRate() throws Exception {
+        IgniteEx ignite = startGrid(0);
+        ignite.cluster().state(ClusterState.ACTIVE);
+
+        long writingRate = 0;
+        byte i = 0;
+        for (; i<100; i++) {
+            long[] arr = new long[64];
+            Arrays.fill(arr, i);
+
+            ignite.getOrCreateCache(DEFAULT_CACHE_NAME).put(i, arr);
+
+            writingRate =  (long)metricRegistry(ignite.name(), ""io"", ""datastorage"").getAttribute(""WalWritingRate"");

Review Comment:
   Empty line after this required.



;28/Feb/23 12:57;githubbot;600","luchnikovbsk commented on code in PR #10508:
URL: https://github.com/apache/ignite/pull/10508#discussion_r1120028321


##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.Arrays;
+import java.util.Collection;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /** WALMode. */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /** WALMode values. */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() throws Exception {
+        super.afterTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalSegmentSize((int)(U.MB))
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+     */
+    @Test
+    public void walWritingRate() throws Exception {
+        IgniteEx ignite = startGrid(0);

Review Comment:
   done



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.Arrays;
+import java.util.Collection;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /** WALMode. */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /** WALMode values. */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() throws Exception {
+        super.afterTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalSegmentSize((int)(U.MB))
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+     */
+    @Test
+    public void walWritingRate() throws Exception {
+        IgniteEx ignite = startGrid(0);
+        ignite.cluster().state(ClusterState.ACTIVE);
+
+        long writingRate = 0;

Review Comment:
   done



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.Arrays;
+import java.util.Collection;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /** WALMode. */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /** WALMode values. */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() throws Exception {
+        super.afterTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalSegmentSize((int)(U.MB))
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+     */
+    @Test
+    public void walWritingRate() throws Exception {
+        IgniteEx ignite = startGrid(0);
+        ignite.cluster().state(ClusterState.ACTIVE);
+
+        long writingRate = 0;
+        byte i = 0;
+        for (; i<100; i++) {
+            long[] arr = new long[64];

Review Comment:
   done



##########
modules/core/src/test/java/org/apache/ignite/internal/processors/cache/IoDatastorageMetricsTest.java:
##########
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache;
+
+import java.util.Arrays;
+import java.util.Collection;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.configuration.WALMode;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.util.typedef.internal.U;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+/**
+ * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+ */
+@RunWith(Parameterized.class)
+public class IoDatastorageMetricsTest extends GridCommonAbstractTest {
+
+    /** WALMode. */
+    @Parameterized.Parameter
+    public WALMode walMode;
+
+    /** WALMode values. */
+    @Parameterized.Parameters(name = ""walMode={0}"")
+    public static Collection<Object> parameters() {
+        return Arrays.asList(
+            WALMode.FSYNC,
+            WALMode.BACKGROUND,
+            WALMode.LOG_ONLY
+        );
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() throws Exception {
+        super.afterTest();
+
+        stopAllGrids();
+        cleanPersistenceDir();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setDataStorageConfiguration(
+                new DataStorageConfiguration()
+                    .setMetricsEnabled(true)
+                    .setWalSegmentSize((int)(U.MB))
+                    .setWalMode(walMode)
+                    .setDefaultDataRegionConfiguration(
+                        new DataRegionConfiguration()
+                            .setPersistenceEnabled(true)
+                    )
+            );
+    }
+
+    /**
+     * The test shows that the WalWritingRate metric is not calculated when walMode in all modes.
+     */
+    @Test
+    public void walWritingRate() throws Exception {
+        IgniteEx ignite = startGrid(0);
+        ignite.cluster().state(ClusterState.ACTIVE);
+
+        long writingRate = 0;
+        byte i = 0;
+        for (; i<100; i++) {
+            long[] arr = new long[64];
+            Arrays.fill(arr, i);
+
+            ignite.getOrCreateCache(DEFAULT_CACHE_NAME).put(i, arr);
+
+            writingRate =  (long)metricRegistry(ignite.name(), ""io"", ""datastorage"").getAttribute(""WalWritingRate"");

Review Comment:
   done



;28/Feb/23 13:02;githubbot;600","nizhikov merged PR #10508:
URL: https://github.com/apache/ignite/pull/10508


;01/Mar/23 07:13;githubbot;600",,,,,,,,0,23400,,,0,23400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"12/Jan/23 08:11;AldoRaine;IoDatastorageMetricsTest.java;https://issues.apache.org/jira/secure/attachment/13054537/IoDatastorageMetricsTest.java","12/Jan/23 08:29;AldoRaine;patch.patch;https://issues.apache.org/jira/secure/attachment/13054543/patch.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Release Notes Required,,,,Tue Feb 28 18:28:34 UTC 2023,,,,,,,,,,"0|z1eqxc:",9223372036854775807,Fixed WalWritingRate metric for LOG_ONLY and BACKGROUND modes,,,,,,,,,,,,,,,,,,,,"01/Feb/23 12:22;AldoRaine;Results of reproducer before fix
{code:java}
[WARN ][main][] >>> REPORT: {walMode=LOG_ONLY=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], walMode=FSYNC=[1049108, 2098258, 3145859, 4194373, 5243456, 6291815, 7339121, 8388446, 9436414, 10484015, 11532977, 12581012, 13629532, 14681087, 15726022, 16773290, 17822132, 18871023, 19918624, 20967597], walMode=BACKGROUND=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{code}
after fix
{code:java}
[WARN ][main][] >>> REPORT: {walMode=LOG_ONLY=[1049506, 2096889, 3144710, 4194337, 5242085, 6289895, 7339524, 8387920, 9435820, 10483503, 11532449, 12580499, 13628020, 14676257, 15724492, 16772470, 17820948, 18868506, 19914180, 20961781], walMode=FSYNC=[1049563, 2096946, 3144826, 4193340, 5242378, 6290782, 7339017, 8387531, 9435499, 10488430, 11531195, 12580086, 13627675, 14675985, 15724801, 16772772, 17821276, 18869238, 19918129, 20971125], walMode=BACKGROUND=[1049565, 2097066, 3144887, 4194514, 5242262, 6290993, 7339346, 8386745, 9435701, 10483384, 11531866, 12579549, 13632820, 14675929, 15723864, 16772386, 17821417, 18870092, 19917693, 20966584]}
{code}
in a table view

 
||LOG_ONLY||LOG_ONLY+fix||FSYNC||FSYNC+fix||BACKGROUND||BACKGROUND+fix||
|0|1049506|1049108|1049563|0|1049565|
|0|2096889|2098258|2096946|0|2097066|
|0|3144710|3145859|3144826|0|3144887|
|0|4194337|4194373|4193340|0|4194514|
|0|5242085|5243456|5242378|0|5242262|
|0|6289895|6291815|6290782|0|6290993|
|0|7339524|7339121|7339017|0|7339346|
|0|8387920|8388446|8387531|0|8386745|
|0|9435820|9436414|9435499|0|9435701|
|0|10483503|10484015|10488430|0|10483384|
|0|11532449|11532977|11531195|0|11531866|
|0|12580499|12581012|12580086|0|12579549|
|0|13628020|13629532|13627675|0|13632820|
|0|14676257|14681087|14675985|0|14675929|
|0|15724492|15726022|15724801|0|15723864|
|0|16772470|16773290|16772772|0|16772386|
|0|17820948|17822132|17821276|0|17821417|
|0|18868506|18871023|18869238|0|18870092|
|0|19914180|19918624|19918129|0|19917693|
|0|20961781|20967597|20971125|0|20966584|

 

 ;;;","01/Feb/23 12:35;AldoRaine;[~zstan] could you please take a look?;;;","01/Feb/23 15:30;zstan;[~AldoRaine] i take a look, if you form test correctly i will check it. What the purpose to check not completed issue ?;;;","27/Feb/23 17:29;ignitetcbot;{panel:title=Branch: [pull/10508/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10508/head] Base: [master] : New Tests (3)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Cache 8{color} [[tests 3|https://ci2.ignite.apache.org/viewLog.html?buildId=7068237]]
* {color:#013220}IgniteCacheTestSuite8: IoDatastorageMetricsTest.WalWritingRate[walMode=LOG_ONLY] - PASSED{color}
* {color:#013220}IgniteCacheTestSuite8: IoDatastorageMetricsTest.WalWritingRate[walMode=BACKGROUND] - PASSED{color}
* {color:#013220}IgniteCacheTestSuite8: IoDatastorageMetricsTest.WalWritingRate[walMode=FSYNC] - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7068333&amp;buildTypeId=IgniteTests24Java8_RunAll];;;","28/Feb/23 18:28;ignitetcbot;{panel:title=Branch: [pull/10508/head] Base: [master] : No blockers found!|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}{panel}
{panel:title=Branch: [pull/10508/head] Base: [master] : New Tests (3)|borderStyle=dashed|borderColor=#ccc|titleBGColor=#D6F7C1}
{color:#00008b}Cache 8{color} [[tests 3|https://ci2.ignite.apache.org/viewLog.html?buildId=7069979]]
* {color:#013220}IgniteCacheTestSuite8: IoDatastorageMetricsTest.walWritingRate[walMode=BACKGROUND] - PASSED{color}
* {color:#013220}IgniteCacheTestSuite8: IoDatastorageMetricsTest.walWritingRate[walMode=FSYNC] - PASSED{color}
* {color:#013220}IgniteCacheTestSuite8: IoDatastorageMetricsTest.walWritingRate[walMode=LOG_ONLY] - PASSED{color}

{panel}
[TeamCity *--&gt; Run :: All* Results|https://ci2.ignite.apache.org/viewLog.html?buildId=7070075&amp;buildTypeId=IgniteTests24Java8_RunAll];;;",
IndexOutOfBoundsException in KafkaToIgniteCdcStreamer,IGNITE-18532,13517617,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,timonin.maksim,KB_Open,KB_Open,11/Jan/23 13:12,12/Apr/23 16:18,13/Jul/23 09:11,12/Apr/23 16:17,2.14,,,,,,,2.16,extensions,,,0,ise,,,"If the applier threads for some reason, then whiling joining the runner threads, join is waiting  for extra thread which actually does not exist.
{code:java}
class org.apache.ignite.IgniteException: Index 8 out of bounds for length 8
2	at org.apache.ignite.cdc.kafka.AbstractKafkaToIgniteCdcStreamer.run(AbstractKafkaToIgniteCdcStreamer.java:128)
3	at org.apache.ignite.cdc.kafka.KafkaToIgniteCdcStreamer.run(KafkaToIgniteCdcStreamer.java:71)
4	at org.apache.ignite.cdc.kafka.KafkaToIgniteCommandLineStartup.main(KafkaToIgniteCommandLineStartup.java:68)
5Caused by: java.lang.IndexOutOfBoundsException: Index 8 out of bounds for length 8
6	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:64)
7	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:70)
8	at java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:248)
9	at java.base/java.util.Objects.checkIndex(Objects.java:372)
10	at java.base/java.util.ArrayList.get(ArrayList.java:459)
11	at org.apache.ignite.cdc.kafka.AbstractKafkaToIgniteCdcStreamer.runAppliers(AbstractKafkaToIgniteCdcStreamer.java:184)
12	at org.apache.ignite.cdc.kafka.KafkaToIgniteCdcStreamer.runx(KafkaToIgniteCdcStreamer.java:110)
13	at org.apache.ignite.cdc.kafka.AbstractKafkaToIgniteCdcStreamer.run(AbstractKafkaToIgniteCdcStreamer.java:125)
14	... 2 more {code}
Problematic code is
{code:java}
try { 
      for (int i = 0; i < threadCnt + 1; i++) 
          runners.get(i).join(); 
}
{code}
runners is as array list of threads whose size is configured to specified number of threadCount.

{{runners = new ArrayList<>(streamerCfg.getThreadCount());}}

In our yaml {{threadCount: 8}}

If this is the case, then in above code, while joining threads why are we iterating for 9 threads ({{{}threadCnt + 1{}}} = 8 +1)

As a solution we need to iterate over runners with condition {{i < threadCnt}} and not {{i < threadCnt + 1}}",,KB_Open,timonin.maksim,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Apr 12 16:17:59 UTC 2023,,,,,,,,,,"0|z1eq1c:",9223372036854775807,,,NSAmelchev,,,,,,,,,,,,,,,,,,"12/Apr/23 16:17;timonin.maksim;[~KB_Open] thanks for finding that!

[~NSAmelchev] thanks for review.

Merged to master

TC successful build: https://ci2.ignite.apache.org/buildConfiguration/IgniteExtensions_Tests_Cdc/7134958;;;",,,,,
Integration test failures on Windows,IGNITE-18530,13517584,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,vpakhnushev,vpakhnushev,vpakhnushev,11/Jan/23 10:02,13/Feb/23 14:35,13/Jul/23 09:11,12/Jan/23 07:45,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Some of the runner integration tests fail on Windows due to the hardcoded ""\n"" conversion when parsing the SQL query results. The tests are ItProjectScanMergeRuleTest, ItJoinTest and ItAggregatesTest.",,ptupitsyn,vpakhnushev,,,,"valepakh opened a new pull request, #1512:
URL: https://github.com/apache/ignite-3/pull/1512

   https://issues.apache.org/jira/browse/IGNITE-18530


;11/Jan/23 10:04;githubbot;600","ptupitsyn merged PR #1512:
URL: https://github.com/apache/ignite-3/pull/1512


;12/Jan/23 07:44;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17601,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jan 12 07:44:52 UTC 2023,,,,,,,,,,"0|z1epu0:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"12/Jan/23 07:44;ptupitsyn;Merged to main: 5272ba8177faef35efef243ccb197279e941f11a;;;",,,,,
Sql. Query hangs if exception is thrown in mapping phase,IGNITE-18521,13517466,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,xtern,korlov,korlov,10/Jan/23 15:46,31/Jan/23 17:43,13/Jul/23 09:11,31/Jan/23 17:43,,,,,,,,3.0.0-beta2,sql,,,0,ignite-3,,,"Look at the closure passed to {{taskExecutor}} at the beginning of {{org.apache.ignite.internal.sql.engine.exec.ExecutionServiceImpl.DistributedQueryManager#execute}}. Any exception thrown before the try-catch block will cause the root fragment not to be initialized and, as a consequence, the query will hang forever.

Let's add the proper exception handling to this place.",,korlov,xtern,,,,"korlov42 commented on code in PR #1581:
URL: https://github.com/apache/ignite-3/pull/1581#discussion_r1088703959


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -576,36 +572,48 @@ private void submitFragment(String initiatorNode, String fragmentString, Fragmen
 
         private AsyncCursor<List<Object>> execute(MultiStepPlan plan) {
             taskExecutor.execute(() -> {
-                plan.init(mappingSrvc, new MappingQueryContext(localNode.name()));
+                try {
+                    plan.init(mappingSrvc, new MappingQueryContext(localNode.name()));
 
-                List<Fragment> fragments = plan.fragments();
+                    List<Fragment> fragments = plan.fragments();
 
-                // we rely on the fact that the very first fragment is a root. Otherwise we need to handle
-                // the case when a non-root fragment will fail before the root is processed.
-                assert !nullOrEmpty(fragments) && fragments.get(0).rootFragment() : fragments;
+                    // we rely on the fact that the very first fragment is a root. Otherwise we need to handle
+                    // the case when a non-root fragment will fail before the root is processed.
+                    assert !nullOrEmpty(fragments) && fragments.get(0).rootFragment() : fragments;
 
-                // start remote execution
-                try {
+                    // start remote execution
                     for (Fragment fragment : fragments) {
-                        if (fragment.rootFragment()) {
-                            assert rootFragmentId == null;
+                        try {
+                            if (fragment.rootFragment()) {
+                                assert rootFragmentId == null;
 
-                            rootFragmentId = fragment.fragmentId();
-                        }
+                                rootFragmentId = fragment.fragmentId();
+                            }
 
-                        FragmentDescription fragmentDesc = new FragmentDescription(
-                                fragment.fragmentId(),
-                                plan.mapping(fragment),
-                                plan.target(fragment),
-                                plan.remotes(fragment)
-                        );
+                            FragmentDescription fragmentDesc = new FragmentDescription(
+                                    fragment.fragmentId(),
+                                    plan.mapping(fragment),
+                                    plan.target(fragment),
+                                    plan.remotes(fragment)
+                            );
+
+                            for (String nodeName : fragmentDesc.nodeNames()) {
+                                sendFragment(nodeName, fragment, fragmentDesc);
+                            }
+                        } catch (Throwable t0) {
+                            if (fragment.rootFragment()) {
+                                throw t0;
+                            }
+
+                            root.thenAccept(exec -> exec.onError(t0));
 
-                        for (String nodeName : fragmentDesc.nodeNames()) {
-                            sendFragment(nodeName, fragment, fragmentDesc);
+                            break;
                         }
                     }
-                } catch (Throwable e) {
-                    root.thenAccept(root -> root.onError(e));
+                } catch (Throwable t) {
+                    LOG.error(""An error occurred while executing the query."", t);

Review Comment:
   we should not use ERROR severity here. PLease take a look at [this](https://cwiki.apache.org/confluence/display/IGNITE/Java+Logging+Guidelines#JavaLoggingGuidelines-ERROR) guidelines



;27/Jan/23 08:41;githubbot;600","korlov42 commented on code in PR #1581:
URL: https://github.com/apache/ignite-3/pull/1581#discussion_r1088707122


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -576,36 +572,48 @@ private void submitFragment(String initiatorNode, String fragmentString, Fragmen
 
         private AsyncCursor<List<Object>> execute(MultiStepPlan plan) {
             taskExecutor.execute(() -> {
-                plan.init(mappingSrvc, new MappingQueryContext(localNode.name()));
+                try {
+                    plan.init(mappingSrvc, new MappingQueryContext(localNode.name()));
 
-                List<Fragment> fragments = plan.fragments();
+                    List<Fragment> fragments = plan.fragments();
 
-                // we rely on the fact that the very first fragment is a root. Otherwise we need to handle
-                // the case when a non-root fragment will fail before the root is processed.
-                assert !nullOrEmpty(fragments) && fragments.get(0).rootFragment() : fragments;
+                    // we rely on the fact that the very first fragment is a root. Otherwise we need to handle
+                    // the case when a non-root fragment will fail before the root is processed.
+                    assert !nullOrEmpty(fragments) && fragments.get(0).rootFragment() : fragments;
 
-                // start remote execution
-                try {
+                    // start remote execution
                     for (Fragment fragment : fragments) {
-                        if (fragment.rootFragment()) {
-                            assert rootFragmentId == null;
+                        try {
+                            if (fragment.rootFragment()) {
+                                assert rootFragmentId == null;
 
-                            rootFragmentId = fragment.fragmentId();
-                        }
+                                rootFragmentId = fragment.fragmentId();
+                            }
 
-                        FragmentDescription fragmentDesc = new FragmentDescription(
-                                fragment.fragmentId(),
-                                plan.mapping(fragment),
-                                plan.target(fragment),
-                                plan.remotes(fragment)
-                        );
+                            FragmentDescription fragmentDesc = new FragmentDescription(
+                                    fragment.fragmentId(),
+                                    plan.mapping(fragment),
+                                    plan.target(fragment),
+                                    plan.remotes(fragment)
+                            );
+
+                            for (String nodeName : fragmentDesc.nodeNames()) {
+                                sendFragment(nodeName, fragment, fragmentDesc);
+                            }
+                        } catch (Throwable t0) {
+                            if (fragment.rootFragment()) {
+                                throw t0;
+                            }
+
+                            root.thenAccept(exec -> exec.onError(t0));
 
-                        for (String nodeName : fragmentDesc.nodeNames()) {
-                            sendFragment(nodeName, fragment, fragmentDesc);
+                            break;
                         }
                     }
-                } catch (Throwable e) {
-                    root.thenAccept(root -> root.onError(e));
+                } catch (Throwable t) {
+                    LOG.error(""An error occurred while executing the query."", t);
+
+                    root.completeExceptionally(t);

Review Comment:
   what if `root` has been already completed at this point?



;27/Jan/23 08:45;githubbot;600","xtern commented on code in PR #1581:
URL: https://github.com/apache/ignite-3/pull/1581#discussion_r1089045553


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -576,36 +572,48 @@ private void submitFragment(String initiatorNode, String fragmentString, Fragmen
 
         private AsyncCursor<List<Object>> execute(MultiStepPlan plan) {
             taskExecutor.execute(() -> {
-                plan.init(mappingSrvc, new MappingQueryContext(localNode.name()));
+                try {
+                    plan.init(mappingSrvc, new MappingQueryContext(localNode.name()));
 
-                List<Fragment> fragments = plan.fragments();
+                    List<Fragment> fragments = plan.fragments();
 
-                // we rely on the fact that the very first fragment is a root. Otherwise we need to handle
-                // the case when a non-root fragment will fail before the root is processed.
-                assert !nullOrEmpty(fragments) && fragments.get(0).rootFragment() : fragments;
+                    // we rely on the fact that the very first fragment is a root. Otherwise we need to handle
+                    // the case when a non-root fragment will fail before the root is processed.
+                    assert !nullOrEmpty(fragments) && fragments.get(0).rootFragment() : fragments;
 
-                // start remote execution
-                try {
+                    // start remote execution
                     for (Fragment fragment : fragments) {
-                        if (fragment.rootFragment()) {
-                            assert rootFragmentId == null;
+                        try {
+                            if (fragment.rootFragment()) {
+                                assert rootFragmentId == null;
 
-                            rootFragmentId = fragment.fragmentId();
-                        }
+                                rootFragmentId = fragment.fragmentId();
+                            }
 
-                        FragmentDescription fragmentDesc = new FragmentDescription(
-                                fragment.fragmentId(),
-                                plan.mapping(fragment),
-                                plan.target(fragment),
-                                plan.remotes(fragment)
-                        );
+                            FragmentDescription fragmentDesc = new FragmentDescription(
+                                    fragment.fragmentId(),
+                                    plan.mapping(fragment),
+                                    plan.target(fragment),
+                                    plan.remotes(fragment)
+                            );
+
+                            for (String nodeName : fragmentDesc.nodeNames()) {
+                                sendFragment(nodeName, fragment, fragmentDesc);
+                            }
+                        } catch (Throwable t0) {
+                            if (fragment.rootFragment()) {
+                                throw t0;
+                            }
+
+                            root.thenAccept(exec -> exec.onError(t0));
 
-                        for (String nodeName : fragmentDesc.nodeNames()) {
-                            sendFragment(nodeName, fragment, fragmentDesc);
+                            break;
                         }
                     }
-                } catch (Throwable e) {
-                    root.thenAccept(root -> root.onError(e));
+                } catch (Throwable t) {
+                    LOG.error(""An error occurred while executing the query."", t);

Review Comment:
   thanks, additional logging removed



;27/Jan/23 14:48;githubbot;600","xtern commented on code in PR #1581:
URL: https://github.com/apache/ignite-3/pull/1581#discussion_r1089053233


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImpl.java:
##########
@@ -576,36 +572,48 @@ private void submitFragment(String initiatorNode, String fragmentString, Fragmen
 
         private AsyncCursor<List<Object>> execute(MultiStepPlan plan) {
             taskExecutor.execute(() -> {
-                plan.init(mappingSrvc, new MappingQueryContext(localNode.name()));
+                try {
+                    plan.init(mappingSrvc, new MappingQueryContext(localNode.name()));
 
-                List<Fragment> fragments = plan.fragments();
+                    List<Fragment> fragments = plan.fragments();
 
-                // we rely on the fact that the very first fragment is a root. Otherwise we need to handle
-                // the case when a non-root fragment will fail before the root is processed.
-                assert !nullOrEmpty(fragments) && fragments.get(0).rootFragment() : fragments;
+                    // we rely on the fact that the very first fragment is a root. Otherwise we need to handle
+                    // the case when a non-root fragment will fail before the root is processed.
+                    assert !nullOrEmpty(fragments) && fragments.get(0).rootFragment() : fragments;
 
-                // start remote execution
-                try {
+                    // start remote execution
                     for (Fragment fragment : fragments) {
-                        if (fragment.rootFragment()) {
-                            assert rootFragmentId == null;
+                        try {
+                            if (fragment.rootFragment()) {
+                                assert rootFragmentId == null;
 
-                            rootFragmentId = fragment.fragmentId();
-                        }
+                                rootFragmentId = fragment.fragmentId();
+                            }
 
-                        FragmentDescription fragmentDesc = new FragmentDescription(
-                                fragment.fragmentId(),
-                                plan.mapping(fragment),
-                                plan.target(fragment),
-                                plan.remotes(fragment)
-                        );
+                            FragmentDescription fragmentDesc = new FragmentDescription(
+                                    fragment.fragmentId(),
+                                    plan.mapping(fragment),
+                                    plan.target(fragment),
+                                    plan.remotes(fragment)
+                            );
+
+                            for (String nodeName : fragmentDesc.nodeNames()) {
+                                sendFragment(nodeName, fragment, fragmentDesc);
+                            }
+                        } catch (Throwable t0) {
+                            if (fragment.rootFragment()) {
+                                throw t0;
+                            }
+
+                            root.thenAccept(exec -> exec.onError(t0));
 
-                        for (String nodeName : fragmentDesc.nodeNames()) {
-                            sendFragment(nodeName, fragment, fragmentDesc);
+                            break;
                         }
                     }
-                } catch (Throwable e) {
-                    root.thenAccept(root -> root.onError(e));
+                } catch (Throwable t) {
+                    LOG.error(""An error occurred while executing the query."", t);
+
+                    root.completeExceptionally(t);

Review Comment:
   Fixed a bit to handle such scenario :thinking: 



;27/Jan/23 14:54;githubbot;600","AMashenkov commented on code in PR #1581:
URL: https://github.com/apache/ignite-3/pull/1581#discussion_r1090569332


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImplTest.java:
##########
@@ -607,7 +633,8 @@ protected TestTable createTable(String name, int size, IgniteDistribution distr,
                 new TableDescriptorImpl(columns, distr),
                 name,
                 ColocationGroup.forNodes(nodeNames),
-                size
+                size,
+                () -> mappingException

Review Comment:
   ```suggestion
                   size
   ```
   Let's just override the `colocationGroup` method instead, and add a short explanation on why we throws an exception from here.



;30/Jan/23 12:35;githubbot;600","AMashenkov commented on code in PR #1581:
URL: https://github.com/apache/ignite-3/pull/1581#discussion_r1090569871


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/framework/TestTable.java:
##########
@@ -234,6 +239,12 @@ public boolean rolledUpColumnValidInsideAgg(
     /** {@inheritDoc} */
     @Override
     public ColocationGroup colocationGroup(MappingQueryContext ctx) {
+        RuntimeException ex = mappingExceptionSupplier.get();
+
+        if (ex != null) {
+            throw ex;
+        }
+

Review Comment:
   ```suggestion
   ```
   This looks like a dirty hack.



;30/Jan/23 12:36;githubbot;600","xtern commented on code in PR #1581:
URL: https://github.com/apache/ignite-3/pull/1581#discussion_r1090737122


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/exec/ExecutionServiceImplTest.java:
##########
@@ -607,7 +633,8 @@ protected TestTable createTable(String name, int size, IgniteDistribution distr,
                 new TableDescriptorImpl(columns, distr),
                 name,
                 ColocationGroup.forNodes(nodeNames),
-                size
+                size,
+                () -> mappingException

Review Comment:
   Thanks, I've fixed it as per your suggestion.



;30/Jan/23 14:59;githubbot;600","xtern commented on code in PR #1581:
URL: https://github.com/apache/ignite-3/pull/1581#discussion_r1090738797


##########
modules/sql-engine/src/test/java/org/apache/ignite/internal/sql/engine/framework/TestTable.java:
##########
@@ -234,6 +239,12 @@ public boolean rolledUpColumnValidInsideAgg(
     /** {@inheritDoc} */
     @Override
     public ColocationGroup colocationGroup(MappingQueryContext ctx) {
+        RuntimeException ex = mappingExceptionSupplier.get();
+
+        if (ex != null) {
+            throw ex;
+        }
+

Review Comment:
   Thanks, I reverted my changes in TestTable.



;30/Jan/23 15:00;githubbot;600","xtern merged PR #1581:
URL: https://github.com/apache/ignite-3/pull/1581


;31/Jan/23 17:41;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,5400,,,0,5400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Tue Jan 31 17:43:13 UTC 2023,,,,,,,,,,"0|z1ep3s:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"31/Jan/23 17:43;xtern;[~amashenkov], [~korlov] thanks for the review!

Merged to the main branch.;;;",,,,,
Sorted index scan may return obsolete row versions,IGNITE-18518,13517450,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,sdanilov,ibessonov,ibessonov,10/Jan/23 12:44,22/May/23 08:25,13/Jul/23 09:11,22/May/23 08:25,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"According to the MV store design, indexes must be filtered before returning data to user. For example, imagine that a row is deleted. This means that there's a tombstone.

But, there's still an entry in indexes, for column values that the row used to have. These should not be visible to end user.",,apolovtcev,ibessonov,sdanilov,,,"ibessonov opened a new pull request, #2037:
URL: https://github.com/apache/ignite-3/pull/2037

   https://issues.apache.org/jira/browse/IGNITE-18518


;08/May/23 13:59;githubbot;600","SammyVimes merged PR #2037:
URL: https://github.com/apache/ignite-3/pull/2037


;22/May/23 08:22;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17766,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Mon May 22 08:25:35 UTC 2023,,,,,,,,,,"0|z1ep0g:",9223372036854775807,,,apolovtcev,,,,,,,,,,,,,,,,,,"22/May/23 08:24;apolovtcev;LGTM!;;;","22/May/23 08:25;sdanilov;Ivan, thanks for the contribution, Aleksandr, thanks for the review. Merged to the main branch.;;;",,,,
Sql. CompositePublisher is not thread safe,IGNITE-18510,13517207,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,jooger,jooger,jooger,09/Jan/23 09:16,17/Jan/23 12:19,13/Jul/23 09:11,17/Jan/23 10:00,,,,,,,,,sql,,,0,ignite-3,,,"Currently our CompositePublisher is not threadsafe, but we have to deal with 3 types of potentially concurrent signals when arbitrating {*}Flow.Subscription{*}s:
 # A *request(long)* call from downstream that has to be routed to the current Flow.Subscription
 # A *cancel()* call from downstream that has to be routed to the current *Flow.Subscription* and cancel any future {*}Flow.Subscription{*}.
 # A *setSubscription(Flow.Subscription)* that is called by the current *Flow.Subscriber* after subscribing to any *Flow.Publisher* which is not guaranteed to happen on the same thread *subscribe()* is called

Let's reimplement our CompositePublisher",,jooger,xtern,,,,"xtern commented on code in PR #1511:
URL: https://github.com/apache/ignite-3/pull/1511#discussion_r1068092636


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/ConcatPublisher.java:
##########
@@ -0,0 +1,263 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.sql.engine.util;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodHandles.Lookup;
+import java.lang.invoke.VarHandle;
+import java.util.Iterator;
+import java.util.concurrent.Flow.Publisher;
+import java.util.concurrent.Flow.Subscriber;
+import java.util.concurrent.Flow.Subscription;
+import java.util.concurrent.atomic.AtomicInteger;
+
+
+/**
+ * Thread-safe realization of combine multiple publishers. Generally, start consuming a source once the previous source has terminated,
+ * building a chain.
+ */
+public class ConcatPublisher<T> implements Publisher<T> {
+    /** Iterator of upstream publishers. */
+    private final Iterator<Publisher<? extends T>> sources;
+
+    /**
+     * Constructor.
+     *
+     * @param sources Iterator of upstream publishers.
+     */
+    public ConcatPublisher(Iterator<Publisher<? extends T>> sources) {
+        this.sources = sources;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void subscribe(Subscriber<? super T> downstream) {
+        ConcatCoordinator<T> subscription = new ConcatCoordinator<>(downstream, sources);
+
+        downstream.onSubscribe(subscription);
+        subscription.drain();
+    }
+
+    /**
+     * Concatenation composite subscription.
+     */
+    static final class ConcatCoordinator<T> extends SubscriptionArbiter implements Subscriber<T> {
+        /** Counter to prevent concurrent execution of a critical section. */
+        private final AtomicInteger guardCntr = new AtomicInteger();
+
+        final Subscriber downstream;
+
+        final Iterator<Publisher<? extends T>> sources;
+
+        long consumed;
+
+        ConcatCoordinator(
+                Subscriber downstream,
+                Iterator<Publisher<? extends T>> sources
+        ) {
+            this.downstream = downstream;
+            this.sources = sources;
+        }
+
+        @Override
+        public void onSubscribe(Subscription s) {
+            setSubscription(s);
+        }
+
+        @Override
+        public void onNext(T item) {
+            consumed++;
+            downstream.onNext(item);
+        }
+
+        @Override
+        public void onError(Throwable throwable) {
+            downstream.onError(throwable);
+        }
+
+        @Override
+        public void onComplete() {
+            drain();
+        }
+
+        void drain() {
+            if (guardCntr.getAndIncrement() == 0) {
+                do {
+                    if (isCancelled()) {
+                        return;
+                    }
+
+                    if (!sources.hasNext()) {
+                        downstream.onComplete();
+                        return;
+                    }
+
+                    long c = consumed;
+                    if (c != 0L) {
+                        consumed = 0L;
+                        setProduced(c);
+                    }
+
+                    sources.next().subscribe(this);
+
+                } while ((guardCntr.getAndDecrement() - 1) != 0);
+            }
+        }
+    }
+
+    static class SubscriptionArbiter implements Subscription {

Review Comment:
   We currently have only one class that inherits from `SubscriptionArbiter` - `ConcatCoordinator`.
   It seems we should just combine `ConcatCoordinator` with `SubscriptionArbiter`



;12/Jan/23 13:11;githubbot;600","xtern commented on code in PR #1511:
URL: https://github.com/apache/ignite-3/pull/1511#discussion_r1071259421


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/ConcatPublisher.java:
##########
@@ -0,0 +1,263 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.sql.engine.util;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodHandles.Lookup;
+import java.lang.invoke.VarHandle;
+import java.util.Iterator;
+import java.util.concurrent.Flow.Publisher;
+import java.util.concurrent.Flow.Subscriber;
+import java.util.concurrent.Flow.Subscription;
+import java.util.concurrent.atomic.AtomicInteger;
+
+
+/**
+ * Thread-safe realization of combine multiple publishers. Generally, start consuming a source once the previous source has terminated,
+ * building a chain.
+ */
+public class ConcatPublisher<T> implements Publisher<T> {

Review Comment:
   Done



##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/ConcatPublisher.java:
##########
@@ -0,0 +1,263 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.sql.engine.util;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodHandles.Lookup;
+import java.lang.invoke.VarHandle;
+import java.util.Iterator;
+import java.util.concurrent.Flow.Publisher;
+import java.util.concurrent.Flow.Subscriber;
+import java.util.concurrent.Flow.Subscription;
+import java.util.concurrent.atomic.AtomicInteger;
+
+
+/**
+ * Thread-safe realization of combine multiple publishers. Generally, start consuming a source once the previous source has terminated,
+ * building a chain.
+ */
+public class ConcatPublisher<T> implements Publisher<T> {
+    /** Iterator of upstream publishers. */
+    private final Iterator<Publisher<? extends T>> sources;
+
+    /**
+     * Constructor.
+     *
+     * @param sources Iterator of upstream publishers.
+     */
+    public ConcatPublisher(Iterator<Publisher<? extends T>> sources) {
+        this.sources = sources;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void subscribe(Subscriber<? super T> downstream) {
+        ConcatCoordinator<T> subscription = new ConcatCoordinator<>(downstream, sources);
+
+        downstream.onSubscribe(subscription);
+        subscription.drain();
+    }
+
+    /**
+     * Concatenation composite subscription.
+     */
+    static final class ConcatCoordinator<T> extends SubscriptionArbiter implements Subscriber<T> {
+        /** Counter to prevent concurrent execution of a critical section. */
+        private final AtomicInteger guardCntr = new AtomicInteger();
+
+        final Subscriber downstream;
+
+        final Iterator<Publisher<? extends T>> sources;
+
+        long consumed;
+
+        ConcatCoordinator(
+                Subscriber downstream,
+                Iterator<Publisher<? extends T>> sources
+        ) {
+            this.downstream = downstream;
+            this.sources = sources;
+        }
+
+        @Override
+        public void onSubscribe(Subscription s) {
+            setSubscription(s);
+        }
+
+        @Override
+        public void onNext(T item) {
+            consumed++;
+            downstream.onNext(item);
+        }
+
+        @Override
+        public void onError(Throwable throwable) {
+            downstream.onError(throwable);
+        }
+
+        @Override
+        public void onComplete() {
+            drain();
+        }
+
+        void drain() {
+            if (guardCntr.getAndIncrement() == 0) {
+                do {
+                    if (isCancelled()) {
+                        return;
+                    }
+
+                    if (!sources.hasNext()) {
+                        downstream.onComplete();
+                        return;
+                    }
+
+                    long c = consumed;
+                    if (c != 0L) {
+                        consumed = 0L;
+                        setProduced(c);
+                    }
+
+                    sources.next().subscribe(this);
+
+                } while ((guardCntr.getAndDecrement() - 1) != 0);
+            }
+        }
+    }
+
+    static class SubscriptionArbiter implements Subscription {
+        Subscription current;
+        static final VarHandle CURRENT;
+
+        Subscription next;
+        static final VarHandle NEXT;
+
+        long requested;
+
+        long downstreamRequested;
+        static final VarHandle DOWNSTREAM_REQUESTED;
+
+        long produced;
+        static final VarHandle PRODUCED;
+
+        int wip;
+        static final VarHandle WIP;
+
+        static {
+            Lookup lk = MethodHandles.lookup();
+
+            try {
+                CURRENT = lk.findVarHandle(SubscriptionArbiter.class, ""current"", Subscription.class);
+                NEXT = lk.findVarHandle(SubscriptionArbiter.class, ""next"", Subscription.class);
+                DOWNSTREAM_REQUESTED = lk.findVarHandle(SubscriptionArbiter.class, ""downstreamRequested"", long.class);
+                PRODUCED = lk.findVarHandle(SubscriptionArbiter.class, ""produced"", long.class);
+                WIP = lk.findVarHandle(SubscriptionArbiter.class, ""wip"", int.class);
+
+            } catch (NoSuchFieldException | IllegalAccessException ex) {
+                throw new InternalError(ex);
+            }
+        }

Review Comment:
   Done



;16/Jan/23 13:41;githubbot;600","xtern commented on code in PR #1511:
URL: https://github.com/apache/ignite-3/pull/1511#discussion_r1071259733


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/OrderedMergePublisher.java:
##########
@@ -107,14 +109,20 @@ public void subscribe(Subscriber<? super T> downstream) {
         /** Number of emitted rows (guarded by {@link #guardCntr}). */
         private long emitted;
 
+        static final VarHandle ERROR;
+
+        static final VarHandle CANCELLED;
+
+        static final VarHandle REQUESTED;

Review Comment:
   Done



;16/Jan/23 13:41;githubbot;600","xtern commented on code in PR #1511:
URL: https://github.com/apache/ignite-3/pull/1511#discussion_r1071260952


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/ConcatPublisher.java:
##########
@@ -0,0 +1,263 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.sql.engine.util;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodHandles.Lookup;
+import java.lang.invoke.VarHandle;
+import java.util.Iterator;
+import java.util.concurrent.Flow.Publisher;
+import java.util.concurrent.Flow.Subscriber;
+import java.util.concurrent.Flow.Subscription;
+import java.util.concurrent.atomic.AtomicInteger;
+
+
+/**
+ * Thread-safe realization of combine multiple publishers. Generally, start consuming a source once the previous source has terminated,
+ * building a chain.
+ */
+public class ConcatPublisher<T> implements Publisher<T> {
+    /** Iterator of upstream publishers. */
+    private final Iterator<Publisher<? extends T>> sources;
+
+    /**
+     * Constructor.
+     *
+     * @param sources Iterator of upstream publishers.
+     */
+    public ConcatPublisher(Iterator<Publisher<? extends T>> sources) {
+        this.sources = sources;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void subscribe(Subscriber<? super T> downstream) {
+        ConcatCoordinator<T> subscription = new ConcatCoordinator<>(downstream, sources);
+
+        downstream.onSubscribe(subscription);
+        subscription.drain();
+    }
+
+    /**
+     * Concatenation composite subscription.
+     */
+    static final class ConcatCoordinator<T> extends SubscriptionArbiter implements Subscriber<T> {
+        /** Counter to prevent concurrent execution of a critical section. */
+        private final AtomicInteger guardCntr = new AtomicInteger();
+
+        final Subscriber downstream;
+
+        final Iterator<Publisher<? extends T>> sources;
+
+        long consumed;
+
+        ConcatCoordinator(
+                Subscriber downstream,
+                Iterator<Publisher<? extends T>> sources
+        ) {
+            this.downstream = downstream;
+            this.sources = sources;
+        }
+
+        @Override

Review Comment:
   Done



;16/Jan/23 13:42;githubbot;600","xtern commented on code in PR #1511:
URL: https://github.com/apache/ignite-3/pull/1511#discussion_r1071261364


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/ConcatPublisher.java:
##########
@@ -0,0 +1,263 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.sql.engine.util;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodHandles.Lookup;
+import java.lang.invoke.VarHandle;
+import java.util.Iterator;
+import java.util.concurrent.Flow.Publisher;
+import java.util.concurrent.Flow.Subscriber;
+import java.util.concurrent.Flow.Subscription;
+import java.util.concurrent.atomic.AtomicInteger;
+
+
+/**
+ * Thread-safe realization of combine multiple publishers. Generally, start consuming a source once the previous source has terminated,
+ * building a chain.
+ */
+public class ConcatPublisher<T> implements Publisher<T> {
+    /** Iterator of upstream publishers. */
+    private final Iterator<Publisher<? extends T>> sources;
+
+    /**
+     * Constructor.
+     *
+     * @param sources Iterator of upstream publishers.
+     */
+    public ConcatPublisher(Iterator<Publisher<? extends T>> sources) {
+        this.sources = sources;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void subscribe(Subscriber<? super T> downstream) {
+        ConcatCoordinator<T> subscription = new ConcatCoordinator<>(downstream, sources);
+
+        downstream.onSubscribe(subscription);
+        subscription.drain();
+    }
+
+    /**
+     * Concatenation composite subscription.
+     */
+    static final class ConcatCoordinator<T> extends SubscriptionArbiter implements Subscriber<T> {

Review Comment:
   Renamed to `ConcatenatedSubscriber`



;16/Jan/23 13:43;githubbot;600","xtern commented on code in PR #1511:
URL: https://github.com/apache/ignite-3/pull/1511#discussion_r1071286076


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/OrderedMergePublisher.java:
##########
@@ -36,49 +35,52 @@
  *
  * <p>Merges multiple concurrent ordered data streams into one.
  */
-public class SortingCompositePublisher<T> extends CompositePublisher<T> {
+public class OrderedMergePublisher<T> implements Publisher<T> {
     /** Rows comparator. */
-    private final Comparator<T> comp;
+    private final Comparator<? super T> comp;
+
+    /** Array of upstream publishers. */
+    private final Publisher<? extends T>[] sources;
 
     /** Prefetch size. */
     private final int prefetch;
 
     /**
      * Constructor.
      *
-     * @param publishers List of upstream publishers.
      * @param comp Rows comparator.
      * @param prefetch Prefetch size.
+     * @param sources List of upstream publishers.
      */
-    public SortingCompositePublisher(Collection<? extends Publisher<T>> publishers, Comparator<T> comp, int prefetch) {
-        super(publishers);
-
-        this.comp = comp;
+    public OrderedMergePublisher(
+            Comparator<? super T> comp,
+            int prefetch,
+            Publisher<? extends T>... sources) {
+        this.sources = sources;
         this.prefetch = prefetch;
+        this.comp = comp;
     }
 
+    /** {@inheritDoc} */
     @Override
     public void subscribe(Subscriber<? super T> downstream) {
-        subscribe(new OrderedMergeCompositeSubscription<>(downstream, comp, prefetch, publishers.size()), downstream);
+        OrderedMergeSubscription<? super T> subscription = new OrderedMergeSubscription<>(downstream, comp, prefetch, sources.length);
+
+        subscription.subscribe(sources);
+        downstream.onSubscribe(subscription);
+        subscription.drain();
     }
 
     /**
      * Sorting composite subscription.
      *
      * <p>Merges multiple concurrent ordered data streams into one.
      */
-    public static class OrderedMergeCompositeSubscription<T> extends CompositePublisher.CompositeSubscription<T> {
-        /** Marker to indicate completed subscription. */
+    static final class OrderedMergeSubscription<T> implements Subscription {

Review Comment:
   It seems to me that the current names `OrderedMergePublisher` and `OrderedMergeSubscription` better reflect the purpose of these classes.



;16/Jan/23 14:08;githubbot;600","xtern commented on code in PR #1511:
URL: https://github.com/apache/ignite-3/pull/1511#discussion_r1071287538


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/OrderedMergePublisher.java:
##########
@@ -36,49 +35,52 @@
  *
  * <p>Merges multiple concurrent ordered data streams into one.
  */
-public class SortingCompositePublisher<T> extends CompositePublisher<T> {
+public class OrderedMergePublisher<T> implements Publisher<T> {

Review Comment:
   Javadoc updated:
   
   ```
   /**
    * Sorting composite publisher.
    *
    * <p>Merges multiple publishers using merge-sort algorithm.
    *
    * <p>Note: upstream publishers must be sources of sorted data.
    */
   ```



;16/Jan/23 14:09;githubbot;600","xtern commented on code in PR #1511:
URL: https://github.com/apache/ignite-3/pull/1511#discussion_r1071289825


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/ConcatPublisher.java:
##########
@@ -0,0 +1,263 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.sql.engine.util;
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodHandles.Lookup;
+import java.lang.invoke.VarHandle;
+import java.util.Iterator;
+import java.util.concurrent.Flow.Publisher;
+import java.util.concurrent.Flow.Subscriber;
+import java.util.concurrent.Flow.Subscription;
+import java.util.concurrent.atomic.AtomicInteger;
+
+
+/**
+ * Thread-safe realization of combine multiple publishers. Generally, start consuming a source once the previous source has terminated,
+ * building a chain.
+ */
+public class ConcatPublisher<T> implements Publisher<T> {
+    /** Iterator of upstream publishers. */
+    private final Iterator<Publisher<? extends T>> sources;
+
+    /**
+     * Constructor.
+     *
+     * @param sources Iterator of upstream publishers.
+     */
+    public ConcatPublisher(Iterator<Publisher<? extends T>> sources) {
+        this.sources = sources;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void subscribe(Subscriber<? super T> downstream) {
+        ConcatCoordinator<T> subscription = new ConcatCoordinator<>(downstream, sources);
+
+        downstream.onSubscribe(subscription);
+        subscription.drain();
+    }
+
+    /**
+     * Concatenation composite subscription.
+     */
+    static final class ConcatCoordinator<T> extends SubscriptionArbiter implements Subscriber<T> {
+        /** Counter to prevent concurrent execution of a critical section. */
+        private final AtomicInteger guardCntr = new AtomicInteger();
+
+        final Subscriber downstream;
+
+        final Iterator<Publisher<? extends T>> sources;
+
+        long consumed;
+
+        ConcatCoordinator(
+                Subscriber downstream,
+                Iterator<Publisher<? extends T>> sources
+        ) {
+            this.downstream = downstream;
+            this.sources = sources;
+        }
+
+        @Override
+        public void onSubscribe(Subscription s) {
+            setSubscription(s);
+        }
+
+        @Override
+        public void onNext(T item) {
+            consumed++;
+            downstream.onNext(item);
+        }
+
+        @Override
+        public void onError(Throwable throwable) {
+            downstream.onError(throwable);
+        }
+
+        @Override
+        public void onComplete() {
+            drain();
+        }
+
+        void drain() {
+            if (guardCntr.getAndIncrement() == 0) {
+                do {
+                    if (isCancelled()) {
+                        return;
+                    }
+
+                    if (!sources.hasNext()) {
+                        downstream.onComplete();
+                        return;
+                    }
+
+                    long c = consumed;
+                    if (c != 0L) {
+                        consumed = 0L;
+                        setProduced(c);
+                    }
+
+                    sources.next().subscribe(this);
+
+                } while ((guardCntr.getAndDecrement() - 1) != 0);
+            }
+        }
+    }
+
+    static class SubscriptionArbiter implements Subscription {
+        Subscription current;
+        static final VarHandle CURRENT;
+
+        Subscription next;
+        static final VarHandle NEXT;
+
+        long requested;
+
+        long downstreamRequested;
+        static final VarHandle DOWNSTREAM_REQUESTED;
+
+        long produced;
+        static final VarHandle PRODUCED;
+
+        int wip;
+        static final VarHandle WIP;

Review Comment:
   We decided to keep the code as close as possible to the original source https://akarnokd.blogspot.com/2017/09/java-9-flow-api-arbitration-and.html



;16/Jan/23 14:11;githubbot;600","xtern merged PR #1511:
URL: https://github.com/apache/ignite-3/pull/1511


;17/Jan/23 09:57;githubbot;600","AMashenkov commented on code in PR #1511:
URL: https://github.com/apache/ignite-3/pull/1511#discussion_r1072138375


##########
modules/sql-engine/src/main/java/org/apache/ignite/internal/sql/engine/util/OrderedMergePublisher.java:
##########
@@ -36,49 +35,52 @@
  *
  * <p>Merges multiple concurrent ordered data streams into one.
  */
-public class SortingCompositePublisher<T> extends CompositePublisher<T> {
+public class OrderedMergePublisher<T> implements Publisher<T> {
     /** Rows comparator. */
-    private final Comparator<T> comp;
+    private final Comparator<? super T> comp;
+
+    /** Array of upstream publishers. */
+    private final Publisher<? extends T>[] sources;
 
     /** Prefetch size. */
     private final int prefetch;
 
     /**
      * Constructor.
      *
-     * @param publishers List of upstream publishers.
      * @param comp Rows comparator.
      * @param prefetch Prefetch size.
+     * @param sources List of upstream publishers.
      */
-    public SortingCompositePublisher(Collection<? extends Publisher<T>> publishers, Comparator<T> comp, int prefetch) {
-        super(publishers);
-
-        this.comp = comp;
+    public OrderedMergePublisher(
+            Comparator<? super T> comp,
+            int prefetch,
+            Publisher<? extends T>... sources) {
+        this.sources = sources;
         this.prefetch = prefetch;
+        this.comp = comp;
     }
 
+    /** {@inheritDoc} */
     @Override
     public void subscribe(Subscriber<? super T> downstream) {
-        subscribe(new OrderedMergeCompositeSubscription<>(downstream, comp, prefetch, publishers.size()), downstream);
+        OrderedMergeSubscription<? super T> subscription = new OrderedMergeSubscription<>(downstream, comp, prefetch, sources.length);
+
+        subscription.subscribe(sources);
+        downstream.onSubscribe(subscription);
+        subscription.drain();
     }
 
     /**
      * Sorting composite subscription.
      *
      * <p>Merges multiple concurrent ordered data streams into one.
      */
-    public static class OrderedMergeCompositeSubscription<T> extends CompositePublisher.CompositeSubscription<T> {
-        /** Marker to indicate completed subscription. */
+    static final class OrderedMergeSubscription<T> implements Subscription {

Review Comment:
   Concatenated publisher is also ordered, but not sorted, as it iterates over array of upstreams.
   Another example, LinkedHashMap is ordered, but not sorted.
   



;17/Jan/23 12:19;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,6000,,,0,6000,,IGNITE-18227,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Tue Jan 17 10:00:37 UTC 2023,,,,,,,,,,"0|z1enkw:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"17/Jan/23 10:00;xtern;[~jooger], thanks for the contribution!

Merged to the main branch.

;;;",,,,,
Metastorage-api does not generate jar,IGNITE-18508,13516655,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Berkov,Berkov,Berkov,05/Jan/23 14:58,12/Jan/23 11:02,13/Jul/23 09:11,12/Jan/23 11:02,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"Need to add
{noformat}
apply from: ""$rootDir/buildscripts/publishing.gradle""{noformat}
into the module's build.gradle.

The same for metastorage module.",,Berkov,,,,,"Berkof opened a new pull request, #1499:
URL: https://github.com/apache/ignite-3/pull/1499

   Add publishing specifications into metastorage modules gradle configuration.


;05/Jan/23 16:32;githubbot;600","Pochatkin commented on PR #1499:
URL: https://github.com/apache/ignite-3/pull/1499#issuecomment-1380146227

   LGTM


;12/Jan/23 10:51;githubbot;600","ibessonov merged PR #1499:
URL: https://github.com/apache/ignite-3/pull/1499


;12/Jan/23 11:01;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,IGNITE-18413,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,2023-01-05 14:58:08.0,,,,,,,,,,"0|z1ek6g:",9223372036854775807,,,krokpop,,,,,,,,,,,,,,,,,,,,,,,
ItDataSchemaSyncTest.checkSchemasCorrectlyRestore() is flaky,IGNITE-18506,13516647,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,zstan,rpuch,rpuch,05/Jan/23 13:37,10/Mar/23 12:25,13/Jul/23 09:11,10/Mar/23 12:25,3.0.0-beta1,,,,,,,,,,,0,ignite-3,tech-debt,,"[https://ci.ignite.apache.org/test/5151808410902558750?currentProjectId=ApacheIgnite3xGradle_Test_IntegrationTests&expandTestHistoryChartSection=true&branch=]

In failing runs, nodes leave the cluster and return to it during the test. This seems to make session hang (until timeout of 5 minutes triggers).",,rpuch,zstan,,,,"zstan closed pull request #1776: IGNITE-18506 Correct schemaSync test annotation for disabled test
URL: https://github.com/apache/ignite-3/pull/1776


;10/Mar/23 12:24;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,,,,IGNITE-18514,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Fri Mar 10 10:54:05 UTC 2023,,,,,,,,,,"0|z1ek4o:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,"10/Mar/23 10:54;zstan;The problem will be fixed after [1]. Seems all we need here is to correct disabled annotation.

[1] https://issues.apache.org/jira/browse/IGNITE-18203;;;",,,,,
Need to return the ability of WatchListener to listen to one specific key,IGNITE-18503,13516635,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,apolovtcev,Sergey Uttsel,Sergey Uttsel,05/Jan/23 12:09,09/Jan/23 08:21,13/Jul/23 09:11,09/Jan/23 08:21,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"h3. Motivation
The MetaStorageManager#registerWatch method was removed in  IGNITE-18413. Usage of 'registerWatch' was changed on 'registerWatchByPrefix' in DistributionZoneManager. So now WatchListener in DistributionZoneManager is triggered not only by key 'distributionZones.logicalTopology' but also 'distributionZones.logicalTopologyVersion'.

h3. Definition of Done
Need to check where 'registerWatch' was used and return the ability to listen to one specific key.",,rpuch,Sergey Uttsel,,,,"sashapolo opened a new pull request, #1498:
URL: https://github.com/apache/ignite-3/pull/1498

   https://issues.apache.org/jira/browse/IGNITE-18503


;05/Jan/23 13:09;githubbot;600","ibessonov merged PR #1498:
URL: https://github.com/apache/ignite-3/pull/1498


;09/Jan/23 08:21;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,IGNITE-18413,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Thu Jan 05 15:01:03 UTC 2023,,,,,,,,,,"0|z1ek20:",9223372036854775807,,,rpuch,,,,,,,,,,,,,,,,,,"05/Jan/23 14:26;Sergey Uttsel;[~apolovtcev] LGTM;;;","05/Jan/23 15:01;rpuch;The patch looks good to me;;;",,,,
Read only get returns a first one value getting from primary index,IGNITE-18497,13516355,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,Denis Chudov,v.pyatkov,v.pyatkov,03/Jan/23 17:54,09/Feb/23 17:48,13/Jul/23 09:11,09/Feb/23 17:48,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"*Motivation*

Indexes store all value associated with different versions of one entry. By the reason, for getting value by primary index, we scan the index with the specific key. If we insert, delete and again insert an entry with the same indexed fields, the entry can resolve in versioned storage for different row ids. But only one resolution should return not empty value, because only one entry can exist by the unique index.

*Implementation notes*

The resolution happens here:
{code:java}
PartitionReplicaListener#resolveRowByPk(BinaryRow, HybridTimestamp){code}
But in case when a read result is resolved to null, need to continue the loop, because the actual value associated with the key may be removed (this is the null value, but it is not actual) and inserted again.
 
h3. upd 1:
 # Seems that it's rather simple in case of primary index (and given ticket is about primary index) because keys are unmodifiable, so it's only possible to have multiple entries for particular search key only in case of creation-> removal -> creation. That means that we can have one and only one non empty readResult for any read timestamp for the given key. Which in turn means that if we found non empty readResult during PK index iteration we can proceed with readResult resolution and stop the iteration, oterwise, in case of empty read result we should continue the iteration as Vlad told. So basically we should add 
{code:java}
if (readResult.isEmpty()) {continue;}{code}
after 
{code:java}
ReadResult readResult = mvDataStorage.read(rowId, ts);{code}

 # We should probably fix PartitionReplicaListener#resolveReadResult instead of returning null in case of null readResult we should complete future with null.

{code:java}
    private CompletableFuture<BinaryRow> resolveReadResult(
            ReadResult readResult,
            @Nullable UUID txId,
            @Nullable HybridTimestamp timestamp,
            @Nullable Supplier<BinaryRow> lastCommitted
    ) {
        if (readResult == null) {
            return null;
             {code}",,Denis Chudov,v.pyatkov,,,,"denis-chudov opened a new pull request, #1624:
URL: https://github.com/apache/ignite-3/pull/1624

   https://issues.apache.org/jira/browse/IGNITE-18497


;02/Feb/23 22:17;githubbot;600","vldpyatkov merged PR #1624:
URL: https://github.com/apache/ignite-3/pull/1624


;09/Feb/23 17:47;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,Docs Required,Release Notes Required,,,Thu Feb 09 17:48:12 UTC 2023,,,,,,,,,,"0|z1eibs:",9223372036854775807,,,v.pyatkov,,,,,,,,,,,,,,,,,,"08/Feb/23 07:56;Denis Chudov;[~v.pyatkov] could you pls review the fix?;;;","08/Feb/23 14:25;v.pyatkov;[~Denis Chudov] I do not find something wrong in your PR.
But if it possible, fix also a mistake that mentioned in description:
{code}
 private CompletableFuture<BinaryRow> resolveReadResult(
            ReadResult readResult,
            @Nullable UUID txId,
            @Nullable HybridTimestamp timestamp,
            @Nullable Supplier<BinaryRow> lastCommitted
    ) {
if (readResult == null) {
            return ConpletableFuture.completedFuture(null);
...
}
{code}
and if you do not mind, change a property of TxStateReplicaRequest.commitTimestamp to readTimestamp.
;;;","09/Feb/23 13:07;v.pyatkov;LGTM;;;","09/Feb/23 17:48;v.pyatkov;Merged 5f834c5c7ef87fece68f6af4d5f1329aa77fc19b;;;",,
Fix RAFT snapshot installation hang due to response swap on retry,IGNITE-18495,13516334,Bug,Resolved,IGNITE,Ignite,software,cos,Apache Ignite,http://ignite.apache.org,Major,Fixed,rpuch,rpuch,rpuch,03/Jan/23 14:37,04/Jan/23 07:52,13/Jul/23 09:11,04/Jan/23 07:40,,,,,,,,3.0.0-beta2,,,,0,ignite-3,,,"The scenario follows:
 # InstallSnapshot request is sent, its processing starts hanging forever (it will be cancelled on step 3)
 # After a timeout, second InstallSnapshot request is sent with same index+term as the first had; in JRaft, it causes a special handling (previous request processing is NOT cancelled)
 # After a timeout, third InstallSnapshot request is sent with DIFFERENT index, so it cancels the first snapshot processing effectively unblocking the first thread

In the original JRaft implementation, after being unblocked, the first thread fails to clean up, so subsequent retries will always see a phantom of an unfinished snapshot, so the snapshotting process will be jammed. Also, node stop might stuck because one 'download' task will remain unfinished forever.",,maliev,rpuch,,,,"rpuch opened a new pull request, #1491:
URL: https://github.com/apache/ignite-3/pull/1491

   https://issues.apache.org/jira/browse/IGNITE-18495


;03/Jan/23 17:18;githubbot;600","ibessonov merged PR #1491:
URL: https://github.com/apache/ignite-3/pull/1491


;04/Jan/23 07:40;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,IGNITE-18079,,,,,,,,,,IGNITE-18428,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,IGNITE-17774,,,,,,,,,,,,,,,,,9223372036854775807,,,,,,Wed Jan 04 07:50:24 UTC 2023,,,,,,,,,,"0|z1ei74:",9223372036854775807,,,maliev,,,,,,,,,,,,,,,,,,"03/Jan/23 18:42;rpuch;It looks like we can just port the corresponding fix from JRaft: [https://github.com/sofastack/sofa-jraft/commit/a1fa8c30a895fc45f39c9661eb383a890ba4b6d8];;;","04/Jan/23 06:15;rpuch;[~maliev] could you please take a look?;;;","04/Jan/23 07:37;maliev;[~rpuch] thank you for the contribution, ok from my side ;;;","04/Jan/23 07:50;rpuch;Thanks!;;;",,
