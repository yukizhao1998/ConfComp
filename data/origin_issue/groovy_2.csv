Summary,Issue key,Issue id,Issue Type,Status,Project key,Project name,Project type,Project lead,Project description,Project url,Priority,Resolution,Assignee,Reporter,Creator,Created,Updated,Last Viewed,Resolved,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Fix Version/s,Fix Version/s,Fix Version/s,Component/s,Component/s,Due Date,Votes,Labels,Labels,Labels,Description,Environment,Watchers,Watchers,Watchers,Original Estimate,Remaining Estimate,Time Spent,Work Ratio,Σ Original Estimate,Σ Remaining Estimate,Σ Time Spent,Security Level,Inward issue link (Completes),Inward issue link (Problem/Incident),Outward issue link (Problem/Incident),Outward issue link (Problem/Incident),Inward issue link (Reference),Inward issue link (Reference),Inward issue link (Reference),Inward issue link (Reference),Inward issue link (Reference),Inward issue link (Reference),Inward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Attachment,Attachment,Attachment,Attachment,Attachment,Custom field (Affects version (Component)),Custom field (Attachment count),Custom field (Blog - New Blog Administrators),Custom field (Blog - New Blog PMC),Custom field (Blog - Write access),Custom field (Blog Administrator?),Custom field (Blogs - Admin for blog),Custom field (Blogs - Email Address),Custom field (Blogs - Existing Blog Access Level),Custom field (Blogs - Existing Blog Name),Custom field (Blogs - New Blog Write Access),Custom field (Blogs - Username),Custom field (Bug Category),Custom field (Bugzilla - Email Notification Address),Custom field (Bugzilla - List of usernames),Custom field (Bugzilla - PMC Name),Custom field (Bugzilla - Project Name),Custom field (Bugzilla Id),Custom field (Bugzilla Id),Custom field (Change Category),Custom field (Complexity),Custom field (Discovered By),Custom field (Docs Text),Custom field (Enable Automatic Patch Review),Custom field (Epic Link),Custom field (Estimated Complexity),Custom field (Evidence Of Open Source Adoption),Custom field (Evidence Of Registration),Custom field (Evidence Of Use On World Wide Web),Custom field (Existing GitBox Approval),Custom field (External issue URL),Custom field (Fix version (Component)),Custom field (Git Notification Mailing List),Custom field (Git Repository Import Path),Custom field (Git Repository Name),Custom field (Git Repository Type),Custom field (GitHub Options),Custom field (Github Integration),Custom field (Github Integrations - Other),Custom field (Global Rank),Custom field (INFRA - Subversion Repository Path),Custom field (Initial Confluence Contributors),Custom field (Language),Custom field (Last public comment date),Custom field (Level of effort),Custom field (Machine Readable Info),Custom field (Mentor),Custom field (New-TLP-TLPName),Custom field (Original story points),Custom field (Parent Link),Custom field (Priority),Custom field (Project),Custom field (Protected Branch),Custom field (Rank),Custom field (Rank (Obsolete)),Custom field (Review Date),Custom field (Reviewer),Custom field (Severity),Custom field (Severity),Custom field (Skill Level),Custom field (Source Control Link),Custom field (Space Description),Custom field (Space Key),Custom field (Space Name),Custom field (Start Date),Custom field (Tags),Custom field (Target end),Custom field (Target start),Custom field (Team),Custom field (Test and Documentation Plan),Custom field (Testcase included),Custom field (Tester),Custom field (Workaround),Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment
Calling SwingWorker publish() method aborts with groovy.lang.MissingMethodException,GROOVY-11112,13541355,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,dschum,dschum,26/Jun/23 07:16,27/Jun/23 13:51,13/Jul/23 08:58,27/Jun/23 13:50,3.0.15,,,,,,3.0.16,,,,,,0,,,,"Hello,

 

with Groovy 3.0.15 and Java *17* I get the following exception when I call a SwingWorker publish() method

 
{code:java}
groovy.lang.MissingMethodException: No signature of method: TestWorker2.publish() is applicable for argument types: (Integer) values: [0]
java.util.concurrent.ExecutionException: groovy.lang.MissingMethodException: No signature of method: TestWorker2.publish() is applicable for argument types: (Integer) values: [0]
    at java.base/java.util.concurrent.FutureTask.report(FutureTask.java:122)
    at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:191)
    at java.desktop/javax.swing.SwingWorker.get(SwingWorker.java:613)
    at java_util_concurrent_Future$get.callCurrent(Unknown Source)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:171)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:176)
    at TestWorker2.done(TestWorker2.groovy:32)
    at java.desktop/javax.swing.SwingWorker$5.run(SwingWorker.java:750)
    at java.desktop/javax.swing.SwingWorker$DoSubmitAccumulativeRunnable.run(SwingWorker.java:848)
    at java.desktop/sun.swing.AccumulativeRunnable.run(AccumulativeRunnable.java:112)
    at java.desktop/javax.swing.SwingWorker$DoSubmitAccumulativeRunnable.actionPerformed(SwingWorker.java:858)
    at java.desktop/javax.swing.Timer.fireActionPerformed(Timer.java:311)
    at java.desktop/javax.swing.Timer$DoPostEvent.run(Timer.java:243)
    at java.desktop/java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:318)
    at java.desktop/java.awt.EventQueue.dispatchEventImpl(EventQueue.java:771)
    at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:722)
    at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:716)
    at java.base/java.security.AccessController.doPrivileged(AccessController.java:399)
    at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:86)
    at java.desktop/java.awt.EventQueue.dispatchEvent(EventQueue.java:741)
    at java.desktop/java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:203)
    at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:124)
    at java.desktop/java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:113)
    at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:109)
    at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)
    at java.desktop/java.awt.EventDispatchThread.run(EventDispatchThread.java:90)
Caused by: groovy.lang.MissingMethodException: No signature of method: publish() is applicable for argument types: (Integer) values: [0]
    at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:72)
    at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:82)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:171)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:185)
    at TestWorker2.doInBackground(TestWorker2.groovy:16)
    at TestWorker2.doInBackground(TestWorker2.groovy)
    at java.desktop/javax.swing.SwingWorker$1.call(SwingWorker.java:304)
    at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
    at java.desktop/javax.swing.SwingWorker.run(SwingWorker.java:343)
    at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
    at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
    at java.base/java.lang.Thread.run(Thread.java:833) {code}
 

 

The code example is the following:

TestWorker2Test.groovy

 
{code:java}
import java.awt.EventQueue

class TestWorker2Test {
	
	static void main(String[] args) {
		
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				try {
					println ""TestWorkerTest2""
					TestWorker2 tw2 = new TestWorker2()
					tw2.execute()
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		})
		
	}
}

 {code}
 

TestWorker2.groovy
{code:java}
import javax.swing.SwingWorker


class TestWorker2 extends SwingWorker<Void, Integer> {
    
        @Override
        protected Void doInBackground() throws Exception {
            
            for(int i=0; i<10; i++) {
                publish(i)
            }
            return null
        }
        
        @Override
        protected void process(List<Integer> chunks) {
            // Get Info
            for (Integer number : chunks) {
                println""Execute 'process chunks' in TestWorker 2! Number:$number""
            }
        }
        
        @Override
        protected void done() {
            try {
                get()
                println ""Background thread has been processed.""
            } catch (Exception ex) {
                println ""Error!""
                println ex.getMessage()
                ex.printStackTrace()
            }
        }
        
} {code}
When I run the above code with Groovy 3.0.15 and Java *11* everything works fine, only after switching to Java *17* I get the above exception.

 

What has changed with Java 17 and how can I solve the problem? Thanks in advance!

 ",,dschum,paulk,,,,,,,,,,GROOVY-10070,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,groovy,Tue Jun 27 13:48:36 UTC 2023,,,,,,,,,,"0|z1irvc:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Jun/23 10:04;paulk;I can reproduce in 3.0.15 with JDK17 but your test works fine in 3.0.16, 3.0.17 and the upcoming 3.0.18.;;;","27/Jun/23 13:48;dschum;Thanks for your assistance! With Groovy 3.0.17 the code works fine!

I looked at the release notes of Groovy 3.0.16 and saw that it has the same error pattern as described in issue https://issues.apache.org/jira/browse/GROOVY-10070

 ;;;",,,,,,,,,,
EnumSet varargs constructor is not recognized (broken) in runtime,GROOVY-11107,13540830,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,ntn.immortal,ntn.immortal,21/Jun/23 01:16,26/Jun/23 17:39,13/Jul/23 08:58,21/Jun/23 15:54,2.5.22,3.0.17,,,,,3.0.18,,,,,,0,,,,"EnumSet.of() has 6 overloaded variants, the one with varargs is throwing GroovyRuntimeException, claiming it can not find a proper constructor. But it is working for jdk 8 with any Groovy version: 2.4, 2.5, 3.0 and 4.0, broken for jdk 11 and 17 with 2.5 and 3.0 and working fine for groovy 4.0 with any jdk.

It is a runtime exception and the code needs to access the field:

 
{code:java}
package test
enum Test1 {
    ONE,
    TWO,
    THREE,
    FOUR,
    FIVE,
    SIX
    
    public static EnumSet<Test1> test1 = EnumSet.of(ONE, TWO, THREE, FOUR, FIVE, SIX)
    //public static EnumSet<Test1> test2 = EnumSet.of(ONE, TWO, THREE, FOUR) + EnumSet.of(FIVE, SIX) // workaround to not use varargs, works for any combinations
}
class Application {
    static void main(String[] args) {
        Test1.test1
   }
}
{code}
It was working fine in groovy 2.4 and all groovy version using jdk 8. But in groovy 2.5 and 3.0, using JDK 11 and 17 it is throwing an exception:
{code:java}
Exception in thread ""main"" java.lang.ExceptionInInitializerError
    at java.base/jdk.internal.misc.Unsafe.ensureClassInitialized0(Native Method)
    at java.base/jdk.internal.misc.Unsafe.ensureClassInitialized(Unsafe.java:1042)
    at java.base/jdk.internal.reflect.UnsafeFieldAccessorFactory.newFieldAccessor(UnsafeFieldAccessorFactory.java:43)
    at java.base/jdk.internal.reflect.ReflectionFactory.newFieldAccessor(ReflectionFactory.java:186)
    at java.base/java.lang.reflect.Field.acquireFieldAccessor(Field.java:1105)
    at java.base/java.lang.reflect.Field.getFieldAccessor(Field.java:1086)
    at java.base/java.lang.reflect.Field.get(Field.java:418)
    at org.codehaus.groovy.reflection.CachedField.getProperty(CachedField.java:70)
    at groovy.lang.MetaClassImpl.getProperty(MetaClassImpl.java:1890)
    at groovy.lang.MetaClassImpl.getProperty(MetaClassImpl.java:3827)
    at org.codehaus.groovy.runtime.callsite.ClassMetaClassGetPropertySite.getProperty(ClassMetaClassGetPropertySite.java:50)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGetProperty(AbstractCallSite.java:329)
    at test.Application.main(Application.groovy:20)
Caused by: org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object '[FOUR, ONE, TWO, SIX, FIVE, THREE]' with class 'java.util.ImmutableCollections$SetN' to class 'java.util.EnumSet' due to: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: java.util.EnumSet(test.Test1, test.Test1, test.Test1, test.Test1, test.Test1, test.Test1)
    at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.continueCastOnSAM(DefaultTypeTransformation.java:402)
    at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.continueCastOnNumber(DefaultTypeTransformation.java:315)
    at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.continueCastOnCollection(DefaultTypeTransformation.java:273)
    at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:230)
    at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.castToType(ScriptBytecodeAdapter.java:615)
    at test.Test1.<clinit>(Application.groovy:14)
    ... 13 more
    Suppressed: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: java.util.EnumSet(SetN)
        at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1835)
        at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1605)
        at org.codehaus.groovy.runtime.InvokerHelper.invokeConstructorOf(InvokerHelper.java:1067)
        at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.continueCastOnSAM(DefaultTypeTransformation.java:378)
        ... 18 more{code}
Although it is working fine in groovy 4 in all JDK: 8, 11 and 17.

 
||Groovy\JDK||JDK8||jdk-11.0.19+7||jdk-17.0.7+7||
|2.4.21|{color:#00875a}V{color}|N/A|N/A|
|2.5.22|{color:#00875a}V{color}|{color:#de350b}X{color}|{color:#de350b}X{color}|
|3.0.17|{color:#00875a}V{color}|{color:#de350b}X{color}|{color:#de350b}X{color}|
|4.0.12|{color:#00875a}V{color}|{color:#00875a}V{color}|{color:#00875a}V{color}|

Also, static compilation of enum is also fixing the problem. I am using CentOS 7 and AdoptNet(Temurin) Java, see versions of groovy and java in the table above.

 ",,emilles,ntn.immortal,paulk,,,,,,,,,,,,,,,,,,,,GROOVY-8164,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,groovy,Mon Jun 26 17:39:01 UTC 2023,,,,,,,,,,"0|z1ion4:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jun/23 13:45;emilles;If your use case is to create an {{EnumSet}} of all of the enum constants, you can use {{EnumSet.allOf(Test1)}} to do that.

The runtime matches 3 candidate methods under Java 11:
{code:java}
Set Set.of(Object...)
Set Set.of(Object, Object, Object, Object, Object, Object)
EnumSet EnumSet.of(Enum, Enum...)
{code}
The middle one matches based on the return values of {{MetaClassHelper#calculateParameterDistance}}.;;;","21/Jun/23 13:59;emilles;Groovy 4 uses a different method index strategy (see GROOVY-8164).  It does not match any of the ""Set.of"" methods.

Moving this back to Groovy 3 would break any code that references a static interface method indirectly.  For example ""LinkedList.of(42)"" or ""class C implements List \{ def list = of(42) \}"";;;","21/Jun/23 15:54;emilles;https://github.com/apache/groovy/commit/6bff438f722862f88cd6ddd1a134847911de4f97

The old index scheme can be enabled by setting system property ""groovy.interface.methods.of_super"" to true.

[~paulk] Before the next Groovy 3 release is created, can you have a look at this and see if the default for the system property should be inverted or if this is safe enough as-is?;;;","21/Jun/23 16:10;ntn.immortal;{quote}If your use case is to create an {{EnumSet}} of all of the enum constants, you can use {{EnumSet.allOf(Test1)}} to do that.
{quote}
Thanks, but it is just a minimal example to reproduce the issue, in real production code it is actually a subset and requires to use ""EnumSet.of()"".
{quote}Moving this back to Groovy 3 would break any code that references an index method indirectly. For example ""LinkedList.of(42)"" or ""class C implements List \{ def list = of(42) }""
{quote}
I am upgrading to Grails 5 from 3, so I am stuck with Groovy 3 and JDK 11. About half of my unit tests were failing as Spock was failing to create a mock for any classes that have even indirect reference to any enum with such EnumSet in it. And a caused by exceptions hard to read by default in test results, so it looked like a Spock issue, while it was actually a groovy issue mentioned here. Although, splitting EnumSet.of into many as a workaround does the trick.;;;","26/Jun/23 05:27;paulk;[~emilles] I think this is okay.;;;","26/Jun/23 17:39;ntn.immortal;Checked with 3.0.18-SNAPSHOT and jdk 11 and 17, works fine in both cases. Thanks!;;;",,,,,,
Static import of property accessor for type in same unit,GROOVY-11104,13540521,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,emilles,emilles,18/Jun/23 14:11,18/Jun/23 15:39,13/Jul/23 08:58,18/Jun/23 14:44,,,,,,,3.0.18,4.0.13,,,,,0,,,,"Consider the following:
{code:groovy}
import static Type.setP as store
class Type {
  static p
}
@groovy.transform.CompileStatic
void test() {
  store('') // not recognized if Type is in same unit; property methods not there yet
}
test()
{code}",,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,groovy,Sun Jun 18 14:44:39 UTC 2023,,,,,,,,,,"0|z1imqo:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jun/23 14:44;emilles;https://github.com/apache/groovy/commit/ceb167a23e6843b1506cf4ad60a41686662bd16e;;;",,,,,,,,,,,
STC: closure param type inference for array and list,GROOVY-11089,13539336,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,emilles,emilles,08/Jun/23 21:10,12/Jun/23 15:14,13/Jul/23 08:58,09/Jun/23 18:12,4.0.12,,,,,,3.0.18,4.0.13,,Static Type Checker,,,0,,,,"Consider the following:
{code:groovy}
@groovy.transform.TypeChecked
void test() {
  (new String[]{'a','b'}).with { a, b -> } // throws MissingMethodException
  ['a','b'].with { a, b -> } // param count error
}
test()
{code}

1. STC thinks it can spread array elements across closure parameters, but this does not work.
2. STC thinks it cannot spread list elements across closure parameters, which does work (if length check is lifted).",,emilles,,,,,,,,,,,,,,,GROOVY-8499,GROOVY-11076,GROOVY-6939,,,,,GROOVY-11090,GROOVY-11092,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,groovy,Fri Jun 09 18:12:36 UTC 2023,,,,,,,,,,"0|z1ifg8:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Jun/23 18:12;emilles;https://github.com/apache/groovy/commit/68e16ff561a75ac84c465c127221a46108a84419;;;",,,,,,,,,,,
Missing symbol for package-private member under joint compilation,GROOVY-11088,13539300,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,emilles,emilles,08/Jun/23 14:59,08/Jun/23 18:08,13/Jul/23 08:58,08/Jun/23 17:14,3.0.17,4.0.12,,,,,3.0.18,4.0.13,,Stub generator / Joint compiler,,,0,,,,"Consider the following:
{code:groovy}
class C {
  @PackageScope static final String X = ""x""
}
{code}

Reference to ""C.X"" from a java class in the same package produces error:
{code}
Main.java:4: error: cannot find symbol
                            System.err.println(C.X);
                                                ^
      symbol:   variable X
      location: class C
    1 error
{code}

This has to do with stubgen running on an early compile phase.  In this case, there are no members to generate, only modifiers to adjust so we should be able to sniff this out and handle it special.",,emilles,,,,,,,,,,,,,,,GROOVY-7764,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Thu Jun 08 16:23:44 UTC 2023,,,,,,,,,,"0|z1if88:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Jun/23 16:23;emilles;https://github.com/apache/groovy/commit/9e23c5f21fb293707ae4d1d779d6606dc4b1be4c
https://github.com/apache/groovy/commit/548649ad03b51d96830ddaca89b1438fa0c7ce0b;;;",,,,,,,,,,,
STC: assignment of closure with untyped parameter to SAM-type (setter target),GROOVY-11085,13539106,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,emilles,emilles,07/Jun/23 14:10,07/Jun/23 14:32,13/Jul/23 08:58,07/Jun/23 14:32,3.0.17,,,,,,3.0.18,,,Static Type Checker,,,0,,,,"Consider the following:
{code:groovy}
void setStrategy(Predicate<Long> tester) {
  assert tester.test(1L)
}
strategy = { n -> n instanceof Long }
{code}

Compiler error: ""Incompatible generic argument types. Cannot assign Predicate<Object> to Predicate<Long>""",,emilles,,,,,,,,,,,,,,,GROOVY-11083,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Wed Jun 07 14:32:28 UTC 2023,,,,,,,,,,"0|z1ie14:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Jun/23 14:32;emilles;https://github.com/apache/groovy/commit/588d20ab494712d8260002e6d935dc5b26562a4c;;;",,,,,,,,,,,
STC: closure param's default not type-checked (method target),GROOVY-11083,13538960,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,emilles,emilles,06/Jun/23 18:36,07/Jun/23 14:12,13/Jul/23 08:58,06/Jun/23 21:11,,,,,,,4.0.13,,,Static Type Checker,,,0,,,,"Consider the following:
{code:groovy}
void setFoo(java.util.function.Consumer<Number> c) {}
@groovy.transform.TypeChecked
void test(Date d) {
  foo = { n = d -> }
}
{code}

The default value expression ""d"" is not compatible with the Number parameter ""n"".  There is no type-checking error for the call case.  Direct assignment is checked: ""java.util.function.Consumer<Number> c = \{ n = new Date() -> \}"" and ""def bar = \{ Number n = d -> \}""",,emilles,,,,,,,,,,,,,,,GROOVY-10072,,,,,,,GROOVY-11085,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue Jun 06 21:11:00 UTC 2023,,,,,,,,,,"0|z1id4o:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jun/23 21:11;emilles;https://github.com/apache/groovy/commit/1e0e8b98bd7418e7ba7d455394d9fd9f3a4a849a;;;",,,,,,,,,,,
Static type checking regression with implicit generics of inline maps,GROOVY-11080,13538831,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,lukebemish,lukebemish,05/Jun/23 22:10,06/Jun/23 13:38,13/Jul/23 08:58,06/Jun/23 13:32,4.0.12,,,,,,4.0.13,,,Static Type Checker,,,0,,,,"In 4.0.12, generic types of inline map definitions are no longer correctly inferred in situations where they would be under 4.0.11. For instance, the following:
{code:java}
@CompileStatic
class TypeCheckingTest {
    static final Map<String, Map<String, String>> testMap = [:]

    static test() {
        testMap.put(""test"", [:])
    }
}{code}
Fails to compile in 4.0.12, but compiles in 4.0.11. The error produced is:
{code:java}
10: [Static type checking] - Cannot find matching method java.util.Map#put(java.lang.String, java.util.LinkedHashMap<#K, #V>). Please check if the declared type is correct and if the method exists.
 @ line 10, column 9.
           testMap.put(""test"", [:])
           ^1 error {code}",,emilles,lukebemish,,,,,,,,,,,GROOVY-11028,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue Jun 06 13:32:04 UTC 2023,,,,,,,,,,"0|z1icc0:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jun/23 13:32;emilles;https://github.com/apache/groovy/commit/357a3020bac60dbc8015c251cc26b666459afbb0
https://github.com/apache/groovy/commit/77024ea1c171ebb6d5b2eb7d3878cf35d6e87120;;;",,,,,,,,,,,
GroovyCastException on closure implementing Consumer,GROOVY-11079,13538650,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,chrylis,chrylis,02/Jun/23 21:00,09/Jun/23 19:44,13/Jul/23 08:58,06/Jun/23 02:29,4.0.12,,,,,,4.0.13,,,Static compilation,,,0,,,,"I'm having trouble making a minimal repro for this one, but here's the actual code. Libraries are PDFBox (PDDocument) and Vavr. The bytecode problem seems to be that although 31 pushes {{null}} onto the stack, it's popped before being cast to {{Void}}, leaving the {{String}} on top. Shouldn't these be reversed?

{code}
loadOriginal(ep.payload)
  .onSuccess { sps.envelope.filename = it._1 }  // exception thrown at the end of this closure
  .<PDDocument> map(Tuple2::_2)
{code}

{code}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'dummy.pdf' with class 'java.lang.String' to class 'java.lang.Void'
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.continueCastOnSAM(DefaultTypeTransformation.java:424)
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.continueCastOnNumber(DefaultTypeTransformation.java:335)
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:255)
	at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321)
	at com.example.EsignFinisherImpl$_notifySignatureApplied_closure2$_closure11.doCall(EsignFinisherImpl.groovy:70)
{code}

{code}
  public java.lang.Void doCall(java.lang.Object);
    descriptor: (Ljava/lang/Object;)Ljava/lang/Void;
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=3, locals=3, args_size=2
         0: aload_1
         1: checkcast     #35                 // class io/vavr/Tuple2
         4: getfield      #38                 // Field io/vavr/Tuple2._1:Ljava/lang/Object;
         7: dup
         8: astore_2
         9: aload_0
        10: getfield      #27                 // Field sps:Lgroovy/lang/Reference;
        13: invokevirtual #44                 // Method groovy/lang/Reference.get:()Ljava/lang/Object;
        16: checkcast     #46                 // class SignaturePageSpec
        19: invokevirtual #50                 // Method SignaturePageSpec.getEnvelope:()LSignaturePageSpec$Envelope;
        22: aload_2
        23: invokedynamic #64,  0             // InvokeDynamic #0:cast:(Ljava/lang/Object;)Ljava/lang/String;
        28: invokevirtual #70                 // Method SignaturePageSpec$Envelope.setFilename:(Ljava/lang/String;)V
        31: aconst_null
        32: pop
        33: invokedynamic #72,  0             // InvokeDynamic #0:cast:(Ljava/lang/Object;)Ljava/lang/Void;
        38: areturn
{code}",,chrylis,emilles,,,,,,,,,,,,,,GROOVY-11068,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue Jun 06 02:29:42 UTC 2023,,,,,,,,,,"0|z1ib7s:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jun/23 21:08;chrylis;Update: This entire section is inside a {{forEach}}, which expects a {{Consumer}} (closure2), and I think perhaps the outside closure's void return may be ""pulling inside"" and leading to the compiler trying really hard to get a {{Void}} out of the nested closure.;;;","03/Jun/23 16:01;emilles;Can you show your whole test method up to the closure(s)?  It is hard to guess the structure from your description.

I have this, but all I get is another {{VerifyError}} case if I remove the type from ""doc"":
{code:groovy}
@Grab('org.apache.pdfbox:pdfbox:2.0.28')
import org.apache.pdfbox.pdmodel.*
@Grab('io.vavr:vavr:0.10.4')
import io.vavr.control.Try

Try<Iterable<PDPage>> extraPages() {
  Try.success([new PDPage()])
}

@CompileStatic
void test(List<PDDocument> docs) {
  docs.forEach { PDDocument doc ->
    extraPages().onSuccess {
      it.forEach(doc::addPage)
      doc.documentId = 1L
    }
  }
}

test([new PDDocument()])
{code};;;","03/Jun/23 17:09;emilles;In general, what is going on with ""tryVar.onSuccess \{ sps.envelope.filename = it._1 \}"" is that the value of ""it._1"" is the result of the whole assignment expression.  This is done via a transformation to {{PoppingMethodCallExpression}}, which is why you are seeing a pop for the null value that the void-return setter produces.  After that, the closure's ""doCall"" method casts the top operand to the inferred closure return type.  I am getting {{java.lang.Long}} but you have {{java.lang.Void}}.

In case of {{Void}} it should probably just pop the top operand and push {{null}}.;;;","03/Jun/23 17:39;emilles;What is the return type of your ""loadOriginal"" method?  As far as I can figure it's ""io.vavr.control.Try<io.vavr.Tuple2<java.lang.String, org.apache.pdfbox.pdmodel.PDDocument>>"".  You are adding a type argument in "".<PDDocument>.map(Tuple2::_2)"" which should not be necessary unless your tuple type is underspecified.

Not sure if it is confused by ""it._1"" vs ""it._1()"".  And where is ""filename"" or ""setFilename"" declared?;;;","05/Jun/23 20:33;emilles;Thanks for sending the extra information.  I am able to recreate like this:
{code:groovy}
@Grab('io.vavr:vavr:0.10.4')
import io.vavr.control.Try
import io.vavr.Tuple2

Map<String,Object> getSpec() { [:] }

Try<Tuple2<String,Object>> tuple() {
  Try.success( new Tuple2("""",null) )
}

@CompileStatic // GROOVY-11079
void test(List list) {
  list.forEach {
    def map = getSpec()
    tuple().onSuccess {
      map.foo = it._1
    }
  //.map(Tuple2::_2)
  }
}

test( [null] )
{code};;;","05/Jun/23 21:21;emilles;The closure shared variable ""sps"" in your example or ""map"" in mine cause a revisit, which is where the return type gets overwritten.  https://github.com/apache/groovy/blob/cfc22e46ce02ffde86fbd8401ba2b71e9dc71a48/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java#L2432

And here is where the re-visit return value is dropped: https://github.com/apache/groovy/blob/cfc22e46ce02ffde86fbd8401ba2b71e9dc71a48/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java#L2249;;;","06/Jun/23 02:29;emilles;https://github.com/apache/groovy/commit/8d2fe6889c8773f35e44c494a2fec91e7e696cb0
https://github.com/apache/groovy/commit/97ea854cf0ddd051060fc72edcaf1cbb37d19543;;;",,,,,
@ClosureParams for StringGroovyMethods.replaceFirst and StringGroovyMethods.replaceAll wrong,GROOVY-11076,13538550,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,vampire,vampire,02/Jun/23 09:07,12/Jun/23 15:13,13/Jul/23 08:58,09/Jun/23 18:12,3.0.17,,,,,,3.0.18,4.0.13,,,,,0,,,,"The {{@ClosureParams}} for {{StringGroovyMethods.replaceFirst}} and {{StringGroovyMethods.replaceAll}} seems to be wrong. It says {{​&#123;""List<String>"", ""String[]""&#125;​}}, so without static compilation IntelliJ shows a warning and with static compilation an error for the {{String it}} parts of
{code:groovy}
def pascalCasedWorkflowName = workflowName
    .replaceAll(/-\w/) { String it -> it[1].toUpperCase() }
    .replaceFirst(/^\w/) { String it -> it[0].toUpperCase() }
{code}
while it compiles and works perfectly fine. I'd guess it should be {{​&#123;""String"", ""List<String>"", ""String[]""&#125;​}}",,emilles,paulk,vampire,,,,,,,,,,,,,,,,,,,,GROOVY-11089,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Fri Jun 09 18:11:45 UTC 2023,,,,,,,,,,"0|z1ialk:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jun/23 10:12;emilles;When a closure is called with an array or iterable, the elements can be spread over the params. I think that is what’s happening in your case. ;;;","02/Jun/23 12:42;vampire;Ah, right, so it is an IntelliJ bug instead, that it does not recognize the spreading, right? Sorry.;;;","02/Jun/23 12:48;vampire;Reported as https://youtrack.jetbrains.com/issue/IDEA-321626;;;","02/Jun/23 16:46;emilles;{{replaceAll}} and {{replaceFirst}} delegate to this method: https://github.com/apache/groovy/blob/1d9f35a448a2a731499534841ffe64150e80744c/src/main/java/org/codehaus/groovy/runtime/StringGroovyMethods.java#L1521

It calls the supplied closure with a String (if no capturing group) or a list of String or an Object[] (if your closure signature matches).  So, as you assert, the {{ClosureParams}} metadata could be improved.  I don't know the history of when the metadata was added -- it may not be easy to sort out which of 3 options applies.

You can give it a try by creating a simple test wrapper.
{code:java}
public static String replaceAll(CharSequence sequence, Pattern pattern, @ClosureParams(value=FromString.class, options={""List<String>"",""Object[]"",""String""}) Closure closure) {
    return StringGroovyMethods.replaceAll(sequence, pattern, closure);
}
{code}

You have to call it like ""replaceAll('...', ~/.../, \{ -> ... \})"" not like an extension.;;;","02/Jun/23 23:38;vampire;I'm sure I just do something wrongly, but it seems to ignore the annotation and just accept all.
But anyway even if the one-String variant is explicitly used, the spreading would still be done wouldn't it?
So it is either way an IntelliJ bug and would cover both cases if fixed.;;;","03/Jun/23 00:18;emilles;The behavior of the implementation depends on the inputs, so it is not possible to type-check all possibilities. If your pattern lacks a capture group, then one String is how the closure is called. The String[] option may cover this in how the runtime executes the closure, or it may not. I’ll need to try a couple things to be sure. ;;;","03/Jun/23 11:02;paulk;""String[]"" should act like varargs, at least it used to, so ""String"" should be covered.
The ""Object[]"" is mainly to handle the dynamic default multiple args case with something like:
{code}
replaceAll(/-(\w)/) { all, w -> w.toUpperCase() }
{code}
We should probably just check for String[] as well as Object[] in getReplacement.;;;","09/Jun/23 18:11;emilles;I managed to find how the runtime does this.  In {{ClosureMetaClass#invokeMethod}} there is a fallback if the arguments cannot be matched to a {{doCall}} signature.  If there is one list argument, the runtime gets the length and tries that.  I am fixing STC to account for this and to stop thinking that arrays have this behavior.  See GROOVY-11089

So the examples will type-check and execute:
{code:groovy}
workflowName.replaceAll(/-\w/) { String s -> s[1].toUpperCase() }
{code}

https://github.com/apache/groovy/commit/68e16ff561a75ac84c465c127221a46108a84419;;;",,,,
The method pointer operator suppresses checked exceptions and results in a MethodMissingException,GROOVY-11075,13538139,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,astrogg,astrogg,30/May/23 16:52,30/May/23 21:34,13/Jul/23 08:58,30/May/23 20:47,4.0.12,,,,,,3.0.18,4.0.13,,,,,0,,,,"The method pointer operator suppresses checked exceptions and results in a MethodMissingException instead in groovy 4.0.12. This issue seems to first appear in groovy 3.0.16, which is the earliest version I am able to reproduce. Example code
{code:java}
class Foo {
    static void bar(String str) {
        throw new IOException()
        println str
    }
}
def baz = Foo.&bar

baz('hi') {code}
This results in a MethodMissingException despite the IO Exception being thrown. This seems to be the case for any checked exception.

 
{code:java}
class Foo {
    static void bar(String str) {
        throw new IOException()
        println str
    }
}

Foo.bar(""hi"") {code}
When calling the method directly I get an IO Exception as expected ",,astrogg,emilles,,,,,,,,,,,,,,GROOVY-10929,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue May 30 20:47:44 UTC 2023,,,,,,,,,,"0|z1i82w:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/May/23 20:47;emilles;https://github.com/apache/groovy/commit/a0aa62fd001e66863cec53f9a57668bed9094c0e;;;",,,,,,,,,,,
Cannot infer type of parameterized method when dealing with arrays,GROOVY-11073,13537787,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,theosot,theosot,26/May/23 09:56,31/May/23 16:15,13/Jul/23 08:58,31/May/23 16:12,,,,,,,5.0.0-alpha-1,,,Static Type Checker,,,0,,,,"I have the following code

{code}
class Main {
  static final void test() {
    double[] x = Tuple.tuple(org.codehaus.groovy.runtime.ArrayGroovyMethods.max((double[][]) null, { -> 1 })).getV1();
  }
}
{code}

h3. Actual behavior

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Main.groovy: 3: [Static type checking] - Cannot assign value of type (java.io.Serializable or java.lang.Cloneable) to variable of type double[]
 @ line 3, column 18.
       double[] x = Tuple.tuple(org.codehaus.groovy.runtime.ArrayGroovyMethods.max((double[][]) null, { -> 1 })).getV1();
                    ^

1 error
{code}

h3. Expected behavior

Compile successully

Tested against master (commit: 73c0f12ab35427bc3e7fd76929b482df61e1b80d)",,emilles,theosot,,,,,,,,,,,,,,GROOVY-5114,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Wed May 31 16:12:56 UTC 2023,,,,,,,,,,"0|z1i5x4:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/May/23 14:29;emilles;The overloads of greatest interest:
{code:java}
static <T> T max(T[] self)
static <T> T max(T[] self, Comparator<? super T> comparator)
static <T> T max(T[] self, @ClosureParams(value=FromString.class,options={""T"",""T,T""}) Closure<?> closure)
{code}
STC selects ""max(T[])"" and I think the intent was ""max(T[],Closure)"". [~paulk] has been experimenting with changing the closure variant to ""maxBy"". I tried changing the closure in the call to accept 1 or 2 params and added type arguments and was able to get STC to select the max-by variant. It is not easy to specify which you mean, so maybe this variant should be renamed to maxBy for Groovy 5+.

I will have a look at the param distance calculation, which should have a high-value match for ""(T[],Closure)"".

Also, this form seems to match as expected: ( (double[][])null ).max\{ 1 \};;;","31/May/23 16:12;emilles;https://github.com/apache/groovy/commit/ecf3d8c3dad01961373dcd28921d58d89245711e;;;",,,,,,,,,,
Unable to compile: Expected type for closure parameter ,GROOVY-11072,13537759,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,lepe,lepe,26/May/23 07:06,26/May/23 22:42,13/Jul/23 08:58,26/May/23 21:10,3.0.12,3.0.13,3.0.14,3.0.15,3.0.16,3.0.17,3.0.18,4.0.13,,Compiler,,,0,compile-error,CompileStatic,parameters,"This code is unable to compile, throwing the exception:
{code:java}
Main.groovy: 15: 22: [Static type checking] - Expected type java.util.List<T> for closure parameter: list
 @ line 22, column 17.
                   List<String> list ->
                   ^ 

Main.groovy: 17: [Static type checking] - Expected type java.lang.Object for closure parameter: tm
 @ line 17, column 21.
                       TestModel tm ->
                       ^

Main.groovy: 18: [Static type checking] - No such property: id for class: java.lang.Object
 @ line 18, column 33.
                           println(tm.id)
                                   ^{code}
Code:
{code:java}
@CompileStatic
class Main {
    static void main(String[] args) {
        TestTable table = new TestTable()
        table.getAll({
            List<TestModel> list ->
                list.each {
                    TestModel tm ->
                        println(tm.id)
                }
        })
    }
}{code}
This is a simplified version of my code which worked fine in 3.0.11, it failed first on 3.0.12 including 4.x. 

I have prepared a git project with the minimum code at:

[https://gitlab.com/intellisrc/groovy-compile-error2]

In _build.gradle_ you can change between 3.0.11 and 4.0.12 versions

 ","Ubuntu 22.04
Java 11",emilles,lepe,,,,,,,,,,,,,,GROOVY-11013,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,groovy,Fri May 26 21:10:06 UTC 2023,,,,,,,,,,"0|z1i5qw:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/May/23 21:10;emilles;https://github.com/apache/groovy/commit/859955225b22c20271d3ff1b12344edfb375258d;;;",,,,,,,,,,,
Compiler error related to getAt and interface methods,GROOVY-11071,13537463,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,hussdl,hussdl,24/May/23 10:02,24/May/23 20:12,13/Jul/23 08:58,24/May/23 20:12,3.0.17,4.0.12,,,,,5.0.0-alpha-1,,,class generator,,,0,,,,"*Error message:*
{code:none}
BUG! exception in phase 'class generation' in source unit '...Reproducer.groovy' At line 11 column 21
On receiver: myMap with message: getAt and arguments: new Reproducer$Key()
This method should not have been called. {code}
*Simple example reproducing the error:*
{code:groovy}
import groovy.transform.CompileStatic
import org.junit.jupiter.api.Test

@CompileStatic
class Reproducer {

    @Test
    void reproduce() {
        MyMap myMap = null
        try {
            println(myMap[new Key()].toString())
        } catch (NullPointerException ignored) {
            // Expected
        }
    }

    static class Key {}

    static interface SomeMap<SELF extends SomeMap<SELF, K, V>, K, V> {
        V getAt(K key);
    }

    static interface MyMap extends SomeMap<MyMap, Key, Object> {}
}
 {code}",,emilles,hussdl,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Wed May 24 20:12:25 UTC 2023,,,,,,,,,,"0|z1i3xc:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/May/23 19:16;emilles;You can re-declare ""Object getAt(Key key)"" on {{MyMap}} to have it discovered by the current release.;;;","24/May/23 20:12;emilles;https://github.com/apache/groovy/commit/73c0f12ab35427bc3e7fd76929b482df61e1b80d;;;",,,,,,,,,,
VerifyError when using generic container in closure,GROOVY-11068,13537373,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,chrylis,chrylis,23/May/23 17:00,03/Jun/23 15:49,13/Jul/23 08:58,28/May/23 14:54,4.0.12,,,,,,3.0.18,4.0.13,,Static compilation,,,0,VerifyError,,,"The following code produces a {{VerifyError}}. It appears to this amateur eye that the code in the closure actually performs an {{invokedynamic}} on the nested method reference and _then_ calls the Iterable's {{forEach}}, when I would expect it to push a reference to the method handle somehow and then let that be passed to {{forEach}}.
{code:groovy}
@Grab('org.apache.pdfbox:pdfbox:2.0.28')
import org.apache.pdfbox.pdmodel.*
@Grab('io.vavr:vavr:0.10.4')
import io.vavr.control.Try
@CompileStatic
@POJO
class Bug {
    public static void main(String... args) {
        PDDocument doc = new PDDocument()
        extraPages().forEach {
            it.forEach(doc::addPage)
        }
    }
    static Try<Iterable<PDPage>> extraPages() {
        return Try.success([null]) // value present only to cause the iteration to proceed; NPE is the expected outcome here
    }
}
{code}

{code}
java.lang.VerifyError: Bad type on operand stack
Exception Details:
  Location:
    Bug$_main_closure1.doCall(Ljava/lang/Object;)Ljava/lang/Void; @11: invokedynamic
  Reason:
    Type 'java/lang/Object' (current frame, stack[1]) is not assignable to 'org/apache/pdfbox/pdmodel/PDDocument'
  Current Frame:
    bci: @11
    flags: { }
    locals: { 'Bug$_main_closure1', 'java/lang/Object' }
    stack: { 'java/lang/Iterable', 'java/lang/Object' }
  Bytecode:
    0000000: 2bc0 0024 2ab4 001c b600 2aba 003f 0000
    0000010: b900 4302 0001 ba00 5000 00b0          

	at Bug.main(Bug.groovy:16)
{code}

{code}
  public java.lang.Void doCall(java.lang.Object);
    descriptor: (Ljava/lang/Object;)Ljava/lang/Void;
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_1
         1: checkcast     #36                 // class java/lang/Iterable
         4: aload_0
         5: getfield      #28                 // Field doc:Lgroovy/lang/Reference;
         8: invokevirtual #42                 // Method groovy/lang/Reference.get:()Ljava/lang/Object;
        11: invokedynamic #63,  0             // InvokeDynamic #0:accept:(Lorg/apache/pdfbox/pdmodel/PDDocument;)Ljava/util/function/Consumer;
        16: invokeinterface #67,  2           // InterfaceMethod java/lang/Iterable.forEach:(Ljava/util/function/Consumer;)V
        21: aconst_null
        22: invokedynamic #80,  0             // InvokeDynamic #1:cast:(Ljava/lang/Object;)Ljava/lang/Void;
        27: areturn
      LineNumberTable:
        line 17: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      28     0  this   LBug$_main_closure1;
            0      28     1    it   Ljava/lang/Object;
    MethodParameters:
      Name                           Flags
      it
{code}",,chrylis,emilles,,,,,,,,,,,,,,,,,,,,,GROOVY-11079,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Sun May 28 14:54:01 UTC 2023,,,,,,,,,,"0|z1i3dc:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/May/23 14:54;emilles;https://github.com/apache/groovy/commit/40231c26be588c971a3fc36061f8ea88feeb0d2f
https://github.com/apache/groovy/commit/cfc22e46ce02ffde86fbd8401ba2b71e9dc71a48;;;",,,,,,,,,,,
NPE in ListHashMap,GROOVY-11063,13536597,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,weih,weih,17/May/23 16:32,18/May/23 13:18,13/Jul/23 08:58,17/May/23 22:56,4.0.12,,,,,,4.0.13,,,,,,0,,,,"Stacktrace:
{code:java}
java.lang.NullPointerException
at org.codehaus.groovy.util.ListHashMap.get(ListHashMap.java:120)
at org.codehaus.groovy.ast.NodeMetaDataHandler.getNodeMetaData(NodeMetaDataHandler.java:44){code}
 

It's fixed on master branch with commit 923f680d769f236a543e622121c7fa3b4badcd56, but wasn't backported to 4.x branch.",,emilles,weih,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Wed May 17 22:56:25 UTC 2023,,,,,,,,,,"0|z1hyl4:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/May/23 22:56;emilles;https://github.com/apache/groovy/commit/923f680d769f236a543e622121c7fa3b4badcd56
https://github.com/apache/groovy/commit/62097da6116edb5d55a72c02c1a33042137e07d7;;;",,,,,,,,,,,
Annotation collection isn't properly handling enum annotation attribute values,GROOVY-11062,13536508,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,17/May/23 07:57,22/May/23 00:40,13/Jul/23 08:58,22/May/23 00:40,,,,,,,3.0.18,4.0.13,,class generator,Stub generator / Joint compiler,,0,,,,"The easiest way to reproduce is to change the definition of `Immutable`.

 Change the line:

{code}
@TupleConstructor(defaults = false)
{code}

to:

{code}
@TupleConstructor(defaultsMode = DefaultsMode.OFF)
{code}

The first error is to do with stub generation:
{noformat}
subprojects/groovy-macro/build/tmp/compileGroovy/groovy-java-stubs/org/codehaus/groovy/macro/matcher/MatchingConstraints.java:3: error: incompatible types: String cannot be converted to DefaultsMode
@groovy.transform.CompileStatic() @groovy.transform.ToString(includeSuperProperties=true, cache=true) @groovy.transform.EqualsAndHashCode(cache=true) @groovy.transform.ImmutableBase() @groovy.transform.Final() @groovy.transform.ImmutableOptions(knownImmutableClasses={org.codehaus.groovy.macro.matcher.internal.ConstraintPredicate.class}) @groovy.transform.PropertyOptions(propertyHandler=groovy.transform.options.ImmutablePropertyHandler.class) @groovy.transform.TupleConstructor(defaultsMode=""OFF"") @groovy.transform.MapConstructor(noArg=true, includeSuperProperties=true, includeFields=true) @groovy.transform.KnownImmutable() public class MatchingConstraints
                                                                                                                                                                                                                                                                                                                                                                        
              ^
1 error
startup failed:
Compilation failed; see the compiler error output for details.
{noformat}

Once that is fixed, the next error surfaces which is once the `compileTestGroovy` task is executed:
{noformat}
General error during instruction selection: Cannot generate bytecode for constant: OFF of type: groovy.transform.DefaultsMode

org.codehaus.groovy.classgen.ClassGeneratorException: Cannot generate bytecode for constant: OFF of type: groovy.transform.DefaultsMode
        at org.codehaus.groovy.classgen.asm.OperandStack.pushConstant(OperandStack.java:513)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstantExpression(AsmClassGenerator.java:897)
        at org.codehaus.groovy.ast.expr.ConstantExpression.visit(ConstantExpression.java:82)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitMapExpression(AsmClassGenerator.java:1615)
        at org.codehaus.groovy.ast.expr.MapExpression.visit(MapExpression.java:54)
...
{noformat}

",,emilles,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Sun May 21 06:44:39 UTC 2023,,,,,,,,,,"0|z1hy1c:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/May/23 11:55;emilles;defaults and defaultsMode are not considered together. I have a bit of code to look at DefaultsMode in unresolved situation. You can have a look at groovy-eclipse repository’s base folder. [https://github.com/groovy/groovy-eclipse/blob/98135b353ad1f3f7409f0d492a8f17db8b1c4fca/base/org.codehaus.groovy50/src/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java#L396];;;","21/May/23 06:44;githubbot;paulk-asert merged PR #1890:
URL: https://github.com/apache/groovy/pull/1890


;;;",,,,,,,,,,
SC internal error when spreading inside list literal,GROOVY-11060,13536323,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,chrylis,chrylis,15/May/23 22:12,22/May/23 17:10,13/Jul/23 08:58,22/May/23 17:07,4.0.12,,,,,,5.0.0-alpha-1,,,Static compilation,,,0,,,,"Spreading a list inside brackets causes a {{SpreadExpression should not be visited here}} during class generation. (The business instance of this is trying to use a list of URL patterns for Spring {{antMatchers}}.)

{code}
@CompileStatic
class Bug {
    public static final List<String> A = ['a1', 'a2']

    static void varargs(String... strings) {
        println Arrays.toString(strings)
    }

    public static void main(String... args) {
        varargs([
            *A
        ] as String[])
    }
}
{code}",,chrylis,emilles,,,,,,,,,,,,,,GROOVY-10597,GROOVY-10599,,,,,,GROOVY-11067,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Mon May 22 17:07:37 UTC 2023,,,,,,,,,,"0|z1hwwg:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/May/23 02:32;emilles;You should be able to do “A as String[]” or “A.toArray(String)” — I’d have to double check the availability of the toArray DGM. ;;;","17/May/23 03:02;chrylis;I have a workaround with ""plus"", so it's not a blocker, just clunky.


;;;","17/May/23 11:52;emilles;What’s clunky? The plus sequence? The spread into list in the example creates a list. Then you as into an array. -Now that I look at it, you should be able to just use *A as your argument expression.-
{code:groovy}
@CompileStatic
class Groovy11060 {
  public static final List<String> A_LIST = ['a1', 'a2']

  static void varargs(String... strings) {
    println Arrays.toString(strings)
  }

  static main(args) {
    varargs(*A_LIST) // GROOVY-10597
    varargs(A_LIST as String[])
    varargs(A_LIST.toArray(new String[0]))
  }
}
{code};;;","17/May/23 15:21;chrylis;The code in the description is an MCVE. The actual use case is 

{code}
antMatchers([
  '/health',
  *STATIC_RESOURCES,
  *PUBLIC_ENDPOINTS
] as String)
{code}

which is a workaround for GROOVY-10597. I can use {{(['/health'] + STATIC_RESOURCES + PUBLIC_ENDPOINTS) as String[]}} for now.;;;","17/May/23 15:42;emilles;Thanks.  The extra bit of context is helpful.  Sometimes minimal to trigger the error is too minimal to understand intent/usage.  I take it the docs for list literals, spread arguments and static compilation are sparse for this case.  In general, spread arguments are not well supported by static compilation – de-spreading is a {{ScriptBytecodeAdapter}} operation (which indicates run-time behavior).;;;","20/May/23 15:41;emilles;The root issue is missing support for spread in arrays. `['x', *Y] as String[]` is transformed to `new String[]\{'x', *Y}` in {{{}CastExpressionOptimizer{}}}. If you break it up as `List<String> list = ['x', *Y]; antMatchers(list as String[])` it works.;;;","22/May/23 17:07;emilles;https://github.com/apache/groovy/commit/ce62aff0e69cc2da564d9a340c7826d3e419289c;;;",,,,,
STC Generic type matching failure,GROOVY-11057,13536166,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,jhunovis,jhunovis,15/May/23 06:18,06/Jun/23 13:30,13/Jul/23 08:58,18/May/23 15:58,4.0.12,,,,,,4.0.13,,,Compiler,,,0,,,,"With Groovy version 4.0.12 this code will no longer compile:

 
{code:java}
import groovy.transform.CompileStatic
import org.junit.jupiter.api.Test
import org.mockito.Mockito

@CompileStatic
interface Configuration {
  Map<String, Object> getSettings()
}

@CompileStatic
class GenericMapStubbing {

  @Test
  void stubSettings() {
    def configuration = Mockito.mock(Configuration).tap {
      Mockito.when(it.getSettings()).thenReturn([:])
    }

    assert configuration.settings.isEmpty()
  }
} {code}
Failure message:

 

18: [Static type checking] - Cannot find matching method org.mockito.stubbing.OngoingStubbing#thenReturn(java.util.LinkedHashMap<#K, #V>). Please check if the declared type is correct and if the method exists.
 @ line 16, column 7.
         Mockito.when(it.getSettings()).thenReturn([:])",,emilles,jhunovis,,,,,,,,,,,GROOVY-11028,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Thu May 18 15:58:49 UTC 2023,,,,,,,,,,"0|z1hvxs:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/May/23 17:18;emilles;Do you need the map to be mutable?  You should be able to replace ""[:]"" with ""Collections.emptyMap()"".;;;","16/May/23 05:34;jhunovis;The `emptyMap` works, but the code was that way before the compiler update. I prefer the `[:]` in tests, though. It looks nice.;;;","16/May/23 15:59;emilles;I will be taking a look this week -- just wanted to know if there was a difference between empty map literal and empty map factory method.  The goal was to have them work the same.;;;","18/May/23 13:20;emilles;I think the problem is in {{GenericsUtils#parameterizeType}} which produces {{Map<#,#>}} from {{LinkedHashMap<#K,#V>}}.;;;","18/May/23 15:58;emilles;https://github.com/apache/groovy/commit/357a3020bac60dbc8015c251cc26b666459afbb0;;;",,,,,,,
modified behavior of variable resolution within Closure ,GROOVY-11056,13536153,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,ninside,ninside,15/May/23 02:55,16/May/23 17:10,13/Jul/23 08:58,16/May/23 15:43,2.5.22,3.0.16,4.0.0,,,,2.5.23,3.0.18,4.0.13,groovy-runtime,,,0,,,,"Groovy stopped seeing statically imported instances when called within Closure within Closure. And instead it thinks it is some method call.

Below is the example to repro. At the moment it affects all our users written test scripts and we rolled back to 3.0.15 where behavior is still as expected.

Tried various closure resolution strategies to no result 
{code:java}
import static org.testingisdocumenting.webtau.persona.ReproPersonaList.Admin

class ClosureResolveRepro {
    static void main(String[] args) {
        def LocalAdmin = new ReproPersona(""local-admin"")

        wrapper {
            LocalAdmin { // <-- no issue here as it can correctly see LocalAdmin
            }
        }

        wrapper {
            Admin { // <--- issue is here, for some reason it doesn't see statically imported instance. It works as expected in 3.0.15
            }
        }
    }

    private static void wrapper(Closure code) { // this wrapper is required to reproduce 
        code.run()
    }
}
 {code}
{code:java}
person: local-adminException in thread ""main"" groovy.lang.MissingMethodException: No signature of method: org.testingisdocumenting.webtau.persona.ClosureResolveRepro$_main_closure2.Admin() is applicable for argument types: (org.testingisdocumenting.webtau.persona.ClosureResolveRepro$_main_closure2$_closure4) values: [org.testingisdocumenting.webtau.persona.ClosureResolveRepro$_main_closure2$_closure4@40f08448]Possible solutions: find(), dump(), find(), dump(), any(), any() at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:380) at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1035) at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:73) at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:51) at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:171) at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:185) at org.testingisdocumenting.webtau.persona.ClosureResolveRepro$_main_closure2.doCall(ClosureResolveRepro.groovy:31) at org.testingisdocumenting.webtau.persona.ClosureResolveRepro$_main_closure2.doCall(ClosureResolveRepro.groovy) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:107) at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:323) at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:274) at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1035) at groovy.lang.Closure.call(Closure.java:412) at groovy.lang.Closure.call(Closure.java:406) at groovy.lang.Closure.run(Closure.java:493) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:107) at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:323) at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:274) at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1035) at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:38) at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:47) at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:53) at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:130) at org.testingisdocumenting.webtau.persona.ClosureResolveRepro.wrapper(ClosureResolveRepro.groovy:37) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:107) at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite$StaticMetaMethodSiteNoUnwrapNoCoerce.invoke(StaticMetaMethodSite.java:149) at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.callStatic(StaticMetaMethodSite.java:100) at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallStatic(CallSiteArray.java:55) at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:217) at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:231) at org.testingisdocumenting.webtau.persona.ClosureResolveRepro.main(ClosureResolveRepro.groovy:30)
{code}
 
{code:java}
class ReproPersona {
    private String id

    ReproPersona(String id) {
        this.id = id
    }

    void call(Closure code) {
        println ""person: $id""
    }
} {code}
{code:java}
class ReproPersonaList {
    public static def Admin = new ReproPersona(""admin"")
} {code}
 ",,emilles,ninside,,,,,,,,,,,GROOVY-10329,,,GROOVY-8389,GROOVY-3945,GROOVY-7490,GROOVY-7701,GROOVY-9655,GROOVY-9768,GROOVY-9683,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue May 16 15:43:24 UTC 2023,,,,,,,,,,"0|z1hvv4:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/May/23 18:44;emilles;Thanks for the issue.  It works when ""Admin"" is declared as a method that accepts closure.  We must have missed something for the static field case.;;;","15/May/23 18:56;emilles;Here is where {{StaticImportVisitor}} finds the static field import, but chooses to skip:
{code:java}
        String name = method.getText();
        Map<String, ImportNode> staticImports = currentClass.getModule().getStaticImports();
        // look for one of these:
        //   import static MyClass.field [as alias]
        //   import static MyClass.method [as alias]
        //   import static MyClass.property [as alias]
        // when resolving implicit-this call name(args)
        if (staticImports.containsKey(name)) {
            ImportNode importNode = staticImports.get(name);
            expression = findStaticMethod(importNode.getType(), importNode.getFieldName(), args);
            if (expression != null) {
                return expression;
            }
            if (!inClosure && !inLeftExpression) { // *** inClosure is true for ""Admin"" ***
                expression = findStaticPropertyOrField(importNode.getType(), importNode.getFieldName());
                if (expression != null) { // assume name refers to a callable static field/property
                    MethodCallExpression call = new MethodCallExpression(expression, ""call"", args);
                    call.setImplicitThis(false);
                    return call;
                }
            }
        }
{code}

https://github.com/apache/groovy/blame/c793a80e9160ca31a225948f256b3de953e6e1da/src/main/java/org/codehaus/groovy/control/StaticImportVisitor.java#L450;;;","15/May/23 21:53;emilles;If you need this to work with Groovy 3.0.16, you can replace ""Admin"" with ""Admin.call"" or you could declare ""def GlobalAdmin = Admin, LocalAdmin = new ReproPersona('local-admin')"".;;;","15/May/23 23:42;ninside;It is a good suggestion. Unfortunately it is users scripts that are failing and I don’t have access to. So I temporarily rolled back version bump. My end goal is to move to groovy 4. ;;;","16/May/23 13:23;emilles;I ran some tests yesterday and the ""!inClosure"" checks are not tied to any test cases.  I think the intent was to let a closure's resolve strategy handle name resolution.  For example:
{code:groovy}
import static p.T.name
one {
  two {
    name()
  }
}
{code}

Depending on the resolution strategies of the ""one"" and ""two"" methods, ""name"" might be coming from a delegate object.  GROOVY-8389 is where the check first came up.  That issue does not specifically indicate ""within closure"" so I think it was just a precaution on the part of the implementer.

I have one more bug ticket to track down (and link) that discusses the precedence between static field and closure delegate.;;;","16/May/23 14:00;emilles;The prevailing wind seems to be let closures take first crack at name resolution.  However, in this case, if ""name()"" (from my example) or ""Admin \{"" (from yours) is not transformed into "".call(..)"" form by {{StaticImportVisitor}}, there is no path to resolving at runtime to the imported member.  I think SC/STC depends on the transformation as well.;;;","16/May/23 15:43;emilles;https://github.com/apache/groovy/commit/7a118010591ca469f0394d8d6946b44201d04ebd;;;",,,,,
Method ambiguity error when having methods with primitive arrays and varargs,GROOVY-11053,13535815,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,theosot,theosot,11/May/23 13:43,29/May/23 20:23,13/Jul/23 08:58,29/May/23 15:40,,,,,,,3.0.18,4.0.13,,Static Type Checker,,,0,overloading,varargs,,"I have the following program (it uses the apache-commons-lang3 library)

{code}
class Main {
  static final void test() {
    final byte[] vetting = new byte[1];
    final byte[] grafting = org.apache.commons.lang3.ArrayUtils.removeAll(vetting); // works 
    final byte[] grafting = org.apache.commons.lang3.ArrayUtils.removeAll(vetting, 0); // fails 
  }
}
{code}

h3. Actual behavior

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
groovy38.groovy: 4: [Static type checking] - Reference to method is ambiguous. Cannot choose between [byte[] org.apache.commons.lang3.ArrayUtils#removeAll(byte[], int[]), long[] org.apache.commons.lang3.ArrayUtils#removeAll(long[], int[]), float[] org.apache.commons.lang3.ArrayUtils#removeAll(float[], int[]), double[] org.apache.commons.lang3.ArrayUtils#removeAll(double[], int[]), int[] org.apache.commons.lang3.ArrayUtils#removeAll(int[], int[]), short[] org.apache.commons.lang3.ArrayUtils#removeAll(short[], int[])]
 @ line 4, column 29.
       final byte[] grafting = org.apache.commons.lang3.ArrayUtils.removeAll(vetting, 0);
                               ^

1 error
{code}

h3. Expected behavior

Compile successfully

h3. Tested against master (commit: 7a4b2679c77aea8cd9dc00fa2d3b71e25e97fbd2)",,emilles,theosot,,,,,,,,,,,,,,GROOVY-10720,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Mon May 29 15:40:06 UTC 2023,,,,,,,,,,"0|z1htxs:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/May/23 15:40;emilles;https://github.com/apache/groovy/commit/7ccc3057cd675651710fad8721af3a46a9e8bdce;;;",,,,,,,,,,,
Static compiler does not coerce Groovy truth from closures,GROOVY-11051,13535692,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,chrylis,chrylis,10/May/23 20:01,30/May/23 17:48,13/Jul/23 08:58,30/May/23 17:17,4.0.12,,,,,,5.0.0-alpha-1,,,Static compilation,,,0,,,,"The static compiler will accept a closure returning a non-boolean value as fulfilling a {{Predicate}}, but it does not coerce the return value using Groovy truth.

{code}
@CompileStatic
class Bug {
    static void main(String[] args) {
        println new AtomicReference<Object>(null).stream()
            .filter( { it.get() } as Predicate<AtomicReference<?>>)
      // or .filter(AtomicReference::get as Predicate<AtomicReference<?>>)
            .findAny()
    }
}
{code}

Expected result: {{Optional.empty}}
Actual result: NullPointerException on unboxing the {{null}} return value

Using an explicit {{as boolean}} inside the lambda works, but this doesn't work with method references. Coercion should work even without {{as Predicate}} if the compiler sees the functional return type is boolean/Boolean.",,chrylis,emilles,,,,,,,,,,,,,,GROOVY-8168,GROOVY-9971,GROOVY-10792,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue May 30 17:17:26 UTC 2023,,,,,,,,,,"0|z1ht6g:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/May/23 01:38;emilles;This is the STC closure return type check.  https://github.com/apache/groovy/blob/7ccc3057cd675651710fad8721af3a46a9e8bdce/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java#L2256

There are a few limited cases allowed like simple covariance and GString to String.  {{boolean}} is explicitly skipped.;;;","30/May/23 17:17;emilles;https://github.com/apache/groovy/commit/f1aef96fed3d8911afba1d160ce07ff085e14dc2;;;",,,,,,,,,,
SC: property access within closure produces cast exception,GROOVY-11044,13535041,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,emilles,emilles,04/May/23 17:54,04/May/23 23:51,13/Jul/23 08:58,04/May/23 18:29,4.0.12,,,,,,4.0.12,,,Static compilation,,,0,,,,"Consider the following:
{code:groovy}
class Bar {
  @groovy.beans.Bindable
  String baz
  String other
}
class Foo {
  Bar bar
  @groovy.beans.Bindable
  String foo
  @groovy.transform.CompileStatic
  void postConstruct() {
    bar = new Bar()
    bar.with {
      addPropertyChangeListener('baz') { event ->
        other = 'value' // ClassCastException: class Foo cannot be cast to class Bar
        print 'changed'
      }
    }
    print 'ready;'
  }
}

Foo foo = new Foo()
foo.postConstruct()
foo.getBar().setBaz('xxx')
{code}",,emilles,,,,,,,,,,,,GROOVY-11029,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Thu May 04 18:29:16 UTC 2023,,,,,,,,,,"0|z1hp60:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/May/23 18:29;emilles;https://github.com/apache/groovy/commit/6177f7cf55b0eaec573e39624d8549ae5c68da55;;;",,,,,,,,,,,
Incorrect property handling for records,GROOVY-11041,13534647,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,02/May/23 05:54,09/May/23 13:59,13/Jul/23 08:58,03/May/23 21:13,,,,,,,4.0.12,,,record,,,0,,,,"While it is not normal to override record component getters, it is perfectly allowable.

 

The following record is getting both an ""x()"" method and a ""getX()"" method. The supplied ""x()"" method isn't being associated correctly with the property.
{code:java}
record Foo(String x, String y) {
    String x() {
        'z'
    }
} {code}",,emilles,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Thu May 04 15:06:02 UTC 2023,,,,,,,,,,"0|z1hmqo:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/May/23 15:06;emilles;https://github.com/apache/groovy/commit/aa794aa1c8fa8a4ed7b35c81f988408ddd97332e;;;",,,,,,,,,,,
StackOverflowError in cyclic interface inheritance,GROOVY-11036,13534428,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,theosot,theosot,28/Apr/23 08:57,01/May/23 17:27,13/Jul/23 08:58,01/May/23 17:16,,,,,,,3.0.18,4.0.12,,Static Type Checker,,,0,StackOverflowError,,,"I have the following program

{code}
interface Bar {}
interface Foo extends Foo, Bar {}
{code}

h3. Actual behavior

{code}
>>> a serious error occurred: null
>>> stacktrace:
java.lang.StackOverflowError
	at org.codehaus.groovy.ast.ClassNode.getText(ClassNode.java:1606)
	at org.codehaus.groovy.ast.ClassNode.hashCode(ClassNode.java:734)
	at org.codehaus.groovy.ast.ClassNode.hashCode(ClassNode.java:734)
	at java.base/java.util.HashMap.hash(HashMap.java:339)
	at java.base/java.util.HashMap.put(HashMap.java:607)
	at java.base/java.util.HashSet.add(HashSet.java:220)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:466)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
	at org.codehaus.groovy.ast.ClassNode.getAllInterfaces(ClassNode.java:470)
{code}

h3. Expected behavior

Reject due to cyclic inheritance.

Tested against master (commit: ed4b33c8d5ac71ee4963d6bb391850593c59e5b1)",,emilles,theosot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Mon May 01 17:16:18 UTC 2023,,,,,,,,,,"0|z1hleg:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/May/23 17:16;emilles;https://github.com/apache/groovy/commit/ba1e5010fa12713868a3507a107695549e4e0046;;;",,,,,,,,,,,
CompileStatic: string concatenation in method parameter default value results in NoSuchMethodError,GROOVY-11030,13534348,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,jasongarrett,jasongarrett,27/Apr/23 17:57,27/Apr/23 19:19,13/Jul/23 08:58,27/Apr/23 19:17,4.0.11,4.0.9,,,,,4.0.12,,,Compiler,Static compilation,,0,,,,"If a method parameter's default value is defined by concatenating a String literal to a String variable, calling the method throws java.lang.NoSuchMethodError.
{code:java}
import groovy.transform.CompileStatic
import spock.lang.Specification

@CompileStatic  // works without CompileStatic
class MyClass {
    String makePlural(String word, String plural = word + ""s"") {  // java.lang.NoSuchMethodError: 'java.lang.String java.lang.String.plus(java.lang.CharSequence)'
        return plural
    }
}

class Test extends Specification {
    def test() {
        setup:
            MyClass myObj = new MyClass()
        expect:
            myObj.makePlural(""word"") == ""words""
    }
}    {code}
[Live demo.|https://gwc-experiment.appspot.com/?g=groovy_4_0&codez=eJxdUMFugzAMvecrLC4FbaL3SkiTqh3bTWI_kAUDKZAwJ5Siqv--kIZ2zBcn79nP9pNdr8lCRVqfp9QSV6bU1KV73fWyxdxyKwWT9yrTa9GkLVdVmvcoZCmFo7Vi7G1VD7DdwqipMTBKW-vBwlpPtNwYOEx7n68MXOSWpKqg4w1-tgPxNg6IEypeF7r3FGQehReITJTA1Q888TO_L3fU-SDqA7rRxTuRph1snmxQ-g-kTtrET3Rfc8rxZ0AlMNn4FecgtAOpsIdHb-zGwkVfaCzgxaIqDKwsCkcWWIJ1RXESgDmMk-x3j-8cizXd9PF9ctcqHBcsTh6VeHEj7LrTd6R_XIxmp5xJWQb-aaJl6zn9AvUzpMc]

A workaround is to do the concatenation in a GString:
{code:java}
String makePlural(String word, String plural = ""${word}s"") { {code}",,emilles,jasongarrett,,,,,,,,,,,,,,GROOVY-11023,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Thu Apr 27 19:19:26 UTC 2023,,,,,,,,,,"0|z1hkww:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Apr/23 18:27;emilles;Could you retest with Groovy 4.0.12 snapshot?  I think the 4/24 will do.  I just fixed a case like this where an extension method was targeted by the default value expression.

https://repository.apache.org/content/repositories/snapshots/org/apache/groovy/groovy/4.0.12-SNAPSHOT/;;;","27/Apr/23 19:08;jasongarrett;Yes – I confirm that this does work as expected on 4.0.12-SNAPSHOT.;;;","27/Apr/23 19:19;emilles;Until you pick up 4.0.12, I think you can write `word + ""s""` as `word.concat(""s"")` and it will steer clear of the extension method bug.;;;",,,,,,,,,
SC: super property is not accessible by a subclass that defines a getter and setter,GROOVY-11029,13534343,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,jasongarrett,jasongarrett,27/Apr/23 16:45,04/May/23 17:56,13/Jul/23 08:58,28/Apr/23 16:47,4.0.11,,,,,,3.0.18,4.0.12,,Compiler,Static compilation,,0,,,,"If a class defines a default-visibility property and a subclass declares a getter and a setter for that property, the subclass cannot access super's property.
{code:java}
import groovy.transform.CompileStatic
import spock.lang.Specification

class Foo {
    Object myThing
}

@CompileStatic  // everything works without CompileStatic
class Bar extends Foo {
    void setMyThing(Object list) {
        super.myThing = list
    }
    
    Object getMyThing() {
        return super.myThing as List  // groovy.lang.MissingPropertyException: No such property: myThing for class: Bar
//        return super.@myThing as List  // [Static type checking] - The field Foo.myThing is not accessible
    }
}

class BarTest extends Specification {
    def ""myThing""() {
        when:
            Bar bar = new Bar()
            List list = []
            bar.myThing = list
        then:
            bar.myThing.is(list)
    }
}{code}
[Live Demo|https://gwc-experiment.appspot.com/?g=groovy_4_0&codez=eJxtUUFuwjAQPNevWHGCQ8M9EhJq1Z5KWwluiENwNolLYlv2Qogq_l7bGEgKK9mSM5OZ3VnRaGUISqPUoUvIZNIWyjTJq2q0qHFJGQnOxJllteK7pM5kmSw1clEI7mAlGeN1Zi28KwW_DFx9bX-QEzTdqhKyZCfG5gNFgOkU8ICmI0-AVpmdhVZQpfYEQ_Oz9ktmAI-EMu_7HJTIwSItzkbj6FsLS5NI8WX3Gk0Su4FZwAN4Cne_5fIm1lcwSHsj_wllFj6cUhgmJhjCWQhrHf5tlGNT93bkqH1OKXwqJ8Er0BFKLxGBSx3CpKkflTnFR87zR9brmCl1GoFXyHeOsYFnWFUIhcA694lduxYWpCLIOEfX5rbGmMSJ3aJeodO-xD3YdcwkxwJGUXE0SKqtUKbXly-_uq07M5DY-td4csWfwhR-Hw5eb27f3Q-PFuaL7hx65ETYcVj_Zao_zwXo-w]

A workaround is to declare a getter and setter in the superclass.",,emilles,jasongarrett,,,,,,,,,,,,GROOVY-11044,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Fri Apr 28 16:47:22 UTC 2023,,,,,,,,,,"0|z1hkvs:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Apr/23 16:47;emilles;https://github.com/apache/groovy/commit/707ed5a0e85b6182df44894419c32fb6600687f1

NOTE: if a type-checking extension clears direct target for {{super.m()}} or {{super.p}}, it may be necessary to generate a MOP method; this can be done with:
{code:java}
    if (isSuperExpression(expression.getObjectExpression())) {
        ClassNode superCaller =
typeCheckingContext.getEnclosingClassNode();
        superCaller.getNodeMetaData(SUPER_MOP_METHOD_REQUIRED, x -> new
LinkedList<>()).add(methodTarget);
    }
{code};;;",,,,,,,,,,,
STC: empty map (or list) literal does not type check like emptyMap(),GROOVY-11028,13534231,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,emilles,emilles,26/Apr/23 22:00,06/Jun/23 13:31,13/Jul/23 08:58,27/Apr/23 17:48,,,,,,,4.0.12,,,Static Type Checker,,,0,,,,"Consider the following:
{code:groovy}
@groovy.transform.TypeChecked
void test() {
  List<Integer> list = [].withDefault { 0 }
    // Cannot assign ListWithDefault<? extends Object> to List<Integer>
  Map<String,Integer> map = [:].withDefault { 1 }
    // Cannot assign Map<Object, ? extends Object> to Map<String, Integer>
}
{code}",,emilles,,,,,,,,,,,,,GROOVY-11057,GROOVY-11080,GROOVY-10651,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Thu Apr 27 17:48:25 UTC 2023,,,,,,,,,,"0|z1hk74:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Apr/23 17:48;emilles;https://github.com/apache/groovy/commit/759d892d746e09bda149157c1b2fe18d92b7ed99
https://github.com/apache/groovy/commit/1505ae66658fc11f38b44a723bdde5e236b1bfe8
https://github.com/apache/groovy/commit/357a3020bac60dbc8015c251cc26b666459afbb0;;;",,,,,,,,,,,
NPE when checking compatibility of method reference,GROOVY-11026,13534180,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,theosot,theosot,26/Apr/23 15:40,29/Apr/23 15:28,13/Jul/23 08:58,29/Apr/23 14:52,,,,,,,5.0.0-alpha-1,,,Static Type Checker,,,0,,,,"I have the following program

{code}
import java.util.function.*;
import java.util.List;

class Main {
  static final void test() {
        List<String> x = null;
        m(x::set);
  }

  static final <T, R> void m(BiFunction<T, R, R> y) {}

}
{code}

h3. Actual behavior

{code}
BUG! exception in phase 'instruction selection' in source unit 'test.groovy' unexpected NullPointerException
        at org.codehaus.groovy.control.CompilationUnit$IPrimaryClassNodeOperation.doPhaseOperation(CompilationUnit.java:953)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:694)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:668)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:649)
        at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:311)
        at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:240)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:165)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:205)
        at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:189)
Caused by: java.lang.NullPointerException
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.checkCompatibleAssignmentTypes(StaticTypeCheckingSupport.java:725)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.lambda$visitMethodPointerExpression$25(StaticTypeCheckingVisitor.java:2504)
        at java.base/java.util.Optional.ifPresent(Optional.java:183)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodPointerExpression(StaticTypeCheckingVisitor.java:2496)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitMethodReferenceExpression(CodeVisitorSupport.java:319)
        at org.codehaus.groovy.ast.expr.MethodReferenceExpression.visit(MethodReferenceExpression.java:34)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallArguments(StaticTypeCheckingVisitor.java:2912)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitStaticMethodCallExpression(StaticTypeCheckingVisitor.java:2820)
        at org.codehaus.groovy.ast.expr.StaticMethodCallExpression.visit(StaticMethodCallExpression.java:44)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:117)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:212)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitExpressionStatement(StaticTypeCheckingVisitor.java:2217)
        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:41)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:86)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:175)
        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:72)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:139)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:118)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.lambda$visitConstructorOrMethod$28(StaticTypeCheckingVisitor.java:2681)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.doWithTypeCheckingExtensions(StaticTypeCheckingVisitor.java:463)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:2681)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:110)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2664)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2643)
        at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitConstructorOrMethod(StaticCompilationVisitor.java:189)
        at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:204)
        at org.codehaus.groovy.ast.ClassNode.visitMethods(ClassNode.java:1144)
        at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1137)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:52)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.lambda$visitClass$3(StaticTypeCheckingVisitor.java:499)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.doWithTypeCheckingExtensions(StaticTypeCheckingVisitor.java:463)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:499)
        at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:151)
        at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:68)
        at org.codehaus.groovy.control.customizers.ASTTransformationCustomizer.call(ASTTransformationCustomizer.groovy:303)
        at org.codehaus.groovy.control.CompilationUnit$IPrimaryClassNodeOperation.doPhaseOperation(CompilationUnit.java:948)
        ... 8 more
{code}

h3. Compile succssfully

h3. Notes

Tested against master (commit: 8346e3406ed51dd071a2d31792d3fbad543585a7)",,emilles,theosot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Sat Apr 29 14:52:03 UTC 2023,,,,,,,,,,"0|z1hjvs:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Apr/23 14:52;emilles;https://github.com/apache/groovy/commit/692fae189f8649a7dc864886a7703482d11dad89;;;",,,,,,,,,,,
STC NPE when using Collectors.toMap() with a generic result,GROOVY-11024,13533881,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,chrylis,chrylis,24/Apr/23 17:40,01/May/23 19:52,13/Jul/23 08:58,01/May/23 18:39,4.0.11,,,,,,4.0.12,,,Static compilation,,,0,,,,"I'm not sure what the most specific culprit is, but this reproduces the problem reliably. (The original use case was using {{DynamoDbTable#index(String)}}, which also returns a generic result.)

{code:groovy}
import static java.util.function.Function.identity
import static java.util.stream.Collectors.toMap

import groovy.transform.CompileStatic

@CompileStatic
class Bug {
    Bug() {
        ['a'].stream().collect(toMap(identity(), List::of))
    }
}
{code}

{code}
[ERROR] Caused by: java.lang.NullPointerException: Cannot load from object array because the return value of ""org.codehaus.groovy.ast.ClassNode.getGenericsTypes()"" is null
[ERROR]         at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isAssignableTo(StaticTypeCheckingSupport.java:496)
[ERROR]         at org.codehaus.groovy.ast.tools.ParameterUtils.parametersMatch(ParameterUtils.java:74)
[ERROR]         at org.codehaus.groovy.ast.tools.ParameterUtils.parametersCompatible(ParameterUtils.java:53)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticTypesMethodReferenceExpressionWriter.lambda$findMethodRefMethod$2(StaticTypesMethodReferenceExpressionWriter.java:334)
[ERROR]         at java.base/java.util.Collection.removeIf(Collection.java:576)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticTypesMethodReferenceExpressionWriter.findMethodRefMethod(StaticTypesMethodReferenceExpressionWriter.java:319)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticTypesMethodReferenceExpressionWriter.writeMethodReferenceExpression(StaticTypesMethodReferenceExpressionWriter.java:104)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodReferenceExpression(AsmClassGenerator.java:925)
[ERROR]         at org.codehaus.groovy.ast.expr.MethodReferenceExpression.visit(MethodReferenceExpression.java:34)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.visitArgument(StaticInvocationWriter.java:513)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.loadArguments(StaticInvocationWriter.java:460)
[ERROR]         at org.codehaus.groovy.classgen.asm.InvocationWriter.writeDirectMethodCall(InvocationWriter.java:213)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeDirectMethodCall(StaticInvocationWriter.java:386)
[ERROR]         at org.codehaus.groovy.classgen.asm.InvocationWriter.makeDirectCall(InvocationWriter.java:311)
[ERROR]         at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:131)
[ERROR]         at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:125)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.makeCall(StaticInvocationWriter.java:648)
[ERROR]         at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:454)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeInvokeMethod(StaticInvocationWriter.java:136)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:988)
[ERROR]         at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:77)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.visitArgument(StaticInvocationWriter.java:513)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.loadArguments(StaticInvocationWriter.java:460)
[ERROR]         at org.codehaus.groovy.classgen.asm.InvocationWriter.writeDirectMethodCall(InvocationWriter.java:213)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeDirectMethodCall(StaticInvocationWriter.java:386)
[ERROR]         at org.codehaus.groovy.classgen.asm.InvocationWriter.makeDirectCall(InvocationWriter.java:311)
[ERROR]         at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:131)
[ERROR]         at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:125)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.makeCall(StaticInvocationWriter.java:648)
[ERROR]         at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:454)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeInvokeMethod(StaticInvocationWriter.java:136)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:988)
[ERROR]         at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:77)
[ERROR]         at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:613)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:827)
[ERROR]         at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:41)
[ERROR]         at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:95)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:77)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:752)
[ERROR]         at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:72)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:611)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:546)
[ERROR]         at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructor(ClassCodeVisitorSupport.java:105)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructor(AsmClassGenerator.java:689)
[ERROR]         at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1121)
[ERROR]         at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:52)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:365)
[ERROR]         ... 41 more

{code}",,chrylis,emilles,,,,,,,,,,,,,,GROOVY-10054,GROOVY-9239,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Mon May 01 18:39:15 UTC 2023,,,,,,,,,,"0|z1hi1c:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Apr/23 12:50;emilles;Until GROOVY-10054 is resolved, you'll need to use a more direct type witness:
{code:groovy}
import java.util.stream.*
import java.util.function.*
@groovy.transform.CompileStatic
void test() {
//def a = ['a'].stream().collect(Collectors.toMap(Function.<String,String>identity(), List::<String>of)) -- GROOVY-9239

  def b = ['b'].stream().collect(Collectors.<String,String,List<String>>toMap(Function.identity(), List::of))

  def c = ['c'].stream().collect((Collector<String, ?, Map<String,List<String>>>) Collectors.toMap(Function.identity(), List::of))

  def d = ['d'].stream().collect(Collectors.toMap((Function<String,String>) Function.identity(), (Function<String,List<String>>) List::of))

  Collector<String, ?, Map<String,List<String>>> mapper = Collectors.toMap(Function.identity(), List::of)
  def e = ['e'].stream().collect(mapper)
}
{code}
;;;","01/May/23 18:39;emilles;https://github.com/apache/groovy/commit/ce357be7e43542480a8e01f383aac69b19e1fe8f;;;",,,,,,,,,,
SC: IncompatibleClassChangeError when closure direct-targets extension method,GROOVY-11023,13533863,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,emilles,emilles,24/Apr/23 14:27,27/Apr/23 18:25,13/Jul/23 08:58,24/Apr/23 15:21,,,,,,,3.0.18,4.0.12,,Static compilation,,,0,,,,"Consider the following:
{code:groovy}
@groovy.transform.CompileStatic
void test() {
    def c = { p, q = p.toString() -> '' + p + q }
    assert c('foo', 'bar') == 'foobar'
    assert c('foo') == 'foofoo'
}
test()
{code}

Default argument creates delegate method that does not have static compilation.  Running script throws {{java.lang.IncompatibleClassChangeError}}.",,emilles,,,,,,,,,,,,,,,GROOVY-10072,GROOVY-11001,,,,,,GROOVY-11030,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Mon Apr 24 15:21:38 UTC 2023,,,,,,,,,,"0|z1hhxc:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Apr/23 15:21;emilles;https://github.com/apache/groovy/commit/5650495fe8d9307c7a679053b28ef72810b34a92;;;",,,,,,,,,,,
NullPointerException in instruction selection when calling parameterized function whose type parameter has an upper bound corresponding to a SAM type,GROOVY-11020,13533178,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,theosot,theosot,19/Apr/23 09:15,29/May/23 01:24,13/Jul/23 08:58,19/Apr/23 17:11,,,,,,,3.0.18,4.0.12,,Static Type Checker,,,0,,,,"I have the following code

{code}
import java.util.*;
import java.util.function.*;

class Main {
  static final void test(ArrayDeque<String> y) {
    
    m(y::addFirst);
  }

  static <C extends Consumer<String>> void m(C cl) {}
}
{code}

h3. Actual behavior

The compiler crashes with the following stacktrace:

{code}
>>> a serious error occurred: BUG! exception in phase 'instruction selection' in source unit 'Main.groovy' unexpected NullPointerException
>>> stacktrace:
BUG! exception in phase 'instruction selection' in source unit 'Main.groovy' unexpected NullPointerException
        at org.codehaus.groovy.control.CompilationUnit$IPrimaryClassNodeOperation.doPhaseOperation(CompilationUnit.java:953)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:694)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:668)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:649)
        at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:311)
        at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:240)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:165)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:205)
        at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:189)
Caused by: java.lang.NullPointerException
        at org.codehaus.groovy.ast.tools.GenericsUtils.parameterizeSAM(GenericsUtils.java:974)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferClosureParameterTypes(StaticTypeCheckingVisitor.java:3110)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallArguments(StaticTypeCheckingVisitor.java:2904)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitStaticMethodCallExpression(StaticTypeCheckingVisitor.java:2819)
        at org.codehaus.groovy.ast.expr.StaticMethodCallExpression.visit(StaticMethodCallExpression.java:44)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:117)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:212)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitExpressionStatement(StaticTypeCheckingVisitor.java:2217)
        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:41)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:86)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:175)
        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:72)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:139)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:118)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.lambda$visitConstructorOrMethod$28(StaticTypeCheckingVisitor.java:2680)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.doWithTypeCheckingExtensions(StaticTypeCheckingVisitor.java:463)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:2680)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:110)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2663)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2642)
        at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitConstructorOrMethod(StaticCompilationVisitor.java:189)
        at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:204)
        at org.codehaus.groovy.ast.ClassNode.visitMethods(ClassNode.java:1144)
        at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1137)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:52)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.lambda$visitClass$3(StaticTypeCheckingVisitor.java:499)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.doWithTypeCheckingExtensions(StaticTypeCheckingVisitor.java:463)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:499)
        at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:151)
        at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:68)
        at org.codehaus.groovy.control.customizers.ASTTransformationCustomizer.call(ASTTransformationCustomizer.groovy:303)
        at org.codehaus.groovy.control.CompilationUnit$IPrimaryClassNodeOperation.doPhaseOperation(CompilationUnit.java:948)
        ... 8 more
{code}

h3. Expected behavior 

Compile successfully

h3. Notes

Tested against master (commit: 61f445cf4b1099eb25f770cc0685efb10783b8f1)

Test case adapted from a program that uses the apache-commons-collections lib:

{code}
import java.util.*;
import java.util.function.*;

class Main {
  static final void test(Iterator<String> x,
                         ArrayDeque<String> y) {
    
    org.apache.commons.collections4.CollectionUtils.forAllButLastDo(x, y::addFirst);
  }

}
{code}",,emilles,theosot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Fri Apr 28 21:00:33 UTC 2023,,,,,,,,,,"0|z1hdq8:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Apr/23 17:11;emilles;https://github.com/apache/groovy/commit/5c5ec97a5e7995c36576c719b7503c7dba8215d8;;;","28/Apr/23 08:46;theosot;Interstingly, the following program still crashes the compiler:

{code}
import java.util.*;
import java.util.function.*;

class Main {
  static final void test(Iterator<String> x,
                         ArrayDeque<String> y) {
    
    org.apache.commons.collections4.CollectionUtils.forAllButLastDo(x, y::addFirst);
  }

}
{code};;;","28/Apr/23 20:00;emilles;I have a fix for the NPE.  The resolution of ""y::addFirst"" to the second type variable is a bit more complicated.  {{forAllButLastDo}} is deprecated and uses an odd style for the covariance of a parameter:
{code:java}
static <T,C extends Closure<? super T>> T forAllButLastDo(Iterator<T> iterator, C closure)
{code}
Its replacement uses something that supports closures/lambdas/references more directly:
{code:java}
static <E> E forEachButLast(Iterator<E> iterator, Closure<? super E> closure)
{code}

You should be able to use the latter without issue.;;;","28/Apr/23 21:00;emilles;https://github.com/apache/groovy/commit/dc3ee14961c2b83ccdac9dd01c6d5a00027a8a8a;;;",,,,,,,,
joint compilation:  public static final string does not compile,GROOVY-11019,13532949,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,jasongarrett,jasongarrett,17/Apr/23 21:14,18/Apr/23 19:54,13/Jul/23 08:58,18/Apr/23 19:00,4.0.11,,,,,,3.0.18,4.0.12,,Stub generator / Joint compiler,,,0,,,,"I haven't managed to reproduce this in a simple example, but as I'm upgrading my application from groovy 3 to 4 I have run into this situation.  I have a class that defines a public static final string like this:
{code:java}
class PublicStaticString { 
   public static final String NONE = ""None"" 
}
{code}
Its java stub fails to compile with:
{noformat}
error: no suitable constructor found for String(Object)
public static final java.lang.String NONE = new java.lang.String((java.lang.Object)null);{noformat}
 

I can remove the ""public"" from the declaration and the class/stub will compile, but now any java class that references that field will fail to compile with:
{noformat}
error: NONE has private access in PublicStaticString
         selectNoneButton.setText(PublicStaticString.NONE);{noformat}
The only way I know to fix this is to convert the java class to groovy.",OpenJDK Runtime Environment Temurin-11.0.16.1+1 (build 11.0.16.1+1),emilles,jasongarrett,,,,,,,,,,,,,,GROOVY-10902,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue Apr 18 19:50:11 UTC 2023,,,,,,,,,,"0|z1hcbs:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Apr/23 18:59;emilles;If your string field is initialized with an expression that the groovy compiler cannot convert to an inline constant (one single string literal) then it uses ""new java.lang.String(null)"" as the value so that javac cannot inline the value.  There is a bug where it casts null to java.lang.Object not java.lang.String.

If you can find the initial expression that does this, you may be able to rewrite it so that it inlines properly.  If you move the initialization to a static block, it sets the value as ""null"" which is a bug too, so don't do that.

I have a fix for both paths.;;;","18/Apr/23 19:00;emilles;https://github.com/apache/groovy/commit/1df378cf833598d1c86f776a40c34faa98d6fabc;;;","18/Apr/23 19:50;jasongarrett;Thank you for the suggested workaround and for the fixes.

I didn't encounter any joint compilation issues while upgrading my application from groovy 2.4.x to 3, but going from 3 to 4 I've hit this and the existing issue that @Delegate doesn't work with joint compilation.  Is groovy 4 creating more java stubs than previous versions did?;;;",,,,,,,,,
Fail to substitute type when having SAM type with generics,GROOVY-11013,13532671,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,theosot,theosot,14/Apr/23 14:09,26/May/23 22:42,13/Jul/23 08:58,26/May/23 21:09,,,,,,,3.0.18,4.0.13,,Static Type Checker,,,0,,,,"I have the following program

{code}
import java.util.*;

@FunctionalInterface
interface Foo<T> {
  int m(List<T> x);
}

class Main {
  static final void test() {
    Foo<String> p = (List<String> x) -> 1;
  }
}
{code}

h3. Actual behavior

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Main.groovy: 11: [Static type checking] - Expected type java.util.List<T> for lambda parameter: x
 @ line 11, column 22.
       Foo<String> p = (List<String> x) -> 1;
                        ^

1 error
{code}

h3. Expected behavior

Compile successfully

h3. Notes

Tested against master (commit: cdc57551a7cce33ec7031b40753f25c869dcf0cc)

Test case adapted from the following program that uses the apache-commons-collection4 lib

{code}

class Main {
  static final void test() {
    org.apache.commons.collections4.sequence.ReplacementsHandler<Number> f = (int x, List<java.io.IOException> y, List<Number> z) -> { } ;
  }
}
{code}",,emilles,theosot,,,,,,,,,,,,,,,,,,,,,GROOVY-11072,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Fri May 26 21:09:56 UTC 2023,,,,,,,,,,"0|z1hamo:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/May/23 21:09;emilles;https://github.com/apache/groovy/commit/859955225b22c20271d3ff1b12344edfb375258d;;;",,,,,,,,,,,
Wrong type is inferred when calling method defined in the parent class,GROOVY-11012,13532538,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,theosot,theosot,13/Apr/23 16:19,30/Apr/23 16:29,13/Jul/23 08:58,30/Apr/23 15:58,,,,,,,3.0.18,4.0.12,,Static Type Checker,,,0,traits,,,"I have the following program

{code}
interface Bar<V> {
  default V get(Object x, Object y) { return null; }
}

class Foo<V> implements Bar<V> {
  static <V> Foo<V> create() { return null; }
}

class Main {
  static final void test() {
    Number x = Foo.<Number>create().get(null, null);
  }

}
{code}

h3. Actual behavior

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
test.groovy: 11: [Static type checking] - Cannot assign value of type java.lang.Object to variable of type java.lang.Number
 @ line 11, column 16.
       Number x = Foo.<Number>create().get(null, null);
                  ^

1 error
{code}

h3. Expected behavior

Compile successfully

h3. Notes

Tested against master (commit: 5bcd83e0fde722971f97d479f1a4d6da6cd4aa5f)

Test cased adapt from the following program that uses the Guava lib

{code}
import com.google.common.collect.HashBasedTable;

class Main {
  static final void test() {
    Number x = HashBasedTable.<Number, Number, Number>create().get(null, null);
  }
}
{code}",,emilles,theosot,,,,,,,,,,,,,,GROOVY-8638,GROOVY-10120,,,,,,GROOVY-11035,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Sun Apr 30 15:58:06 UTC 2023,,,,,,,,,,"0|z1h9t4:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Apr/23 20:40;emilles;Guava collections have bridge methods that lack generics in the bytecode.  See GROOVY-10120 and GROOVY-8638.

I have advised my team to cast to the interface type at the point of creation:
{code:groovy}
import com.google.common.collect.*
@groovy.transform.TypeChecked test() {
  def table = (Table<Number,Number,Number>) HashBasedTable.create()
  Number item = table.get(null, null)
}
{code};;;","30/Apr/23 14:49;emilles;This script hits on a different error.  In Groovy, an interface with a default method is implemented as a trait.
{code:groovy}
/*interface Bar<T> {
  default T get(x,y) { }
}*/
trait Bar<T> {
  T get(x,y) {
  }
}

class Foo<V> implements Bar<V> {
  static <V> Foo<V> create() { }
}

@TypeChecked test(Foo<Number> foo) {
  Number x = foo.get(null, null) // Cannot assign value of type Object to variable of type Number
}

test(Foo.<Number>create())
{code};;;","30/Apr/23 15:58;emilles;https://github.com/apache/groovy/commit/b94ce492a5d7ff2b79182d585c588e77519a34a8;;;",,,,,,,,,
SC: array instanceof guard and length or subscript,GROOVY-11011,13532529,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,emilles,emilles,13/Apr/23 15:32,13/Apr/23 17:12,13/Jul/23 08:58,13/Apr/23 16:25,2.5.22,3.0.17,4.0.11,,,,3.0.18,4.0.12,,Static compilation,,,0,ClassFormatError,,,"Consider the following:
{code:groovy}
@groovy.transform.CompileStatic
class FileTreeBuilder {
    def methodMissing(String name, Object args) {
        if (args instanceof Object[] && args.length == 1) {
            def arg = args[0]
            if (arg instanceof Closure) {
                dir(name, arg)
            } else if (arg instanceof CharSequence) {
                file(name, arg.toString())
            } else if (arg instanceof byte[]) {
                file(name, arg)
            } else if (arg instanceof File) {
                file(name, arg)
            }
        }
    }
}
{code}

STC gives no errors for this, but there are 2 class format issues.  ""args.length"" is reporting bad type on operand stack and ""if (arg instanceof CharSequence)"" and subsequent guards are reporting improper class name ""Ljava/lang/Object;"" on the operand stack.",,emilles,,,,,,,,,,,,,,,GROOVY-5683,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Thu Apr 13 16:25:14 UTC 2023,,,,,,,,,,"0|z1h9r4:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Apr/23 16:25;emilles;https://github.com/apache/groovy/commit/cdc57551a7cce33ec7031b40753f25c869dcf0cc;;;",,,,,,,,,,,
STC resolves wrong method reference,GROOVY-11009,13532193,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,theosot,theosot,11/Apr/23 13:35,18/Apr/23 21:21,13/Jul/23 08:58,18/Apr/23 20:51,,,,,,,3.0.18,4.0.12,,Static Type Checker,,,0,,,,"This is probably a regression

I have the following program

{code}
import java.util.function.*;

class Main {
  static final void test() {
    final Function<Double, Double> x = Main::clone;
  }

  public static <T> T clone(T x) { return x; }

}
{code}

h3. Actual behavior

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
test.groovy: 5: [Static type checking] - Invalid return type: java.lang.Object is not convertible to java.lang.Double
 @ line 5, column 40.
       final Function<Double, Double> x = Main::clone;
                                          ^

1 error
{code}

h3. Expected behavior

Compile successfully

h3. Notes
Tested against master (commit: c4ee3ce0661eec7d633fc81281d79c8889b3dc66)

Test case adapted from:

{code}
import java.util.function.*;

class Main {
  static final void test() {
    Function<Double, Double> x = org.apache.commons.lang3.ObjectUtils::clone;
  }
}
{code}",,emilles,theosot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue Apr 18 20:51:56 UTC 2023,,,,,,,,,,"0|z1h7oo:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Apr/23 20:10;emilles;The method reference has 2 methods that may satisfy:
# the static method declared by Main
# the instance method declared by Object

STC does not remove #2 from the candidate list and then subsequent parameter and return type checks aren't strictly limited to the type parameter ""T"".;;;","18/Apr/23 20:51;emilles;https://github.com/apache/groovy/commit/097397631c94f091cbba2b49e490917b865a6355;;;",,,,,,,,,,
STC: instanceof guard for property loses type information,GROOVY-11007,13532088,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,emilles,emilles,10/Apr/23 20:39,10/Apr/23 22:11,13/Jul/23 08:58,10/Apr/23 21:29,3.0.17,4.0.11,,,,,3.0.18,4.0.12,,,,,0,,,,"Consider the following:
{code:groovy}
interface I {
    CharSequence getCharSequence()
}

void accept(CharSequence cs) { }

void test(I i) {
    i.with {
        if (charSequence instanceof String) {
            charSequence.toUpperCase()
            accept(charSequence)
        }
    }
}

test({ -> 'works' } as I)
{code}


Reports ""Cannot find matching method script#accept(java.lang.Object)"".",,emilles,,,,,,,,,,,,,,,GROOVY-10981,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Mon Apr 10 21:29:28 UTC 2023,,,,,,,,,,"0|z1h71k:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Apr/23 21:29;emilles;https://github.com/apache/groovy/commit/e7e057f4ba4a3bfa617d9770f8d364ab40b4108b;;;",,,,,,,,,,,
CompileStatic: Cannot set default-visible property in superclass that has a getter without a setter,GROOVY-11005,13531910,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,jasongarrett,jasongarrett,07/Apr/23 21:02,11/Apr/23 00:06,13/Jul/23 08:58,11/Apr/23 00:06,3.0.17,,,,,,3.0.18,,,Compiler,,,0,,,,"If a class's ancestors declare a default-visibility property and a getter for that property:
{code:java}
class HasProperty {
    Object foo

    Object getFoo() {
       return foo
    }
} {code}
Then the class, if it is CompileStatic, cannot set that property.

 

This fails to compile:
{code:java}
import groovy.transform.CompileStatic

@CompileStatic
class SetsProperty extends HasProperty {
    void doStuff() {
       foo = ""example""
    }
} {code}
Compiler output:
{noformat}
SetsProperty.groovy: 8: [Static type checking] - Cannot set read-only property: foo
 @ line 8, column 3.
           foo = ""example""{noformat}
 

It also fails to compile with ""this.@"":
{code:java}
import groovy.transform.CompileStatic

@CompileStatic
class SetsProperty extends HasProperty {
    void doStuff() {
       this.@foo = ""example""
    }
} {code}
Results in:
{noformat}
SetsProperty.groovy: 8: [Static type checking] - The field HasProperty.foo is not accessible
 @ line 8, column 9.
           this.@foo = ""example""{noformat}
 

{{These do compile if the class is not CompileStatic, or if the property is explicitly declared ""public"".}}

 

 ",,emilles,jasongarrett,,,,,,,,,,,,,,GROOVY-5450,GROOVY-9127,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue Apr 11 00:06:27 UTC 2023,,,,,,,,,,"0|z1h5y0:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Apr/23 00:06;emilles;https://github.com/apache/groovy/commit/b28c2f204abace120b0b46d5fae789319da589d5;;;",,,,,,,,,,,
Cannot find method with variable arguments when using fully qualified class names,GROOVY-11003,13531867,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,theosot,theosot,07/Apr/23 13:07,11/Apr/23 16:16,13/Jul/23 08:58,11/Apr/23 15:29,,,,,,,3.0.18,4.0.12,,Static Type Checker,,,0,,,,"I have the following program

{code}
class Main {
  static final void test(java.util.List<Integer> p) {
    m(1, p);
  }

  static <T> void m(Integer x, java.util.List<T>... items) { }
}
{code}

h3. Actual behavior

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
test.groovy: 3: [Static type checking] - Cannot find matching method Main#m(int, java.util.List<java.lang.Integer>). Please check if the declared type is correct and if the method exists.
 @ line 3, column 5.
       m(1, p);
       ^

1 error
{code}

h3. Expected behavior

Compile successfully

Tested against master (commit: a4e0d6de9cc2d8ecb48b48df501e63ec1735d837)",,emilles,theosot,,,,,,,,,,,,,,GROOVY-8090,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue Apr 11 15:29:21 UTC 2023,,,,,,,,,,"0|z1h5og:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Apr/23 15:29;emilles;https://github.com/apache/groovy/commit/541277b42af89dd7b88117a5efb342543e614156;;;",,,,,,,,,,,
AIOOBE when using method reference in nested lambda,GROOVY-11001,13531769,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,chrylis,chrylis,06/Apr/23 18:02,24/Apr/23 14:27,13/Jul/23 08:58,11/Apr/23 19:24,4.0.11,,,,,,3.0.18,4.0.12,,Static compilation,,,0,,,,"When using (1) the method-reference operator (but not the method-closure operator) (2) inside a nested lambda, the STC throws an AIOOBE.

{code:groovy}
@Grapes([
    @Grab(group = 'software.amazon.awssdk', module = 'utils', version = '2.18.31'),
    @Grab(group = 'io.vavr', module = 'vavr', version = '0.10.3'),
])
@CompileStatic
class Bug {
    Object bug() {
        Try.success('1234')
            .flatMap {
                Try.success(it)
                    .map(StringInputStream::new)
            }
    }
}
{code}

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during instruction selection: Internal compiler error while compiling Bug.groovy
Method: org.codehaus.groovy.ast.MethodNode@782bf610[software.amazon.awssdk.utils.StringInputStream ctorRef$doCall$0(java.lang.String) from Bug$_bug_closure1]
Line -1, expecting casting to software.amazon.awssdk.utils.StringInputStream but operand stack is empty

java.lang.ArrayIndexOutOfBoundsException: Internal compiler error while compiling Bug.groovy
Method: org.codehaus.groovy.ast.MethodNode@782bf610[software.amazon.awssdk.utils.StringInputStream ctorRef$doCall$0(java.lang.String) from Bug$_bug_closure1]
Line -1, expecting casting to software.amazon.awssdk.utils.StringInputStream but operand stack is empty
        at org.codehaus.groovy.classgen.asm.OperandStack.throwExceptionForNoStackElement(OperandStack.java:335)
        at org.codehaus.groovy.classgen.asm.OperandStack.doConvertAndCast(OperandStack.java:340)
        at org.codehaus.groovy.classgen.asm.OperandStack.doGroovyCast(OperandStack.java:305)
        at org.codehaus.groovy.classgen.asm.StatementWriter.writeReturn(StatementWriter.java:593)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:812)
        at org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:73)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:601)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:546)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:110)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:685)
        at org.codehaus.groovy.ast.ClassNode.visitMethods(ClassNode.java:1142)
        at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1124)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:52)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:365)
        at org.codehaus.groovy.control.CompilationUnit$3.call(CompilationUnit.java:797)
        at org.codehaus.groovy.control.CompilationUnit$3.call(CompilationUnit.java:814)
        at org.codehaus.groovy.control.CompilationUnit$IPrimaryClassNodeOperation.doPhaseOperation(CompilationUnit.java:937)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:692)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:666)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:647)
        at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:311)
        at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:240)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:165)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:205)
        at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:189)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:568)
        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:109)
        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:132)
{code}",,chrylis,emilles,,,,,,,,,,,,,,,,,,,,,GROOVY-11023,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue Apr 11 19:24:58 UTC 2023,,,,,,,,,,"0|z1h52o:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Apr/23 19:24;emilles;https://github.com/apache/groovy/commit/74faadd52effe6f3ade30cc9221af43e79ce5652;;;",,,,,,,,,,,
Compilation issue in Groovy 4,GROOVY-10996,13530645,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,mkamalov,mkamalov,29/Mar/23 15:28,18/Apr/23 17:28,13/Jul/23 08:58,18/Apr/23 16:29,,,,,,,3.0.18,4.0.12,,Compiler,,,0,,,,"We migrate the application to Groovy 4 and got an issue:

1) We use GroovyClassLoader to load *.groovy written classes to a classloader

2) Before the migration we used Groovy 3.0.15.

3) After the migration to 4.0.10 I've got the following error:
{code:java}
Only classes and closures can be used for attribute 'value' in @org.openl.rules.ruleservice.core.annotations.ServiceExtraMethod
 @ line 18, column 30.
       @ServiceExtraMethod(value = org.openl.generated.services.ServiceExtraMethodHandler2Impl.class)
                                ^ {code}
4) If the annotation definition changed from @ServiceExtraMethod(value = org.openl.generated.services.ServiceExtraMethodHandler2Impl.class) to @ServiceExtraMethod(value = org.openl.generated.services.ServiceExtraMethodHandler2Impl) then the code is compiled successfully.

Why does the compilation start to fail with .class? I can't reproduce the same issue on IntelliJ IDEA.

Can you suggest what to try? Is it expected for Groovy to stop supporting .class in Groovy 4?",,emilles,mkamalov,,,,,,,,,,,,,,GROOVY-10571,GROOVY-8184,,,,,,,,"16/Apr/23 19:24;mkamalov;groovy_bug.zip;https://issues.apache.org/jira/secure/attachment/13057303/groovy_bug.zip",,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue Apr 18 16:29:41 UTC 2023,,,,,,,,,,"0|z1gy60:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Apr/23 20:22;emilles;Can you provide a small script that demonstrates the issue?  I think it is resolving ""foo.bar.Baz.class"" to a PropertyExpression instead of a ClassExpression.;;;","16/Apr/23 16:48;emilles;I get no error for this script under Groovy 4.0.11.  We need a simple recreation script or project.
{code:groovy}
def gcl = new GroovyClassLoader()
gcl.parseClass '''package foo.bar
import java.lang.annotation.*
@Retention(RetentionPolicy.CLASS)
@Target(ElementType.TYPE)
@interface Tag {
  Class value()
}
'''
gcl.parseClass '''package foo.bar
class Baz {
}
'''
gcl.parseClass '''package foo.bar
@Tag(value = foo.bar.Baz.class)
class Pogo {
}
'''
print gcl.loadClass('foo.bar.Pogo').newInstance()
{code};;;","16/Apr/23 19:33;mkamalov;I hope this message finds you well. I wanted to share some information about a Maven project I created for you that includes JUnit tests, specifically regarding the Groovy classes Service1, Service2, Service3, and Service4. See attached file: [^groovy_bug.zip]

It appears that there might be a bug related to the import of classes with different package names. For instance, you mentioned that while a class with a simple name and import (Service4) works, a class with the same type but with a full package name defined does not work. This discrepancy could indicate a potential issue with the import statement or package declaration in your code.

I hope this information is helpful in troubleshooting the bug you encountered. If you need further assistance or have any other questions, please feel free to ask.

Apologies for any inconvenience caused by the formatting of my code. Due to time constraints, I was unable to thoroughly format it.;;;","16/Apr/23 19:42;mkamalov;Additional information:

If you try to change
 
{code:java}
<dependency>
    <groupId>org.apache.groovy</groupId>
    <artifactId>groovy</artifactId>
    <version>4.0.11</version>
</dependency>  {code}
to:
{code:java}
<dependency>
    <groupId>org.codehaus.groovy</groupId>
    <artifactId>groovy</artifactId>
    <version>3.0.17</version>
</dependency>{code}
All tests have successfully passed with Groovy 3.0.17, which indicates that there might be a bug present.;;;","18/Apr/23 16:29;emilles;https://github.com/apache/groovy/commit/1aa62736c71be08a75581a451805a3e7f5514589;;;",,,,,,,
Classes are compiled in Groovy 3 and Java but fails in Groovy 4,GROOVY-10995,13530624,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,mkamalov,mkamalov,29/Mar/23 13:08,29/Mar/23 14:14,13/Jul/23 08:58,29/Mar/23 14:14,4.0.10,,,,,,,,,Compiler,,,0,,,,"We use Groovy 3. And I tried to migrate the existing application to use Groovy 4. 

I have a compilation issue in the code and the same behavior in IntelliJ IDEA, because it uses Groovy 4 syntax by default.

What I have:
{code:java}
// A simple interface with generic parameter
// This is Java class compiled by Java
interface MyInterface<T> {
} {code}
{code:java}
// A simple annotation that expects an MyInterface implemenations
// This is Java class compiled by Java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface MyAnnotation {
    Class<? extends MyInterface<?>> value()
} {code}
{code:java}
//A class that implements MyInterface and ignores type raw type using warnings
//This is Groovy class located at the same package with the next code
public class MyClass implements MyInterface { 
}
{code}
{code:java}
// A method that uses MyAnnotation with MyClass parameter
//This is Groovy code that fails and located at the same package with MyClass
@MyAnnotation(value = com.example.MyClass)
static void main(String[] args) { 
}{code}
This code compiles in Groovy 3 and compiles in Java but fails to compile in Groovy 4.0.10

The code starts to compile in Groovy 4 If I change MyClass implementation to:
{code:java}
public class MyClass implements MyInterface<Object> {
} {code}
I think it is a bug, please, validate and fix it.",,mkamalov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Wed Mar 29 13:43:32 UTC 2023,,,,,,,,,,"0|z1gy1c:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Mar/23 13:43;mkamalov;In Java 11 the same reason for compilation fails but Groovy 3 compiles.;;;",,,,,,,,,,,
Fail to resolve method reference with generics,GROOVY-10994,13530414,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,theosot,theosot,28/Mar/23 11:45,11/Apr/23 22:02,13/Jul/23 08:58,11/Apr/23 21:19,,,,,,,3.0.18,4.0.12,,Static Type Checker,,,0,,,,"I have the following program

{code}
import java.util.List;
import java.util.function.Predicate;


class Main {
  static final <T> void test() {

    List<T> x = null;
    Predicate<? super T> y = x::add;

  }
}
{code}

h3. Actual behavior

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Main.groovy: 9: Failed to find method 'add(T)' for the type: java.util.List<T> @ line 9, column 30.
       Predicate<? super T> y = x::add;
                                ^

1 error
{code}

h3. Expected behavior

Compile successfully

Tested against master (commit: a29ce1ce64d565526b70e145ace665dd0617ec9b)",,emilles,theosot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue Apr 11 21:19:52 UTC 2023,,,,,,,,,,"0|z1gwqo:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Apr/23 21:19;emilles;https://github.com/apache/groovy/commit/dd929b4fd879e6d3e5cb7c4372134899fd4e61dc;;;",,,,,,,,,,,
STC: type inference of variable expression with superclass field and access method,GROOVY-10981,13530036,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,emilles,emilles,24/Mar/23 21:28,10/Apr/23 20:40,13/Jul/23 08:58,24/Mar/23 23:37,,,,,,,2.5.22,3.0.17,4.0.11,Static Type Checker,,,0,,,,"Consider the following:
{code:groovy}
abstract class A {
  protected Object thing = 'field'
  String getThing() { 'property' }
}
@groovy.transform.CompileStatic
class C extends A {
  void test() {
    print thing.toUpperCase()
  }
}
new C().test()
{code}

If "".toUpperCase()"" is removed, the script prints ""property"".  However the STC type recorded comes from the field.",,emilles,,,,,,,,,,,,,,,,,,,,,,GROOVY-11007,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Fri Mar 24 23:37:44 UTC 2023,,,,,,,,,,"0|z1guew:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Mar/23 23:37;emilles;https://github.com/apache/groovy/commit/d8836463f03629e1ed27d132a26b43b669c1b9e9
https://github.com/apache/groovy/commit/a29ce1ce64d565526b70e145ace665dd0617ec9b;;;",,,,,,,,,,,
LUB of Type<T extends Something> and Type<? extends Something>,GROOVY-10978,13528996,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,emilles,emilles,17/Mar/23 16:34,05/Apr/23 02:44,13/Jul/23 08:58,17/Mar/23 16:45,2.5.21,3.0.16,4.0.10,,,,2.5.22,3.0.17,4.0.11,,,,0,,,,"Follow up to GROOVY-10756.  Blending wildcard and unresolved parameterized type is incomplete.

Consider the following:
{code:groovy}
            interface Handle {
                int getCount()
            }
            class HandleContainer<H extends Handle> {
                H handle
            }
            interface Input {
                HandleContainer<? extends Handle> getResult(key)
            }
            interface State {
                def <X extends Handle> HandleContainer<X> getResult(key)
            }

            void test(Input input, State state) {
                def container = state.getResult('k') ?: input.getResult('k') // HERE: HandleContainer<# extends Handle> and HandleContainer<? extends Handle>
                Handle handle = container.handle
                Integer count = handle.count
                assert count == 1
            }

            Handle h = {->1}
            def c = new HandleContainer(handle: h)
            test({k->c} as Input, {k->c} as State)
{code}",,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Fri Mar 17 16:45:02 UTC 2023,,,,,,,,,,"0|z1go00:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Mar/23 16:45;emilles;https://github.com/apache/groovy/commit/b92cc2a8957b33fc2ee4f5b9a8d8d302d22f9741;;;",,,,,,,,,,,
Issue in resolving overloaded method reference,GROOVY-10972,13527849,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,theosot,theosot,09/Mar/23 15:51,15/Jun/23 15:23,13/Jul/23 08:58,19/Apr/23 15:30,,,,,,,3.0.18,4.0.12,,Static Type Checker,,,0,,,,"I have the following program

{code}
import java.util.function.Function;
import java.util.LinkedList;

class Foo {}


class Test {

    public static void main(String[] args) {
        LinkedList<Foo> x = new LinkedList();
        x.add(new Foo());

        Function<Integer, Foo> z = x::remove;
        Foo k = z.apply(0); // ClassCastException boolean cannot be cast to Foo.
    }

}
{code}

h3. Actual behavior

The compiler accepts the code, but the following exception is triggered at runtime.

{code}
Exception in thread ""main"" org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'false' with class 'java.lang.Boolean' to class 'Foo'
        at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.continueCastOnSAM(DefaultTypeTransformation.java:425)
        at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.continueCastOnNumber(DefaultTypeTransformation.java:336)
        at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:256)
        at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321)
        at Test.main(test.groovy:14)
{code}

There problem happens because there are two overloaded methods inside LinkedList:
  * E remove(int x)
  * boolean remove(Object d)

The compiler seems to resolve the second method (i.e., boolean remove (Object)) although its return type does not match with Function<Integer, Foo>.

Based only on the argument type, both methods are applicable. If the second ""remove"" method is more specific than the first one, then a compiler error should be raised at compile-time, because boolean does not match Foo. If this is not the case, then the program should call the first ""remove"" method.",,emilles,theosot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Wed Apr 19 15:30:15 UTC 2023,,,,,,,,,,"0|z1ggx4:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Apr/23 15:30;emilles;https://github.com/apache/groovy/commit/313f2bf3c0fa70d7a9fdc105bf42f96ccbab4894;;;",,,,,,,,,,,
STC is looking for the wrong constructor reference,GROOVY-10971,13527826,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,theosot,theosot,09/Mar/23 14:28,12/Apr/23 20:27,13/Jul/23 08:58,12/Apr/23 20:25,,,,,,,5.0.0-alpha-1,,,,,,0,,,,"I have the following program

{code}
class Foo {
  Foo(String d) {}
}

class Main {
  static final void test() {
        def x = java.util.stream.Collectors.groupingBy(Main::m) // works;
        def y = java.util.stream.Collectors.groupingBy(Foo::new) // fails;
  }

  static Foo m(String x) { return null; }
}
{code}

h3. Actual behavior

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
test.groovy: 8: [Static type checking] - Cannot find matching constructor Foo(java.lang.Object)
 @ line 8, column 56.
   .stream.Collectors.groupingBy(Foo::new)
                                 ^

1 error
{code}

h3. Expected behavior

Compile successfully

Tested against master (commit: 46722e7147ed529fe8817660617ac6af98ad6f54)",,emilles,theosot,,,,,,,,,,,,,,GROOVY-10930,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Wed Apr 12 20:25:16 UTC 2023,,,,,,,,,,"0|z1ggs0:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Apr/23 20:25;emilles;https://github.com/apache/groovy/commit/7bcd342a364e09343ef4d6cf5d29255ce737851d;;;",,,,,,,,,,,
AIOOBE with Java lambda syntax,GROOVY-10963,13527311,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,chrylis,chrylis,06/Mar/23 16:27,14/Jun/23 15:17,13/Jul/23 08:58,14/Jun/23 15:17,4.0.9,,,,,,3.0.18,4.0.13,,Static compilation,,,0,,,,"This bug may have something to do with the overload-selection challenges discussed previously, but I don't remember an actual internal exception before.

When using Vavr {{Try}}, several of the methods have overloads that accept either {{Runnable}} or {{Consumer<T>}}. Using a Groovy-syntax lambda with an explicit parameter can result in erroneous selection of {{Runnable}} (covered elsewhere), but using a _Java_-syntax lambda apparently results in the same erroneous selection with a crash instead of a meaningful error.

{code}
Try.<Val> success(someValue)
  .andThen((Val result) -> { println result }) // should be unambiguously Consumer<Val>
{code}

produces
{code}
[ERROR] Failed to execute goal org.codehaus.gmavenplus:gmavenplus-plugin:1.13.1:compile (default) on project azimuth-server: Error occurred while calling a method on a Groovy class from classpath.: InvocationTargetException: startup failed:
[ERROR] General error during instruction selection: Index 0 out of bounds for length 0
[ERROR] 
[ERROR] java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticTypesLambdaWriter.createParametersWithExactType(StaticTypesLambdaWriter.java:296)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticTypesLambdaWriter.addSyntheticLambdaMethodNode(StaticTypesLambdaWriter.java:274)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticTypesLambdaWriter.createLambdaClass(StaticTypesLambdaWriter.java:251)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticTypesLambdaWriter.lambda$getOrAddLambdaClass$2(StaticTypesLambdaWriter.java:216)
[ERROR]         at java.base/java.util.HashMap.computeIfAbsent(HashMap.java:1133)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticTypesLambdaWriter.getOrAddLambdaClass(StaticTypesLambdaWriter.java:215)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticTypesLambdaWriter.writeLambda(StaticTypesLambdaWriter.java:118)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitLambdaExpression(AsmClassGenerator.java:873)
[ERROR]         at org.codehaus.groovy.ast.expr.LambdaExpression.visit(LambdaExpression.java:46)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.visitArgument(StaticInvocationWriter.java:512)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.loadArguments(StaticInvocationWriter.java:459)
[ERROR]         at org.codehaus.groovy.classgen.asm.InvocationWriter.writeDirectMethodCall(InvocationWriter.java:213)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeDirectMethodCall(StaticInvocationWriter.java:385)
[ERROR]         at org.codehaus.groovy.classgen.asm.InvocationWriter.makeDirectCall(InvocationWriter.java:311)
[ERROR]         at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:131)
[ERROR]         at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:125)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.makeCall(StaticInvocationWriter.java:647)
[ERROR]         at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:454)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeInvokeMethod(StaticInvocationWriter.java:135)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:988)
[ERROR]         at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:77)
[ERROR]         at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:613)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:827)
[ERROR]         at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:41)
[ERROR]         at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:95)
[ERROR]         at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:77)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:752)
[ERROR]         at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:70)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:611)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:546)
[ERROR]         at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:110)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:695)
[ERROR]         at org.codehaus.groovy.ast.ClassNode.visitMethods(ClassNode.java:1131)
[ERROR]         at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1124)
[ERROR]         at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:52)
[ERROR]         at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:365)
[ERROR]         at org.codehaus.groovy.control.CompilationUnit$3.call(CompilationUnit.java:797)
[ERROR]         at org.codehaus.groovy.control.CompilationUnit$IPrimaryClassNodeOperation.doPhaseOperation(CompilationUnit.java:937)
[ERROR]         at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:692)
[ERROR]         at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:666)
[ERROR]         at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:647)
[ERROR]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
[ERROR]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
[ERROR]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
[ERROR]         at java.base/java.lang.reflect.Method.invoke(Method.java:566)
[ERROR]         at org.codehaus.gmavenplus.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:212)
[ERROR]         at org.codehaus.gmavenplus.mojo.AbstractCompileMojo.doCompile(AbstractCompileMojo.java:334)
[ERROR]         at org.codehaus.gmavenplus.mojo.CompileMojo.execute(CompileMojo.java:70)
{code}

This may be a duplicate if the correct resolution is ""enhance the overload-selection logic to pick the most suitable one at an earlier stage"".",,chrylis,emilles,,,,,,,,,,,,,,GROOVY-10714,GROOVY-9881,GROOVY-9852,GROOVY-8499,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Wed Jun 14 15:17:44 UTC 2023,,,,,,,,,,"0|z1gdls:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Mar/23 22:38;emilles;You can help method selection with a typecast, like this: "".andThen((Consumer<Val>) result -> println result)""

Closure [1] is closer to Runnable than Consumer.  GROOVY-10714 describes this in more detail.  Replacing ""andThen"" with ""andThenTry"" provides equidistant overloads ({{CheckedConsumer}} and {{CheckedRunnable}}) such that the GROOVY-9881 param count tie-breaker kicks in.

The selection of the method happens before visiting the functional elements.

[1] Yes, I know a lambda is not a closure, but it is type-checked just like a closure -- LambdaExpression extends ClosureExpression.;;;","06/Mar/23 22:57;emilles;I think these two checks would need to come in the opposite order or something:
{code:java}
        if (compare.isInterface()) { MethodNode sam;
            if (receiver.implementsInterface(compare)) {
                return dist + getMaximumInterfaceDistance(receiver, compare);
            } else if (receiver.equals(CLOSURE_TYPE) && (sam = findSAM(compare)) != null) {
                // GROOVY-9881: in case of multiple overloads, give preference to equal parameter count
                Integer closureParamCount = receiver.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);
                if (closureParamCount != null && closureParamCount == sam.getParameters().length) dist -= 1;

                return dist + 13; // GROOVY-9852: @FunctionalInterface vs Object
            }
        }
{code};;;","06/Mar/23 23:05;chrylis;> Yes, I know a lambda is not a closure, but it is type-checked just like a closure – LambdaExpression extends ClosureExpression.

Aha, I think this is the key. I was thinking that even though the Closure overload selection was temporarily disoriented, explicitly providing an argument list might be sufficient help to constrain the overload. This makes the situation clearer. That said, while smoother resolution would be more _convenient_, I filed this ticket because of the non-localized and confusing internal error message.;;;","06/Mar/23 23:24;emilles;I will fix the exception which comes in the lambda writer when it compares Runnable parameters (zero) to what you have supplied (one).;;;","07/Mar/23 14:48;emilles;The fix for GROOVY-8499 would give you an indication that the actual and expected parameter count differ.;;;","07/Mar/23 14:51;chrylis;An error message of that sort would be helpful in at least directing me to
the expression in question!




-- 
Christopher Smith
;;;","14/Jun/23 15:17;emilles;https://github.com/apache/groovy/commit/c7d67a0ce250d8483882f54886bb735ce5ac81fa;;;",,,,,
"Instance ""isser"" prevents resolving of static ""getter""",GROOVY-10962,13527285,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,pmarkus,pmarkus,06/Mar/23 14:07,16/May/23 13:29,13/Jul/23 08:58,06/Mar/23 22:04,4.0.9,,,,,,4.0.10,,,groovy-runtime,,,1,,,,"While upgrading the Groovy-Version in our application, we noticed, like others, that the priority of issers and getters have changed. This has already been confirmed as intended behavior, but there seems to be some odd behavior with static and instance accessors.

When having a class with a static get-method that also has an instance is-method, trying to access the static property via the class name an exception is raised: *groovy.lang.MissingPropertyException: No such property: x for class: mypackage.MyClass  Possible solutions: x*

You can recreate this rather easily:

 
{code:java}
class Test
{
  static String getTestProperty { ""test"" }
  boolean isTestProperty { true }
}
Test.testProperty // => groovy.lang.MissingPropertyException
{code}
 

Given that the property is called from a static context, one would assume, that the instance method isTestProperty would not be in the way. However it is. Removing the method, makes that static getTestProperty available again via Test.testProperty.

Is this also intended behavior?",,emilles,mkomko,pmarkus,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue Mar 14 07:59:22 UTC 2023,,,,,,,,,,"0|z1gdg0:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Mar/23 18:13;emilles;Just a quick note, the static method is invoked if {{@CompileStatic}} is in effect, in case you need a short-term workaround (besides calling the method directly).;;;","06/Mar/23 18:24;emilles;I have not checked, but I'm guessing the inverse was a problem for Groovy 3 and prior.  That is, ""new Test().testProperty"" was probably satisfied by the static method.  In Groovy 4, the isser gets first crack.

*Update:* Yes, Groovy 3 invokes the static getter for both ""Test.testProperty"" and ""new Test().testProperty"".  Groovy 4 invokes the isser for ""new Test().testProperty"".;;;","06/Mar/23 22:04;emilles;https://github.com/apache/groovy/commit/f699f3a26692d1679b79d0b63a905c2eed9ff132;;;","07/Mar/23 07:25;pmarkus;Thank you for the feedback.

Sadly, I don't think @CompileStatic will help us, as we are interfacing mostly with Java-Classes, where the behavior is the same. If that makes any difference, I'm sorry for not specifying this earlier.;;;","14/Mar/23 07:59;pmarkus;Thank you very much! Works like a charm now!;;;",,,,,,,
@Builder doesn't work on records,GROOVY-10955,13526551,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,28/Feb/23 15:38,13/Mar/23 12:15,13/Jul/23 08:58,08/Mar/23 12:13,,,,,,,4.0.10,,,,,,0,,,,"For this code:
{code}
import groovy.transform.builder.*
@Builder
record Developer(Integer id, String first, String last, String email, List<String> skills) { }
Developer.builder().id(2).build()
{code}
The code fails in the {{build}} method. It is meant to create a new Developer but instead creates a DeveloperBuilder instance and then throws a cast exception:
{noformat}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'Developer$DeveloperBuilder@5ef26266' with class 'Developer$DeveloperBuilder' to class 'Developer'
        ...
	at Developer$DeveloperBuilder.build(ConsoleScript25)
{noformat}
I wasn't necessarily expecting it to work. It could be made to work or we could explicitly disable it for records.

Similarly, this code fails:
{code}
@Builder(builderStrategy=InitializerStrategy)
record Developer(Integer id, String first, String last, String email, List<String> skills) { }
Developer.createInitializer().id(2).build()
{code}
with this more obscure error:
{noformat}
java.lang.ArrayIndexOutOfBoundsException: Internal compiler error while compiling ConsoleScript26
Method: org.codehaus.groovy.ast.MethodNode@7cd420f9[Developer$DeveloperInitializer id(java.lang.Integer) from Developer$DeveloperInitializer]
Line -1, expecting casting to Developer$DeveloperInitializer<groovy.transform.builder.InitializerStrategy$SET, T1, T2, T3, T4> but operand stack is empty
        ...
	at org.codehaus.groovy.classgen.asm.OperandStack.doConvertAndCast(OperandStack.java:340)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeReturn(StatementWriter.java:593)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:822)
...
{noformat}
I would probably just used the named args style rather than a builder, e.g.:
{code}
var dev1 = new Developer(id: 1, first: 'Dan', last: 'Vega', email: 'danvega@gmail.com', skills: ['Java', 'Spring'])
assert dev1.with{ [id, first, last, email, skills] } ==
//  [1, 'Dan', 'Vega', 'danvega@gmail.com', ['Java', 'Spring']]
{code}
But we should either support or disable one or more of the @Builder strategies.

Builder can also be written on constructors. That does work for the default strategy but again not for the InitializerStrategy. Here is a working example:
{code}
import groovy.transform.builder.*
record Developer(Integer id, String first, String last, String email, List<String> skills) {
    @Builder
    Developer(Integer id, String full, String email, List<String> skills) {
        this(id, full.split(' ')[0], full.split(' ')[1], email, skills)
    }
}

var dev1 = new Developer(id: 1, first: 'Dan', last: 'Vega', email: 'danvega@gmail.com', skills: ['Java', 'Spring'])

assert dev1.with{ [id, first, last, email, skills] } ==
  [1, 'Dan', 'Vega', 'danvega@gmail.com', ['Java', 'Spring']]

var dev2 = Developer.builder().id(2).full('Paul King').email('paulk@apache.org').skills(['Java', 'Groovy']).build()

assert dev2.with{ [id, first, last, email, skills] } ==
  [2, 'Paul', 'King', 'paulk@apache.org', ['Java', 'Groovy']]
{code}",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Wed Mar 08 12:13:49 UTC 2023,,,,,,,,,,"0|z1g8x4:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Mar/23 05:33;githubbot;paulk-asert merged PR #1868:
URL: https://github.com/apache/groovy/pull/1868


;;;","08/Mar/23 12:13;paulk;Proposed PR merged.;;;",,,,,,,,,,
 Non-static method java.lang.Object#hashCode cannot be called from static context,GROOVY-10939,13524986,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,sdelamo,sdelamo,16/Feb/23 09:37,15/Jun/23 14:30,13/Jul/23 08:58,16/Feb/23 19:17,4.0.7,4.0.8,4.0.9,,,,3.0.16,4.0.10,,,,,0,,,,"Updating Micronaut Framework 4.0.x branch to 4.0.9 we got the following issue:
https://github.com/micronaut-projects/micronaut-core/pull/8784#discussion_r1108171939
{code}
[Static type checking] - Non-static method java.lang.Object#hashCode cannot be called from static context @ line 99, column 16. return visitor.getClass().hashCode(){code}",,emilles,sdelamo,,,,,,,,,,,,,,GROOVY-10820,GROOVY-7987,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Thu Feb 16 19:17:18 UTC 2023,,,,,,,,,,"0|z1fza8:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Feb/23 19:17;emilles;https://github.com/apache/groovy/commit/9372f23311fe711301d18e5036cef44aa388f029;;;",,,,,,,,,,,
record + lombok + groovy == Cannot specify duplicate annotation on the same member : lombok.NonNull,GROOVY-10937,13524743,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,szpak,szpak,15/Feb/23 00:20,13/Mar/23 12:15,13/Jul/23 08:58,24/Feb/23 00:02,4.0.9,,,,,,4.0.10,,,Compiler,,,0,annotations,,,"I've bumped into a strange looking compilation error in a project using JDK 17 record, Lombok's @NotNull and Groovy for tests. It took me a while to find a construction which causes that, as:
 # Compilation error occurs in a Groovy class not related to the problematic Java record.
 # Groovy class must have (non related) inner interface or class.
 # Record has must have two (or more) fields with @NotNull annotation from Lombok.
 # Some (other) Groovy class has to refer to that record.

For example:
{code:java}
// Java
public record SampleRecordWithNonNullFromLombok(
        @NonNull
        String nonNullField,
        @NonNull        //Two or more @NulNull annotated fields are required to trigger the problem
        String nonNullField2
) {}

//Groovy
class ClassWithReferenceToRecord {
    private SampleRecordWithNonNullFromLombok sampleRecord
}

class ReproducerClass {  //it fails to compile

    interface RequiredToReproduceProblem {
    }
}{code}
The error is:
{code:java}
[ERROR] Failed to execute goal org.codehaus.gmavenplus:gmavenplus-plugin:1.13.1:compileTests (default) on project record-lombok-groovy: Error occurred while calling a method on a Groovy class from classpath.: InvocationTargetException: startup failed:
[ERROR] .../ReproducerClass.groovy: -1: Cannot specify duplicate annotation on the same member : lombok.NonNull
[ERROR]  @ line -1, column -1.
[ERROR] 1 error
{code}
I created a shrank version of a reproducer:

[https://github.com/szpak/code-examples-and-poc/tree/master/record-lombok-groovy]

 

It might be a problem with the way how Lombok generates .class for Java record, however, I start here as Groovy compilation is the final reason.

I have observed that error occasionally with Groovy 3(.0.14), but it occurs every time with 4(0.9).",,emilles,szpak,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Mon Mar 06 20:44:09 UTC 2023,,,,,,,,,,"0|z1fxsg:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Feb/23 22:22;emilles;Type annotations are being added to the shared instance of String within ClassSignatureParser.
{code:java}
public record SampleRecordWithNonNullFromLombok(
  @NonNull
  String nonNullField,
  @NonNull // Two or more @NulNull annotated fields are required to trigger the problem
  String nonNullField2)
{
}
{code};;;","24/Feb/23 00:02;emilles;https://github.com/apache/groovy/commit/e5ca7e630e4bffd368d27eabb30c6158fad4d23c
https://github.com/apache/groovy/commit/99af5dfacce807e7ba95fa2dff5e505cd489f610;;;","06/Mar/23 20:44;szpak;Thanks [~emilles] . I've just tested it with the original project and it worked!;;;",,,,,,,,,
MissingPropertyException truncates nested class name,GROOVY-10935,13524541,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,chrylis,chrylis,13/Feb/23 21:23,13/Mar/23 12:15,13/Jul/23 08:58,23/Feb/23 00:25,4.0.9,,,,,,4.0.10,,,,,,0,,,,"When a nested class is the target of an invalid property expression, the resulting error message has the wrong class name:

{code:groovy}
class Outer {
  static class Inner {}
}

new Outer.Inner().missing
{code}

results in

{code}
groovy.lang.MissingPropertyException: No such property: missing for class: com.example.Outer
{code}",,chrylis,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Thu Feb 23 00:25:40 UTC 2023,,,,,,,,,,"0|z1fwjk:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Feb/23 14:55;emilles;{code}
groovy.lang.MissingPropertyException: No such property: missing for class: Outer
	at Outer$Inner.propertyMissing(Scratch.groovy)
{code}

The inner class has a synthetic {{propertyMissing}} method that tries the outer class.  This would need to catch MissingPropertyException and produce one for the inner class (or modify the message of the outer's exception).
{code:java}
        addSyntheticMethod(node,
                ""propertyMissing"",
                ACC_PUBLIC,
                OBJECT_TYPE,
                params(param(STRING_TYPE, ""name"")),
                (methodBody, parameters) -> {
                    if (isStatic) {
                        setPropertyGetterDispatcher(methodBody, classX(outerClass), parameters);
                    } else {
                        methodBody.addStatement(
                                new BytecodeSequence(new BytecodeInstruction() {
                                    @Override
                                    public void visit(final MethodVisitor mv) {
                                        getThis(mv, classInternalName, outerClassDescriptor, outerClassInternalName);
                                        mv.visitVarInsn(ALOAD, 1);
                                        mv.visitMethodInsn(INVOKEVIRTUAL, outerClassInternalName, ""this$dist$get$"" + outerClassDistance, ""(Ljava/lang/String;)Ljava/lang/Object;"", false);
                                        mv.visitInsn(ARETURN);
                                    }
                                })
                        );
                    }
                }
        );
{code};;;","23/Feb/23 00:25;emilles;https://github.com/apache/groovy/commit/95103625d0162b3018513e2664dd51cefa3eeaaa;;;",,,,,,,,,,
Bootstrap Method Error on non-void lambda for Consumer,GROOVY-10933,13524539,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,chrylis,chrylis,13/Feb/23 21:19,13/Mar/23 12:14,13/Jul/23 08:58,14/Feb/23 15:48,4.0.9,,,,,,3.0.16,4.0.10,,Static compilation,,,0,,,,"When a method that returns a value is used as a {{Consumer}}, a runtime {{Error}} is produced.

{code:groovy}
class BugRepro extends Specification {
    def 'repro'() {
        expect:
        new Demo().run()
    }
}

@CompileStatic
class Demo {
    List<String> strings = []

    void run() {
        Optional.of('hello')
            .ifPresent(strings::add)
    }
}
{code}

{code}
Condition failed with Exception:

new Demo().run()
|          |
|          java.lang.BootstrapMethodError: bootstrap method initialization exception
|          	at java.base/java.lang.invoke.BootstrapMethodInvoker.invoke(BootstrapMethodInvoker.java:194)
|          	at java.base/java.lang.invoke.CallSite.makeSite(CallSite.java:307)
|          	at java.base/java.lang.invoke.MethodHandleNatives.linkCallSiteImpl(MethodHandleNatives.java:258)
|          	at java.base/java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:248)
|          	at Demo.run(BugRepro.groovy:18)
|          	at BugRepro.repro(BugRepro.groovy:9)
|          Caused by: java.lang.invoke.LambdaConversionException: Type mismatch for lambda expected return: boolean is not convertible to void
|          	at java.base/java.lang.invoke.AbstractValidatingLambdaMetafactory.checkDescriptor(AbstractValidatingLambdaMetafactory.java:317)
|          	at java.base/java.lang.invoke.AbstractValidatingLambdaMetafactory.validateMetafactoryArgs(AbstractValidatingLambdaMetafactory.java:294)
|          	at java.base/java.lang.invoke.LambdaMetafactory.metafactory(LambdaMetafactory.java:328)
|          	at java.base/java.lang.invoke.BootstrapMethodInvoker.invoke(BootstrapMethodInvoker.java:127)
|          	... 5 more
<Demo@18e8473e strings=[]>

	at BugRepro.repro(BugRepro.groovy:9)
Caused by: java.lang.BootstrapMethodError: bootstrap method initialization exception
	at java.base/java.lang.invoke.BootstrapMethodInvoker.invoke(BootstrapMethodInvoker.java:194)
	at java.base/java.lang.invoke.CallSite.makeSite(CallSite.java:307)
	at java.base/java.lang.invoke.MethodHandleNatives.linkCallSiteImpl(MethodHandleNatives.java:258)
	at java.base/java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:248)
	at Demo.run(BugRepro.groovy:18)
	... 1 more
Caused by: java.lang.invoke.LambdaConversionException: Type mismatch for lambda expected return: boolean is not convertible to void
	at java.base/java.lang.invoke.AbstractValidatingLambdaMetafactory.checkDescriptor(AbstractValidatingLambdaMetafactory.java:317)
	at java.base/java.lang.invoke.AbstractValidatingLambdaMetafactory.validateMetafactoryArgs(AbstractValidatingLambdaMetafactory.java:294)
	at java.base/java.lang.invoke.LambdaMetafactory.metafactory(LambdaMetafactory.java:328)
	at java.base/java.lang.invoke.BootstrapMethodInvoker.invoke(BootstrapMethodInvoker.java:127)
	... 5 more
{code}",,chrylis,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue Feb 14 15:48:14 UTC 2023,,,,,,,,,,"0|z1fwj4:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Feb/23 15:48;emilles;https://github.com/apache/groovy/commit/40d7e5e32d494952ad88c83d01eda63505eab2c3;;;",,,,,,,,,,,
STC accepts program although constructor reference is invalid,GROOVY-10930,13524205,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,theosot,theosot,10/Feb/23 10:46,12/Apr/23 14:13,13/Jul/23 08:58,15/Feb/23 16:59,,,,,,,5.0.0-alpha-1,,,Static Type Checker,,,0,,,,"I have the following program

{code}
import java.util.function.*;

class Bar {}

public class Test {

    public static void main(String[] args) {
      m(Bar::new);
    }

    static <X> void m(Function<String, X> d) {
      d.apply(""dfa"")
    }
}
{code}

h3. Actual behavior

The compiler accepts the program, but notice that the constructor reference is invalid. So, at runtime, we get:

{code}
Exception in thread ""main"" groovy.lang.GroovyRuntimeException: Could not find matching constructor for: Bar(String)
        at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1908)
        at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1677)
        at org.codehaus.groovy.vmplugin.v8.IndyInterface.fromCache(IndyInterface.java:321)
        at Test.ctorRef$main$0(test.groovy)
        at Test.m(test.groovy:13)
        at Test.main(test.groovy:9)
{code}

h3. Expected behavior

The compiler should have rejected this example program.

Tested against master (commit: 2c40df2827b8d1bc941bd6ebdc386b3f9bc3bf3b)",,emilles,theosot,,,,,,,,,,,,,,,,,,,,,GROOVY-10971,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Wed Feb 15 16:59:23 UTC 2023,,,,,,,,,,"0|z1fugw:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Feb/23 16:59;emilles;https://github.com/apache/groovy/commit/eb61b270f4d6bdb1fb51f10b01cc7e6afbaf9d18;;;",,,,,,,,,,,
Method closure somehow doesn't match argument,GROOVY-10929,13523832,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,emilles,chrylis,chrylis,08/Feb/23 20:34,30/May/23 21:13,13/Jul/23 08:58,15/Feb/23 18:34,4.0.8,,,,,,3.0.16,4.0.10,,Compiler,,,0,,,,"I do not understand at all how this is happening, but when I pass class literals to a method closure whose parameter is a {{Class}}, I'm getting {{MissingMethodException}}. This seems to have something to do with ASTTs, because it only happens when {{TupleConstructor}} is involved. In my business code, {{TupleConstructor}} on a top-level containing class triggers the error on a static nested class; I have a repro, but I'm only able to make it trigger on the specific class involved.

In any case, in my business code I'm using {{@CompileStatic}}, but that doesn't seem to be protecting me against runtime dynamic dispatch.

{code:groovy}
@Grab(group='software.amazon.awssdk', module='dynamodb-enhanced', version='2.19.25')
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.*
import software.amazon.awssdk.enhanced.dynamodb.TableSchema
import java.util.function.Function
import groovy.transform.*

@DynamoDbBean @TupleConstructor(defaults=false)
class TopLevel {
    String id

    @DynamoDbPartitionKey
    String getId() { id }

    @DynamoDbBean
    @ToString
    static class Nested {
        String id

        @DynamoDbPartitionKey
        String getId() { id }
    }
}

// https://javadoc.io/static/software.amazon.awssdk/dynamodb-enhanced/2.19.25/software/amazon/awssdk/enhanced/dynamodb/TableSchema.html#fromClass-java.lang.Class-
Function<Class<?>, TableSchema<?>> func = TableSchema.&fromClass
func.apply(TopLevel) // XXX
func.apply(TopLevel.Nested)
{code}

{code}
Condition failed with Exception:

func.apply(TopLevel)
|    |     |
|    |     class com.example.TopLevel
|    groovy.lang.MissingMethodException: No signature of method: org.codehaus.groovy.runtime.MethodClosure.fromClass() is applicable for argument types: (Class) values: [class com.example.TopLevel]
|    Possible solutions: getClass(), metaClass(groovy.lang.Closure)
|    	at com.example.BugRepl.top-level(BugRepl.groovy:19)
org.codehaus.groovy.runtime.MethodClosure@6a472566
{code}

I'm tagging this as critical because it's a ""can't-possibly-happen"" bug (at least in static mode) that has apparently been latent in an internal library for months and is still present as of 4.0.8.",,chrylis,emilles,,,,,,,,,,,,,,,,,,,,,GROOVY-11075,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Wed Feb 15 18:34:29 UTC 2023,,,,,,,,,,"0|z1fs68:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Feb/23 20:57;chrylis;Update: This is possibly Groovy incorrectly catching and masking a downstream {{IllegalArgumentException}}. I am suspicious of {{MetaClassImpl:1022}}.;;;","09/Feb/23 14:18;emilles;Updated description to make runnable example.;;;","15/Feb/23 17:09;emilles;This is the exception that is swallowed: {{IllegalArgumentException}}: Class 'class TopLevel' appears to have no default constructor thus cannot be used with the {{BeanTableSchema}}

Removing ""defaults=false"" or adding a no-argument constructor avoids the exception.;;;","15/Feb/23 18:34;emilles;https://github.com/apache/groovy/commit/1e2111d154a53ab25ced36d85c6634c3a3c4ddbe
https://github.com/apache/groovy/commit/8858b4964d3bf2d8695c697348738c8b01f2b167;;;",,,,,,,,
Invalid stub code for interface field,GROOVY-10928,13523307,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,chrylis,chrylis,06/Feb/23 21:16,13/Mar/23 12:14,13/Jul/23 08:58,07/Feb/23 21:20,4.0.8,,,,,,3.0.16,4.0.10,,Stub generator / Joint compiler,,,0,,,,"When compiling this interface:

{code:groovy}
@CompileStatic
interface Service {
  TypeReference<Map<String, Object>> STATE_TYPE_MAP = new TypeReference<Map<String, Object>>(){}
}
{code}

the stub generator produces code that does not compile under Java 11:

{code:java}
@groovy.transform.CompileStatic() public interface Service
<T> {
;
com.fasterxml.jackson.core.type.TypeReference<java.util.Map<java.lang.String, java.lang.Object>> STATE_TYPE_MAP;
static { STATE_TYPE_MAP = null; }
{code}

{code}
[ERROR] Service.java:[6,112] = expected
[ERROR] Service.java:[7,8] initializers not allowed in interfaces
{code}
",,chrylis,emilles,,,,,,,,,,,,,,GROOVY-5150,GROOVY-10902,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue Feb 07 22:35:24 UTC 2023,,,,,,,,,,"0|z1foxk:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Feb/23 21:20;emilles;https://github.com/apache/groovy/commit/b7750371c763e8aa135a11cc118fdcf93695f0d2;;;","07/Feb/23 22:35;emilles;fixed in 4.0.10 and 3.0.16 -- unless they stop the release train;;;",,,,,,,,,,
stack overflow calling implicit getter/setter from override,GROOVY-10922,13522115,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,jasongarrett,jasongarrett,30/Jan/23 20:07,10/Feb/23 21:31,13/Jul/23 08:58,02/Feb/23 16:24,2.5.19,2.5.20,2.5.21,3.0.14,,,2.5.22,3.0.15,4.0.9,Compiler,Static compilation,,0,StackOverflowError,,,"In the following situation, under static compilation:
 * An interface declares a getter and/or setter
 * An implementing class declares a property of the corresponding name and type, so the implicit getter and/or setter implement the interface
 * A subclass overrides the getter/setter and calls the super getter/setter

the subclass getter/setter will recurse instead of calling the superclass implicit method.

This appears to have been introduced in 3.0.14.

Running the main method in this example will reproduce the stack overflow.
{code:java}
package example

import groovy.transform.CompileStatic

@CompileStatic
class SuperImplicitSetter {
   interface FooHaving {
      String getFoo()
      void setFoo(String foo)
   }

   static class Foo implements FooHaving {
      String foo  // implements interface
   }

   static class Bar extends Foo {
      String bar

      @Override
      void setFoo(String foo) {
         super.setFoo(foo)  // recurses instead of calling implicit Foo.setFoo(String)
         bar = foo
      }
   }

   static void main(String[] args) {
      Bar bar = new Bar()
      bar.setFoo(""bar"")  // stack overflow
      println bar.foo
   }
}
 {code}",,emilles,jasongarrett,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Thu Feb 02 16:24:02 UTC 2023,,,,,,,,,,"0|z1fhn4:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Feb/23 16:24;emilles;https://github.com/apache/groovy/commit/282ba5cd6d74acbe7f8aa57244a82730d0aae2d5;;;",,,,,,,,,,,
Compiler exception with void expression as while condition with CompileStatic,GROOVY-10920,13521815,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,jasongarrett,jasongarrett,27/Jan/23 23:01,30/Apr/23 01:17,13/Jul/23 08:58,30/Apr/23 00:08,2.5.14,3.0.8,,,,,3.0.18,4.0.12,,Compiler,,,0,VerifyError,,,"Under static compilation, using a void expression as the condition (or part of the condition) of a while statement causes the compiler to throw exceptions.

This code:
{code:java}
package example

import groovy.transform.CompileStatic

@CompileStatic
class WhileVoid {
	void isSo() {
		null
	}

	void myBuggyConstruct() {
		while(isSo()) {
			null
		}
	}
}
{code}
results in this exception from the compiler:
{code:java}
startup failed:
General error during instruction selection: ASM reporting processing error for example.WhileVoid#myBuggyConstruct with signature void myBuggyConstruct() in WhileVoid.groovy:11. /Users/jasongarrett/scratch/scratch/src/main/groovy/example/WhileVoid.groovy

groovy.lang.GroovyRuntimeException: ASM reporting processing error for example.WhileVoid#myBuggyConstruct with signature void myBuggyConstruct() in WhileVoid.groovy:11. /Users/jasongarrett/scratch/scratch/src/main/groovy/example/WhileVoid.groovy
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:432)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:106)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:557)
	at org.codehaus.groovy.ast.ClassNode.visitMethods(ClassNode.java:1094)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1087)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:52)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:273)
	at org.codehaus.groovy.control.CompilationUnit$3.call(CompilationUnit.java:798)
	at org.codehaus.groovy.control.CompilationUnit$IPrimaryClassNodeOperation.doPhaseOperation(CompilationUnit.java:943)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:672)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:636)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:611)
	at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:277)
	at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:67)
	at org.gradle.api.internal.tasks.compile.GroovyCompilerFactory$DaemonSideCompiler.execute(GroovyCompilerFactory.java:98)
	at org.gradle.api.internal.tasks.compile.GroovyCompilerFactory$DaemonSideCompiler.execute(GroovyCompilerFactory.java:77)
	at org.gradle.api.internal.tasks.compile.daemon.AbstractDaemonCompiler$CompilerWorkAction.execute(AbstractDaemonCompiler.java:135)
	at org.gradle.workers.internal.DefaultWorkerServer.execute(DefaultWorkerServer.java:63)
	at org.gradle.workers.internal.AbstractClassLoaderWorker$1.create(AbstractClassLoaderWorker.java:49)
	at org.gradle.workers.internal.AbstractClassLoaderWorker$1.create(AbstractClassLoaderWorker.java:43)
	at org.gradle.internal.classloader.ClassLoaderUtils.executeInClassloader(ClassLoaderUtils.java:97)
	at org.gradle.workers.internal.AbstractClassLoaderWorker.executeInClassLoader(AbstractClassLoaderWorker.java:43)
	at org.gradle.workers.internal.IsolatedClassloaderWorker.run(IsolatedClassloaderWorker.java:49)
	at org.gradle.workers.internal.IsolatedClassloaderWorker.run(IsolatedClassloaderWorker.java:30)
	at org.gradle.workers.internal.WorkerDaemonServer.run(WorkerDaemonServer.java:85)
	at org.gradle.workers.internal.WorkerDaemonServer.run(WorkerDaemonServer.java:55)
	at org.gradle.process.internal.worker.request.WorkerAction$1.call(WorkerAction.java:138)
	at org.gradle.process.internal.worker.child.WorkerLogEventListener.withWorkerLoggingProtocol(WorkerLogEventListener.java:41)
	at org.gradle.process.internal.worker.request.WorkerAction.run(WorkerAction.java:135)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:414)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0
	at groovyjarjarasm.asm.Frame.merge(Frame.java:1268)
	at groovyjarjarasm.asm.Frame.merge(Frame.java:1233)
	at groovyjarjarasm.asm.MethodWriter.computeAllFrames(MethodWriter.java:1611)
	at groovyjarjarasm.asm.MethodWriter.visitMaxs(MethodWriter.java:1547)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:413)
Caused by: java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0
{code}
This example, with a slightly more complex condition for the while loop:
{code:java}
package example

import groovy.transform.CompileStatic

@CompileStatic
class WhileNotVoid {
	List list = []

	void isSo() {
		null
	}

	void myBuggyConstruct() {
		while(!list.empty && !isSo()) {
			null
		}
	}
}
{code}
results in a different compiler exception:
{code:java}
BUG! exception in phase 'class generation' in source unit '/Users/jasongarrett/scratch/scratch/src/main/groovy/example/WhileNotVoid.groovy' operand stack contains 2 elements, but we expected only 0
{code}",,emilles,jasongarrett,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Sun Apr 30 00:08:57 UTC 2023,,,,,,,,,,"0|z1fftk:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Jan/23 15:59;jasongarrett;This affects 3.0 back to at least 3.0.8 and 2.5 back to at least 2.5.14.;;;","30/Apr/23 00:08;emilles;https://github.com/apache/groovy/commit/942ae9b3b2ce008df739448086084ca5b8f9683d;;;",,,,,,,,,,
"@MapConstructor Breaks in Groovy4 when combined with @TupleConstructor, fine in Groovy3",GROOVY-10919,13521668,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,aibolit,aibolit,26/Jan/23 21:39,10/Feb/23 21:31,13/Jul/23 08:58,03/Feb/23 17:17,4.0.8,,,,,,4.0.9,,,,,,0,,,,"@MapConstructor Breaks in Groovy4 when combined with @TupleConstructor, fine in Groovy3

 

Example in Groovy4
{code:java}
import groovy.transform.*
@MapConstructor(includeFields = true)
@TupleConstructor(includeFields = true)
@ToString(includeNames = true, includeFields = true)
class Foo {    
  private final float w = 1    
  private final int x    
  private int y = 1    
  private final int z
}
println new Foo(x:2, z: 3){code}

outputs the incorrect value
{code:java}
Foo(x:2, y:0, z:3){code}


In Groovy3 it outputs the correct 
{code:java}
Foo(x:2, y:1, z:3){code}
Also commenting out @TupleConstructor in Groovy4 causes the output to be the correct value. 

 ",,aibolit,emilles,paulk,,,,,,,,,,,,,GROOVY-10238,,,,,,,GROOVY-10925,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Fri Feb 03 17:17:08 UTC 2023,,,,,,,,,,"0|z1fex4:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Feb/23 00:12;paulk;If you are wanting default values and tuple constructors and map-like constructors, the now recommended approach to achieve what you are after in Groovy 4 is to leave out {{@MapConstructor}} and instead use the {{namedVariant}} attribute with {{@TupleConstructor}}, i.e. use:
{code}
@TupleConstructor(includeFields = true, namedVariant = true)
{code}
;;;","03/Feb/23 17:17;emilles;https://github.com/apache/groovy/commit/e18e8923e973614e30107f084a0033311f5e8b39;;;",,,,,,,,,,
Memory leak: local variable values are not discarded,GROOVY-10918,13521641,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,arysin,arysin,26/Jan/23 17:38,13/Mar/23 12:14,13/Jul/23 08:58,16/Feb/23 15:04,4.0.9,,,,,,2.5.22,3.0.16,4.0.10,bytecode,Compiler,,0,MemoryLeak,,,"When I run the code below with 3 statements with closures inside the method the local var (parameter) values (all 4 of them) are staying in memory.
I don't see the same problem if I run corresponding Java code with lambdas.

Run TestOOM.groovy with 
-Xmx600M -XX:+HeapDumpOnOutOfMemoryError

Notice groovy fails:
Y
Z
java.lang.OutOfMemoryError: Java heap space
Dumping heap to java_pid147612.hprof ...
Heap dump file created [497819587 bytes in 0.136 secs]
Caught: java.lang.OutOfMemoryError: Java heap space
java.lang.OutOfMemoryError: Java heap space
    at test.TestOOM.test(TestOOM.groovy:31)
    at test.TestOOM.run(TestOOM.groovy:41)

But Java version does not.

It looks like all the values of s are still in memory (see screenshot), even though previous values should be discarded.",,arysin,emilles,,,,,,,,,,,,,,,,,,,,,,,"26/Jan/23 17:33;arysin;TestOOM.groovy;https://issues.apache.org/jira/secure/attachment/13054825/TestOOM.groovy","05/Feb/23 16:43;arysin;TestOOMIcj.java;https://issues.apache.org/jira/secure/attachment/13055163/TestOOMIcj.java","26/Jan/23 17:33;arysin;TestOOMJ.java;https://issues.apache.org/jira/secure/attachment/13054824/TestOOMJ.java","11/Feb/23 16:56;arysin;TestOOM_works.groovy;https://issues.apache.org/jira/secure/attachment/13055363/TestOOM_works.groovy","26/Jan/23 17:37;arysin;groovy_oom.png;https://issues.apache.org/jira/secure/attachment/13054823/groovy_oom.png",,5.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Thu Feb 16 15:04:40 UTC 2023,,,,,,,,,,"0|z1fer4:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Feb/23 16:46;arysin;Here's another example: TestOOMIcj.java - uses internal class.

Works:
{code:java}
JAVA_TOOL_OPTIONS=""-Xmx600M"" java TestOOMIcj.java{code}
Throws OOM:

 
{code:java}
cp TestOOMIcj.java TestOOMIcj.groovy
JAVA_TOOL_OPTIONS=""-Xmx600M"" groovy TestOOMIcj.groovy
{code}
 

 ;;;","11/Feb/23 16:57;arysin;Interestingly if I don't reuse the same local var and reset intermediate ones to null the script works (TestOOM_works.groovy);;;","11/Feb/23 17:39;arysin;Possibly related to GROOVY-7886 ?;;;","12/Feb/23 20:10;emilles;What kind of behavior do you get with lambdas?  They should match java and do not require creation of Integer parameter and Closure object.
{code:groovy}
import java.util.stream.Collectors

test(""W""*(100*1024*1024))
@groovy.transform.CompileStatic
String test(String s) {
  s = s.chars().mapToObj(ch -> ""X"").collect(Collectors.joining())
  println s.charAt(0)
  s = s.chars().mapToObj(ch -> ""Y"").collect(Collectors.joining())
  println s.charAt(0)
  s = s.chars().mapToObj(ch -> ""Z"").collect(Collectors.joining())
  println s.charAt(0)
  return s
}
{code};;;","12/Feb/23 20:31;arysin;So initially I thought it was related to closures, but then I used inner class instead, and it has the same problem - see comment above with TestOOMIcj.java - same code runs in Java but gets OOM in groovy.

It looks like a problem with local output variables not being cleaned up. Reusing 's' leads to OOM even though previous values should be discarded, if I create new var for each transformation (and set previous ones to null) - this works.

Java seems to be able to drop intermediate values but groovy does not.;;;","15/Feb/23 21:11;emilles;Given your example:
{code:groovy}
@groovy.transform.CompileStatic // line 1
String test(String s) {
  s = s.chars().mapToObj{""X""}.collect(Collectors.joining())
  println s.charAt(0)
  s = s.chars().mapToObj{""Y""}.collect(Collectors.joining())
  println s.charAt(0)
  s = s.chars().mapToObj{""Z""}.collect(Collectors.joining())
  println s.charAt(0)
  return s
}
{code}

The bytecode for the method looks like this:
{code}
public java.lang.String test(java.lang.String s);
      0  aload_1 [s]
      1  invokevirtual java.lang.String.chars() : java.util.stream.IntStream [92]
      4  new Scratch$_test_closure1 [94]
      7  dup
      8  aload_0 [this]
      9  aload_0 [this]
     10  invokespecial Scratch$_test_closure1(java.lang.Object, java.lang.Object) [97]
     13  invokedynamic 2 cast(groovy.lang.Closure) : java.util.function.IntFunction [100]
     18  invokeinterface java.util.stream.IntStream.mapToObj(java.util.function.IntFunction) : java.util.stream.Stream [106] [nargs: 2]
     23  invokestatic java.util.stream.Collectors.joining() : java.util.stream.Collector [112]
     26  invokeinterface java.util.stream.Stream.collect(java.util.stream.Collector) : java.lang.Object [118] [nargs: 2]
     31  astore_2
     32  aload_2
     33  invokedynamic 2 cast(java.lang.Object) : java.lang.String [61]
     38  astore_1 [s]
     39  aload_2
     40  pop
     41  aload_0 [this]
     42  aload_1 [s]
     43  iconst_0
     44  invokevirtual java.lang.String.charAt(int) : char [122]
     47  invokestatic java.lang.Character.valueOf(char) : java.lang.Character [128]
     50  invokevirtual Scratch.println(java.lang.Object) : void [131]
     53  aconst_null
     54  pop
     55  aload_1 [s]
     56  invokevirtual java.lang.String.chars() : java.util.stream.IntStream [92]
     59  new Scratch$_test_closure2 [133]
     62  dup
     63  aload_0 [this]
     64  aload_0 [this]
     65  invokespecial Scratch$_test_closure2(java.lang.Object, java.lang.Object) [134]
     68  invokedynamic 2 cast(groovy.lang.Closure) : java.util.function.IntFunction [100]
     73  invokeinterface java.util.stream.IntStream.mapToObj(java.util.function.IntFunction) : java.util.stream.Stream [106] [nargs: 2]
     78  invokestatic java.util.stream.Collectors.joining() : java.util.stream.Collector [112]
     81  invokeinterface java.util.stream.Stream.collect(java.util.stream.Collector) : java.lang.Object [118] [nargs: 2]
     86  astore_3
     87  aload_3
     88  invokedynamic 2 cast(java.lang.Object) : java.lang.String [61]
     93  astore_1 [s]
     94  aload_3
     95  pop
     96  aload_0 [this]
     97  aload_1 [s]
     98  iconst_0
     99  invokevirtual java.lang.String.charAt(int) : char [122]
    102  invokestatic java.lang.Character.valueOf(char) : java.lang.Character [128]
    105  invokevirtual Scratch.println(java.lang.Object) : void [131]
    108  aconst_null
    109  pop
    110  aload_1 [s]
    111  invokevirtual java.lang.String.chars() : java.util.stream.IntStream [92]
    114  new Scratch$_test_closure3 [136]
    117  dup
    118  aload_0 [this]
    119  aload_0 [this]
    120  invokespecial Scratch$_test_closure3(java.lang.Object, java.lang.Object) [137]
    123  invokedynamic 2 cast(groovy.lang.Closure) : java.util.function.IntFunction [100]
    128  invokeinterface java.util.stream.IntStream.mapToObj(java.util.function.IntFunction) : java.util.stream.Stream [106] [nargs: 2]
    133  invokestatic java.util.stream.Collectors.joining() : java.util.stream.Collector [112]
    136  invokeinterface java.util.stream.Stream.collect(java.util.stream.Collector) : java.lang.Object [118] [nargs: 2]
    141  astore 4
    143  aload 4
    145  invokedynamic 2 cast(java.lang.Object) : java.lang.String [61]
    150  astore_1 [s]
    151  aload 4
    153  pop
    154  aload_0 [this]
    155  aload_1 [s]
    156  iconst_0
    157  invokevirtual java.lang.String.charAt(int) : char [122]
    160  invokestatic java.lang.Character.valueOf(char) : java.lang.Character [128]
    163  invokevirtual Scratch.println(java.lang.Object) : void [131]
    166  aconst_null
    167  pop
    168  aload_1 [s]
    169  areturn
      Line numbers:
        [pc: 0, line: 3]
        [pc: 41, line: 4]
        [pc: 55, line: 5]
        [pc: 96, line: 6]
        [pc: 110, line: 7]
        [pc: 154, line: 8]
        [pc: 168, line: 9]
      Local variable table:
        [pc: 0, pc: 170] local: this index: 0 type: Scratch
        [pc: 0, pc: 170] local: s index: 1 type: java.lang.String
{code}

So it appears to be using local variable slots 2, 3 and 4 to save intermediate results before assigning back to ""s"" (slot 1).;;;","15/Feb/23 21:22;emilles;{{BinaryExpressionHelper}} accounts for chain assignment ""x = y = z"" when processing ""y = z"" as well as assignment expression being the last in a method, which makes it the return value.  So, it saves the value to a temporary variable:
{code:java}
rhsValueId = compileStack.defineTemporaryVariable(""$rhs"", rhsType, true);
{code}.
If you use ""direct assignment"", that is declaring a variable like ""String s1 = ..."" it does not do this.  This is what your {{TestOOM_works.groovy}} demonstrates.;;;","15/Feb/23 22:44;arysin;Thank you for looking into this! So:

1) if I reassign the var 10 times in the method I use 10x or memory?

2) is it different behavior than in Java (I don't see the same code to do OOM with java);;;","15/Feb/23 23:07;emilles;I would guess that javac handles variable assignment without a temporary.  For groovyc, a left side variable expression could refer to a dynamic variable, local variable, field, setter method or something dynamic.  In order to deal with all this, classgen tries to provide a unified approach for multiple options.  https://github.com/apache/groovy/blob/master/src/main/java/org/codehaus/groovy/classgen/asm/BinaryExpressionHelper.java#L380

I do think I can skip the temp when the target is a local variable (like a parameter in this case). 
 I'm trying that out right now.  My experiment produces this, in case you want to compare to the previous bytecode output:
{code}
public java.lang.String test(java.lang.String s);
      0  aload_1 [s]
      1  invokevirtual java.lang.String.chars() : java.util.stream.IntStream [92]
      4  new Scratch$_test_closure1 [94]
      7  dup
      8  aload_0 [this]
      9  aload_0 [this]
     10  invokespecial Scratch$_test_closure1(java.lang.Object, java.lang.Object) [97]
     13  invokedynamic 2 cast(groovy.lang.Closure) : java.util.function.IntFunction [100]
     18  invokeinterface java.util.stream.IntStream.mapToObj(java.util.function.IntFunction) : java.util.stream.Stream [106] [nargs: 2]
     23  invokestatic java.util.stream.Collectors.joining() : java.util.stream.Collector [112]
     26  invokeinterface java.util.stream.Stream.collect(java.util.stream.Collector) : java.lang.Object [118] [nargs: 2]
     31  invokedynamic 2 cast(java.lang.Object) : java.lang.String [61]
     36  astore_1 [s]
     37  aload_1 [s]
     38  pop
     39  aload_0 [this]
     40  aload_1 [s]
     41  iconst_0
     42  invokevirtual java.lang.String.charAt(int) : char [122]
     45  invokestatic java.lang.Character.valueOf(char) : java.lang.Character [128]
     48  invokevirtual Scratch.println(java.lang.Object) : void [131]
     51  aconst_null
     52  pop
     53  aload_1 [s]
     54  invokevirtual java.lang.String.chars() : java.util.stream.IntStream [92]
     57  new Scratch$_test_closure2 [133]
     60  dup
     61  aload_0 [this]
     62  aload_0 [this]
     63  invokespecial Scratch$_test_closure2(java.lang.Object, java.lang.Object) [134]
     66  invokedynamic 2 cast(groovy.lang.Closure) : java.util.function.IntFunction [100]
     71  invokeinterface java.util.stream.IntStream.mapToObj(java.util.function.IntFunction) : java.util.stream.Stream [106] [nargs: 2]
     76  invokestatic java.util.stream.Collectors.joining() : java.util.stream.Collector [112]
     79  invokeinterface java.util.stream.Stream.collect(java.util.stream.Collector) : java.lang.Object [118] [nargs: 2]
     84  invokedynamic 2 cast(java.lang.Object) : java.lang.String [61]
     89  astore_1 [s]
     90  aload_1 [s]
     91  pop
     92  aload_0 [this]
     93  aload_1 [s]
     94  iconst_0
     95  invokevirtual java.lang.String.charAt(int) : char [122]
     98  invokestatic java.lang.Character.valueOf(char) : java.lang.Character [128]
    101  invokevirtual Scratch.println(java.lang.Object) : void [131]
    104  aconst_null
    105  pop
    106  aload_1 [s]
    107  invokevirtual java.lang.String.chars() : java.util.stream.IntStream [92]
    110  new Scratch$_test_closure3 [136]
    113  dup
    114  aload_0 [this]
    115  aload_0 [this]
    116  invokespecial Scratch$_test_closure3(java.lang.Object, java.lang.Object) [137]
    119  invokedynamic 2 cast(groovy.lang.Closure) : java.util.function.IntFunction [100]
    124  invokeinterface java.util.stream.IntStream.mapToObj(java.util.function.IntFunction) : java.util.stream.Stream [106] [nargs: 2]
    129  invokestatic java.util.stream.Collectors.joining() : java.util.stream.Collector [112]
    132  invokeinterface java.util.stream.Stream.collect(java.util.stream.Collector) : java.lang.Object [118] [nargs: 2]
    137  invokedynamic 2 cast(java.lang.Object) : java.lang.String [61]
    142  astore_1 [s]
    143  aload_1 [s]
    144  pop
    145  aload_0 [this]
    146  aload_1 [s]
    147  iconst_0
    148  invokevirtual java.lang.String.charAt(int) : char [122]
    151  invokestatic java.lang.Character.valueOf(char) : java.lang.Character [128]
    154  invokevirtual Scratch.println(java.lang.Object) : void [131]
    157  aconst_null
    158  pop
    159  aload_1 [s]
    160  areturn
{code};;;","15/Feb/23 23:39;emilles;In addition to declaring a new variable for each string, you could refactor to have each large computation as a separate method.  At the end of each method frame, the locals (including temporary) are discarded.;;;","16/Feb/23 01:51;arysin;Thank you, so my original script had several dozen of String.replaceAll() (it's for cleaning up texts for NLP, and it grew over several years).

In general it was:
{code:java}
text = text.replaceAll(...)
text = text.replaceAll(...)
{code}
It was all good until somebody said they need to run my script on 300MB text file and it choke.

So I've split the code into dozen of methods but I still have 2-5 replacements in each, and if text is 300MB then each replacement still multiply the memory requirement.

I've also started using different var names, but it complicates the logic:

a) I have to make sure in each next replaceAll I don't forget to use the right var (which is if you reorder/refactor may be non-trivial)

b) it gets worse if you have conditional replacements - then just introducing new var does not work, e.g.
{code:java}
def t10 = ...
if( t10.contains('\u2028') ) {
    def t11 = t10.replaceAll(/\u2028\n?/, '\n')
t10 = null // shall I force it here?
    t10 = t11
t11 = null // shall I force it here?
}

def t12 = t10.replaceAll(...){code}
 

 

 ;;;","16/Feb/23 15:04;emilles;https://github.com/apache/groovy/commit/fc7a4f875ce9109be284ce8459a560192d35f86e;;;"
SC: class that provides isCase but not isNotCase,GROOVY-10915,13521156,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,emilles,emilles,24/Jan/23 18:48,09/May/23 13:06,13/Jul/23 08:58,07/May/23 15:17,4.0.0,,,,,,4.0.13,,,groovy-jdk,Static compilation,,0,,,,"Consider the following:
{code:groovy}
class C {
  boolean isCase(value) {
    System.out.println(""C isCase""); true
  }
}
@groovy.transform.CompileStatic // comment out and C#isCase is called for all 3
void test() {
  assert 0 in new C()
  assert !!(0 in new C())
  assert !(0 !in new C())
}
test()
{code}
""x in c"" and ""!(x in c)"" will use C's {{isCase}} method. However ""x !in c"" will use {{DGM.isNotCase(c,x)}} which static dispatches to {{{}DGM.isCase{}}}. The isNotCase extension methods added in Groovy 4 should probably use invokeMethod to dynamic dispatch to make use of the isCase implemented by C.

IMO it would be much simpler to ditch ""isNotCase"" and have ""a not in b"" work identically to ""not(a in b)"" so one cannot implement incongruent ""in"" and ""!in"" handling.  Otherwise, expected behavior could be restored by disabling GROOVY-10383 optimization when declaring class of isCase and isNotCase differ.",,emilles,,,,,,,,,,,,,,,GROOVY-10383,GROOVY-10909,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Sun May 07 15:17:12 UTC 2023,,,,,,,,,,"0|z1fbrk:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Jan/23 19:06;emilles;ScriptBytecodeAdapter dispatches isNotCase to dynamic dispatch isCase:
{code:java}
    public static boolean isCase(Object switchValue, Object caseExpression) throws Throwable {
        if (caseExpression == null) {
            return switchValue == null;
        }
        return DefaultTypeTransformation.castToBoolean(invokeMethodN(caseExpression.getClass(), caseExpression, ""isCase"", new Object[]{switchValue}));
    }

    public static boolean isNotCase(Object switchValue, Object caseExpression) throws Throwable {
        return !isCase(switchValue, caseExpression);
    }
{code};;;","24/Jan/23 19:34;emilles;Implementing ""!in"" in terms of ""isCase"" has suitable precedent.  ""=="" and ""!="" both leverage ""equals"" method.  ""==="" and ""!=="" both leverage ""is"" method.  ""<"", ""<="", "">"", "">="" and ""<=>"" all leverage ""compareTo"" method.;;;","07/May/23 15:17;emilles;https://github.com/apache/groovy/commit/34e1858423b8e4041c39f677942d436a35fdfae4

NOTE: I think you can also shut off ""isNotCase"" via the {{groovy.extension.disable}} system property, but I have not tested.;;;",,,,,,,,,
General error during instruction selection: AIOOBE,GROOVY-10911,13520832,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,jasongarrett,jasongarrett,20/Jan/23 15:42,10/Feb/23 21:31,13/Jul/23 08:58,01/Feb/23 23:34,2.5.19,2.5.20,2.5.21,3.0.13,3.0.14,,2.5.22,3.0.15,4.0.9,Compiler,,,0,,,,"I am attempting to upgrade a large application from Groovy 2.4.15.  The application compiles fine with Groovy 2.4.15 and 2.4.21.  The compiler throws an ArrayIndexOutOfBoundsException using 2.5.20 and 3.0.14.  The output contains no clues as to which class was being processed at the time, so I have no idea how to narrow down the cause.

The stack trace from 3.0.14 is:
{code}
startup failed:
General error during canonicalization: Index 1 out of bounds for length 1

java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1
at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsConnections(StaticTypeCheckingSupport.java:1786)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsConnections(StaticTypeCheckingSupport.java:1765)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsConnections(StaticTypeCheckingSupport.java:1726)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsConnections(StaticTypeCheckingSupport.java:1738)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.inferenceCheck(StaticTypeCheckingSupport.java:1496)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.typeCheckMethodsWithGenerics(StaticTypeCheckingSupport.java:1462)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.typeCheckMethodsWithGenerics(StaticTypeCheckingSupport.java:1419)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.typeCheckMethodsWithGenericsOrFail(StaticTypeCheckingVisitor.java:5732)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorCallExpression(StaticTypeCheckingVisitor.java:2316)
at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitConstructorCallExpression(StaticCompilationVisitor.java:436)
at org.codehaus.groovy.ast.expr.ConstructorCallExpression.visit(ConstructorCallExpression.java:44)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:773)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitDeclarationExpression(CodeVisitorSupport.java:335)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitDeclarationExpression(ClassCodeVisitorSupport.java:150)
at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:89)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:117)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:200)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitExpressionStatement(StaticTypeCheckingVisitor.java:2203)
at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:86)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:164)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBlockStatement(StaticTypeCheckingVisitor.java:4048)
at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitClosureExpression(CodeVisitorSupport.java:239)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClosureExpression(StaticTypeCheckingVisitor.java:2438)
at org.codehaus.groovy.ast.expr.ClosureExpression.visit(ClosureExpression.java:46)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallArguments(StaticTypeCheckingVisitor.java:2846)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:3583)
at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:421)
at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:76)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:117)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:200)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitExpressionStatement(StaticTypeCheckingVisitor.java:2203)
at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:86)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:164)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBlockStatement(StaticTypeCheckingVisitor.java:4048)
at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:138)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:111)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:2192)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:106)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2671)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2639)
at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitConstructorOrMethod(StaticCompilationVisitor.java:236)
at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:251)
at org.codehaus.groovy.ast.ClassNode.visitMethods(ClassNode.java:1094)
at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1087)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:52)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:416)
at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:197)
at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:67)
at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:143)
at org.codehaus.groovy.transform.ASTTransformationVisitor.lambda$addPhaseOperations$2(ASTTransformationVisitor.java:221)
at org.codehaus.groovy.control.CompilationUnit$IPrimaryClassNodeOperation.doPhaseOperation(CompilationUnit.java:943)
at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:672)
at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:636)
at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:611)
at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:268)
at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:68)
at org.gradle.api.internal.tasks.compile.GroovyCompilerFactory$DaemonSideCompiler.execute(GroovyCompilerFactory.java:87)
at org.gradle.api.internal.tasks.compile.GroovyCompilerFactory$DaemonSideCompiler.execute(GroovyCompilerFactory.java:75)
at org.gradle.api.internal.tasks.compile.daemon.AbstractDaemonCompiler$CompilerWorkAction.execute(AbstractDaemonCompiler.java:113)
at org.gradle.workers.internal.DefaultWorkerServer.execute(DefaultWorkerServer.java:47)
at org.gradle.workers.internal.AbstractClassLoaderWorker$1.create(AbstractClassLoaderWorker.java:46)
at org.gradle.workers.internal.AbstractClassLoaderWorker$1.create(AbstractClassLoaderWorker.java:36)
at org.gradle.internal.classloader.ClassLoaderUtils.executeInClassloader(ClassLoaderUtils.java:98)
at org.gradle.workers.internal.AbstractClassLoaderWorker.executeInClassLoader(AbstractClassLoaderWorker.java:36)
at org.gradle.workers.internal.IsolatedClassloaderWorker.execute(IsolatedClassloaderWorker.java:54)
at org.gradle.workers.internal.WorkerDaemonServer.execute(WorkerDaemonServer.java:56)
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.base/java.lang.reflect.Method.invoke(Method.java:566)
at org.gradle.process.internal.worker.request.WorkerAction.run(WorkerAction.java:118)
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.base/java.lang.reflect.Method.invoke(Method.java:566)
at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182)
at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164)
at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:412)
at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)
at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)
at java.base/java.lang.Thread.run(Thread.java:829)
{code}

The stack trace from 2.5.20 is similar:
{code}
startup failed:
General error during instruction selection: Index 1 out of bounds for length 1

java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1
at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsConnections(StaticTypeCheckingSupport.java:1856)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsConnections(StaticTypeCheckingSupport.java:1835)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsConnections(StaticTypeCheckingSupport.java:1791)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsConnections(StaticTypeCheckingSupport.java:1803)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.inferenceCheck(StaticTypeCheckingSupport.java:1562)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.typeCheckMethodsWithGenerics(StaticTypeCheckingSupport.java:1528)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.typeCheckMethodsWithGenerics(StaticTypeCheckingSupport.java:1474)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.typeCheckMethodsWithGenericsOrFail(StaticTypeCheckingVisitor.java:5664)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorCallExpression(StaticTypeCheckingVisitor.java:2359)
at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitConstructorCallExpression(StaticCompilationVisitor.java:439)
at org.codehaus.groovy.ast.expr.ConstructorCallExpression.visit(ConstructorCallExpression.java:44)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:809)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitDeclarationExpression(CodeVisitorSupport.java:296)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitDeclarationExpression(ClassCodeVisitorSupport.java:107)
at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:89)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:120)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:203)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitExpressionStatement(StaticTypeCheckingVisitor.java:2237)
at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:86)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:167)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBlockStatement(StaticTypeCheckingVisitor.java:4004)
at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitClosureExpression(CodeVisitorSupport.java:225)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClosureExpression(StaticTypeCheckingVisitor.java:2497)
at org.codehaus.groovy.ast.expr.ClosureExpression.visit(ClosureExpression.java:46)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallArguments(StaticTypeCheckingVisitor.java:2916)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:3651)
at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:423)
at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:68)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:120)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:203)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitExpressionStatement(StaticTypeCheckingVisitor.java:2237)
at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:86)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:167)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBlockStatement(StaticTypeCheckingVisitor.java:4004)
at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:2226)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:125)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2744)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2712)
at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitConstructorOrMethod(StaticCompilationVisitor.java:235)
at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:250)
at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1074)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:51)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:386)
at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:200)
at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:65)
at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:146)
at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:228)
at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1055)
at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:623)
at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:602)
at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:579)
at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:558)
at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:268)
at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:68)
at org.gradle.api.internal.tasks.compile.GroovyCompilerFactory$DaemonSideCompiler.execute(GroovyCompilerFactory.java:87)
at org.gradle.api.internal.tasks.compile.GroovyCompilerFactory$DaemonSideCompiler.execute(GroovyCompilerFactory.java:75)
at org.gradle.api.internal.tasks.compile.daemon.AbstractDaemonCompiler$CompilerWorkAction.execute(AbstractDaemonCompiler.java:113)
at org.gradle.workers.internal.DefaultWorkerServer.execute(DefaultWorkerServer.java:47)
at org.gradle.workers.internal.AbstractClassLoaderWorker$1.create(AbstractClassLoaderWorker.java:46)
at org.gradle.workers.internal.AbstractClassLoaderWorker$1.create(AbstractClassLoaderWorker.java:36)
at org.gradle.internal.classloader.ClassLoaderUtils.executeInClassloader(ClassLoaderUtils.java:98)
at org.gradle.workers.internal.AbstractClassLoaderWorker.executeInClassLoader(AbstractClassLoaderWorker.java:36)
at org.gradle.workers.internal.IsolatedClassloaderWorker.execute(IsolatedClassloaderWorker.java:54)
at org.gradle.workers.internal.WorkerDaemonServer.execute(WorkerDaemonServer.java:56)
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.base/java.lang.reflect.Method.invoke(Method.java:566)
at org.gradle.process.internal.worker.request.WorkerAction.run(WorkerAction.java:118)
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.base/java.lang.reflect.Method.invoke(Method.java:566)
at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36)
at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182)
at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164)
at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:412)
at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)
at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)
at java.base/java.lang.Thread.run(Thread.java:829)
{code}",,emilles,jasongarrett,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Wed Feb 01 23:34:33 UTC 2023,,,,,,,,,,"0|z1f9so:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jan/23 23:57;paulk;Is it possible to isolate a snippet of code that triggers the stacktrace?;;;","23/Jan/23 21:15;jasongarrett;I can try, but there are 450+ groovy class files in the module that throws the exception, so it will be a challenge.  Is there a trick to get the compiler to emit the name of the file it's processing?  Or, is there any particular code construct I should search for?;;;","24/Jan/23 14:36;emilles;It is a bounded wildcard like ""List<? extends Object>"".  Here is the code that throws:
{code:java}
    private static void extractGenericsConnections(final Map<GenericsTypeName, GenericsType> connections, final ClassNode[] usage, final ClassNode[] declaration) {
        if (usage == null || declaration == null || declaration.length == 0) return;
        // both have generics
        for (int i = 0, n = usage.length; i < n; i += 1) {
            ClassNode ui = usage[i];
            ClassNode di = declaration[i];
            if (di.isGenericsPlaceHolder()) {
                storeGenericsConnection(connections, di.getUnresolvedName(), new GenericsType(ui));
            } else if (di.isUsingGenerics()) {
                extractGenericsConnections(connections, ui.getGenericsTypes(), di.getGenericsTypes());
            }
        }
    }
{code}

Which was called by ""extractGenericsConnections(connections, ui.getUpperBounds(), upperBounds);"";;;","25/Jan/23 21:55;jasongarrett;Affected version are 2.5.19+ and 3.0.13+.;;;","26/Jan/23 22:15;jasongarrett;This class causes the 3.0.14 compiler to throw the exception.  The code is suspect to be sure, but something similar has been compiling in 2.4.x for many years.

{code}
package example

import groovy.transform.CompileStatic

@CompileStatic
class FooBar {

	static class Foo {
		String name
	}

	static class Bar extends Foo {
		int count
	}

	static class Baz extends Foo {
		double avg
	}

	void questionablyBoundWildcard(List<? extends Object> list) {}

	void compileThrowsException(Foo foo) {
		def list

		if(foo instanceof Bar) {
			Bar bar = foo as Bar
			list = [bar.name, bar.count, """"]
		} else {
			Baz baz = foo as Baz
			list = [baz.name, """", baz.avg]
		}

		questionablyBoundWildcard(list)
	}
}
{code};;;","01/Feb/23 23:34;emilles;https://github.com/apache/groovy/commit/a6a9872c7f55ded020ed689575f3674bddc708e4;;;",,,,,,
STC doesn't find property accessor on nested class,GROOVY-10904,13518428,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,chrylis,chrylis,13/Jan/23 22:53,14/Jan/23 23:27,13/Jul/23 08:58,14/Jan/23 23:13,4.0.7,,,,,,5.0.0-alpha-1,,,Static Type Checker,,,0,,,,"The STC appears unable to see the property accessor for a nested class.

{code}
@CompileStatic
class Example {
  static class Profile {
    String name
  }

  Map<String, Profile> PROFILES = [new Profile()]
      .stream()
      .collect(toMap(Profile::getName, identity()))
}
{code}

{code}
Groovy:Failed to find class method 'getName(Example$Profile)' or instance method 'getName()' for the type: Example$Profile
{code}",,chrylis,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Sat Jan 14 23:22:28 UTC 2023,,,,,,,,,,"0|z1ev00:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Jan/23 14:32;emilles;Property access methods are created by {{Verifier}} at the start of classgen compile phase.  An inner class is processed after its outer class.  We'll just need to account for that in {{StaticTypesMethodReferenceExpressionWriter}}.;;;","14/Jan/23 23:13;emilles;https://github.com/apache/groovy/commit/f8d78e6eb56e5d966d157c7d0b89e21eee2130b3;;;","14/Jan/23 23:22;emilles;I'm not sure if I will move the fix to Groovy 4 due to the risk involved in the classgen re-shuffle.  You can work around this a number of ways, including declaring the class {{Profile}} outside of (and above) {{Example}}.  Or you can declare an explicit getter.  Or you may be able to use a closure instead of a method reference -- replace ""Profile::getName"" with ""\{ it.name \}"".;;;",,,,,,,,,
Dynamic constants for primitive types get default value in Java,GROOVY-10902,13518307,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,okoskine,okoskine,13/Jan/23 10:12,18/Apr/23 18:47,13/Jul/23 08:58,17/Jan/23 16:41,3.0.14,4.0.7,,,,,3.0.15,4.0.8,,Stub generator / Joint compiler,,,0,,,,"If we define a constant that is resolved during runtime in a Groovy class and reference it in a Java class, it's value gets a static default value in the Java class. This seems to be a regression in Groovy 3.0.10 as earlier versions don't have the problem. Also affects all 4.0.x versions that I tested.

Example:
{code:groovy}
// G.groovy
class G {
    public static final int DYNAMIC_CONSTANT = (9.9).intValue()
} {code}
{code:java}
// J.java
public class J {
    public static void main(String[] args) {
        System.out.println(G.DYNAMIC_CONSTANT);
    }
} {code}
*Groovy 4.0.7*
Prints 0 with the following bytecode for J#main
{code:java}
0: getstatic     #2 // Field java/lang/System.out:Ljava/io/PrintStream;
3: iconst_0
4: invokevirtual #4 // Method java/io/PrintStream.println:(I)V
7: return{code}
*Groovy 3.0.9*
Correctly prints 9 with the following bytecode:
{code:java}
0: getstatic     #2 // Field java/lang/System.out:Ljava/io/PrintStream;
3: getstatic     #3 // Field G.DYNAMIC_CONSTANT:I
6: invokevirtual #4 // Method java/io/PrintStream.println:(I)V
9: return {code}
 

 ",,emilles,okoskine,,,,,,,,,,,,,,GROOVY-10611,,,,,,,GROOVY-10928,GROOVY-11019,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Tue Jan 17 16:41:17 UTC 2023,,,,,,,,,,"0|z1eu9c:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Jan/23 10:22;okoskine;Initially encountered this when upgrading a Grails 3 project to Grails 5 but this minimal reproduction case was tested with the following bash function:
{code:bash}
test_with() {
    local version=$1
    sdk use groovy $version &&
    groovyc -j G.groovy J.java &&
    java -cp ~/.sdkman/candidates/groovy/$version/lib/groovy-$version.jar:. J &&
    javap -v J
}
{code};;;","14/Jan/23 01:58;emilles;The stub generator has gone through some changes to try and set the constant value. If you can use a constant expression for the initializer, please do. 

There might be a todo for this case. ;;;","17/Jan/23 16:41;emilles;https://github.com/apache/groovy/commit/2926b8cbc293fd46b73b051fbaf5bde9eeeb7065;;;",,,,,,,,,
Static Type Checking selects wrong method for abstract method call check,GROOVY-10897,13516723,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,sirywell,sirywell,05/Jan/23 21:02,10/Feb/23 21:40,13/Jul/23 08:58,16/Jan/23 18:28,4.0.7,,,,,,4.0.8,,,Static Type Checker,,,0,,,,"Consider following code:
{code:java}
@CompileStatic
class E extends BImpl {
    @Override
    void a() {
        super.a();
    }
    static void main(args) { }
}
interface A {
    void a()
}
interface B extends A {
    @Override
    void a()
}
class AImpl implements A {
    @Override
    void a() {
    }
}
class BImpl extends AImpl implements B {
} {code}
Compiling it will fail with the error 
{{[Static type checking] - Abstract method a() cannot be called directly}}

However, when running it _without_ {{@CompileStatic}} or when writing similar code in Java, it will select the non-abstract method from {{AImpl}} instead.

It seems like this is a problem in the code to choose the best method here: [https://github.com/apache/groovy/blob/ea6ba7c6fcfefe3d8abdfbb6e20a44b1ebb8823e/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java#L1091]

The distance from {{BImpl}} to {{B}} to the interface is less than (1) the distance to {{AImpl}} (4), therefore the abstract method is chosen as best method.

This originally happened when extending {{AbstractSet}} and calling {{{}super.addAll(...){}}}.",,emilles,sirywell,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Mon Jan 16 18:28:08 UTC 2023,,,,,,,,,,"0|z1eklk:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jan/23 18:28;emilles;https://github.com/apache/groovy/commit/a831581caaf729e438e22b2407703162b5d3c92f;;;",,,,,,,,,,,
Duplicate annotations on trait FieldHelper,GROOVY-10894,13516376,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,chrylis,chrylis,03/Jan/23 20:19,04/Jan/23 22:06,13/Jul/23 08:58,04/Jan/23 22:06,4.0.8,,,,,,,,,Compiler,,,0,regression,,,"The latest nightly (included with GRECLIPSE 4.9.0.v202301012233-e2206) has introduced a regression that appears to be the same bug as GROOVY-10553; JSR-303 annotations applied to a trait property are listed twice in the bytecode on both the field and the {{$get/$set}} methods, resulting in an {{AnnotationFormatError}} at runtime. Compiling with groovyc 4.0.7 produces clean bytecode, and rebuilding in Eclipse reintroduces the duplicate.

Sample:

{code}
trait LocationRelated {
  @NotNull @Valid Location location
}
{code}

In {{FieldHelper}} disassembly:
{code}
  public abstract com.example.Location com_example_LocationRelated__location$set(com.example.Location);
    descriptor: (Lcom/example/Location;)Lcom/example/Location;
    flags: (0x0401) ACC_PUBLIC, ACC_ABSTRACT
    RuntimeVisibleTypeAnnotations:
      0: #11(): METHOD_RETURN
        javax.validation.constraints.NotNull
      1: #12(): METHOD_RETURN
        javax.validation.Valid
      2: #11(): METHOD_RETURN
        javax.validation.constraints.NotNull
      3: #12(): METHOD_RETURN
        javax.validation.Valid
      4: #11(): METHOD_FORMAL_PARAMETER, param_index=0
        javax.validation.constraints.NotNull
      5: #12(): METHOD_FORMAL_PARAMETER, param_index=0
        javax.validation.Valid
      6: #11(): METHOD_FORMAL_PARAMETER, param_index=0
        javax.validation.constraints.NotNull
      7: #12(): METHOD_FORMAL_PARAMETER, param_index=0
        javax.validation.Valid
{code}

(As a side issue, is there a particular reason these methods aren't marked synthetic? I'm not certain that would prevent the problem's actually surfacing in this case, but based on my reading of the Hibernate Validator code it might have. Not sure whether that's a positive or a negative, though.)",,chrylis,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,9223372036854775807,,,,Wed Jan 04 22:06:28 UTC 2023,,,,,,,,,,"0|z1eigg:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Jan/23 22:06;emilles;https://github.com/groovy/groovy-eclipse/commit/5d936fabf20da5718e8da407a1a18dacdf575539;;;",,,,,,,,,,,
